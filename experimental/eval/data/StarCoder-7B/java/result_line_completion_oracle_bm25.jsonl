{"groundtruth": "int startAngle = ((Arc) object).getStartAngle();", "prediction": "\n\n                g.setColor(((Arc) object).getColor());\n                g.fillArc(x, y, width, height, ((Arc) object).getStartAngle(), ((Arc) object).getStopAngle());\n            }\n        }\n    }\n\n    public void addShape(Shape shape) {\n        this.drawQueue.add(shape);\n    }\n\n    public void removeShape(Shape shape) {\n        this.drawQueue.remove(shape);\n    }", "first_line_groundtruth": "int startAngle = ((Arc) object).getStartAngle();", "first_line_prediction": "", "match": 0}
{"groundtruth": "((Line) object).getColor());", "prediction": "Color.BLACK);\n                g.drawLine(x, y, endX, endY);\n            } else if (object instanceof Image) {\n                int width = ((Image) object).getWidth();\n                int height = ((Image) object).getHeight();\n                String fileName = ((Image) object).getFileName();\n\n                BufferedImage image = Image.loadImage(fileName);\n                g.drawImage(image, x, y, width, height, null);\n            }\n        }\n    }\n\n    public void addShape(Shape shape) {\n        this.drawQueue.add(shape);\n    }\n\n    public void removeShape(Shape shape", "first_line_groundtruth": "((Line) object).getColor());", "first_line_prediction": "Color.BLACK);", "match": 0}
{"groundtruth": "(Arc) object).getStopAngle();", "prediction": "int) ((Arc) object).getStopAngle();\n\n                g.setColor(((Arc) object).getColor());\n                g.fillArc(x, y, width, height, startAngle, stopAngle);\n            } else if (object instanceof Line) {\n                int startX = ((Line) object).getStartX();\n                int startY = ((Line) object).getStartY();\n                int endX = ((Line) object).getEndX();\n                int endY = ((Line) object).getEndY();\n\n                g.setColor(((Line) object).getColor());\n                g.drawLine(startX, startY, end", "first_line_groundtruth": "(Arc) object).getStopAngle();", "first_line_prediction": "int) ((Arc) object).getStopAngle();", "match": 0}
{"groundtruth": "server.blockUntilShutdown();", "prediction": " server.blockUntilShutdown();\n    }", "first_line_groundtruth": "server.blockUntilShutdown();", "first_line_prediction": " server.blockUntilShutdown();", "match": 0}
{"groundtruth": "HttpClientUtil.sendGetRequest();", "prediction": " try {\n                 Thread.sleep(1000);\n             } catch (InterruptedException e) {\n                 e.printStackTrace();\n             }\n        });\n    }", "first_line_groundtruth": "HttpClientUtil.sendGetRequest();", "first_line_prediction": " try {", "match": 0}
{"groundtruth": "GreetingClient.start();", "prediction": " // do something here.\n             Thread.sleep(1000);\n        } finally {\n            span.end();\n        }\n    }", "first_line_groundtruth": "GreetingClient.start();", "first_line_prediction": " // do something here.", "match": 0}
{"groundtruth": "RocketMqClients.CreatePushConsumer(messageView -> {", "prediction": " OpenTelemetry openTelemetry = GlobalOpenTelemetry.get();\n         Tracer tracer = openTelemetry.getTracer(\"io.github.aaronai\");\n         Span span = tracer.spanBuilder(\"ProcessC\").startSpan();\n         try {\n             span.setAttribute(\"process\", \"ProcessC\");\n             span.setAttribute(\"process.id\", \"1\");\n             span.setAttribute(\"process.name\", \"ProcessC\");\n             span.setAttribute(\"process.version\", \"1.0\");\n             span.setAttribute(\"process.runtime.name\", \"Java\");\n             span.setAttribute(\"process.runtime.version\", \"1.8\");", "first_line_groundtruth": "RocketMqClients.CreatePushConsumer(messageView -> {", "first_line_prediction": " OpenTelemetry openTelemetry = GlobalOpenTelemetry.get();", "match": 0}
{"groundtruth": "Producer producer = RocketMqClients.CreateProducer();", "prediction": " Producer producer = RocketMqClients.getProducer();\n             SendReceipt sendReceipt = producer.send(request.getName());\n             logger.info(\"Send message success, msgId={}\", sendReceipt.getMsgId());\n        } catch (ClientException e) {\n            logger.error(\"Send message failed\", e);\n        }\n        responseObserver.onNext(io.github.aaronai.proto.GreetingOuterClass.SayHelloResponse.newBuilder()\n                .setMessage(\"Hello \" + request.getName())\n                .build());\n        responseObserver.onCompleted();\n    }", "first_line_groundtruth": "Producer producer = RocketMqClients.CreateProducer();", "first_line_prediction": " Producer producer = RocketMqClients.getProducer();", "match": 0}
{"groundtruth": "systemMessage.setContent(systemprompt);", "prediction": " systemMessage.setText(systemprompt);\n            messages.add(systemMessage);\n\n            // User prompt\n            Message userMessage = new Message();\n            userMessage.setRole(\"user\");\n            userMessage.setText(update.message().text());\n            messages.add(userMessage);\n\n            // Add messages to request\n            chatRequest.setMessages(messages);\n\n            // Send request to OpenAI API\n            response = client.chat(chatRequest);\n\n            // Get response from OpenAI API\n            String text = response.data().get(0).text();\n\n            // Add response to user context\n            MessageLog<Message> log", "first_line_groundtruth": "systemMessage.setContent(systemprompt);", "first_line_prediction": " systemMessage.setText(systemprompt);", "match": 0}
{"groundtruth": "\"Contador de tokens: %d\",gptService.getNumTokens());", "prediction": "\n                \"You have used %d tokens in this conversation.\",\n                this.gptService.getUsage(update));\n        sendReply(update, message);\n    }", "first_line_groundtruth": "\"Contador de tokens: %d\",gptService.getNumTokens());", "first_line_prediction": "", "match": 0}
{"groundtruth": "chatRequest.setMaxTokens(maxtokens);", "prediction": " // Get the user input\n            String userInput = update.message().text();\n            if(userInput==null) {\n                userInput = update.message().caption();\n            }\n            if(userInput==null) {\n                userInput = update.message().text();\n            }\n            if(userInput==null) {\n                userInput = update.message().caption();\n            }\n            if(userInput==null) {\n                userInput = update.message().text();\n            }\n            if(userInput==null) {\n                userInput = update.message().caption();\n            }\n            if(userInput==null", "first_line_groundtruth": "chatRequest.setMaxTokens(maxtokens);", "first_line_prediction": " // Get the user input", "match": 0}
{"groundtruth": "chatRequest.setModel(model);", "prediction": " // Get the user input\n            String userInput = update.message().text();\n            if(userInput==null) {\n                userInput = update.message().caption();\n            }\n            if(userInput==null) {\n                userInput = update.message().replyToMessage().text();\n            }\n            if(userInput==null) {\n                userInput = update.message().replyToMessage().caption();\n            }\n            if(userInput==null) {\n                userInput = update.message().replyToMessage().replyToMessage().text();\n            }\n            if(userInput==null) {\n                userInput", "first_line_groundtruth": "chatRequest.setModel(model);", "first_line_prediction": " // Get the user input", "match": 0}
{"groundtruth": "systemMessage.setRole(\"system\");", "prediction": " systemMessage.setText(systemprompt);\n             messages.add(systemMessage);", "first_line_groundtruth": "systemMessage.setRole(\"system\");", "first_line_prediction": " systemMessage.setText(systemprompt);", "match": 0}
{"groundtruth": "userMessage.setContent(this.presentation);", "prediction": " // Add the custom message to the list of messages\n            userMessage.setContent(text);\n            messages.add(userMessage);\n\n            // set messages to the request\n            chatRequest.setMessages(messages);\n\n            // Send synchronous request to the OpenAI Api\n            response = client.getCompletion(chatRequest);\n            // Incremet token counter\n            ntokens = ntokens + response.getUsage().getTotalTokens();\n\n            // Return text to be sent to the user\n            return response.getChoices().get(0).getMessage().getContent();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"I'm", "first_line_groundtruth": "userMessage.setContent(this.presentation);", "first_line_prediction": " // Add the custom message to the list of messages", "match": 0}
{"groundtruth": "exampleMessage.setRole(role.toLowerCase());", "prediction": " exampleMessage.setRole(role);\n                     exampleMessage.setContent(content);\n                     results.add(exampleMessage);\n                }\n            } catch (Exception e) {\n                log.error(\"Error parsing example: \" + example);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * This method checks if the user is authorized to talk to the bot.\n     * @param update the update object containing the user input\n     * @return true if the user is authorized, false otherwise\n     */\n    private boolean checkPermission(Update update) {\n        if(this.whiteSet==null) {\n            return true;\n       ", "first_line_groundtruth": "exampleMessage.setRole(role.toLowerCase());", "first_line_prediction": " exampleMessage.setRole(role);", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u63d0\u53d6\u5230\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u662f\uff1a\" + i);", "prediction": " //Log.d(TAG, \"extractFirstIntFromString: \" + i);\n        }\n        return i;\n    }\n\n    // \u4ece\u5b57\u7b26\u4e32\u4e2d\u63d0\u53d6\u7b2c\u4e00\u4e2a\u6574\u6570\n    public static String extractFirstIntFromString(String str, int index){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(str);\n\n        String i = \"\";\n        if (m.find()){\n            i = m.group();\n             //Log.d(TAG, \"extractFirstIntFromString: \" + i);\n        }\n        return i;\n    }\n\n    // \u4ece\u5b57\u7b26\u4e32\u4e2d\u63d0\u53d6\u7b2c\u4e00\u4e2a\u6574\u6570\n    public static String", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u63d0\u53d6\u5230\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u662f\uff1a\" + i);", "first_line_prediction": " //Log.d(TAG, \"extractFirstIntFromString: \" + i);", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u5de5\u4f5c\u53f0\");", "prediction": " // \u70b9\u51fb\u201c\u6211\u7684\u201d\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u201c\u6211\u7684\u201d\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u6211\u7684\"));\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c\u901a\u8baf\u5f55\u201d\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u201c\u901a\u8baf\u5f55\u201d\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u901a\u8baf\u5f55\"));\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c\u6dfb\u52a0\u201d\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u201c\u6dfb\u52a0\u201d\");\n        AccUtils.click", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u5de5\u4f5c\u53f0\");", "first_line_prediction": " // \u70b9\u51fb\u201c\u6211\u7684\u201d", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u8003\u52e4\u6253\u5f00\");", "prediction": " // \u70b9\u51fb\u5de5\u4f5c\u53f0\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u5de5\u4f5c\u53f0\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u5de5\u4f5c\u53f0\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u5de5\u4f5c\u53f0\n        AccUtils.clickParentCanClick(AccUtils.", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u8003\u52e4\u6253\u5f00\");", "first_line_prediction": " // \u70b9\u51fb\u5de5\u4f5c\u53f0", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u6253\u5f00\u9489\u9489\");", "prediction": " // \u6253\u5f00", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u6253\u5f00\u9489\u9489\");", "first_line_prediction": " // \u6253\u5f00", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u6253\u5361\");", "prediction": " //Rect(425, 1280 - 656, 1362); packageName: com.alibaba.android.rimet; className: android.view.View; text: \u6253\u5361;\n         //Rect(425, 1280 - 656, 1362); packageName: com.alibaba.android.rimet; className: android.view.View; text: \u6253\u5361;\n         //Rect(425, 1280 - 656, 1362); packageName: com.", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u6253\u5361\");", "first_line_prediction": " //Rect(425, 1280 - 656, 1362); packageName: com.alibaba.android.rimet; className: android.view.View; text: \u6253\u5361;", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u6682\u65f6\u4e0d\");", "prediction": " // \u70b9\u51fb\u6253\u5361\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u6253\u5361\");\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u6253\u5361\"));\n        AccUtils.timeSleep(3000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u786e\u8ba4\");\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u786e\u8ba4\"));\n        AccUtils.timeSleep(3000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u786e\u8ba4\");\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u786e\u8ba4\"));\n        AccUtils.timeSleep(300", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u6682\u65f6\u4e0d\");", "first_line_prediction": " // \u70b9\u51fb\u6253\u5361", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u6807\u9898 => \" + videoDesc);", "prediction": " AccUtils.printLogMsg(\"videoDesc => \" + videoDesc);\n            List<AccessibilityNodeInfo> listByContainId = AccUtils.findElementListByContainText(\"\u8fdb\u5165\u76f4\u64ad\u95f4\");\n            if (listByContainId != null) {\n                for (AccessibilityNodeInfo nodeInfo : listByContainId) {\n                    Log.i(TAG, \"currentVideoDesc: node => \" + nodeInfo);\n                }\n                for (AccessibilityNodeInfo nodeInfo : listByContainId) {\n                    if (nodeInfo.getText().toString().contains(\"\u8fdb\u5165\u76f4\u64ad\u95f4\")) {\n                        AccUtils.clickNodeByPoint(nodeInfo", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u6807\u9898 => \" + videoDesc);", "first_line_prediction": " AccUtils.printLogMsg(\"videoDesc => \" + videoDesc);", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u8fd4\u56de\u5230\u521d\u59cb\u72b6\u6001\");", "prediction": " // \u70b9\u51fb\u201c\u6211\u201d\n        AccUtils.clickNodeByText(\"\u6211\");\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c\u6211\u7684\u201d\n        AccUtils.clickNodeByText(\"\u6211\u7684\");\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c\u6211\u7684\u65e5\u7a0b\u201d\n        AccUtils.clickNodeByText(\"\u6211\u7684\u65e5\u7a0b\");\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c\u6211\u7684\u65e5\u7a0b\u201d\n        AccUtils.clickNodeByText(\"\u6211\u7684\u65e5\u7a0b\");\n        AccUtils.timeSleep(waitTwoSecond);\n\n        // \u70b9\u51fb\u201c", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u8fd4\u56de\u5230\u521d\u59cb\u72b6\u6001\");", "first_line_prediction": " // \u70b9\u51fb\u201c\u6211\u201d", "match": 0}
{"groundtruth": "AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));", "prediction": " AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));\n        AccUtils.timeSleep(2000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u901a\u8baf\u5f55\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u901a\u8baf\u5f55\"));\n        AccUtils.timeSleep(2000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u641c\u7d22\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u641c\u7d22\"));\n        AccUtils.timeSleep(2000);\n\n        AccUtils.printLogMsg(\"\u8f93\u5165\u7528\u6237\u540d\");\n       ", "first_line_groundtruth": "AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));", "first_line_prediction": " AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u5de5\u4f5c\u53f0\"));", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u597d\u7684\");", "prediction": " // \u70b9\u51fb\u6253\u5361\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u6253\u5361\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u6253\u5361\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u6253\u5361\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u6253\u5361\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u6253\u5361\"));\n        AccUtils.timeSleep(3000);\n\n        // \u70b9\u51fb\u6253\u5361\n        AccUtils.clickParentCanClick(AccUtils.", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u70b9\u51fb\u597d\u7684\");", "first_line_prediction": " // \u70b9\u51fb\u6253\u5361", "match": 0}
{"groundtruth": "dyTaskService.main();", "prediction": " // \u542f\u52a8\u4efb\u52a1\n                    dyTaskService.startTask();\n                } catch (ExitException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    // \u4efb\u52a1\u5f00\u59cb\u5165\u53e3\n    private void start_run_dingding() {\n        new Thread(new Runnable() {\n            @RequiresApi(api = Build.VERSION_CODES.N)\n            @Override\n            public void run() {\n                try {\n\n                    DingDingService dingDingService = new DingDingService();\n                    // \u542f\u52a8\u4efb\u52a1\n                    dingDingService.startTask();\n                } catch (Exit", "first_line_groundtruth": "dyTaskService.main();", "first_line_prediction": " // \u542f\u52a8\u4efb\u52a1", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u5411\u4e0b\u6ed1\u52a8\");", "prediction": " // \u70b9\u6389\u5f39\u7a97\n            AccessibilityNodeInfo elementByText1 = AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");\n            if (elementByText1 != null) {\n                AccUtils.clickNodeByPoint(elementByText1);\n            }\n            AccUtils.timeSleep(waitTwoSecond);\n            AccessibilityNodeInfo element1 = AccUtils.findElementByText(\"\u4ee5\u540e\u518d\u8bf4\");\n            if (element1 != null) {\n                AccUtils.clickNodeByPoint(element1);\n            }\n            AccUtils.timeSleep(waitTwoSecond);\n            AccessibilityNodeInfo closeNode1 = AccUtils.findElementByText", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u5411\u4e0b\u6ed1\u52a8\");", "first_line_prediction": " // \u70b9\u6389\u5f39\u7a97", "match": 0}
{"groundtruth": "= AccUtils.findElementListByContainText(\"\u6253\u5361\");", "prediction": " = AccUtils.findElementListByContainText(\"\u4e0a\u73ed\u6253\u5361\");\n        if (listByContainText != null && listByContainText.size() > 0) {\n            AccessibilityNodeInfo nodeInfo = listByContainText.get(0);\n            Rect rect = nodeInfo.getBoundsInScreen();\n            AccUtils.clickNodeByPoint(rect.centerX(), rect.centerY());\n            AccUtils.timeSleep(3000);\n        }\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u786e\u5b9a\");\n        AccUtils.clickParentCanClick(AccUtils.findElementByText(\"\u786e\u5b9a\"));\n        AccUtils", "first_line_groundtruth": "= AccUtils.findElementListByContainText(\"\u6253\u5361\");", "first_line_prediction": " = AccUtils.findElementListByContainText(\"\u4e0a\u73ed\u6253\u5361\");", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u6253\u5361\u5b8c\u6210\uff0c\u8fd4\u56de\u684c\u9762\");", "prediction": " //Rect(425, 1280 - 656, 1362); packageName: com.alibaba.android.rimet; className: android.view.View; text: \u4e0a\u73ed\u6253\u5361;\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u6253\u5361\");\n        listByContainText = AccUtils.findElementListByContainText(\"\u6253\u5361\");\n        if (listByContainText != null && listByContainText.size() > 0) {\n            for (AccessibilityNodeInfo nodeInfo : listByContainText) {\n                Rect rect = new Rect();\n                nodeInfo.getBounds", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u6253\u5361\u5b8c\u6210\uff0c\u8fd4\u56de\u684c\u9762\");", "first_line_prediction": " //Rect(425, 1280 - 656, 1362); packageName: com.alibaba.android.rimet; className: android.view.View; text: \u4e0a\u73ed\u6253\u5361;", "match": 0}
{"groundtruth": "TinkerManager.setUpgradeRetryEnable(true);", "prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c\n        Log.i(TAG, \"onBaseContextAttached: \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\");\n        // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c\n        Tinker.with(this).load(new LoadReporter() {\n            @Override\n            public void onStartLoad(Context context, String apkPath, long loadBeginTime, long loadCostTime) {\n                Log.i(TAG, \"onStartLoad: \u5f00\u59cb\u52a0\u8f7d\");\n            }\n\n            @Override\n            public void onPatchLoadSuccess(Context context, String patchFilePath, long loadBeginTime, long loadCostTime) {\n                Log.i(TAG", "first_line_groundtruth": "TinkerManager.setUpgradeRetryEnable(true);", "first_line_prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c", "match": 0}
{"groundtruth": "AccUtils.findElementByText(\"\u8003\u52e4\u6253\u5361\"));", "prediction": "AccUtils.findElementByText(\"\u8003", "first_line_groundtruth": "AccUtils.findElementByText(\"\u8003\u52e4\u6253\u5361\"));", "first_line_prediction": "AccUtils.findElementByText(\"\u8003", "match": 0}
{"groundtruth": "TinkerManager.installTinker(this);", "prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c\n        Log.i(TAG, \"onBaseContextAttached: \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\");\n    }\n\n    @Override\n    public void onBaseContextDetached() {\n        super.onBaseContextDetached();\n        TinkerManager.setTinkerApplicationLike(null);\n    }\n\n    @Override\n    public void onTinkerPatchResult(int resultCode, String resultMsg) {\n        super.onTinkerPatchResult(resultCode, resultMsg);\n        Log.i(TAG, \"onTinkerPatchResult: \" + resultCode + \" \" + resultMsg);\n    }\n\n    @Override\n   ", "first_line_groundtruth": "TinkerManager.installTinker(this);", "first_line_prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c", "match": 0}
{"groundtruth": "= AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");", "prediction": " = AccUtils.findElementByText(\"\u70b9\u6389\");\n            if (elementByText != null) {\n                elementByText.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n                AccUtils.timeSleep(waitTwoSecond);\n            }\n\n            // \u70b9\u6389\u5f39\u7a97\n            AccessibilityNodeInfo elementByText2  = AccUtils.findElementByText(\"\u70b9\u6389\");\n            if (elementByText2 != null) {\n                elementByText2.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n                AccUtils.timeSleep(waitTwoSecond);\n            }\n\n            // \u70b9\u6389\u5f39\u7a97\n            AccessibilityNodeInfo elementByText", "first_line_groundtruth": "= AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");", "first_line_prediction": " = AccUtils.findElementByText(\"\u70b9\u6389\");", "match": 0}
{"groundtruth": "element = AccUtils.findElementByText(\"\u4ee5\u540e\u518d\u8bf4\");", "prediction": " elementByText1 = AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");\n            if (elementByText1 != null) {\n                AccUtils.clickNodeByPoint(elementByText1);\n            }\n            AccUtils.timeSleep(waitTwoSecond);\n\n            // \u70b9\u6389\u5f39\u7a97\n            AccessibilityNodeInfo elementByText2 = AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");\n            if (elementByText2 != null) {\n                AccUtils.clickNodeByPoint(elementByText2);\n            }\n            AccUtils.timeSleep(waitTwoSecond);\n            AccessibilityNodeInfo  elementByText3 = Acc", "first_line_groundtruth": "element = AccUtils.findElementByText(\"\u4ee5\u540e\u518d\u8bf4\");", "first_line_prediction": " elementByText1 = AccUtils.findElementByText(\"\u6211\u77e5\u9053\u4e86\");", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"open dy App\");", "prediction": " AccUtils.printLogMsg(\"\u6253\u5f00", "first_line_groundtruth": "AccUtils.printLogMsg(\"open dy App\");", "first_line_prediction": " AccUtils.printLogMsg(\"\u6253\u5f00", "match": 0}
{"groundtruth": "AccUtils.openApp(\"\u6296\u97f3\");", "prediction": " // \u6253\u5f00", "first_line_groundtruth": "AccUtils.openApp(\"\u6296\u97f3\");", "first_line_prediction": " // \u6253\u5f00", "match": 0}
{"groundtruth": "TinkerManager.setTinkerApplicationLike(this);", "prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c\n        Log.i(TAG, \"onBaseContextAttached: \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\");\n        Variable.context = base;\n    }\n\n    @Override\n    public void onTinkerPatchResult(int result, String patchName, String patchMd5, String errorMessage) {\n        super.onTinkerPatchResult(result, patchName, patchMd5, errorMessage);\n        Log.i(TAG, \"onTinkerPatchResult: result:\" + result + \" patchName:\" + patchName + \" patchMd5:\" + patchMd5 + \" errorMessage:\" + errorMessage);\n    }", "first_line_groundtruth": "TinkerManager.setTinkerApplicationLike(this);", "first_line_prediction": " // \u8fd9\u91cc\u5b9e\u73b0SDK\u521d\u59cb\u5316\uff0c", "match": 0}
{"groundtruth": "Utils.isBackground()) {", "prediction": "result.isSuccess) {\n                    TinkerServiceInternals.killTinkerPatchServiceProcess(getApplicationContext());\n                }\n            }\n        }\n    }\n\n    private void deleteRawPatchFile(File file) {\n        if (file != null && file.exists()) {\n            file.delete();\n        }\n    }\n\n    private boolean checkIfNeedKill(PatchResult result) {\n        return result.isSuccess && result.isNewPatch;\n    }", "first_line_groundtruth": "Utils.isBackground()) {", "first_line_prediction": "result.isSuccess) {", "match": 0}
{"groundtruth": "AccUtils.printLogMsg(\"\u5728\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u627e\u5230\u6574\u6570\uff01\");", "prediction": " AccUtils.printLogMsg(\"\u63d0\u53d6\u4e0d\u5230\u7b2c\u4e00\u4e2a\u6574\u6570\");\n        }\n        return i;\n    }\n\n    // \u4ece\u5b57\u7b26\u4e32\u4e2d\u63d0\u53d6\u7b2c\u4e00\u4e2a\u6574\u6570\n    public static String extractFirstStringFromString(String str){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(str);\n\n        String i = \"\";\n        if (m.find()){\n            i = m.group();\n            AccUtils.printLogMsg(\"\u63d0\u53d6\u5230\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\uff1a\" + i);\n        } else {\n             AccUtils.printLogMsg(\"\u63d0\u53d6\u4e0d\u5230\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\");\n        }\n        return i;\n    }\n\n    //", "first_line_groundtruth": "AccUtils.printLogMsg(\"\u5728\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u627e\u5230\u6574\u6570\uff01\");", "first_line_prediction": " AccUtils.printLogMsg(\"\u63d0\u53d6\u4e0d\u5230\u7b2c\u4e00\u4e2a\u6574\u6570\");", "match": 0}
{"groundtruth": "WindowPermissionCheck.checkPermission(this);", "prediction": " WindowPermissionCheck.checkPermission(this);\n        if (!permission) {\n            Toast.makeText(this, \"\u8bf7\u6253\u5f00\u6743\u9650\", Toast.LENGTH_SHORT).show();\n            Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n            Uri uri = Uri.fromParts(\"package\", getPackageName(), null);\n            intent.setData(uri);\n            startActivity(intent);\n        }\n\n        // \u6ce8\u518c\u5e7f\u64ad\n        registerReceiver(mReceiver, new IntentFilter(\"com.linsheng.FATJS.ACTION_START_SERVICE\"));\n\n        // \u6ce8\u518c\u670d\u52a1\n        registerService();\n\n        // \u6ce8\u518c\u76d1\u542c", "first_line_groundtruth": "WindowPermissionCheck.checkPermission(this);", "first_line_prediction": " WindowPermissionCheck.checkPermission(this);", "match": 0}
{"groundtruth": "AccUtils.timeSleep(3000);", "prediction": " AccUtils.timeSleep(1000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u901a\u8baf\u5f55\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u901a\u8baf\u5f55\"));\n        AccUtils.timeSleep(1000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u641c\u7d22\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u641c\u7d22\"));\n        AccUtils.timeSleep(1000);\n\n        AccUtils.printLogMsg(\"\u8f93\u5165\u7528\u6237\u540d\");\n        AccUtils.inputTextByNode(AccUtils.findElementByText(\"\u7528\u6237\u540d\"), \"1", "first_line_groundtruth": "AccUtils.timeSleep(3000);", "first_line_prediction": " AccUtils.timeSleep(1000);", "match": 0}
{"groundtruth": "ntokens = ntokens + response.getUsage().getTotalTokens();", "prediction": " this.ntokens += response.getTokens().length;\n\n        } catch (Exception e) {\n            log.error(\"Error while sending message to OpenAI API\", e);\n            return \"I'm sorry but I can't talk to you, please try again later.\";\n        }\n\n        // If the response is null, then the API returned an error\n        if(response == null) {\n            return \"I'm sorry but I can't talk to you, please try again later.\";\n        }\n\n        // If the response is empty, then the API returned an empty response\n        if(response.getMessages().isEmpty()) {\n            return", "first_line_groundtruth": "ntokens = ntokens + response.getUsage().getTotalTokens();", "first_line_prediction": " this.ntokens += response.getTokens().length;", "match": 0}
{"groundtruth": "AccUtils.timeSleep(6000);", "prediction": " AccUtils.timeSleep(3000);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u8003", "first_line_groundtruth": "AccUtils.timeSleep(6000);", "first_line_prediction": " AccUtils.timeSleep(3000);", "match": 0}
{"groundtruth": "out.println(filme.getNome()+\" - \"+filme.getDuracao());", "prediction": "out.println(\"O filme \"+filme.getNome()+\" est\u00e1 sendo exibido\");\n            }\n        }\n    }\n    public void stop(){\n        if(emPlay){\n            emPlay = false;\n            System.out.println(\"O filme \"+filme.getNome()+\" foi desligado\");\n        }\n    }\n    public String toString(){\n        return \"DVD ligado: \"+ligado+\"\\nVolume: \"+volume+\"\\nFilme: \"+filme+\"\\nEm play: \"+emPlay;\n    }", "first_line_groundtruth": "out.println(filme.getNome()+\" - \"+filme.getDuracao());", "first_line_prediction": "out.println(\"O filme \"+filme.getNome()+\" est\u00e1 sendo exibido\");", "match": 0}
{"groundtruth": ".setContent(response.getChoices().get(0).getMessage().getContent());", "prediction": ".setContent(response.getCompletions().get(0).getText());\n                userContext.get(update.message().from().id()).add(assistantMessage);\n            }\n\n            // Return the response\n            return response.getCompletions().get(0).getText();\n\n        } catch (Exception e) {\n            log.error(\"Error sending message to OpenAI API\", e);\n            return \"I'm sorry but I can't talk to you, please try again later.\";\n        }\n    }\n\n    /**\n     * This method checks if the user is authorized to talk to the bot\n     * based on the whitelist.\n     * @", "first_line_groundtruth": ".setContent(response.getChoices().get(0).getMessage().getContent());", "first_line_prediction": ".setContent(response.getCompletions().get(0).getText());", "match": 0}
{"groundtruth": "AccUtils.timeSleep(2000);", "prediction": "\n\n        AccUtils.printLogMsg(\"\u8fdb\u5165\u6253\u5361\u9875\u9762\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u6253\u5361\"));\n        AccUtils.timeSleep(waitTwoSecond);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u7b7e\u5230\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u7b7e\u5230\"));\n        AccUtils.timeSleep(waitTwoSecond);\n\n        AccUtils.printLogMsg(\"\u70b9\u51fb\u7b7e\u5230\");\n        AccUtils.clickNodeByPoint(AccUtils.findElementByText(\"\u7b7e\u5230\"));\n        AccUtils.timeSleep(waitTwoSecond);\n\n       ", "first_line_groundtruth": "AccUtils.timeSleep(2000);", "first_line_prediction": "", "match": 0}
{"groundtruth": "itempedido.getPreco();", "prediction": " itempedido.getPreco();\n        }\n        return total;\n    }", "first_line_groundtruth": "itempedido.getPreco();", "first_line_prediction": " itempedido.getPreco();", "match": 0}
{"groundtruth": "AccUtils.timeSleep(7000);", "prediction": " //  AccUtils.openApp(\"", "first_line_groundtruth": "AccUtils.timeSleep(7000);", "first_line_prediction": " //  AccUtils.openApp(\"", "match": 0}
{"groundtruth": "= meuDVD.removerFilme();", "prediction": " = meuDVD.removerFilme();\n        System.out.println(filmeDevolvido);\n        System.out.println(meuDVD);\n        meuDVD.ligar();\n        meuDVD.inserirFilme(filme1);\n        meuDVD.inserirFilme(filme2);\n        meuDVD.inserirFilme(filme1);\n        meuDVD.inserirFilme(filme2);\n        meuDVD.inserirFilme(filme1);\n        meuDVD.inser", "first_line_groundtruth": "= meuDVD.removerFilme();", "first_line_prediction": " = meuDVD.removerFilme();", "match": 0}
{"groundtruth": "returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);", "prediction": " // check patch file size\n            if (SharePatchFileUtil.getFileOrDirectorySize(patchFile) > NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN) {\n                returnCode = ShareConstants.ERROR_PATCH_SIZE_TOO_BIG;\n            }\n        }\n        return returnCode;\n    }\n\n    @Override\n    public void onPatchReceived(String path, String patchMd5) {\n        super.onPatchReceived(path, patchMd5);\n        TinkerLog.i(TAG, \"receive a patch file: %s, file size:%d\", path, SharePatchFileUtil.getFile", "first_line_groundtruth": "returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);", "first_line_prediction": " // check patch file size", "match": 0}
{"groundtruth": "meuDVD.aumentarVolume();", "prediction": "\n        \n    }", "first_line_groundtruth": "meuDVD.aumentarVolume();", "first_line_prediction": "", "match": 0}
{"groundtruth": "(filme.getNome()+\" - \"+filme.getDuracao());", "prediction": "(\"O filme \"+filme.getNome()+\" est\u00e1 sendo exibido\");\n            }\n        }\n    }\n    public void stop(){\n        if(emPlay){\n            emPlay = false;\n            System.out.println(\"O filme \"+filme.getNome()+\" foi desligado\");\n        }\n    }\n    public String toString(){\n        return \"DVD ligado: \"+ligado+\"\\nVolume: \"+volume+\"\\nFilme: \"+filme+\"\\nEm play: \"+emPlay;\n    }", "first_line_groundtruth": "(filme.getNome()+\" - \"+filme.getDuracao());", "first_line_prediction": "(\"O filme \"+filme.getNome()+\" est\u00e1 sendo exibido\");", "match": 0}
{"groundtruth": "meuDVD.diminuirVolume();", "prediction": "\n        \n    }", "first_line_groundtruth": "meuDVD.diminuirVolume();", "first_line_prediction": "", "match": 0}
{"groundtruth": "meuDVD.play();", "prediction": "\n        \n    }", "first_line_groundtruth": "meuDVD.play();", "first_line_prediction": "", "match": 0}
{"groundtruth": "this.ipList.put(Sneaky.stringifyAddress(address), System.currentTimeMillis());", "prediction": " this.ipList.put(stringifyAddress(address), System.currentTimeMillis());\n         this.saveToFile(false);\n    }\n\n    public boolean isAllowed(SocketAddress address) {\n        return this.ipList.containsKey(stringifyAddress(address));\n    }\n\n    public boolean isAllowed(String ip) {\n        return this.ipList.containsKey(ip);\n    }\n\n    public boolean isAllowed(SocketAddress address, long lastLogin) {\n        return this.isAllowed(address) && this.ipList.get(stringifyAddress(address)) >= lastLogin;\n    }\n\n    public boolean isAllowed(String ip, long last", "first_line_groundtruth": "this.ipList.put(Sneaky.stringifyAddress(address), System.currentTimeMillis());", "first_line_prediction": " this.ipList.put(stringifyAddress(address), System.currentTimeMillis());", "match": 0}
{"groundtruth": "= translator.detectLanguage(questionInput);", "prediction": " = translator.detectLanguage(questionInput);\n                if (!sourceLang.equals(question.getLang())) {\n                    needTranslate = true;\n                }\n            }\n\n            if (needTranslate) {\n                String translatedText = translator.translate(sourceLang, question.getLang(), questionInput);\n                questionInput = translatedText;\n            }\n\n            String url = STREAM_GENERATE_URL + \"?reqid=\" + reqid + \"&snim0e=\" + snim0e + \"&snim0e_ver=1\";\n            url += \"&snim0e_ver=1&snim0e", "first_line_groundtruth": "= translator.detectLanguage(questionInput);", "first_line_prediction": " = translator.detectLanguage(questionInput);", "match": 0}
{"groundtruth": "= translator.translate(translator.middleLanguage(), sourceLang, answerOutput);", "prediction": " = translator.translate(translator.middleLanguage(), sourceLang, answerOutput);\n            }\n\n            return Answer.builder()\n                .answer(answerOutput)\n                .sources(answer.getSources())\n                .relatedTopics(answer.getRelatedTopics())\n                .build();\n        } catch (IOException e) {\n            log.error(\"Error while getting answer\", e);\n            throw new BardApiException(\"Error while getting answer\", e);\n        }\n    }\n\n    private String fetchSNlM0e() throws IOException {\n        Map<String, String> params = new LinkedHashMap<>();\n        params.put(\"bl\", \"boq", "first_line_groundtruth": "= translator.translate(translator.middleLanguage(), sourceLang, answerOutput);", "first_line_prediction": " = translator.translate(translator.middleLanguage(), sourceLang, answerOutput);", "match": 0}
{"groundtruth": "= translator.translate(sourceLang, translator.middleLanguage(), questionInput);", "prediction": " = translator.translate(questionInput, sourceLang, middleLanguage);\n                }\n            }\n\n            String questionInputEncoded = URLEncoder.encode(questionInput, StandardCharsets.UTF_8);\n            String questionInputEncodedWithSnim0e = questionInputEncoded + \"&snim0e=\" + snim0e;\n\n            String url = STREAM_GENERATE_URL + \"?reqid=\" + reqid + \"&snim0e=\" + snim0e;\n            HttpURLConnection connection = createConnection(url);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", CONTENT", "first_line_groundtruth": "= translator.translate(sourceLang, translator.middleLanguage(), questionInput);", "first_line_prediction": " = translator.translate(questionInput, sourceLang, middleLanguage);", "match": 0}
{"groundtruth": "fill(WebActions.decrypt(password));", "prediction": "fill(WebActions.getProperty(password));\n    }\n\n    public void clickLogin() {\n        LOGIN_BUTTON.click();\n    }\n\n    public void clickOnIcon(String iconName) {\n        page.getByText(iconName, new Page.GetByTextOptions().setExact(true)).click();\n    }\n\n    public void fillAutocompleteTextField(String textValue) {\n        BOOKS_SEARCH_BOX.fill(WebActions.getProperty(textValue));\n        page.getByText(\"Blue\", new Page.GetByTextOptions().setExact(true)).click();\n    }\n\n    public boolean verifyBlueColourSelected", "first_line_groundtruth": "fill(WebActions.decrypt(password));", "first_line_prediction": "fill(WebActions.getProperty(password));", "match": 0}
{"groundtruth": "= PluginImpl.getInstance().getAccessKeyId();", "prediction": " = PluginImpl.get().getAccessKeyId();\n        String accessKeySecret = PluginImpl.get().getAccessKeySecret();\n        DefaultProfile profile = DefaultProfile.getProfile(region, accessKeyId, accessKeySecret);\n        DefaultAcsClient client = new DefaultAcsClient(profile);\n        this.ossClient = new OSSClientBuilder().build(endpointFormat, accessKeyId, accessKeySecret);\n        this.oosClient = client;\n    }", "first_line_groundtruth": "= PluginImpl.getInstance().getAccessKeyId();", "first_line_prediction": " = PluginImpl.get().getAccessKeyId();", "match": 0}
{"groundtruth": "instance.getOosClient().getAcsResponse(request);", "prediction": " instance.getOosClient().startExecution(request);\n            executionId = response.getExecutionId();\n            listener.getLogger().println(\"ExecutionId:\" + executionId);\n        } catch (ClientException e) {\n            e.printStackTrace();\n        }\n        return executionId;\n    }\n\n    // ecs resource execute oos Template : ECS_TEMPLATE_NAME\n    private String ecsResourceExec(StartExecutionRequest request,  AliyunClientFactory instance, TaskListener listener) {\n        request.setTemplateName(ECS_TEMPLATE_NAME);\n        String parameter =\n                \"{\\\"\" +\n                        \"invokeDestinationDir\\\":\\\"\"", "first_line_groundtruth": "instance.getOosClient().getAcsResponse(request);", "first_line_prediction": " instance.getOosClient().startExecution(request);", "match": 0}
{"groundtruth": "uploadPartResult = instance.getOssClient().uploadPart(uploadPartRequest);", "prediction": "uret = instance.getOssClient().uploadPart(uploadPartRequest);\n                partETags.add(uret.getPartETag());\n                instream.close();\n            }\n            CompleteMultipartUploadRequest completeMultipartUploadRequest = new CompleteMultipartUploadRequest();\n            completeMultipartUploadRequest.setBucketName(bucketName);\n            completeMultipartUploadRequest.setKey(objectName);\n            completeMultipartUploadRequest.setUploadId(uploadId);\n            completeMultipartUploadRequest.setPartETags(partETags);\n            CompleteMultipartUploadResult curet = instance.getOssClient().completeMultipartUpload(complete", "first_line_groundtruth": "uploadPartResult = instance.getOssClient().uploadPart(uploadPartRequest);", "first_line_prediction": "uret = instance.getOssClient().uploadPart(uploadPartRequest);", "match": 0}
{"groundtruth": "instance.build(this.region);", "prediction": " /**\n         * get oss client\n         * */\n        OSS ossClient = instance.getOssClient(region);\n        /**\n         * get oss bucket\n         * */\n        OSSBucket ossBucket = ossClient.getBucket(bucket);\n        /**\n         * get oss object\n         * */\n        OSSObject ossObject = ossBucket.getObject(objectName);\n        /**\n         * get oss object content\n         * */\n        InputStream inputStream = ossObject.getObjectContent();\n        /**\n         * get oss object content length\n         * */\n        long contentLength = ossObject.getObjectMetadata().getContentLength();\n        /**\n         * get oss object content", "first_line_groundtruth": "instance.build(this.region);", "first_line_prediction": " /**", "match": 0}
{"groundtruth": "(instance.getOssClient() != null) {", "prediction": " (zipFile.exists()) {\n                logger.println(\"Failed to delete file \" + zipFile.getPath());\n            }\n        }\n    }\n\n    private void uploadOssFile(AliyunClientFactory instance, FilePath sourceDirectory, PrintStream logger) {\n        String bucketName = this.bucket;\n        try {\n            InitiateMultipartUploadRequest request = new InitiateMultipartUploadRequest(bucketName, objectName);\n            InitiateMultipartUploadResult upresult = instance.getOssClient().initiateMultipartUpload(request);\n            String uploadId = upresult.getUploadId();\n            List<PartETag> partET", "first_line_groundtruth": "(instance.getOssClient() != null) {", "first_line_prediction": " (zipFile.exists()) {", "match": 0}
{"groundtruth": "upresult = instance.getOssClient().initiateMultipartUpload(request);", "prediction": " result = instance.getOssClient().getAcsResponse(request);\n            String uploadId = result.getUploadId();\n            logger.println(\"UploadId:\" + uploadId);\n            UploadPartRequest uploadPartRequest = new UploadPartRequest();\n            uploadPartRequest.setBucketName(bucketName);\n            uploadPartRequest.setKey(objectName);\n            uploadPartRequest.setUploadId(uploadId);\n            uploadPartRequest.setPartNumber(1);\n            uploadPartRequest.setInputStream(new FileInputStream(zipFile));\n            UploadPartResult uploadPartResult = instance.getOssClient().getAcs", "first_line_groundtruth": "upresult = instance.getOssClient().initiateMultipartUpload(request);", "first_line_prediction": " result = instance.getOssClient().getAcsResponse(request);", "match": 0}
{"groundtruth": "instance.getOosClient().getAcsResponse(executionsRequest).getExecutions().get(0).getStatus();", "prediction": " instance.getOosClient().listExecutions(executionsRequest).getExecutions().get(0).getStatus();\n            } catch (ClientException e) {\n                logger.println(\"list executions failed\");\n            }\n        }\n        if (\"Success\".equalsIgnoreCase(status)) {\n            logger.println(\"OOS template execution success\");\n        } else {\n            logger.println(\"OOS template execution failed\");\n        }\n    }\n\n    /**\n     * zipAndUpload is used to compress and upload the specific path of the built project.\n     * @param instance\n     * @param projectName\n     * @param sourceDirectory\n     * @param logger", "first_line_groundtruth": "instance.getOosClient().getAcsResponse(executionsRequest).getExecutions().get(0).getStatus();", "first_line_prediction": " instance.getOosClient().listExecutions(executionsRequest).getExecutions().get(0).getStatus();", "match": 0}
{"groundtruth": "HazardDiamondAPI.open(this);", "prediction": " HazardDiamondAPI.open(data);\n        }\n        else {\n            HazardDiamondAPI.open(player, data);\n        }\n        return ActionResult.SUCCESS;\n    }", "first_line_groundtruth": "HazardDiamondAPI.open(this);", "first_line_prediction": " HazardDiamondAPI.open(data);", "match": 0}
{"groundtruth": "setScreen(new HazardScreen(holder.getHazardData()));", "prediction": "open(holder);\n    }\n\n    /**\n     * Opens an immutable {@link HazardScreen} on the client.\n     * @param players the players to display the hazard screen to\n     * @param holder the holder of the hazard data object to display\n     */\n    @Environment(EnvType.CLIENT)\n    public static void open(Collection<ServerPlayerEntity> players, HazardDataHolder holder) {\n        HazardDiamondAPIImpl.open(players, holder);\n    }\n\n    /**\n     * Opens an immutable {@link HazardScreen} on the client.\n     * @param player the player to display", "first_line_groundtruth": "setScreen(new HazardScreen(holder.getHazardData()));", "first_line_prediction": "open(holder);", "match": 0}
{"groundtruth": ".register(Registry.ITEM, HDiamond.id(\"panel_item\"), INSTANCE);", "prediction": ".register(Registry.ITEM, HDiamond.id(\"panel\"), INSTANCE);\n    }", "first_line_groundtruth": ".register(Registry.ITEM, HDiamond.id(\"panel_item\"), INSTANCE);", "first_line_prediction": ".register(Registry.ITEM, HDiamond.id(\"panel\"), INSTANCE);", "match": 0}
{"groundtruth": "AliyunPushLog.e(REC_TAG, \"key \" + entry.getKey() + \" value \" + entry.getValue());", "prediction": "\tAliyunPushLog.e(REC_TAG, \"showNotificationNow: \" + entry.getKey() + \" = \" + entry.getValue());\n\t\t}\n\t\treturn true;", "first_line_groundtruth": "AliyunPushLog.e(REC_TAG, \"key \" + entry.getKey() + \" value \" + entry.getValue());", "first_line_prediction": "\tAliyunPushLog.e(REC_TAG, \"showNotificationNow: \" + entry.getKey() + \" = \" + entry.getValue());", "match": 0}
{"groundtruth": "= holder.getHazardData().getTooltip().stream()\n                .map(Text.Serializer::toJson)\n                .toList();", "prediction": " = new NbtList();\n        var pictograms = new NbtList();\n        for (var pictogram : holder.getHazardData().getPictograms()) {\n            pictograms.add(NbtString.of(pictogram.toString()));\n        }\n        nbt.put(\"WailaData\", NbtCompound.of(\n            \"tooltips\",  tooltips,\n            \"pictograms\", pictograms\n        ));\n    }", "first_line_groundtruth": "= holder.getHazardData().getTooltip().stream()", "first_line_prediction": " = new NbtList();", "match": 0}
{"groundtruth": "ResultUtil.error();", "prediction": " ResultUtil.error(ErrorCode.SERVER_ERROR);\n    }", "first_line_groundtruth": "ResultUtil.error();", "first_line_prediction": " ResultUtil.error(ErrorCode.SERVER_ERROR);", "match": 0}
{"groundtruth": "target = (Annotation) AopUtil.getTarget(annotation);", "prediction": " annotation1 = annotation.annotationType();\n                if (annotation1 instanceof RequestMapping) {\n                    RequestMapping requestMapping = (RequestMapping) annotation;\n                    url = requestMapping.value()[0];\n                    httpMethod = requestMapping.method()[0].name();\n                }\n            }\n        }\n    }", "first_line_groundtruth": "target = (Annotation) AopUtil.getTarget(annotation);", "first_line_prediction": " annotation1 = annotation.annotationType();", "match": 0}
{"groundtruth": ".info(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u5931\u8d25\uff01\u624b\u673a\u53f7\uff1a\u3010{", "prediction": ".error(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u5931\u8d25\uff01\u624b\u673a\u53f7\uff1a\u3010{}\u3011 -- \u9a8c\u8bc1\u7801\uff1a\u3010{}\u3011 -- {}\", phone, param.get(\"code\"), DateUtil.now());\n        return \"\";\n    }\n\n    /**\n     * \u521b\u5efa\u8bf7\u6c42\u5bf9\u8c61\n     *\n     * @param phone \u624b\u673a\u53f7\n     * @param code  \u9a8c\u8bc1\u7801\n     * @return SendSmsRequest\n     */\n    private SendSmsRequest createRequest(String phone, String code) {\n        SendSmsRequest request = new SendSmsRequest();\n        request.setPhoneNumbers(phone);\n        request.setSignName(SmsConfig.SIGN_NAME);\n       ", "first_line_groundtruth": ".info(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u5931\u8d25\uff01\u624b\u673a\u53f7\uff1a\u3010{", "first_line_prediction": ".error(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u5931\u8d25\uff01\u624b\u673a\u53f7\uff1a\u3010{}\u3011 -- \u9a8c\u8bc1\u7801\uff1a\u3010{}\u3011 -- {}\", phone, param.get(\"code\"), DateUtil.now());", "match": 0}
{"groundtruth": "= UserRoleEnum.getEnumByValue(mustRole);", "prediction": " = UserRoleEnum.getEnumByValue(mustRole);\n            if (mustUserRoleEnum == null) {\n                throw new BusinessException(ErrorCode.AUTH_CHECK_ERROR);\n            }\n            if (mustUserRoleEnum.getValue() > loginUser.getRole().getValue()) {\n                throw new BusinessException(ErrorCode.AUTH_CHECK_ERROR);\n            }\n        }\n        Object proceed = joinPoint.proceed(joinPoint.getArgs());\n        return proceed;\n    }", "first_line_groundtruth": "= UserRoleEnum.getEnumByValue(mustRole);", "first_line_prediction": " = UserRoleEnum.getEnumByValue(mustRole);", "match": 0}
{"groundtruth": "username = jwtTokenProvider.getUsername(token);", "prediction": " username = jwtTokenProvider.getUsername(token);\n\n      // get user details from username\n      UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n\n      // create authentication token\n      UsernamePasswordAuthenticationToken authentication =\n          new UsernamePasswordAuthenticationToken(\n              userDetails, null, userDetails.getAuthorities());\n\n      // set authentication details\n      authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n      // set authentication in security context\n      SecurityContextHolder.getContext().setAuthentication(authentication);\n    }\n\n    filterChain.doFilter(request, response);\n  }\n\n  private String getTokenFromRequest", "first_line_groundtruth": "username = jwtTokenProvider.getUsername(token);", "first_line_prediction": " username = jwtTokenProvider.getUsername(token);", "match": 0}
{"groundtruth": "(errorCode.getMsg());", "prediction": "(message);// \u9519\u8bef\u4fe1\u606f\n        this.code=errorCode.getCode();\n        this.message=message;\n    }\n\n    public BusinessException(ErrorCode errorCode){\n        super(errorCode.getMsg());// \u9519\u8bef\u4fe1\u606f\n        this.code=errorCode.getCode();\n        this.message=errorCode.getMsg();\n    }", "first_line_groundtruth": "(errorCode.getMsg());", "first_line_prediction": "(message);// \u9519\u8bef\u4fe1\u606f", "match": 0}
{"groundtruth": "(cityService.findCitiesByName(pageNo, pageSize, sortBy, sortDir,name));", "prediction": "(cityService.findCitiesByName(pageNo, pageSize, sortBy, sortDir, name));\n    }\n\n    @PostMapping\n    @PreAuthorize(\"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')\")\n    public ResponseEntity<CityDto> createCity(@RequestBody CityDto cityDto) {\n        return ResponseEntity.ok(cityService.createCity(cityDto));\n    }\n\n    @PutMapping(\"/{id}\")\n    @PreAuthorize(\"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')\")\n    public ResponseEntity<CityDto> updateCity(@PathVariable Long id, @RequestBody CityDto", "first_line_groundtruth": "(cityService.findCitiesByName(pageNo, pageSize, sortBy, sortDir,name));", "first_line_prediction": "(cityService.findCitiesByName(pageNo, pageSize, sortBy, sortDir, name));", "match": 0}
{"groundtruth": "(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u6210\u529f\uff01\u624b\u673a\u53f7\uff1a\u3010{", "prediction": "(\"\u53d1\u9001\u9a8c\u8bc1\u7801\u6210\u529f, phone:{}\", phone);\n                return param.getString(\"code\");\n            } else {\n                log.error(\"\u53d1\u9001\u9a8c\u8bc1\u7801\u5931\u8d25, phone:{}\", phone);\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"\u53d1\u9001\u9a8c\u8bc1\u7801\u5931\u8d25, phone:{}\", phone);\n            return null;\n        }\n    }\n\n    /**\n     * \u968f\u673a\u751f\u6210\u9a8c\u8bc1\u7801\n     *\n     * @return JSONObject\n     */\n    private JSONObject randomCode() {\n        JSONObject param = new JSONObject();\n        param.put(\"code\", RandomUtil.randomNumbers(6));\n        return param;\n    }\n\n    /**\n     *", "first_line_groundtruth": "(\"\u963f\u91cc\u4e91\u77ed\u4fe1\u53d1\u9001\u6210\u529f\uff01\u624b\u673a\u53f7\uff1a\u3010{", "first_line_prediction": "(\"\u53d1\u9001\u9a8c\u8bc1\u7801\u6210\u529f, phone:{}\", phone);", "match": 0}
{"groundtruth": "return JSON_CONVERTOR.parseObject(input, clazz);", "prediction": " return JSON_CONVERTOR.parseObject(input, clazz);\n    }\n\n    /**\n     * \u89e3\u6790/\u53d1\u5e8f\u5217\u5316\u6210\u5bf9\u8c61\n     */\n    public static <T> T parseObject(byte[] bytes, Charset charset, Class<T> clazz) {\n        return JSON_CONVERTOR.parseObject(bytes, charset, clazz);\n    }\n\n    /**\n     * \u89e3\u6790/\u53d1\u5e8f\u5217\u5316\u6210\u5bf9\u8c61\n     */\n    public static <T> T parseObject(String input, Charset charset, Class<T> clazz) {\n        return JSON_CONVERTOR.parseObject(input, charset, clazz);\n    }\n\n    /**\n     *", "first_line_groundtruth": "return JSON_CONVERTOR.parseObject(input, clazz);", "first_line_prediction": " return JSON_CONVERTOR.parseObject(input, clazz);", "match": 0}
{"groundtruth": ".append(commandNamespace.name());", "prediction": "\n                            .append(commandNamespace.name())\n                            .append(\":\\n\");\n                    commandNamespace.getCommands().forEach(\n                            (cmdName, cmd) -> {\n                                builder.append(\"\\t\")\n                                        .append(cmdName)\n                                        .append(\"(\")\n                                        .append(cmd.getArgs().stream().map(arg -> arg.getName()).reduce(\"\", (a, b) -> a + \",\" + b))\n                                        .append(\")\\n\");\n                            });\n                });\n        return builder.toString();\n    }", "first_line_groundtruth": ".append(commandNamespace.name());", "first_line_prediction": "", "match": 0}
{"groundtruth": ".namespaceManager.getCommandNamespaces().forEach(namespace -> {", "prediction": ".setMetaClass(new GroovyShellMetaClass(this));\n    }\n\n    @Override\n    public void init() {\n        super.init();\n        // init reserved words\n        reservedWord.put(\"exit\", new ReservedWord() {\n            @Override\n            public void execute(ParsedLine line, ShellContext context) {\n                context.exit();\n            }\n        });\n        reservedWord.put(\"help\", new ReservedWord() {\n            @Override\n            public void execute(ParsedLine line, ShellContext context) {\n                context.help();\n            }\n        });\n        reservedWord.put(\"cls\", new ReservedWord() {\n            @", "first_line_groundtruth": ".namespaceManager.getCommandNamespaces().forEach(namespace -> {", "first_line_prediction": ".setMetaClass(new GroovyShellMetaClass(this));", "match": 0}
{"groundtruth": ".print(namespaceManager.dump());", "prediction": "\n            .println(\"help: print help info\");\n        RUNTIME.getPrinter()\n            .println(\"exit: exit the shell\");\n    }\n\n    protected void welcome() {\n        RUNTIME.getPrinter()\n            .println(\"Welcome to mychain-gl shell\");\n        RUNTIME.getPrinter()\n            .println(\"Type 'help' for more information\");\n    }", "first_line_groundtruth": ".print(namespaceManager.dump());", "first_line_prediction": "", "match": 0}
{"groundtruth": "shell.start();", "prediction": " // start shell\n         shell.start();\n    }\n\n    private static String getVersion() {\n        return ResourceUtil.readUtf8Str(\"META-INF/version.txt\");\n    }", "first_line_groundtruth": "shell.start();", "first_line_prediction": " // start shell", "match": 0}
{"groundtruth": "commandNamespace.getCommands().forEach(\n                            (cmdName, cmd) -> {", "prediction": " commandNamespace.getCommands().forEach(\n                            (cmdName, cmd) -> {\n                                builder.append(\"\\n\\t.\").append(cmdName);\n                                if (!cmd.getArgs().isEmpty()) {\n                                    builder.append(\"(\");\n                                    cmd.getArgs().forEach(arg -> {\n                                        builder.append(\"String \").append(arg.getName()).append(\",\");\n                                    });\n                                }\n                            }\n                    );\n                }\n        );\n        return builder.toString();\n    }", "first_line_groundtruth": "commandNamespace.getCommands().forEach(", "first_line_prediction": " commandNamespace.getCommands().forEach(", "match": 0}
{"groundtruth": "String result = shell.execute(command);", "prediction": " resultBuilder.append(shell.execute(command)).append(\"\\n\");\n                    } catch (Exception e) {\n                        resultBuilder.append(e.getMessage()).append(\"\\n\");\n                    }\n                    command = reader.readLine();\n                }\n                System.out.println(resultBuilder.toString());\n            } catch (Exception e) {\n                System.out.printf(\"execute file failed, file path: %s\\n\", filePath);\n            }\n            return;\n        }\n\n        shell.start();\n    }\n\n    private static String getVersion() {\n        try {\n            return ResourceUtil.readUtf8Str(Launcher.class.", "first_line_groundtruth": "String result = shell.execute(command);", "first_line_prediction": " resultBuilder.append(shell.execute(command)).append(\"\\n\");", "match": 0}
{"groundtruth": "!grpcClient.checkServerStatus()) {", "prediction": "cmd.hasOption(OP_CMD)) {\n            String cmdStr = cmd.getOptionValue(OP_CMD);\n            shellProvider.execute(cmdStr);\n        } else if (cmd.hasOption(OP_FILE)) {\n            String filePath = cmd.getOptionValue(OP_FILE);\n            File file = new File(filePath);\n            if (!file.exists()) {\n                System.out.println(\"file not exists\");\n                return;\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(ResourceUtil.getStream(filePath), Charset.forName(\"UTF-8\")));\n            String line;\n            while ((line", "first_line_groundtruth": "!grpcClient.checkServerStatus()) {", "first_line_prediction": "cmd.hasOption(OP_CMD)) {", "match": 0}
{"groundtruth": "getGrpcClient().shutdown();", "prediction": "getGrpcClient().stopBBC();\n            }\n        } catch (Exception e) {\n            // ignore\n        }\n    }\n\n    private void welcome() {\n        RUNTIME.getPrinter().println(\"Welcome to AntChain Plugin Server CLI\");\n        RUNTIME.getPrinter().println(\"Type 'help' for more information\");\n    }\n\n    private void initReservedWord() {\n        reservedWord.put(\"help\", new ReservedWord() {\n            @Override\n            public void execute() {\n                printHelp();\n            }\n        });\n\n        reservedWord.put(\"exit\", new ReservedWord() {\n            @Override\n            public void execute() {\n               ", "first_line_groundtruth": "getGrpcClient().shutdown();", "first_line_prediction": "getGrpcClient().stopBBC();", "match": 0}
{"groundtruth": "\"                          PLUGIN SERVER CLI \" + Launcher.getVersion()\n        );", "prediction": " \"                                                                               v0.1.0\");\n    }", "first_line_groundtruth": "\"                          PLUGIN SERVER CLI \" + Launcher.getVersion()", "first_line_prediction": " \"                                                                               v0.1.0\");", "match": 0}
{"groundtruth": ").execute();", "prediction": " + \"\").execute(cmd);\n\n                            } else {\n\n                                shellProvider.execute(cmd);\n                            }\n                        } catch (Exception e) {\n                            System.out.printf(\"illegal command [ %s ], execute failed\\n\", cmd);\n                        }\n                    }\n                }).start();\n            }\n        } finally {\n            shellLock.unlock();\n        }\n    }\n\n    public void stop() {\n        loopRunning.set(false);\n        reader.getTerminal().writer().flush();\n        reader.getTerminal().writer().close();\n        reader.getTerminal().close();\n    }\n\n    private void welcome() {\n        System.out.", "first_line_groundtruth": ").execute();", "first_line_prediction": " + \"\").execute(cmd);", "match": 0}
{"groundtruth": "().println(JsonUtil.format(result));", "prediction": "().println(result);\n                                } else {\n                                    RUNTIME.getPrinter().println(result + \"\\n\");\n                                }\n                            }\n                        } catch (Exception e) {\n                            RUNTIME.getPrinter().println(\"error\\n\");\n                        }\n                    }\n                }).start();\n            }\n        } finally {\n            shellLock.unlock();\n        }\n    }\n\n    public void stop() {\n        loopRunning.set(false);\n    }\n\n    private void welcome() {\n        RUNTIME.getPrinter().println(\"Welcome to AntChain Bridge Plugin Server CLI\");\n        RUNTIME.getPrinter().println(\"Type 'help' for more information", "first_line_groundtruth": "().println(JsonUtil.format(result));", "first_line_prediction": "().println(result);", "match": 0}
{"groundtruth": "(!buffer.isEmpty() && !namespace.name().startsWith(buffer)) {", "prediction": " (namespace.getCommandNames().isEmpty()) {\n                    return;\n                }\n\n                namespace.getCommandNames().forEach(commandName -> {\n                    if (!buffer.isEmpty() && !commandName.startsWith(buffer)) {\n                        return;\n                    }\n\n                    candidates.add(new Candidate(commandName, commandName, null, null, null, null, true));\n                });\n            });\n        } else {\n            // \u8865\u5168\u547d\u4ee4\n            namespaces.forEach(namespace -> {\n\n                if  (namespace.getCommandNames().isEmpty()) {\n                    return;\n                }\n\n                namespace.getCommandNames().forEach(commandName -> {", "first_line_groundtruth": "(!buffer.isEmpty() && !namespace.name().startsWith(buffer)) {", "first_line_prediction": " (namespace.getCommandNames().isEmpty()) {", "match": 0}
{"groundtruth": "new StringBuilder(namespace.name());", "prediction": " new StringBuilder();\n                namespace.getCommands().forEach(\n                        (cmdName, cmd) -> {\n                            sb.append(cmdName).append(\" \");\n                        }\n                );\n                String command = sb.toString();\n                if (command.endsWith(\" \")) {\n                    command = command.substring(0, command.length() - 1);\n                }\n                candidates.add(new Candidate(command, command, null, null, null, null, true));\n            });\n        } else {\n            //\u8865\u5168\u547d\u4ee4\n            namespaces.forEach(namespace -> {\n                if (!buffer.isEmpty() && !namespace.name().startsWith(", "first_line_groundtruth": "new StringBuilder(namespace.name());", "first_line_prediction": " new StringBuilder();", "match": 0}
{"groundtruth": "namespace.getCommands().forEach((cmdName, cmd) -> {", "prediction": " namespace.getCommands().forEach(\n                         (cmdName, cmd) -> {\n                             sb.append(\" \").append(cmdName);\n                         });\n\n                candidates.add(new Candidate(sb.toString(), sb.toString(), null, null, null, null, true));\n            });\n        }\n    }", "first_line_groundtruth": "namespace.getCommands().forEach((cmdName, cmd) -> {", "first_line_prediction": " namespace.getCommands().forEach(", "match": 0}
{"groundtruth": "!namespace.name().equals(buf[0])) {", "prediction": "namespace.name().equals(buf[0])) {\n                    CommandNamespace commandNamespace = namespace;\n                    commandNamespace.getCommands().forEach((cmdName, cmd) -> {\n                        if (cmdName.equals(buf[1])) {\n                            cmd.getArgs().forEach(arg -> {\n                                candidates.add(new Candidate(arg.getName(), arg.getName(), null, null, null, null, true));\n                            });\n                        }\n                    });\n                }\n            });\n        }\n    }", "first_line_groundtruth": "!namespace.name().equals(buf[0])) {", "first_line_prediction": "namespace.name().equals(buf[0])) {", "match": 0}
{"groundtruth": "mThermalUtils.setDefaultThermalProfile();", "prediction": " mThermalUtils.setThermalProfile(mPreviousApp);\n        }\n    };\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        mThermalUtils = ThermalUtils.getInstance(this);\n        mActivityTaskManager = (IActivityTaskManager) getSystemService(Context.ACTIVITY_TASK_SERVICE);\n        mActivityTaskManager.registerTaskStackListener(mTaskListener);\n        mActivityTaskManager.registerReceiverAsUser(mIntentReceiver, new IntentFilter(Intent.ACTION_BOOT_COMPLETED), UserHandle.ALL, null);\n    }\n\n    @Override\n    public void on", "first_line_groundtruth": "mThermalUtils.setDefaultThermalProfile();", "first_line_prediction": " mThermalUtils.setThermalProfile(mPreviousApp);", "match": 0}
{"groundtruth": "Candidate(namespace.name() + \".\", namespace.name(), null, null, null, null, true));", "prediction": " Candidate(sb.toString(), sb.toString(), null, null, null, null, true));\n            });\n        }\n    }", "first_line_groundtruth": "Candidate(namespace.name() + \".\", namespace.name(), null, null, null, null, true));", "first_line_prediction": " Candidate(sb.toString(), sb.toString(), null, null, null, null, true));", "match": 0}
{"groundtruth": "mThermalUtils.setThermalProfile(foregroundApp);", "prediction": " mThermalUtils.writePackage(foregroundApp, 0);\n                     mPreviousApp = foregroundApp;\n                     notifyDataSetChanged();\n                }\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to get focused root task info\", e);\n            }\n        }\n    };\n\n    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            if (action.equals(Intent.ACTION_SCREEN_ON)) {\n                mThermalUtils.writePackage(mPreviousApp", "first_line_groundtruth": "mThermalUtils.setThermalProfile(foregroundApp);", "first_line_prediction": " mThermalUtils.writePackage(foregroundApp, 0);", "match": 0}
{"groundtruth": "cmd.addArgs(argName, param.getType().getSimpleName(), constraints);", "prediction": " cmd.addArgs(argName, param.getType().getName(), constraints);\n            }\n\n            this.addCommand(cmd);\n        });\n    }\n\n    @Override\n    public void execute(PluginManageRequest request) {\n        super.execute(request);\n    }", "first_line_groundtruth": "cmd.addArgs(argName, param.getType().getSimpleName(), constraints);", "first_line_prediction": " cmd.addArgs(argName, param.getType().getName(), constraints);", "match": 0}
{"groundtruth": "(namespaceManager.getCommandNamespaces());", "prediction": "(namespaceManager.getCommandNamespaces());\n    }\n\n    /**\n     * \u6dfb\u52a0\u4fdd\u7559\u5173\u952e\u5b57\n     *\n     * @param reservedWords\n     */\n    public void addReservedWords(List<String> reservedWords) {\n\n        this.reservedWords.addAll(reservedWords);\n    }\n\n    @Override\n    public void complete(LineReader reader, ParsedLine line, List<Candidate> candidates) {\n\n        String lineText = line.line().trim();\n        if (lineText.isEmpty()) {\n            // \u8f93\u5165\u7a7a\u5b57\u7b26\u4e32\u65f6\uff0c\u8865\u5168\u6240\u6709namespace\n            for (CommandNamespace namespace : namespaces) {\n                candidates.add(new Candidate", "first_line_groundtruth": "(namespaceManager.getCommandNamespaces());", "first_line_prediction": "(namespaceManager.getCommandNamespaces());", "match": 1}
{"groundtruth": "mDiracSound.setMusic(enable ? 1 : 0);", "prediction": " refreshPlaybackIfNecessary();\n    }\n\n    public void setScenario(int scenario) {\n        mDiracSound.setScenario(scenario);\n    }\n\n    public void setPreset(int preset) {\n        mDiracSound.setPreset(preset);\n    }\n\n    public void setMusic(int enable) {\n        mDiracSound.setMusic(enable);\n    }\n\n    public void setHeadsetType(int type) {\n        mDiracSound.setHeadsetType(type);\n    }\n\n    public void setLevel(int band, float level) {\n        mDiracSound.setLevel(band, level);\n   ", "first_line_groundtruth": "mDiracSound.setMusic(enable ? 1 : 0);", "first_line_prediction": " refreshPlaybackIfNecessary();", "match": 0}
{"groundtruth": "FileUtils.writeLine(THERMAL_SCONFIG, THERMAL_STATE_DEFAULT);", "prediction": " FileUtils.writeFile(THERMAL_SCONFIG, THERMAL_STATE_DEFAULT);\n    }\n\n    protected static void setBenchmarkThermalProfile() {\n        FileUtils.writeFile(THERMAL_SCONFIG, THERMAL_STATE_BENCHMARK);\n    }\n\n    protected static void setBrowserThermalProfile() {\n        FileUtils.writeFile(THERMAL_SCONFIG, THERMAL_STATE_BROWSER);\n    }\n\n    protected static void setCameraThermalProfile() {\n        FileUtils.writeFile(THERMAL_SCONFIG, THERMAL_STATE_CAMERA);\n    }\n\n    protected static void setDialerThermalProfile()", "first_line_groundtruth": "FileUtils.writeLine(THERMAL_SCONFIG, THERMAL_STATE_DEFAULT);", "first_line_prediction": " FileUtils.writeFile(THERMAL_SCONFIG, THERMAL_STATE_DEFAULT);", "match": 0}
{"groundtruth": "null && mDiracSound.getMusic() == 1;", "prediction": " null && mDiracSound.isEnabled();\n    }\n\n    public void setScenario(int scenario) {\n        mDiracSound.setScenario(scenario);\n    }\n\n    public void setPreset(int preset) {\n        mDiracSound.setPreset(preset);\n    }\n\n    public void setHeadsetType(int type) {\n        mDiracSound.setHeadsetType(type);\n    }\n\n    public void setLevel(int band, float level) {\n        mDiracSound.setLevel(band, level);\n    }\n\n    public void setVolume(float volume) {\n        mDiracSound.setVolume(", "first_line_groundtruth": "null && mDiracSound.getMusic() == 1;", "first_line_prediction": " null && mDiracSound.isEnabled();", "match": 0}
{"groundtruth": "mDiracSound.setLevel(band, Float.valueOf(level[band]));", "prediction": " mDiracSound.setLevel(band, level[band]);\n        }\n    }\n\n    public void setScenario(int scene) {\n        mDiracSound.setScenario(scene);\n    }\n\n    public void setHeadsetType(int type) {\n        mDiracSound.setHeadsetType(type);\n    }\n\n    public void setHifiMode(int mode) {\n        mDiracSound.setHifiMode(mode);\n    }\n\n    public void setAudioStream(int stream) {\n        mDiracSound.setAudioStream(stream);\n    }\n\n    public void setAudioMode(int mode) {", "first_line_groundtruth": "mDiracSound.setLevel(band, Float.valueOf(level[band]));", "first_line_prediction": " mDiracSound.setLevel(band, level[band]);", "match": 0}
{"groundtruth": "? mDiracUtils.isDiracEnabled() : false;", "prediction": " && mDiracUtils.isDiracEnabled();\n\n        mSwitchBar = (MainSwitchPreference) findPreference(PREF_ENABLE);\n        mSwitchBar.setChecked(enhancerEnabled);\n        mSwitchBar.setOnPreferenceChangeListener(this);\n\n        mHeadsetType = (ListPreference) findPreference(PREF_HEADSET);\n        mHeadsetType.setSummary(mHeadsetType.getEntry());\n        mHeadsetType.setOnPreferenceChangeListener(this);\n\n        mPreset = (ListPreference) findPreference(PREF_PRESET);\n        mPreset.setSummary(mPreset.getEntry());\n        mPreset.setOn", "first_line_groundtruth": "? mDiracUtils.isDiracEnabled() : false;", "first_line_prediction": " && mDiracUtils.isDiracEnabled();", "match": 0}
{"groundtruth": "mDiracSound.setHifiMode(paramInt);", "prediction": " mDiracSound.setHifiMode(paramInt);\n    }\n\n    public void setScenario(int scenario) {\n        mDiracSound.setScenario(scenario);\n    }\n\n    public void setMusic(int paramInt) {\n        mDiracSound.setMusic(paramInt);\n    }\n\n    public void setAudioFocus(boolean paramBoolean) {\n        mDiracSound.setAudioFocus(paramBoolean);\n    }\n\n    public void setAudioFocus(boolean paramBoolean, int paramInt) {\n        mDiracSound.setAudioFocus(paramBoolean, paramInt);\n    }\n\n    public void set", "first_line_groundtruth": "mDiracSound.setHifiMode(paramInt);", "first_line_prediction": " mDiracSound.setHifiMode(paramInt);", "match": 0}
{"groundtruth": "gptClient.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPrompt);", "prediction": "propertyChangeSupport.firePropertyChange(\"settings\", oldValues, newValues);\n    }", "first_line_groundtruth": "gptClient.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPrompt);", "first_line_prediction": "propertyChangeSupport.firePropertyChange(\"settings\", oldValues, newValues);", "match": 0}
{"groundtruth": "mDiracUtils.setHifiMode((Boolean) newValue ? 1 : 0);", "prediction": " mDiracUtils.setHifiMode(Integer.parseInt(newValue.toString()));\n                 return true;\n            case PREF_PRESET:\n                mDiracUtils.setPreset(Integer.parseInt(newValue.toString()));\n                return true;\n            case PREF_SCENE:\n                mDiracUtils.setScene(Integer.parseInt(newValue.toString()));\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public void onSwitchChanged(SwitchPreference preference, boolean isChecked) {\n        if (mDiracUtils == null) return;\n        mDiracUtils.", "first_line_groundtruth": "mDiracUtils.setHifiMode((Boolean) newValue ? 1 : 0);", "first_line_prediction": " mDiracUtils.setHifiMode(Integer.parseInt(newValue.toString()));", "match": 0}
{"groundtruth": "mDiracUtils.setHeadsetType(Integer.parseInt(newValue.toString()));", "prediction": " mDiracUtils.setHeadsetType((String) newValue);\n                 break;\n            case PREF_PRESET:\n                 mDiracUtils.setPreset((String) newValue);\n                 break;\n            case PREF_HIFI:\n                 mDiracUtils.setHifi((Boolean) newValue);\n                 break;\n            case PREF_SCENE:\n                 mDiracUtils.setScene((String) newValue);\n                 break;\n            default:\n                return false;\n        }\n        return true;\n    }\n\n    @Override\n    public void onSwitchChanged(SwitchPreference preference, boolean isChecked) {\n        if (mDir", "first_line_groundtruth": "mDiracUtils.setHeadsetType(Integer.parseInt(newValue.toString()));", "first_line_prediction": " mDiracUtils.setHeadsetType((String) newValue);", "match": 0}
{"groundtruth": ".helpMenu.setHelpColors(config.getMessages().getHelpCmd().getHelpColors());", "prediction": ".helpMenu.colorsProvider(\n           (sender, key, args) -> config.getMessages().getHelpCmd().getColors(key));\n      this.helpMenu.reloadSuccessProvider(\n           (sender, key, args) -> config.getMessages().getReloadSuccess().getMessage(key));\n      this.helpMenu.reloadSuccessColorProvider(\n           (sender, key, args) -> config.getMessages().getReloadSuccess().getColors(key));\n      this.helpMenu.reloadFailureProvider(\n           (sender, key, args) -> config.getMessages().getReloadFailure().getMessage(key));", "first_line_groundtruth": ".helpMenu.setHelpColors(config.getMessages().getHelpCmd().getHelpColors());", "first_line_prediction": ".helpMenu.colorsProvider(", "match": 0}
{"groundtruth": "Menu menu = MyMenu.createMenu(this);", "prediction": " montoyaApi.registerScanCheck(scanCheck);\n         montoyaApi.registerContextMenuFactory(new MyContextMenuFactory(montoyaApi, logging));\n         montoyaApi.registerScannerCheck(new MyScannerCheck(montoyaApi, logging));\n         montoyaApi.registerScannerListener(new MyScannerListener(montoyaApi, logging));\n         montoyaApi.registerScannerInsertionPointListener(new MyScannerInsertionPointListener(montoyaApi, logging));\n         montoyaApi.registerScannerInsertionPointFactory(new MyScannerInsertionPointFactory(montoyaApi,", "first_line_groundtruth": "Menu menu = MyMenu.createMenu(this);", "first_line_prediction": " montoyaApi.registerScanCheck(scanCheck);", "match": 0}
{"groundtruth": "(sender, key, args) -> config.getMessages().getHelpCmd().getMessage(key));", "prediction": " (sender, key, args) -> {\n             if (key.equals(\"help\")) {\n               return config.getHelpCmd().getHelp(args);\n             }\n             return config.getMessages().get(key, args);\n           });\n\n      this.helpMenu.colorsProvider(\n           (sender, key, args) -> {\n             if (key.equals(\"help\")) {\n               return config.getHelpCmd().getColors(args);\n             }\n             return config.getMessages().getColors(key, args);\n           });\n\n      this.helpMenu.register();\n\n      getServer().getPluginManager().registerEvents(new", "first_line_groundtruth": "(sender, key, args) -> config.getMessages().getHelpCmd().getMessage(key));", "first_line_prediction": " (sender, key, args) -> {", "match": 0}
{"groundtruth": "description = HtmlResourceLoader.loadHtmlContent(\"aboutDescription.html\");", "prediction": " description = HtmlResourceLoader.loadResource(\"about.html\");\n        JLabel descriptionLabel = new JLabel(description);\n        descriptionLabel.putClientProperty(\"html.disable\", null);\n        return descriptionLabel;\n    }\n\n    private JButton createUpgradeButton() {\n        JButton upgradeButton = new JButton(\"Upgrade to Pro\");\n        upgradeButton.addActionListener(e -> {\n            try {\n                Desktop.getDesktop().browse(new URI(WEBSITE));\n            } catch (IOException | URISyntaxException ex) {\n                ex.printStackTrace();\n            }\n        });\n        upgradeButton.setBackground(UIManager.getColor(\"Burp.burpOrange", "first_line_groundtruth": "description = HtmlResourceLoader.loadHtmlContent(\"aboutDescription.html\");", "first_line_prediction": " description = HtmlResourceLoader.loadResource(\"about.html\");", "match": 0}
{"groundtruth": "mDiracUtils.setScenario(Integer.parseInt(newValue.toString()));", "prediction": " mDiracUtils.setScenario(Integer.parseInt(newValue.toString()));\n                 return true;\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public void onSwitchChanged(SwitchPreference preference, boolean isChecked) {\n        if (mDiracUtils == null) return;\n        mDiracUtils.setEnabled(isChecked);\n    }", "first_line_groundtruth": "mDiracUtils.setScenario(Integer.parseInt(newValue.toString()));", "first_line_prediction": " mDiracUtils.setScenario(Integer.parseInt(newValue.toString()));", "match": 0}
{"groundtruth": "mDiracUtils.setLevel((String) newValue);", "prediction": " mDiracUtils.setPreset(Integer.parseInt(newValue.toString()));\n                return true;\n            case PREF_SCENE:\n                mDiracUtils.setScene(Integer.parseInt(newValue.toString()));\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public void onSwitchChanged(SwitchPreference preference, boolean isChecked) {\n        if (mDiracUtils == null) return;\n        mDiracUtils.setEnabled(isChecked);\n    }", "first_line_groundtruth": "mDiracUtils.setLevel((String) newValue);", "first_line_prediction": " mDiracUtils.setPreset(Integer.parseInt(newValue.toString()));", "match": 0}
{"groundtruth": "myBurpExtension.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPromptText);", "prediction": " myBurpExtension.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPromptText);\n         onApplyButtonClickListener.onApplyButtonClick();\n    }\n\n    private GridBagConstraints createGridBagConstraints(int x, int y) {\n        GridBagConstraints gbc = new GridBagConstraints();\n        gbc.gridx = x;\n        gbc.gridy = y;\n        gbc.anchor = GridBagConstraints.WEST;\n        gbc.insets = new Insets(5, 5, 5, 5);\n        return gbc;\n    }\n\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {", "first_line_groundtruth": "myBurpExtension.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPromptText);", "first_line_prediction": " myBurpExtension.updateSettings(newApiKey, newModelId, newMaxPromptSize, newPromptText);", "match": 0}
{"groundtruth": "settingsView.setOnApplyButtonClickListener(() -> {", "prediction": " // the below code fragment can be found in:\n         // lib/src/main/java/burpgpt/gui/views/SettingsView.java\n         //     private void registerApplyButtonListener() {\n         //         applyButton.addActionListener(e -> {\n         //             myBurpExtension.getMontoyaApi().userInterface().applyThemeToComponent(this);\n         //             myBurpExtension.getMontoyaApi().userInterface().applyThemeToComponent(settingsView);\n         //             myBurpExtension.getMontoyaApi().userInterface().applyThemeToComponent(placeholdersView);\n         //            ", "first_line_groundtruth": "settingsView.setOnApplyButtonClickListener(() -> {", "first_line_prediction": " // the below code fragment can be found in:", "match": 0}
{"groundtruth": "gptRequest.setPrompt(prompt);", "prediction": " RequestBody body = RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), gson.toJson(gptRequest));\n     Request request = new Request.Builder()\n         .url(\"https://api.openai.com/v1/engines/\" + model + \"/completions\")\n         .addHeader(\"Authorization\", \"Bearer \" + apiKey)\n         .addHeader(\"Content-Type\", \"application/json\")\n         .post(body)\n         .build();\n     Response response = client.newCall(request).execute();\n     if (!response.isSuccessful()) {\n       throw new IOException", "first_line_groundtruth": "gptRequest.setPrompt(prompt);", "first_line_prediction": " RequestBody body = RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), gson.toJson(gptRequest));", "match": 0}
{"groundtruth": "inst.setOption(\"Skill Level\", String.valueOf(level));", "prediction": " inst.setLevel(level);\n    }", "first_line_groundtruth": "inst.setOption(\"Skill Level\", String.valueOf(level));", "first_line_prediction": " inst.setLevel(level);", "match": 0}
{"groundtruth": "(reader.getRest());", "prediction": "(reader.getRest());\n            }\n            else {\n                string.append(reader.peek(p - reader.getPos()));\n            }\n            if (string.length() == 0) {\n                finish();\n            }\n        }\n\n        @Override\n        public StringNode getResult() {\n            return node;\n        }\n    }", "first_line_groundtruth": "(reader.getRest());", "first_line_prediction": "(reader.getRest());", "match": 1}
{"groundtruth": "reader.hint(\"An Integer\");", "prediction": " else {\n                return null;\n            }\n        }\n\n        @Override\n        public void parse(StringReader reader) {\n            String next = tryParse(reader);\n            if (next != null) {\n                parsed = next;\n                super.parse(reader);\n            }\n            else {\n                reader.accept();\n                reader.peek(1);\n                reader.accept();\n            }\n        }\n\n        @Override\n        public IntegerNode getParsed() {\n            return (IntegerNode) super.getParsed();\n        }\n\n        @Override\n        public void finish() {\n            super.finish();\n            getParsed().setParsed(parsed);\n        }\n   ", "first_line_groundtruth": "reader.hint(\"An Integer\");", "first_line_prediction": " else {", "match": 0}
{"groundtruth": "if (!reader.canRead()) {", "prediction": " while ((p = reader.find(\" \")) != -1) {\n                 string.append(reader.getRest(p - reader.getPos()));\n                 reader.setPos(p);\n             }\n             string.append(reader.getRest());\n             reader.setPos(reader.length());\n             super.finish();\n         }\n    }", "first_line_groundtruth": "if (!reader.canRead()) {", "first_line_prediction": " while ((p = reader.find(\" \")) != -1) {", "match": 0}
{"groundtruth": "(cfg.getApiKey() != null) {", "prediction": " (cfg.getToken() != null) {\n            metadata.put(authorization, cfg.getToken());\n        }\n\n        if (cfg.getApiKey() != null) {\n            metadata.put(authorization, \"Bearer \" + cfg.getApiKey());\n        }\n\n        ManagedChannel channel;\n        if (cfg.getInsecure()) {\n            channel = NettyChannelBuilder.forAddress(cfg.getHost(), cfg.getPort())\n                    .usePlaintext(true)\n                    .build();\n        } else {\n            SslContext sslContext = GrpcSslContexts.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();", "first_line_groundtruth": "(cfg.getApiKey() != null) {", "first_line_prediction": " (cfg.getToken() != null) {", "match": 0}
{"groundtruth": "cfg.getTenantId() != null) {", "prediction": "cfg.getToken() != null) {\n            metadata.put(authorization, \"Bearer \" + cfg.getToken());\n        }\n\n        if (cfg.getTenantId() != null) {\n            metadata.put(asertoTenantId, cfg.getTenantId());\n        }\n\n        if (cfg.getApiKey() != null) {\n            metadata.put(authorization, \"ApiKey \" + cfg.getApiKey());\n        }\n\n        ManagedChannel channel = null;\n        if (cfg.getInsecure()) {\n            channel = NettyChannelBuilder.forAddress(cfg.getHost(), cfg.getPort())\n                    .usePlaintext(true)\n                    .", "first_line_groundtruth": "cfg.getTenantId() != null) {", "first_line_prediction": "cfg.getToken() != null) {", "match": 0}
{"groundtruth": "cfg.setCaCertPath(caCertPath);", "prediction": " cfg.setCaCertPath(caCertPath);\n\n        return this;\n    }\n\n    public ManagedChannel build() throws SSLException {\n        SslContext sslContext = null;\n        if (cfg.getInsecure()) {\n            sslContext = GrpcSslContexts.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslContext = GrpcSslContexts.forClient().trustManager(new File(cfg.getCaCertPath())).build();\n        }\n\n        ManagedChannel channel = NettyChannelBuilder.forAddress(cfg.getHost(), cfg.getPort())\n                .sslContext(", "first_line_groundtruth": "cfg.setCaCertPath(caCertPath);", "first_line_prediction": " cfg.setCaCertPath(caCertPath);", "match": 0}
{"groundtruth": "), cfg.getPort())\n                .intercept(MetadataUtils.newAttachHeadersInterceptor(metadata));", "prediction": "cfg.getHost()), cfg.getPort(cfg.getPort()))\n                 .intercept(MetadataUtils.newAttachHeadersInterceptor(metadata));\n\n        if (cfg.getInsecure(cfg.getInsecure())) {\n            channelBuilder.usePlaintext();\n        } else {\n            SslContext sslContext = GrpcSslContexts.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n            channelBuilder.sslContext(sslContext);\n        }\n\n        return channelBuilder.build();\n    }", "first_line_groundtruth": "), cfg.getPort())", "first_line_prediction": "cfg.getHost()), cfg.getPort(cfg.getPort()))", "match": 0}
{"groundtruth": "(cfg.getHost(), cfg.getPort())\n                .intercept(MetadataUtils.newAttachHeadersInterceptor(metadata));", "prediction": "(cfg.getHost(), cfg.getPort())\n                 .intercept(MetadataUtils.newAttachHeadersInterceptor(metadata));\n\n        if (cfg.getToken() != null) {\n            channelBuilder.intercept(MetadataUtils.newAttachHeadersInterceptor(Metadata.of(authorization, \"bearer \" + cfg.getToken())));\n        }\n\n        if (cfg.getInsecure()) {\n            channelBuilder.usePlaintext();\n        } else {\n            SslContext sslContext = GrpcSslContexts.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n            channelBuilder.sslContext(sslContext);\n        }\n\n        return channelBuilder", "first_line_groundtruth": "(cfg.getHost(), cfg.getPort())", "first_line_prediction": "(cfg.getHost(), cfg.getPort())", "match": 1}
{"groundtruth": "reader.peek(1);", "prediction": "\n             }\n        }\n\n        @Override\n        public StringNode build() {\n            return new StringNode(node.canBeEmpty);\n        }\n    }", "first_line_groundtruth": "reader.peek(1);", "first_line_prediction": "", "match": 0}
{"groundtruth": "return new AnalysisTaskWrapper(inst.calculate(), b);", "prediction": " return new AnalysisTaskWrapper(this.inst.calculate(), b);\n    }", "first_line_groundtruth": "return new AnalysisTaskWrapper(inst.calculate(), b);", "first_line_prediction": " return new AnalysisTaskWrapper(this.inst.calculate(), b);", "match": 0}
{"groundtruth": "reader.peek(p - reader.getPos()));", "prediction": "reader.peek(p - reader.getPos()));\n                reader.setPos(p);\n            }\n        }\n\n        @Override\n        public StringNode getNode() {\n            return node;\n        }\n\n        @Override\n        public String getFinished() {\n            return finished;\n        }\n    }", "first_line_groundtruth": "reader.peek(p - reader.getPos()));", "first_line_prediction": "reader.peek(p - reader.getPos()));", "match": 1}
{"groundtruth": "= reader.find(\" \")) == -1) {", "prediction": " = reader.find(\" \")) != -1) {\n                string.append(reader.peek(p - reader.getPos()));\n                reader.accept(p);\n            }\n            else {\n                string.append(reader.getRest());\n            }\n        }\n\n        @Override\n        public StringNode build() {\n            return new StringNode(node.canBeEmpty);\n        }\n    }\n\n    @Override\n    boolean test(StringReader reader) {\n        return reader.expect(node.name) && (!reader.canRead(node.name.length() + 1) || reader.expect(node.name + \"", "first_line_groundtruth": "= reader.find(\" \")) == -1) {", "first_line_prediction": " = reader.find(\" \")) != -1) {", "match": 0}
{"groundtruth": "mDiracUtils.setEnabled(isChecked);", "prediction": " if (isChecked) {\n            mDiracUtils.setEnabled(true);\n        } else {\n            mDiracUtils.setEnabled(false);\n        }\n    }", "first_line_groundtruth": "mDiracUtils.setEnabled(isChecked);", "first_line_prediction": " if (isChecked) {", "match": 0}
{"groundtruth": "Node.greedyString())\n                                )\n                );", "prediction": "Node.string().complete(s -> {\n                                             if (s.startsWith(\"bestmove\")) {\n                                                 collectedBestMove = s.substring(9);\n                                             } else if (s.startsWith(\"ponder\")) {\n                                                 collectedPonder = s.substring(6);\n                                             }\n                                         }))\n                                 )\n                 )\n                 .with(\n                        Node.literal(\"option\")\n                                 .mustConsumeChild()\n                                 .with(Node.literal(\"name\").mustConsumeChild()\n                                         .with(Node.string().complete(optionName::set))\n                                 )\n                                 .with(Node.literal(\"type\").mustConsumeChild()\n                                         .with", "first_line_groundtruth": "Node.greedyString())", "first_line_prediction": "Node.string().complete(s -> {", "match": 0}
{"groundtruth": "ShadeParser.parseShadeOutput(buildResult.toPath()),\n                        DependencyParser.parseDependencyCopyOutput(buildResult.toPath()));", "prediction": " parseDeployOutput(buildResult),\n                         parseDependencyTreeOutput(buildResult),\n                         parseShadeOutput(buildResult),\n                         parseNoticeFile(buildResult));\n\n        // check for excess dependencies\n        final Map<String, Set<Dependency>> modulesWithExcessDependencies =\n                findExcessDependencies(modulesWithBundledDependencies);\n\n        // check for missing dependencies\n        final Map<String, Set<Dependency>> modulesWithMissingDependencies =\n                findMissingDependencies(modulesWithBundledDependencies);\n\n        // check for missing NOTICE files\n        final Map<String, Set<Dependency>> modulesWithMissingNotices =\n                findMissingNotices(modules", "first_line_groundtruth": "ShadeParser.parseShadeOutput(buildResult.toPath()),", "first_line_prediction": " parseDeployOutput(buildResult),", "match": 0}
{"groundtruth": "DependencyParser.parseDependencyCopyOutput(buildResult.toPath()));", "prediction": "0,\n                        root);\n\n        // parse included dependencies from NOTICE files\n        final Map<String, Set<Dependency>> modulesWithNoticeDependencies =\n                combineAndFilterPaimonDependencies(\n                        NoticeParser.parseNoticeOutput(buildResult.toPath()),\n                        1,\n                        root);\n\n        // parse included dependencies from deploy output\n        final Map<String, Set<Dependency>> modulesWithDeployDependencies =\n                combineAndFilterPaimonDependencies(\n                        DeployParser.parseDeployOutput(buildResult.toPath()),\n                        2,\n                        root);\n\n        // parse dependency tree output\n        final Map<String, DependencyTree> modulesWithDependencyTree", "first_line_groundtruth": "DependencyParser.parseDependencyCopyOutput(buildResult.toPath()));", "first_line_prediction": "0,", "match": 0}
{"groundtruth": "= !cfg.getCaCertPath().isEmpty();", "prediction": " = cfg.getCaCertPath() != null;\n\n        if (insecure) {\n            channelBuilder.usePlaintext();\n        } else if (caSpecified) {\n            SslContext sslContext = GrpcSslContexts.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n            channelBuilder.sslContext(sslContext);\n        }\n\n        return channelBuilder.build();\n    }", "first_line_groundtruth": "= !cfg.getCaCertPath().isEmpty();", "first_line_prediction": " = cfg.getCaCertPath() != null;", "match": 0}
{"groundtruth": "return ParserUtils.parsePluginOutput(\n                lines,\n                DEPENDENCY_COPY_NEXT_MODULE_PATTERN,\n                DependencyParser::parseCopyDependencyBlock);", "prediction": " return parseDependencyCopyOutput(lines, DEPENDENCY_COPY_ITEM_PATTERN);\n    }\n\n    @VisibleForTesting\n    static Map<String, Set<Dependency>> parseDependencyCopyOutput(\n            Stream<String> lines, Pattern pattern) {\n        Map<String, Set<Dependency>> result = Map.of();\n        Set<Dependency> dependencies = new LinkedHashSet<>();\n        Iterator<String> iterator = lines.iterator();\n        while (iterator.hasNext()) {\n            String line = iterator.next();\n            Matcher matcher = pattern.matcher(line);\n            if (matcher.matches()) {\n                String module = matcher.group", "first_line_groundtruth": "return ParserUtils.parsePluginOutput(", "first_line_prediction": " return parseDependencyCopyOutput(lines, DEPENDENCY_COPY_ITEM_PATTERN);", "match": 0}
{"groundtruth": "with(Node.literal(\"string\").mustConsumeChild()\n                                        .with(Node.greedyString())\n                                )\n                );", "prediction": "with(Node.literal(\"multipv\").mustConsumeChild()\n                                         .with(Node.integer().complete(multipv::set))\n                                 )\n                                 .with(Node.literal(\"score\").mustConsumeChild()\n                                         .with(\n                                                Node.literal(\"cp\").mustConsumeChild()\n                                                         .with(Node.integer().complete(scoreCP::set))\n                                         )\n                                         .with(\n                                                Node.literal(\"mate\").mustConsumeChild()\n                                                         .with(Node.integer().complete(scoreMate::set))\n                                         )\n                                         .with(Node.literal(\"lowerbound\"))\n                                         .with(Node.literal(\"", "first_line_groundtruth": "with(Node.literal(\"string\").mustConsumeChild()", "first_line_prediction": "with(Node.literal(\"multipv\").mustConsumeChild()", "match": 0}
{"groundtruth": "return dependency.getGroupId().contains(\"org.scala-lang\")\n                || scalaSuffixPattern.matcher(dependency.getArtifactId()).find();", "prediction": " return scalaSuffixPattern.matcher(dependency.getArtifactId()).matches();\n    }\n\n    private static boolean isExcluded(final String artifactId) {\n        return EXCLUDED_MODULES.contains(artifactId);\n    }\n\n    private static Collection<String> checkScalaSuffixes(\n            final ParseResult parseResult,\n            final Path paimonRootPath) {\n        final List<String> violations = new ArrayList<>();\n        for (String moduleName : parseResult.getInfectedModules()) {\n            final Path modulePath = paimonRootPath.resolve(moduleName);\n            final Path modulePathWithSuffix = modulePath.resolve(\"src", "first_line_groundtruth": "return dependency.getGroupId().contains(\"org.scala-lang\")", "first_line_prediction": " return scalaSuffixPattern.matcher(dependency.getArtifactId()).matches();", "match": 0}
{"groundtruth": "+ dependency.getVersion()\n                + \":\"\n                + dependency.getClassifier().orElse(\"(no-classifier)\");", "prediction": " + dependency.getVersion();\n    }", "first_line_groundtruth": "+ dependency.getVersion()", "first_line_prediction": " + dependency.getVersion();", "match": 0}
{"groundtruth": "boolean isTestDependency = dependency.getScope().get().equals(\"test\");", "prediction": " boolean dependsOnScalaTest = dependsOnScalaTest(dependency);\n                if (dependsOnScala || dependsOnScalaTest) {\n                    infected = true;\n                    break;\n                }\n            }\n            if (infected) {\n                infectedModules.add(moduleName);\n            } else {\n                cleanModules.add(moduleName);\n            }\n        }\n\n        return new ParseResult(cleanModules, infectedModules);\n    }\n\n    private static boolean isExcluded(final String moduleName) {\n        return EXCLUDED_MODULES.contains(moduleName);\n    }\n\n    private static String stripScalaSuffix(final String moduleName) {\n        return", "first_line_groundtruth": "boolean isTestDependency = dependency.getScope().get().equals(\"test\");", "first_line_prediction": " boolean dependsOnScalaTest = dependsOnScalaTest(dependency);", "match": 0}
{"groundtruth": "wrapped.start(cmd),\n                SearchResultsWrapper::new,\n                b\n        );", "prediction": "wrapped.start(cmd),\n                e -> new SearchResultsWrapper(e),\n                b\n        );\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<Void, Void> stop() {\n        return new CompletableFutureWrapper<>(\n                this.wrapped.stop(),\n                Function.identity(),\n                b\n        );\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<Void, Void> quit() {\n        return new CompletableFutureWrapper<>(\n                this.wrapped.quit(),\n                Function.identity(),\n                b\n        );\n    }\n\n    @LuaWhitelist\n    public CompletableFutureWrapper<Void, Void> quit(String cmd) {\n        return new CompletableFutureWrapper<>(\n               ", "first_line_groundtruth": "wrapped.start(cmd),", "first_line_prediction": "wrapped.start(cmd),", "match": 1}
{"groundtruth": "= NoticeFileChecker.run(new File(args[0]), Paths.get(args[1]));", "prediction": " = 0;\n        int warningIssueCount = 0;\n        int infoIssueCount    = 0;\n\n        final Path mavenOutputPath = Paths.get(args[0]);\n        final Path paimonRootPath = Paths.get(args[1]);\n        final Path paimonDeployedPath = Paths.get(args[2]);\n\n        final ParseResult parseResult = parseMavenOutput(mavenOutputPath);\n\n        final Collection<String> violations = checkLicenses(parseResult, paimonRootPath, paimonDeployedPath);\n\n        for (final String violation : violations) {\n            if (violation", "first_line_groundtruth": "= NoticeFileChecker.run(new File(args[0]), Paths.get(args[1]));", "first_line_prediction": " = 0;", "match": 0}
{"groundtruth": "severeIssueCount += JarFileChecker.checkPath(Paths.get(args[2]));", "prediction": " // check for shaded dependencies\n        int shadedIssueCount = ShadedDependencyChecker.run(new File(args[0]), Paths.get(args[1]));\n\n        // check for missing NOTICE files\n        int missingNoticeIssueCount = MissingNoticeFileChecker.run(new File(args[0]), Paths.get(args[1]));\n\n        // check for missing NOTICE files\n        int missingDeployedArtifactIssueCount = MissingDeployedArtifactChecker.run(new File(args[0]), Paths.get(args[1]));\n\n        // check for missing NOTICE files\n        int missingLicenseIssueCount = MissingLicenseChecker.", "first_line_groundtruth": "severeIssueCount += JarFileChecker.checkPath(Paths.get(args[2]));", "first_line_prediction": " // check for shaded dependencies", "match": 0}
{"groundtruth": "DependencyParser.parseDependencyTreeOutput(path);", "prediction": " DependencyParser.parseMavenOutput(path);\n\n        for (Map.Entry<String, DependencyTree> entry : dependenciesByModule.entrySet()) {\n            final String moduleName = entry.getKey();\n            final DependencyTree dependencyTree = entry.getValue();\n\n            if (EXCLUDED_MODULES.contains(moduleName)) {\n                continue;\n            }\n\n            if (dependencyTree.isScalaFree()) {\n                cleanModules.add(moduleName);\n            } else {\n                infectedModules.add(moduleName);\n            }\n        }\n\n        return new ParseResult(cleanModules, infectedModules);\n    }\n\n    private static Collection<String> check", "first_line_groundtruth": "DependencyParser.parseDependencyTreeOutput(path);", "first_line_prediction": " DependencyParser.parseMavenOutput(path);", "match": 0}
{"groundtruth": "(!noticeContents.getNoticeModuleName().equals(moduleName)) {", "prediction": " (!noticeContents.getLines().get(0).equals(moduleName)) {\n                addProblem(problemsBySeverity, Severity.CRITICAL, \"The first line of the NOTICE file is not the module name.\");\n            }\n\n            // check that all dependencies are listed in the NOTICE file\n            for (Dependency dependency : modulesWithShadedDependencies.get(moduleName)) {\n                if (!noticeContents.getDependencies().contains(dependency)) {\n                    addProblem(\n                            problemsBySeverity,\n                            Severity.CRITICAL,\n                            \"The NOTICE file does not list the dependency \" + dependency);\n                }\n            }\n\n            // check that all dependencies are listed in", "first_line_groundtruth": "(!noticeContents.getNoticeModuleName().equals(moduleName)) {", "first_line_prediction": " (!noticeContents.getLines().get(0).equals(moduleName)) {", "match": 0}
{"groundtruth": "wrapped.stop();", "prediction": " wrapped.stop();\n        } catch (StockfishError.ProcessExitedError e) {\n            return LuaValue.NIL;\n        }\n        return LuaValue.NIL;\n    }", "first_line_groundtruth": "wrapped.stop();", "first_line_prediction": " wrapped.stop();", "match": 0}
{"groundtruth": "+ dependency.getClassifier().orElse(\"(no-classifier)\");", "prediction": " + dependency.getClassifier().orElse(null);\n    }", "first_line_groundtruth": "+ dependency.getClassifier().orElse(\"(no-classifier)\");", "first_line_prediction": " + dependency.getClassifier().orElse(null);", "match": 0}
{"groundtruth": "final Set<String> deployedModules = DeployParser.parseDeployOutput(buildResult);", "prediction": " // parse NOTICE files from modules\n        final Map<String, NoticeContents> modulesWithNotices =\n                parseNotices(modulesWithBundledDependencies, root);\n\n        // check NOTICE files for missing dependencies\n        final Map<String, Set<Dependency>> modulesWithMissingDependencies =\n                checkNoticesForMissingDependencies(modulesWithNotices, modulesWithBundledDependencies);\n\n        // check NOTICE files for excess dependencies\n        final Map<String, Set<Dependency>> modulesWithExcessDependencies =\n                checkNoticesForExcessDependencies(modulesWithNotices, modulesWithBundledDependencies);\n\n        // check NOTICE files for duplicate dependencies\n       ", "first_line_groundtruth": "final Set<String> deployedModules = DeployParser.parseDeployOutput(buildResult);", "first_line_prediction": " // parse NOTICE files from modules", "match": 0}
{"groundtruth": "= isExcluded(dependency.getArtifactId());", "prediction": " = isExcluded(dependency);\n                if (dependsOnScala && !isTestDependency && !isExcluded) {\n                    infected = true;\n                    break;\n                }\n            }\n\n            if (infected) {\n                infectedModules.add(moduleName);\n            } else {\n                cleanModules.add(moduleName);\n            }\n        }\n\n        return new ParseResult(cleanModules, infectedModules);\n    }\n\n    private static boolean isExcluded(final String moduleName) {\n        return EXCLUDED_MODULES.contains(moduleName);\n    }\n\n    private static boolean dependsOnScala(final Dependency dependency) {\n        return dependency.get", "first_line_groundtruth": "= isExcluded(dependency.getArtifactId());", "first_line_prediction": " = isExcluded(dependency);", "match": 0}
{"groundtruth": "declaredDependency : noticeContents.getDeclaredDependencies()) {", "prediction": " dependency : noticeContents.getDependencies()) {\n                declaredDependencies.add(dependency);\n            }\n\n            // collect all shaded dependencies from NOTICE file\n            Set<Dependency> shadedDependencies = new HashSet<>();\n            for (Dependency dependency : noticeContents.getDependencies()) {\n                if (dependency.getGroupId().contains(\"org.apache.paimon\")) {\n                    shadedDependencies.add(dependency);\n                }\n            }\n\n            // collect all shaded dependencies from modules\n            Set<Dependency> shadedDependenciesFromModules = new HashSet<>();\n            for (Map.Entry<String, Set<Dependency>> entry : modulesWithShadedDependencies", "first_line_groundtruth": "declaredDependency : noticeContents.getDeclaredDependencies()) {", "first_line_prediction": " dependency : noticeContents.getDependencies()) {", "match": 0}
{"groundtruth": "of(Dependency.create(groupId, artifactId, version, classifier));", "prediction": "of(\n                    Dependency.create(groupId, artifactId, version, classifier));\n        }\n        return Optional.empty();\n    }", "first_line_groundtruth": "of(Dependency.create(groupId, artifactId, version, classifier));", "first_line_prediction": "of(", "match": 0}
{"groundtruth": "(dependency.getArtifactId()).find();", "prediction": "(dependency.getArtifactId()).matches();\n    }\n\n    private static boolean isExcluded(final String artifactId) {\n        return EXCLUDED_MODULES.contains(artifactId);\n    }\n\n    private static Collection<String> checkScalaSuffixes(\n            final ParseResult parseResult,\n            final Path paimonRootPath) {\n        final List<String> violations = new ArrayList<>();\n        for (String moduleName : parseResult.getInfectedModules()) {\n            final Path modulePath = paimonRootPath.resolve(moduleName);\n            final Path noticePath = modulePath.resolve(\"NOTICE\");\n            if (Files.exists(", "first_line_groundtruth": "(dependency.getArtifactId()).find();", "first_line_prediction": "(dependency.getArtifactId()).matches();", "match": 0}
{"groundtruth": "(policyCtx.getName(), policyCtx.getLabel());", "prediction": "(policyCtx.getName(), policyCtx.getLabel());\n\n        isBuilder.setIdentityContext(identityContext);\n        isBuilder.setPolicyContext(policyContext);\n        isBuilder.setPolicyInstance(policy);\n\n        if (values != null) {\n            for (Map.Entry<String, Value> entry : values.entrySet()) {\n                isBuilder.addValues(buildValue(entry.getKey(), entry.getValue()));\n            }\n        }\n\n        IsResponse response = client.is(isBuilder.build());\n\n        return response.getResultList();\n    }\n\n    public Struct query(String query, PolicyCtx policyContext, Map", "first_line_groundtruth": "(policyCtx.getName(), policyCtx.getLabel());", "first_line_prediction": "(policyCtx.getName(), policyCtx.getLabel());", "match": 1}
{"groundtruth": "NoticeParser.parseNoticeFile(noticeFile);", "prediction": " Optional.of(NoticeParser.parseNoticeFile(noticeFile));\n                                            } catch (IOException e) {\n                                                LOG.error(\"Failed to parse NOTICE file {}\", noticeFile, e);\n                                                return Optional.empty();\n                                            }\n                                        }));\n\n        final Map<String, Set<String>> moduleToBundledDependencies =\n                modulesWithBundledDependencies.entrySet().stream()\n                                            .collect(\n                                                    Collectors.toMap(\n                                                            Map.Entry::getKey,\n                                                            entry -> entry.getValue().stream()\n                                                                       .map(Dependency::toString)\n                                                                       .collect(Collectors.toSet())));\n\n        final Map<String, Set<String", "first_line_groundtruth": "NoticeParser.parseNoticeFile(noticeFile);", "first_line_prediction": " Optional.of(NoticeParser.parseNoticeFile(noticeFile));", "match": 0}
{"groundtruth": "identityContext.getIdentityType());", "prediction": "identityContext.getIdentityType().toString());\n\n        return identityContextBuilder.build();\n    }\n\n    private PolicyContext buildPolicyContext(PolicyCtx policyContext) {\n        PolicyContext.Builder policyContextBuilder = PolicyContext.newBuilder();\n        policyContextBuilder.setPath(policyContext.getPath());\n        policyContextBuilder.setLabel(policyContext.getLabel());\n        policyContextBuilder.setDecisions(Arrays.asList(policyContext.getDecisions()));\n\n        return policyContextBuilder.build();\n    }\n\n    private Struct.Builder buildResourceContext(Map<String, Value> values) {\n        Struct.Builder structBuilder = Struct", "first_line_groundtruth": "identityContext.getIdentityType());", "first_line_prediction": "identityContext.getIdentityType().toString());", "match": 0}
{"groundtruth": ".get(module).flatten().collect(Collectors.toList());", "prediction": ".get(module).getDependencies();\n            final List<Dependency> cleanDependencies =\n                    dependencies.stream()\n                              .filter(dependency -> !dependency.isScala())\n                              .collect(Collectors.toList());\n            final List<Dependency> infectedDependencies =\n                    dependencies.stream()\n                              .filter(dependency -> dependency.isScala())\n                              .collect(Collectors.toList());\n\n            if (cleanDependencies.isEmpty()) {\n                cleanModules.add(moduleName);\n            } else {\n                infectedModules.add(moduleName);\n            }\n        }\n\n        return new ParseResult(cleanModules, infectedModules);\n    }\n\n    private static", "first_line_groundtruth": ".get(module).flatten().collect(Collectors.toList());", "first_line_prediction": ".get(module).getDependencies();", "match": 0}
{"groundtruth": "PolicyInstance policy = buildPolicy(policyContext.getName(), policyContext.getLabel());", "prediction": " PolicyContext policyContextProto = buildPolicyContext(policyContext);\n         Struct.Builder resourceContext = buildResourceContext(values);\n\n        queryRequestBuilder.setPolicyContext(policyContextProto);\n        queryRequestBuilder.setResourceContext(resourceContext);\n\n        QueryResponse queryResponse = client.query(queryRequestBuilder.build());\n\n        return queryResponse.getResult();\n    }\n\n    public Map<String, Value> decisionTree(IdentityCtx identityCtx, PolicyCtx policyCtx) {\n        DecisionTreeRequest.Builder decisionTreeRequestBuilder = DecisionTreeRequest.newBuilder();\n\n        IdentityContext identityContext = buildIdentityContext(identityCtx);\n        PolicyContext policy", "first_line_groundtruth": "PolicyInstance policy = buildPolicy(policyContext.getName(), policyContext.getLabel());", "first_line_prediction": " PolicyContext policyContextProto = buildPolicyContext(policyContext);", "match": 0}
{"groundtruth": "return ParserUtils.parsePluginOutput(\n                lines.filter(line -> !line.contains(\" Excluding \")),\n                SHADE_NEXT_MODULE_PATTERN,\n                ShadeParser::parseBlock);", "prediction": " return ParserUtils.parsePluginOutput(\n                 lines,\n                 SHADE_NEXT_MODULE_PATTERN,\n                 ShadeParser::parseShadeBlock);\n    }\n\n    private static Set<Dependency> parseShadeBlock(Matcher matcher) {\n        final String module = matcher.group(\"module\");\n        final Set<Dependency> dependencies = new LinkedHashSet<>();\n        final String groupId = matcher.group(\"groupId\");\n        final String artifactId = matcher.group(\"artifactId\");\n        final String version = matcher.group(\"version\");\n        dependencies.add(new Dependency(groupId, artifactId, version));\n        return dependencies;\n    }\n\n    /**\n    ", "first_line_groundtruth": "return ParserUtils.parsePluginOutput(", "first_line_prediction": " return ParserUtils.parsePluginOutput(", "match": 0}
{"groundtruth": "configIntermediary.updateConfigByObject(className, configObjString);", "prediction": " configIntermediary.updateConfigByObject(className, configObjString);\n        responseWriter(response, \"success\");\n    }\n\n    private void responseWriter(HttpServletResponse response, String result) throws IOException {\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        response.getWriter().write(result);\n    }", "first_line_groundtruth": "configIntermediary.updateConfigByObject(className, configObjString);", "first_line_prediction": " configIntermediary.updateConfigByObject(className, configObjString);", "match": 0}
{"groundtruth": "gitClient.listTags();", "prediction": " gitClient.getAllTags();\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Unable to get all tags due to: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n\n    Collections.reverse(tags);\n    return tags;\n  }\n\n  private void generateChangelog(JGit gitClient, JiraClient jiraClient, ChangelogGenerator changelogGenerator, String tagName, List<String> issueKeys) {\n    try {\n      changelogGenerator.generateChangelog(gitClient, jiraClient, tagName, issueKeys);\n    } catch (IOException e) {\n     ", "first_line_groundtruth": "gitClient.listTags();", "first_line_prediction": " gitClient.getAllTags();", "match": 0}
{"groundtruth": "gitClient.commitChangelogTagAndPush(tagName);", "prediction": " gitClient.commitChangelogTagAndPush(tagName);\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Committing exception: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n\n    log.info(\"Changelog generation complete.\");\n  }\n\n  private List<String> getAllTags(JGit gitClient) throws MissingObjectException, GitAPIException {\n    return gitClient.listTags();\n  }\n\n  private String processGenerateChangelogRequest(JGit gitClient, JiraClient jiraClient, ChangelogGenerator changelogGenerator, List<String> tags, String", "first_line_groundtruth": "gitClient.commitChangelogTagAndPush(tagName);", "first_line_prediction": " gitClient.commitChangelogTagAndPush(tagName);", "match": 0}
{"groundtruth": "> issueKeys = gitClient.getAllIssuesSinceLastTag();", "prediction": "> newTags = gitClient.incrementVersion(tags, versioningStrategy);\n        tagName = newTags.get(newTags.size() - 1);\n      } else {\n        tagName = gitClient.generateChangelog(tags);\n      }\n    } catch (GitAPIException | IOException e) {\n      log.error(\"Unable to generate the changelog due to: [{}]\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n\n    log.info(\"Generating the Changelog for the tag: [{}]\", tagName);\n    List<Issue> issues = jiraClient.getIssuesSinceLastTag(tagName", "first_line_groundtruth": "> issueKeys = gitClient.getAllIssuesSinceLastTag();", "first_line_prediction": "> newTags = gitClient.incrementVersion(tags, versioningStrategy);", "match": 0}
{"groundtruth": ".generateChangelogFromExisting(gitClient.getWorkingDir(), tagName, jiraIssues);", "prediction": ".generateChangelog(gitClient, jiraIssues, tagName);\n  }", "first_line_groundtruth": ".generateChangelogFromExisting(gitClient.getWorkingDir(), tagName, jiraIssues);", "first_line_prediction": ".generateChangelog(gitClient, jiraIssues, tagName);", "match": 0}
{"groundtruth": "ConfigPlus config = new ConfigPlus(configCategory, configCode, TypeJudgmentUtil.toJsonString(configValue));", "prediction": " ConfigPlus config = new ConfigPlus(configCategory, configCode, configValue);\n                 this.insert(config);\n            }\n        }\n        return configSupport;\n    }\n\n    @Override\n    default <T extends ConfigSupport> void delete(T configSupport) {\n        Field[] fields = configSupport.getClass().getDeclaredFields();\n        String configCategory = configSupport.getClass().getSimpleName();\n        List<ConfigPlus> configs = getConfigByCategoryAndCode(configCategory, TypeJudgmentUtil.getConfigCodes(fields));\n        Field.setAccessible(fields, true);\n        for (Field field : fields) {\n            String config", "first_line_groundtruth": "ConfigPlus config = new ConfigPlus(configCategory, configCode, TypeJudgmentUtil.toJsonString(configValue));", "first_line_prediction": " ConfigPlus config = new ConfigPlus(configCategory, configCode, configValue);", "match": 0}
{"groundtruth": "Config(configCategory, configCode, TypeJudgmentUtil.toJsonString(configValue));", "prediction": " Config(configCategory, configCode, configValue);\n                entityManager.persist(config);\n            }\n        }\n        return configSupport;\n    }\n\n    @Override\n    public <T extends ConfigSupport> List<T> getAll(Class<T> clazz) {\n        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(clazz);\n        Root<T> root = criteriaQuery.from(clazz);\n        criteriaQuery.select(root);\n        return entityManager.createQuery(criteriaQuery).getResultList();\n    }\n\n    @Override\n    public <T extends", "first_line_groundtruth": "Config(configCategory, configCode, TypeJudgmentUtil.toJsonString(configValue));", "first_line_prediction": " Config(configCategory, configCode, configValue);", "match": 0}
{"groundtruth": "replaceAll(configIntermediary.getRequestMapping() + \"get\", \"\");", "prediction": "substring(requestURI.lastIndexOf(\"/\") + 1);\n        String configObjString = null;\n        try {\n            configObjString = configIntermediary.getFineelyConfigService().get(className);\n        } catch (Exception e) {\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n            response.getWriter().write(JSONObject.toJSONString(e.getMessage()));\n            return;\n        }\n        response.setStatus(HttpServletResponse.SC_OK);\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        response", "first_line_groundtruth": "replaceAll(configIntermediary.getRequestMapping() + \"get\", \"\");", "first_line_prediction": "substring(requestURI.lastIndexOf(\"/\") + 1);", "match": 0}
{"groundtruth": "> issueKeys = gitClient.getIssuesWithinTag(tagName);", "prediction": "> issueKeys = gitClient.getIssuesWithinTag(tagName);\n\n        generateChangelog(gitClient, jiraClient, changelogGenerator, tagName, issueKeys);\n      } else {\n        tagName = tags.get(tags.size() - 1);\n\n        List<String> issueKeys = gitClient.getIssuesWithinTag(tagName);\n\n        generateChangelog(gitClient, jiraClient, changelogGenerator, tagName, issueKeys);\n      }\n    } catch (GitAPIException | MissingObjectException | IOException | URISyntaxException e) {\n      log.error(\"Unable to generate the changelog due to: [{}]\",", "first_line_groundtruth": "> issueKeys = gitClient.getIssuesWithinTag(tagName);", "first_line_prediction": "> issueKeys = gitClient.getIssuesWithinTag(tagName);", "match": 1}
{"groundtruth": "<Issue> jiraIssues = jiraClient.getIssueList(jiraIssueKeys);", "prediction": "<Issue> issues = jiraClient.getIssues(jiraIssueKeys);\n    changelogGenerator.generateChangelog(gitClient, tagName, issues);\n  }", "first_line_groundtruth": "<Issue> jiraIssues = jiraClient.getIssueList(jiraIssueKeys);", "first_line_prediction": "<Issue> issues = jiraClient.getIssues(jiraIssueKeys);", "match": 0}
{"groundtruth": "withRegion(null != config.getAwsRegionName() ? config.getAwsRegionName() : Constants.DEFAULT_AWS_REGION_NAME)\n                .withClientConfiguration(configuration)\n                .build();", "prediction": "withEndpointConfiguration(config.getEndpointConfiguration())\n                 .withClientConfiguration(configuration)\n                 .build();\n        writer = new DataWriter(config, client);\n    }\n\n    @Override\n    public void put(Collection<SinkRecord> records) {\n        log.info(\"Putting records to Personalize\");\n        for (SinkRecord record : records) {\n            try {\n                writer.write(record);\n            } catch (Exception e) {\n                log.error(\"Error writing record to Personalize\", e);\n                if (reporter != null) {\n                    reporter.reportError(record, e);\n                }\n            }\n       ", "first_line_groundtruth": "withRegion(null != config.getAwsRegionName() ? config.getAwsRegionName() : Constants.DEFAULT_AWS_REGION_NAME)", "first_line_prediction": "withEndpointConfiguration(config.getEndpointConfiguration())", "match": 0}
{"groundtruth": "writer.closeQuietly();", "prediction": " log.error(\"Retrying {} times\", retryAttempts);\n             remainingRetries = retryAttempts - 1;\n             reporter.report(records);\n        } else {\n            log.error(\"Giving up after {} retries\", retryAttempts);\n            reporter.report(records);\n        }\n    }\n\n    @Override\n    public void flush(Map<TopicPartition, OffsetAndMetadata> offsets) {\n        log.info(\"Flushing records\");\n        try {\n            writer.flush();\n        } catch (Exception ex) {\n            log.error(\"Error in flushing data:\", ex);\n        }\n    }\n\n    @Override\n    public void stop", "first_line_groundtruth": "writer.closeQuietly();", "first_line_prediction": " log.error(\"Retrying {} times\", retryAttempts);", "match": 0}
{"groundtruth": "(config.getMaxRetries());", "prediction": "(config.getMaxRetries());\n        AmazonPersonalizeEvents client = new AmazonPersonalizeEventsClient(configuration);\n        writer = new DataWriter(config, client);\n    }\n\n    @Override\n    public void put(Collection<SinkRecord> records) {\n        for (SinkRecord record : records) {\n            try {\n                writer.write(record);\n            } catch (Exception e) {\n                log.error(\"Error writing record to Personalize\", e);\n                if (reporter != null) {\n                    reporter.report(record, e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void flush(Map<", "first_line_groundtruth": "(config.getMaxRetries());", "first_line_prediction": "(config.getMaxRetries());", "match": 1}
{"groundtruth": "\"chat\", token.chat().id())\n      .fetch()\n      .first()\n      .then();", "prediction": "\n         \"chat\",\n         new PgChat(token.chat())\n       )\n       .fetch()\n       .rowsUpdated()\n       .then();\n  }", "first_line_groundtruth": "\"chat\", token.chat().id())", "first_line_prediction": "", "match": 0}
{"groundtruth": "!= config.getAwsRegionName() ? config.getAwsRegionName() : Constants.DEFAULT_AWS_REGION_NAME)\n                .withClientConfiguration(configuration)\n                .build();", "prediction": " // TODO: remove this once we have a region set in the config\n                )\n                 .withClientConfiguration(configuration)\n                 .build();\n\n        writer = new DataWriter(config, client);\n    }\n\n    @Override\n    public void put(Collection<SinkRecord> records) {\n        log.info(\"Putting records to Personalize\");\n        for (SinkRecord record : records) {\n            try {\n                writer.write(record);\n            } catch (Exception e) {\n                log.error(\"Error writing record to Personalize\", e);\n                if (reporter != null) {\n                    reporter.reportError(record, e", "first_line_groundtruth": "!= config.getAwsRegionName() ? config.getAwsRegionName() : Constants.DEFAULT_AWS_REGION_NAME)", "first_line_prediction": " // TODO: remove this once we have a region set in the config", "match": 0}
{"groundtruth": "methodLog.setStartTime(startTime);", "prediction": " methodLog.setArgs(args);\n         methodLog.setReturning(returning);\n         methodLog.setExceptionInfo(exceptionInfo);\n         methodLog.setIpAddress(ipAddress);\n         methodLog.setUrl(url);\n         methodLog.setModule(module);\n         methodLog.setMethod(methodName);\n         methodLog.setMethods(Arrays.toString(methods));\n         methodLog.setTimeConsuming(timeConsuming);\n         methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setStartTime(startTime);", "first_line_prediction": " methodLog.setArgs(args);", "match": 0}
{"groundtruth": "methodLog.setOperator(\"system\");", "prediction": " methodLog.setOperator(ipAddress);\n        }\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setOperator(\"system\");", "first_line_prediction": " methodLog.setOperator(ipAddress);", "match": 0}
{"groundtruth": ".bind(\"id\", chat.id())\n      .fetch()\n      .first()\n      .then();", "prediction": "\n       .bind(\"id\", chat.id())\n       .fetch()\n       .rowsUpdated()\n       .then();\n  }", "first_line_groundtruth": ".bind(\"id\", chat.id())", "first_line_prediction": "", "match": 0}
{"groundtruth": "methodLog.setMethodName(methodName);", "prediction": " methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setIpAddress(ipAddress);\n        methodLog.setArgs(args);\n        methodLog.setReturning(returning);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methods);\n        methodLog.setOperator(CommonConstants.DEFAULT_OPERATOR);\n        methodLog.setMethodName(methodName);\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setMethodName(methodName);", "first_line_prediction": " methodLog.setExceptionInfo(exceptionInfo);", "match": 0}
{"groundtruth": "methodLog.setAllParams(args);", "prediction": " methodLog.setArgs(args);\n        methodLog.setReturning(returning);\n        methodLog.setIpAddress(ipAddress);\n        methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methods);\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setAllParams(args);", "first_line_prediction": " methodLog.setArgs(args);", "match": 0}
{"groundtruth": "methodLog.setCreateTime(startTime);", "prediction": "", "first_line_groundtruth": "methodLog.setCreateTime(startTime);", "first_line_prediction": "", "match": 0}
{"groundtruth": "methodLog.setTimeConsuming(timeConsuming);", "prediction": " methodLog.setIp(ipAddress);\n        methodLog.setArgs(args);\n        methodLog.setReturning(returning);\n        methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methodName);\n        methodLog.setMethods(Arrays.toString(methods));\n        methodLog.setTimeConsuming(timeConsuming);\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setTimeConsuming(timeConsuming);", "first_line_prediction": " methodLog.setIp(ipAddress);", "match": 0}
{"groundtruth": "methodLog.setExceptionInfo(exceptionInfo);", "prediction": " methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setOperator(CommonConstants.DEFAULT_OPERATOR);\n        methodLog.setCreateTime(LocalDateTime.now());\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setExceptionInfo(exceptionInfo);", "first_line_prediction": " methodLog.setExceptionInfo(exceptionInfo);", "match": 0}
{"groundtruth": "methodLog.setIpAddress(ipAddress);", "prediction": " methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setIpAddress(ipAddress);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methods);\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setIpAddress(ipAddress);", "first_line_prediction": " methodLog.setExceptionInfo(exceptionInfo);", "match": 0}
{"groundtruth": "methodLog.setResult(returning);", "prediction": " methodLog.setReturning(returning);\n        methodLog.setIpAddress(ipAddress);\n        methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methods);\n        methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setResult(returning);", "first_line_prediction": " methodLog.setReturning(returning);", "match": 0}
{"groundtruth": "methodLog.setDesc(finishedDesc);", "prediction": " methodLog.setIp(ipAddress);\n         methodLog.setModule(module);\n         methodLog.setUrl(url);\n         methodLog.setMethod(methodName);\n         methodLog.setArgs(args);\n         methodLog.setReturning(returning);\n         methodLog.setFinishedDesc(finishedDesc);\n         methodLog.setExceptionInfo(exceptionInfo);\n         methodLog.setTimeConsuming(timeConsuming);\n         methodLog.setMethods(Arrays.toString(methods));\n         methodLogDao.save(methodLog);\n    }", "first_line_groundtruth": "methodLog.setDesc(finishedDesc);", "first_line_prediction": " methodLog.setIp(ipAddress);", "match": 0}
{"groundtruth": "methodLog.setEndTime(endTime);", "prediction": " if (Objects.nonNull(endTime)) {\n            methodLog.setEndTime(endTime);\n        }\n        methodLog.setIp(ipAddress);\n        methodLog.setArgs(args);\n        methodLog.setReturning(returning);\n        methodLog.setExceptionInfo(exceptionInfo);\n        methodLog.setModule(module);\n        methodLog.setUrl(url);\n        methodLog.setMethod(methodName);\n        methodLog.setTimeConsuming(timeConsuming);\n        methodLog.setMethod(methodName);\n        methodLog.setMethod(methodName);\n        methodLog.setMethod(methodName);\n       ", "first_line_groundtruth": "methodLog.setEndTime(endTime);", "first_line_prediction": " if (Objects.nonNull(endTime)) {", "match": 0}
{"groundtruth": "movimentacaoRepository.findByVeiculoId(id).isEmpty()){", "prediction": "movimentacaoRepository.findByCondutorId(id).isEmpty()){\n            condutorBanco.setAtivo(false);\n            this.condutorRepository.save(condutorBanco);\n        } else {\n            this.condutorRepository.delete(condutorBanco);\n        }\n    }\n\n    /**\n     * Retrieves all Condutores.\n     *\n     * @return ResponseEntity with a list of all Condutores.\n     */\n    public List<Condutor> listAll() {\n        return this.condutorRepository.findAll();\n    }\n\n    /**\n     * Retrieves a Condutor by its ID.", "first_line_groundtruth": "movimentacaoRepository.findByVeiculoId(id).isEmpty()){", "first_line_prediction": "movimentacaoRepository.findByCondutorId(id).isEmpty()){", "match": 0}
{"groundtruth": ".marcaRepository.findByNome(nome));", "prediction": ".marcaRepository.findByNome(nome));\n    }\n\n    /**\n     * Registers a new Marca.\n     *\n     * @param marca The Marca object to register.\n     * @return ResponseEntity indicating the success or failure of the operation.\n     */\n    @PostMapping\n    public ResponseEntity<?> registerMarca(@Validated @RequestBody Marca marca) {\n        try {\n            marcaRepository.save(marca);\n            return ResponseEntity.ok(marca);\n        } catch (DataIntegrityViolationException e) {\n            return ResponseEntity.badRequest().body(\"Marca j\u00e1 cadastrada\");\n        }\n    }\n\n   ", "first_line_groundtruth": ".marcaRepository.findByNome(nome));", "first_line_prediction": ".marcaRepository.findByNome(nome));", "match": 1}
{"groundtruth": "return ResponseEntity.ok(condutorRepository.findAllAtivo());", "prediction": " return ResponseEntity.ok(this.condutorRepository.findAllAtivo());\n     }", "first_line_groundtruth": "return ResponseEntity.ok(condutorRepository.findAllAtivo());", "first_line_prediction": " return ResponseEntity.ok(this.condutorRepository.findAllAtivo());", "match": 0}
{"groundtruth": "marcaService.validarDeleteMarca(id);", "prediction": " marcaService.validarDeleteMarca(id);\n            return ResponseEntity.ok(\"Registro atualizado com sucesso\");\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.internalServerError().body(\"Error: \" + e.getMessage());\n        }\n    }", "first_line_groundtruth": "marcaService.validarDeleteMarca(id);", "first_line_prediction": " marcaService.validarDeleteMarca(id);", "match": 0}
{"groundtruth": "<Veiculo> veiculoList = veiculoRepository.findAllAtivo();", "prediction": "<Veiculo> veiculos = this.veiculoRepository.findAllAtivo();\n        return ResponseEntity.ok(veiculos);\n    }", "first_line_groundtruth": "<Veiculo> veiculoList = veiculoRepository.findAllAtivo();", "first_line_prediction": "<Veiculo> veiculos = this.veiculoRepository.findAllAtivo();", "match": 0}
{"groundtruth": "= this.veiculoRepository.findByPlaca(placa);", "prediction": " = veiculoRepository.findByPlaca(placa);\n        return veiculo == null ? ResponseEntity.badRequest().body(\"placa n\u00e3o encontrada\") : ResponseEntity.ok(veiculo);\n    }", "first_line_groundtruth": "= this.veiculoRepository.findByPlaca(placa);", "first_line_prediction": " = veiculoRepository.findByPlaca(placa);", "match": 0}
{"groundtruth": "!this.movimentacaoRepository.findByVeiculoId(id).isEmpty()) {", "prediction": "this.veiculoRepository.findByPlaca(veiculo.getPlaca()).isPresent()) {\n            this.veiculoRepository.deleteById(id);\n        } else {\n            throw new IllegalArgumentException(\"Vehicle not registered !\");\n        }\n    }\n\n    /**\n     * Realiza valida\u00e7\u00f5es para cadastrar um novo modelo no sistema.\n     *\n     * @param modelo o objeto Modelo a ser validado.\n     * @throws IllegalArgumentException se alguma das valida\u00e7\u00f5es n\u00e3o passar.\n     */\n    @Transactional\n    public void validarCadastroModelo(Modelo modelo) {\n\n        modelo.setCadastro(LocalDateTime.now", "first_line_groundtruth": "!this.movimentacaoRepository.findByVeiculoId(id).isEmpty()) {", "first_line_prediction": "this.veiculoRepository.findByPlaca(veiculo.getPlaca()).isPresent()) {", "match": 0}
{"groundtruth": "Condutor condutor = this.condutorRepository.findbyCPF(cpf);", "prediction": " Condutor condutor = this.condutorRepository.findByCpf(cpf);\n\n        if (condutor == null || condutor.getCpf() == null) {\n            return ResponseEntity.badRequest().body(\"cpf inv\u00e1lido\");\n        }\n\n        return ResponseEntity.ok(condutor);\n    }", "first_line_groundtruth": "Condutor condutor = this.condutorRepository.findbyCPF(cpf);", "first_line_prediction": " Condutor condutor = this.condutorRepository.findByCpf(cpf);", "match": 0}
{"groundtruth": "(!this.modeloRepository.findByMarcaId(id).isEmpty()){", "prediction": " (!this.marcaRepository.findByModelos(id).isEmpty()) {\n            marca.setAtivo(false);\n            marcaRepository.save(marca);\n        } else {\n            marcaRepository.delete(marca);\n        }\n    }\n\n    /**\n     * Validates if a brand ID exists in the database.\n     *\n     * @param id The ID of the brand to be validated.\n     * @throws IllegalArgumentException if the ID does not exist in the database.\n     */\n    private void validarIdMarca(Long id) {\n        Assert.notNull(id, \"The brand ID cannot be", "first_line_groundtruth": "(!this.modeloRepository.findByMarcaId(id).isEmpty()){", "first_line_prediction": " (!this.marcaRepository.findByModelos(id).isEmpty()) {", "match": 0}
{"groundtruth": "veiculoService.validarDeleteVeiculo(id);", "prediction": " veiculoService.validarDeleteVeiculo(id);\n             return ResponseEntity.ok(\"Registro apagado com sucesso\");\n         } catch (IllegalArgumentException e) {\n             return ResponseEntity.internalServerError().body(\"Error: \" + e.getMessage());\n         }\n     }", "first_line_groundtruth": "veiculoService.validarDeleteVeiculo(id);", "first_line_prediction": " veiculoService.validarDeleteVeiculo(id);", "match": 0}
{"groundtruth": "modeloService.validarDeleteModelo(id);", "prediction": " modeloService.validarDeleteModelo(id);\n             return ResponseEntity.ok(\"Registro atualizado com sucesso\");\n         } catch (IllegalArgumentException e) {\n             return ResponseEntity.internalServerError().body(\"Error: \" + e.getMessage());\n         }\n     }", "first_line_groundtruth": "modeloService.validarDeleteModelo(id);", "first_line_prediction": " modeloService.validarDeleteModelo(id);", "match": 0}
{"groundtruth": "condutor = this.condutorRepository.findByNome(nome);", "prediction": " condutor = condutorRepository.findByNome(nome);\n        return condutor == null ? ResponseEntity.badRequest().body(\"Nome n\u00e3o encontrado\") : ResponseEntity.ok(condutor);\n    }\n\n    /**\n     * Registers a new Condutor.\n     *\n     * @param condutor The Condutor object to register.\n     * @return ResponseEntity indicating the success or failure of the operation.\n     */\n    @PostMapping\n    public ResponseEntity<?> register(@Validated @RequestBody Condutor condutor) {\n        return ResponseEntity.ok(this.condutorService.register(condutor));\n    }\n\n    /**\n     * Updates an", "first_line_groundtruth": "condutor = this.condutorRepository.findByNome(nome);", "first_line_prediction": " condutor = condutorRepository.findByNome(nome);", "match": 0}
{"groundtruth": "= movimentacaoRepository.findLastFiveByOrderByEntryDateDesc();", "prediction": " = movimentacaoRepository.findLastFiveMovimentacoes();\n        return ResponseEntity.ok(lastFiveMovimentacoes);\n    }", "first_line_groundtruth": "= movimentacaoRepository.findLastFiveByOrderByEntryDateDesc();", "first_line_prediction": " = movimentacaoRepository.findLastFiveMovimentacoes();", "match": 0}
{"groundtruth": ".ok(movimentacaoRepository.ultimaMovimentacao());", "prediction": ".ok(movimentacaoRepository.findLastMovimentacao());\n    }", "first_line_groundtruth": ".ok(movimentacaoRepository.ultimaMovimentacao());", "first_line_prediction": ".ok(movimentacaoRepository.findLastMovimentacao());", "match": 0}
{"groundtruth": "ok(marcaRepository.findAllAtivo());", "prediction": "ok(this.marcaRepository.findAllAtivo());\n    }\n\n    /**\n     * Creates a new Marca.\n     *\n     * @param marca The Marca to create.\n     * @return ResponseEntity with the created Marca.\n     */\n    @PostMapping\n    public ResponseEntity<?> createMarca(@Validated @RequestBody Marca marca) {\n        try {\n            marcaRepository.save(marca);\n            return ResponseEntity.ok(marca);\n        } catch (DataIntegrityViolationException e) {\n            return ResponseEntity.badRequest().body(\"J\u00e1 existe uma marca com esse nome\");\n        }\n    }", "first_line_groundtruth": "ok(marcaRepository.findAllAtivo());", "first_line_prediction": "ok(this.marcaRepository.findAllAtivo());", "match": 0}
{"groundtruth": "<Movimentacao> movimentacoes = movimentacaoRepository.findMovimentacoesAbertasByPlaca(placa);", "prediction": "<Movimentacao> movimentacoes = movimentacaoRepository.findMovimentacoesAbertasByPlaca(placa);\n            return ResponseEntity.ok(movimentacoes);\n        } else {\n            // Perform a search based on the placa (vehicle license plate)\n            List<Movimentacao> movimentacoes = movimentacaoRepository.findMovimentacoesAbertasByPlaca(placa);\n            return ResponseEntity.ok(movimentacoes);\n        }\n    }\n\n    /**\n     * Retrieves Movimentacoes by ID.\n     *\n     * @param id The ID of the Movimentacao to retrieve.\n    ", "first_line_groundtruth": "<Movimentacao> movimentacoes = movimentacaoRepository.findMovimentacoesAbertasByPlaca(placa);", "first_line_prediction": "<Movimentacao> movimentacoes = movimentacaoRepository.findMovimentacoesAbertasByPlaca(placa);", "match": 1}
{"groundtruth": ".ok(this.modeloRepository.findByNome(nome));", "prediction": ".ok(this.modeloRepository.findByNome(nome));\n    }", "first_line_groundtruth": ".ok(this.modeloRepository.findByNome(nome));", "first_line_prediction": ".ok(this.modeloRepository.findByNome(nome));", "match": 1}
{"groundtruth": "> modeloList = modeloRepository.findAllAtivo();", "prediction": "> modeloList = modeloRepository.findAllAtivo();\n        if (modeloList == null || modeloList.isEmpty()) {\n            return ResponseEntity.badRequest().body(\"N\u00e3o tem nenhum modelo ativo\");\n        } else {\n            return ResponseEntity.ok(modeloList);\n        }\n    }", "first_line_groundtruth": "> modeloList = modeloRepository.findAllAtivo();", "first_line_prediction": "> modeloList = modeloRepository.findAllAtivo();", "match": 1}
{"groundtruth": ".ok(configuracaoRepository.ultimaConfiguracao());", "prediction": ".ok(configuracaoService.getLast());\n    }\n\n    @PostMapping\n    public ResponseEntity<?> saveRequest(@Validated @RequestBody Configuracao configuracao) {\n        return ResponseEntity.ok(configuracaoRepository.save(configuracao));\n    }", "first_line_groundtruth": ".ok(configuracaoRepository.ultimaConfiguracao());", "first_line_prediction": ".ok(configuracaoService.getLast());", "match": 0}
{"groundtruth": "Movimentacao> movimentacoes = movimentacaoRepository.findAllAbertas();", "prediction": "Movimentacao> movimentacoes = movimentacaoRepository.findLastFiveByOrderByEntryDateDesc();\n            return ResponseEntity.ok(movimentacoes);\n        }\n    }\n\n    /**\n     * Retrieves Movimentacoes by Marca.\n     *\n     * @param marca The Marca of the Movimentacao to retrieve.\n     * @return ResponseEntity with a list of Movimentacoes by Marca.\n     */\n    @GetMapping(\"/marca/{marca}\")\n    public ResponseEntity<?> findMovimentacoesByMarca(@PathVariable(\"marca\") Marca marca) {\n        List<Movimentacao> movimentacoes", "first_line_groundtruth": "Movimentacao> movimentacoes = movimentacaoRepository.findAllAbertas();", "first_line_prediction": "Movimentacao> movimentacoes = movimentacaoRepository.findLastFiveByOrderByEntryDateDesc();", "match": 0}
{"groundtruth": "if (!this.modeloRepository.findByMarcaId(id).isEmpty()) {", "prediction": " // Verificar se o modelo est\u00e1 em uso\n        final List<Veiculo> veiculos = this.veiculoRepository.findByModeloId(id);\n        Assert.isTrue(veiculos.isEmpty(), \"O modelo est\u00e1 em uso!\");\n\n        modeloRepository.deleteById(id);\n    }", "first_line_groundtruth": "if (!this.modeloRepository.findByMarcaId(id).isEmpty()) {", "first_line_prediction": " // Verificar se o modelo est\u00e1 em uso", "match": 0}
{"groundtruth": "= marcaRepository.findActiveElement(marcaId);", "prediction": " = marcaRepository.findActiveElement(marcaId);\n        Assert.isTrue(!isActive.isEmpty(), \"The brand associated with this model is inactive.\");\n    }\n\n    /**\n     * Validates if the model associated with the marca is active.\n     *\n     * @param modeloId The ID of the model associated with the marca.\n     * @throws IllegalArgumentException If the model associated with the marca is inactive.\n     */\n    private void validarModeloAtivo(Long modeloId) {\n        final List<Modelo> isActive = modeloRepository.findActiveElement(modeloId);\n        Assert.isTrue(!isActive", "first_line_groundtruth": "= marcaRepository.findActiveElement(marcaId);", "first_line_prediction": " = marcaRepository.findActiveElement(marcaId);", "match": 0}
{"groundtruth": "movimentacaoService.validarDeleteMovimentacao(id);", "prediction": " movimentacaoService.excluirMovimentacao(id);\n             return ResponseEntity.ok(\"Registro Exclu\u00eddo com Sucesso\");\n        } catch (Exception e) {\n            return ResponseEntity.badRequest().body(e);\n        }\n    }", "first_line_groundtruth": "movimentacaoService.validarDeleteMovimentacao(id);", "first_line_prediction": " movimentacaoService.excluirMovimentacao(id);", "match": 0}
{"groundtruth": "<Boolean>newResult().data(dao.deleteComposition(composerId, title)).build();", "prediction": "newResult().data(dao.deleteComposition(composerId, title));\n        }\n        catch (EmptyResultDataAccessException e)\n        {\n            throw new GraphqlErrorException(\"No composition found with title: \" + title, e);\n        }\n    }\n\n    private UnaryOperator<Composer> selectIfPresent(String value, Function<Composer, String> getter)\n    {\n        return value == null ? c -> c : c -> Objects.equals(value, getter.apply(c)) ? c : null;\n    }", "first_line_groundtruth": "<Boolean>newResult().data(dao.deleteComposition(composerId, title)).build();", "first_line_prediction": "newResult().data(dao.deleteComposition(composerId, title));", "match": 0}
{"groundtruth": "(dao.allComposers()).detect(c -> id == c.id());", "prediction": "(this.dao.allComposers()).select(c -> c.id() == id).getFirstOptional().get().toRecord();\n    }\n\n    @QueryMapping\n    public List<Composer> composers()\n    {\n        return ListAdapter.adapt(this.dao.allComposers()).collect(Composer::toRecord);\n    }\n\n    @MutationMapping\n    public Composer updateComposer(@Argument int id, @Argument ComposerInput composer)\n    {\n        try\n        {\n            return this.dao.updateComposer(id, composer).toRecord();\n        }\n        catch (EmptyResultDataAccessException e)\n        {\n           ", "first_line_groundtruth": "(dao.allComposers()).detect(c -> id == c.id());", "first_line_prediction": "(this.dao.allComposers()).select(c -> c.id() == id).getFirstOptional().get().toRecord();", "match": 0}
{"groundtruth": "symbolNum = lsbBitReader.readBit() + 1;", "prediction": "ql = 0;\n            int q = 0;\n            int i = 0;\n            int j = 0;\n            int k = 0;\n            int l = 0;\n            int m = 0;\n            int n = 0;\n            int o = 0;\n            int p = 0;\n            int q0 = 0;\n            int q1 = 0;\n            int q2 = 0;\n            int q3 = 0;\n            int q4 = 0;\n            int q5 = 0;\n            int q6 = 0;\n            int q7", "first_line_groundtruth": "symbolNum = lsbBitReader.readBit() + 1;", "first_line_prediction": "ql = 0;", "match": 0}
{"groundtruth": "(Lists.adapt(dao.allComposers()));", "prediction": "(dao.allComposers());\n    }\n\n    @MutationMapping\n    public Composer addComposition(@Argument CompositionInput input)\n    {\n        return dao.addComposition(input);\n    }\n\n    @MutationMapping\n    public Composer updateComposer(@Argument ComposerInput input)\n    {\n        return dao.updateComposer(input);\n    }\n\n    private UnaryOperator<List<Composer>> selectIfPresent(String arg1, Function<Composer, String> function)\n    {\n        return list ->\n        {\n            if (arg1 == null)\n            {\n                return list;\n            }\n            return list.stream()\n                     .filter(c ->", "first_line_groundtruth": "(Lists.adapt(dao.allComposers()));", "first_line_prediction": "(dao.allComposers());", "match": 0}
{"groundtruth": "int) (2 + 2 * lsbBitReader.readBits(3));", "prediction": "int) (lsbBitReader.readBits(4) + 4);\n            codedSymbols = alphabetSize - 1;\n        } else {\n            codedSymbols = alphabetSize;\n        }\n\n        short[] codeLengths = new short[codedSymbols];\n\n        for (int i = 0; i < codedSymbols; i++) {\n            int symbol = lsbBitReader.readBits(maxSymbolBitLength);\n            codeLengths[i] = (short) huffmanTable.getCodeLength(symbol);\n        }\n\n        return codeLengths;\n    }\n\n    /**\n     * Returns the code length for the given symbol\n     *", "first_line_groundtruth": "int) (2 + 2 * lsbBitReader.readBits(3));", "first_line_prediction": "int) (lsbBitReader.readBits(4) + 4);", "match": 0}
{"groundtruth": "short len = (short) lsbBitReader.readBits(3);", "prediction": " lCodeLengths[L_CODE_ORDER[i]] = (short) lsbBitReader.readBits(8);\n            }\n\n            // now read the \"second stage\" code lengths\n            // In the following this is called the P-Code (for position code)\n            int numPCodeLengths = (int) (lsbBitReader.readBits(4) + 4);\n            short[] pCodeLengths = new short[numPCodeLengths];\n\n            for (int i = 0; i < numPCodeLengths; i++) {\n                pCodeLengths[i] = (short) lsbBit", "first_line_groundtruth": "short len = (short) lsbBitReader.readBits(3);", "first_line_prediction": " lCodeLengths[L_CODE_ORDER[i]] = (short) lsbBitReader.readBits(8);", "match": 0}
{"groundtruth": "lsbBitReader.readBits(length);", "prediction": " // Read the symbol\n        short symbol = (short) (lengthAndSymbol & 0xffff);\n\n        // Advance the reader\n        lsbBitReader.readBits(length);\n\n        return symbol;\n    }", "first_line_groundtruth": "lsbBitReader.readBits(length);", "first_line_prediction": " // Read the symbol", "match": 0}
{"groundtruth": "int) (lsbBitReader.readBits(4) + 4);", "prediction": "int) lsbBitReader.readBits(5);\n            int[] lCodeLengths = new int[numLCodeLengths];\n            for (int i = 0; i < numLCodeLengths; i++) {\n                lCodeLengths[i] = (int) lsbBitReader.readBits(3);\n            }\n\n            // now read the \"second stage\" code lengths\n            // In the following this is called the D-Code (for distance code)\n            int numDCodeLengths = (int) lsbBitReader.readBits(5);\n            int[] dCodeLengths = new int[num", "first_line_groundtruth": "int) (lsbBitReader.readBits(4) + 4);", "first_line_prediction": "int) lsbBitReader.readBits(5);", "match": 0}
{"groundtruth": "lsbBitReader.readBits(LEVEL1_BITS);", "prediction": " int symbol = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);\n             return (short) (level2.get(index >>> LEVEL1_BITS)[symbol]);\n        } else {\n            // Lvl1 lookup\n            return (short) (lengthAndSymbol & 0xffff);\n        }\n    }", "first_line_groundtruth": "lsbBitReader.readBits(LEVEL1_BITS);", "first_line_prediction": " int symbol = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);", "match": 0}
{"groundtruth": "short symbol2 = (short) lsbBitReader.readBits(8);", "prediction": " level1[0] = symbol1;\n            } else {\n                for (int i = 0; i < symbolNum; i++) {\n                    level1[i] = symbol1;\n                }\n            }\n        } else {\n            int symbolNum = lsbBitReader.readBit() + 1;\n            boolean first8Bits = lsbBitReader.readBit() == 1;\n            short symbol1 = (short) lsbBitReader.readBits(first8Bits ? 8 : 1);\n\n            if (symbolNum == 2) {\n                level1[0] = symbol1", "first_line_groundtruth": "short symbol2 = (short) lsbBitReader.readBits(8);", "first_line_prediction": " level1[0] = symbol1;", "match": 0}
{"groundtruth": "(int) (lsbBitReader.readBits(extraBits) + repeatOffset);", "prediction": "0;\n                while (repeatCount < 64) {\n                    if (lsbBitReader.readBit() == 1) {\n                        repeatCount++;\n                    } else {\n                        repeatCount += 2;\n                    }\n                }\n\n                repeatCount += repeatOffset;\n\n                if (repeatSymbol == 0) {\n                    repeatSymbol = lsbBitReader.readBits(extraBits);\n                }\n\n                for (int j = 0; j < repeatCount; j++) {\n                    codeLengths[i] = repeatSymbol;\n                }\n\n                prevLength = repeatSymbol;\n            }\n        }\n\n        return codeLengths;\n    }", "first_line_groundtruth": "(int) (lsbBitReader.readBits(extraBits) + repeatOffset);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "simpleLengthCode = lsbBitReader.readBit() == 1;", "prediction": " isMetaCode = lsbBitReader.readBit() == 1;\n        int metaCodeBits = (int) lsbBitReader.readBits(3) + 2;\n        int xSize = subSampleSize(alphabetSize, metaCodeBits);\n        int ySize = subSampleSize(alphabetSize, metaCodeBits);\n        int colorCacheBits = (int) lsbBitReader.readBits(3) + 2;\n        int colorCacheSize = 1 << colorCacheBits;\n        int colorCacheMask = colorCacheSize - 1;\n        int colorCache = 0;", "first_line_groundtruth": "simpleLengthCode = lsbBitReader.readBit() == 1;", "first_line_prediction": " isMetaCode = lsbBitReader.readBit() == 1;", "match": 0}
{"groundtruth": "level2Index = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);", "prediction": " index2 = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);\n            int[] table = level2.get(index2);\n            int symbol = table[(int) lsbBitReader.peekBits(length - LEVEL1_BITS - LEVEL2_BITS)];\n\n            lsbBitReader.readBits(length - LEVEL1_BITS - LEVEL2_BITS); // Consume bits of second level\n\n            return (short) symbol;\n        } else {\n            // Lvl1 lookup\n            lsbBitReader.readBits(length); // Consume bits of", "first_line_groundtruth": "level2Index = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);", "first_line_prediction": " index2 = (int) lsbBitReader.peekBits(length - LEVEL1_BITS);", "match": 0}
{"groundtruth": "short symbol1 = (short) lsbBitReader.readBits(first8Bits ? 8 : 1);", "prediction": " // 1-256\n            int codeLength = first8Bits ? lsbBitReader.readBits(8) + 1 : symbolNum;\n            int symbol = symbolNum;\n            for (int i = 0; i < codeLength; i++) {\n                level1[symbol] = i;\n                symbol <<= 1;\n            }\n        } else {\n            int codeLength = lsbBitReader.readBits(LEVEL1_BITS);\n            int symbol = 1 << codeLength;\n            for (int i = 0; i < alphabetSize; i++) {\n                level1[symbol", "first_line_groundtruth": "short symbol1 = (short) lsbBitReader.readBits(first8Bits ? 8 : 1);", "first_line_prediction": " // 1-256", "match": 0}
{"groundtruth": ") lsbBitReader.peekBits(LEVEL1_BITS);", "prediction": ") (lsbBitReader.readBits(LEVEL1_BITS) >>> 1);\n\n        if (index < level1.length) {\n            return (short) (level1[index] >>> 16);\n        }\n\n        int level2Index = (int) (lsbBitReader.readBits(LEVEL2_BITS) >>> 1);\n        int level2Size = (int) (level1[index] & 0xffff);\n\n        if (level2Index >= level2Size) {\n            throw new IOException(\"Huffman: Invalid level2 index.\");\n        }\n\n        int[] level2 = this", "first_line_groundtruth": ") lsbBitReader.peekBits(LEVEL1_BITS);", "first_line_prediction": ") (lsbBitReader.readBits(LEVEL1_BITS) >>> 1);", "match": 0}
{"groundtruth": "data.getDataElements(x >> bits, y >> bits, rgba);", "prediction": " raster.getDataElements(x, y, rgba);\n                 int r = rgba[0];\n                 int g = rgba[1];\n                 int b = rgba[2];\n                 int a = rgba[3];\n                 if (a == 0) {\n                     rgba[0] = rgba[1] = rgba[2] = 0;\n                 } else {\n                     rgba[0] = (byte) (r * a / 255);\n                     rgba[1] = (byte) (g * a / 255);\n                     rgba[2] = (byte) (b * a / ", "first_line_groundtruth": "data.getDataElements(x >> bits, y >> bits, rgba);", "first_line_prediction": " raster.getDataElements(x, y, rgba);", "match": 0}
{"groundtruth": "int) (2 + lsbBitReader.readBits(maxSymbolBitLength));", "prediction": "int) (lsbBitReader.readBits(maxSymbolBitLength) + 1);\n        } else {\n            codedSymbols = (int) (lsbBitReader.readBits(1) + 1);\n        }\n\n        short[] codeLengths = new short[codedSymbols];\n\n        for (int i = 0; i < codedSymbols; i++) {\n            int symbol = (int) (lsbBitReader.readBits(huffmanTable.getBitLength(i)) + 1);\n            codeLengths[i] = (short) symbol;\n        }\n\n        return codeLengths;\n    }\n\n    /**", "first_line_groundtruth": "int) (2 + lsbBitReader.readBits(maxSymbolBitLength));", "first_line_prediction": "int) (lsbBitReader.readBits(maxSymbolBitLength) + 1);", "match": 0}
{"groundtruth": "raster.setDataElements(x, 0, rgba);", "prediction": " raster.setDataElements(x, 0, rgba);\n        }\n\n        // (0,y) T predict\n        for (int y = 1; y < height; y++) {\n            raster.getDataElements(0, y, rgba);\n            raster.getDataElements(0, y - 1, predictor);\n            addPixels(rgba, predictor);\n            raster.setDataElements(0, y, rgba);\n        }\n\n        // (x,y) TR predict\n        for (int x = 1; x < width; x++) {\n            for (int y = 1; y < height; y++)", "first_line_groundtruth": "raster.setDataElements(x, 0, rgba);", "first_line_prediction": " raster.setDataElements(x, 0, rgba);", "match": 0}
{"groundtruth": "ReplayManager.getInstance().despawnPlayerClone(this);", "prediction": " this.setGamemode(GameMode.SURVIVAL);\n        }\n    }", "first_line_groundtruth": "ReplayManager.getInstance().despawnPlayerClone(this);", "first_line_prediction": " this.setGamemode(GameMode.SURVIVAL);", "match": 0}
{"groundtruth": "raster.getDataElements(0, 0, rgba);", "prediction": " // (0,1) L predict\n         // (0,2) T predict\n         // (0,3) TR predict\n         // (0,4) TL predict\n         // (0,5) Average2(L, TR) predict\n         // (0,6) Average2(L, TL) predict\n         // (0,7) Average2(L, T) predict\n         // (0,8) Average2(TL, T) predict\n         // (0,9) Average2(T, TR) predict\n         // (0,10) Average2(Average2(L, TL),", "first_line_groundtruth": "raster.getDataElements(0, 0, rgba);", "first_line_prediction": " // (0,1) L predict", "match": 0}
{"groundtruth": "Live.getInstance().requestLiveToken(\n                (deviceCode, userCode, verificationUrl, expiresIn, interval) -> {", "prediction": " AccountManager.getInstance().startAuth();\n    }", "first_line_groundtruth": "Live.getInstance().requestLiveToken(", "first_line_prediction": " AccountManager.getInstance().startAuth();", "match": 0}
{"groundtruth": "raster.setDataElements(0, 0, rgba);", "prediction": " raster.setDataElements(0, 0, rgba);\n\n        // (0,1) L predict\n        raster.getDataElements(0, 1, rgba);\n        rgba[3] += 0xff;\n         raster.setDataElements(0, 1, rgba);\n\n        // (0,2) T predict\n        raster.getDataElements(0, 2, rgba);\n        rgba[3] += 0xff;\n         raster.setDataElements(0, 2, rgba);\n\n        // (0,3) TR predict\n        raster.getDataElements(0, 3, rgba);\n        rgba[3", "first_line_groundtruth": "raster.setDataElements(0, 0, rgba);", "first_line_prediction": " raster.setDataElements(0, 0, rgba);", "match": 0}
{"groundtruth": "String data = FileManager.getFileResourceAsString(\"bedrock-data/required_item_list.json\");", "prediction": " ITEM_DEFINITIONS = JSON.parseObject(FileManager.getFileResourceAsString(\"bedrock-data/item_definitions.json\"), new TypeReference<ArrayList<ItemDefinition>>() {});\n    }", "first_line_groundtruth": "String data = FileManager.getFileResourceAsString(\"bedrock-data/required_item_list.json\");", "first_line_prediction": " ITEM_DEFINITIONS = JSON.parseObject(FileManager.getFileResourceAsString(\"bedrock-data/item_definitions.json\"), new TypeReference<ArrayList<ItemDefinition>>() {});", "match": 0}
{"groundtruth": "ReplayManager.getInstance().spawnPlayerClone(this);", "prediction": " this.setGamemode(GameMode.SPECTATOR);\n        } else {\n            this.setGamemode(GameMode.SURVIVAL);\n        }\n    }", "first_line_groundtruth": "ReplayManager.getInstance().spawnPlayerClone(this);", "first_line_prediction": " this.setGamemode(GameMode.SPECTATOR);", "match": 0}
{"groundtruth": "OutputWindow.print(\"Proxy server Listening on \" + bindAddress);", "prediction": "\n\n        OutputWindow.print(\"Starting ReplayViewerServer...\");\n        ReplayViewerServer replayViewerServer = new ReplayViewerServer(port);\n        replayViewerServer.start();\n\n        OutputWindow.print(\"Starting Live...\");\n        Live live = new Live();\n        live.start();\n\n        OutputWindow.print(\"Starting BedrockServer...\");\n        BedrockServer bedrockServer = new BedrockServer(port);\n        bedrockServer.start();\n\n        OutputWindow.print(\"Starting BedrockClient...\");\n        BedrockClient bedrockClient = new BedrockClient(port);\n        bedrockClient.start();\n\n        OutputWindow.print", "first_line_groundtruth": "OutputWindow.print(\"Proxy server Listening on \" + bindAddress);", "first_line_prediction": "", "match": 0}
{"groundtruth": "proxyServer.start();", "prediction": "\n\n        OutputWindow.print(\"Starting proxy server...\");\n        proxyServer.start();\n\n        OutputWindow.print(\"Starting replay viewer server...\");\n        ReplayViewerServer replayViewerServer = new ReplayViewerServer(proxyServer);\n        replayViewerServer.start();\n\n        OutputWindow.print(\"Starting live server...\");\n        Live.start();\n\n        OutputWindow.print(\"BedrockReplay started!\");\n        OutputWindow.print(\"Press any key to exit...\");\n        System.in.read();\n\n        OutputWindow.print(\"Stopping BedrockReplay...\");\n        proxyServer.stop();\n        replayViewerServer.stop();\n        Live.stop();\n\n        long", "first_line_groundtruth": "proxyServer.start();", "first_line_prediction": "", "match": 0}
{"groundtruth": "OutputWindow.print(\"Successfully loaded your account!\");", "prediction": " AccountManager.loadAccount(accountFile);\n            } catch (Exception e) {\n                OutputWindow.print(\"Failed to load account file!\");\n                e.printStackTrace();\n            }\n        } else {\n            OutputWindow.print(\"No account file found!\");\n            OutputWindow.print(\"Please create one using the 'createaccount' command!\");\n        }\n    }", "first_line_groundtruth": "OutputWindow.print(\"Successfully loaded your account!\");", "first_line_prediction": " AccountManager.loadAccount(accountFile);", "match": 0}
{"groundtruth": "raster.getSample(xC, y, 1);", "prediction": "0;\n                for (int i = 0; i < componentSize; i++) {\n                    sample |= (colorTable[xC * componentSize + i] & 0xff) << componentOffset;\n                }\n\n                data.getDataElements(x >> bits, y >> bits, rgba);\n                rgba[3] = (byte) (sample >> 24);\n                rgba[0] = (byte) (sample >> 16);\n                rgba[1] = (byte) (sample >> 8);\n                rgba[2] = (byte) (sample);\n                raster.setDataElements(x, y", "first_line_groundtruth": "raster.getSample(xC, y, 1);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "OutputWindow.print(\"Done (took \" + (System.currentTimeMillis() / 1000L - startTime) + \"s)!\");", "prediction": "\n\n        OutputWindow.print(\"Loading account data...\");\n        AccountManager.loadAccounts();\n\n        OutputWindow.print(\"Loading Live data...\");\n        Live.loadLive();\n\n        OutputWindow.print(\"BedrockReplay started!\");\n        OutputWindow.print(\"Press any key to exit...\");\n        System.in.read();\n        OutputWindow.print(\"Exiting...\");\n\n        long endTime = (System.currentTimeMillis() / 1000L);\n        OutputWindow.print(\"BedrockReplay finished in \" + (endTime - startTime) + \" seconds!\");\n    }", "first_line_groundtruth": "OutputWindow.print(\"Done (took \" + (System.currentTimeMillis() / 1000L - startTime) + \"s)!\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "raster.getDataElements(x, 0, rgba);", "prediction": " raster.getDataElements(x, 0, rgba);\n             predictor[0] = rgba[0];\n             predictor[1] = rgba[1];\n             predictor[2] = rgba[2];\n             predictor[3] = rgba[3];\n             raster.setDataElements(x, 0, predictor);\n        }\n\n        // (0,y) T predict\n        for (int y = 1; y < height; y++) {\n             raster.getDataElements(0, y, rgba);\n             predictor[0] = rgba[0];\n             predictor[1] = rgba[1];\n             predictor[2", "first_line_groundtruth": "raster.getDataElements(x, 0, rgba);", "first_line_prediction": " raster.getDataElements(x, 0, rgba);", "match": 0}
{"groundtruth": "raster.getDataElements(x - 1, 0, predictor);", "prediction": "", "first_line_groundtruth": "raster.getDataElements(x - 1, 0, predictor);", "first_line_prediction": "", "match": 0}
{"groundtruth": "callback.onComplete(accessToken, refreshToken);", "prediction": " callback.onComplete(accessToken, refreshToken);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, 0, deviceAuth.getIntValue(\"interval\") * 1000);\n    }\n\n    @SneakyThrows\n    private JSONObject startDeviceAuth() {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(LIVE_CONNECT_URL))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .POST(HttpRequest.BodyPublishers.ofString(\"client_", "first_line_groundtruth": "callback.onComplete(accessToken, refreshToken);", "first_line_prediction": " callback.onComplete(accessToken, refreshToken);", "match": 0}
{"groundtruth": "FileManager.getFileContents(connection.getInputStream());", "prediction": " connection.getHeaderField(\"x-xbl-token\");\n        if (responce == null) {\n            throw new Exception(\"Failed to get device token\");\n        }\n        return responce;\n    }\n\n    private void addSignatureHeader(HttpsURLConnection connection, JSONObject jsonObject, ECPrivateKey privateKey) throws Exception {\n        String header = this.getSignatureHeader(jsonObject, privateKey);\n        connection.setRequestProperty(\"x-xbl-signature\", header);\n    }\n\n    private String getSignatureHeader(JSONObject jsonObject, ECPrivateKey privateKey) throws Exception {\n        String header = \"ES256\";\n        String headerBase", "first_line_groundtruth": "FileManager.getFileContents(connection.getInputStream());", "first_line_prediction": " connection.getHeaderField(\"x-xbl-token\");", "match": 0}
{"groundtruth": "OutputWindow.print(\"Failed to load your account, please authenticate with your Microsoft account again.\");", "prediction": " OutputWindow.print(\"Failed to load your account!\");\n            }\n        } else {\n            OutputWindow.print(\"No account found, please create one!\");\n            String username = JOptionPane.showInputDialog(\"Username: \");\n            String password = JOptionPane.showInputDialog(\"Password: \");\n            String account = username + \":\" + password;\n            String encoded = Base64.getEncoder().encodeToString(account.getBytes());\n            FileManager.writeToFile(\".account\", encoded);\n            OutputWindow.print(\"Account created!\");\n        }\n    }", "first_line_groundtruth": "OutputWindow.print(\"Failed to load your account, please authenticate with your Microsoft account again.\");", "first_line_prediction": " OutputWindow.print(\"Failed to load your account!\");", "match": 0}
{"groundtruth": "Utils.toByteArray(currentTime));", "prediction": "postData.toJSONString().getBytes(StandardCharsets.UTF_8));\n        bytesToSign.write(new byte[]{0, 0, 0, 0});\n\n        byte[] signature = this.sign(bytesToSign.toByteArray(), privateKey);\n\n        httpsURLConnection.setRequestProperty(\"x-xbl-signature\", Base64.getUrlEncoder().withoutPadding().encodeToString(signature));\n        httpsURLConnection.setRequestProperty(\"x-xbl-contract-version\", \"1\");\n        httpsURLConnection.setRequestProperty(\"x-xbl-contract-version\", \"1\");\n        httpsURLConnection.setRequestProperty(\"x-", "first_line_groundtruth": "Utils.toByteArray(currentTime));", "first_line_prediction": "postData.toJSONString().getBytes(StandardCharsets.UTF_8));", "match": 0}
{"groundtruth": "OutputWindow.print(\"First time running BedrockReplay, please authenticate with your Microsoft account first.\");", "prediction": " OutputWindow.print(\"No account found, please authenticate with your Microsoft account.\");\n             startAuth();\n        }\n    }\n\n    private static void startAuth() {\n        Live.startAuth();\n    }", "first_line_groundtruth": "OutputWindow.print(\"First time running BedrockReplay, please authenticate with your Microsoft account first.\");", "first_line_prediction": " OutputWindow.print(\"No account found, please authenticate with your Microsoft account.\");", "match": 0}
{"groundtruth": "int transformType = data.getSample(x >> bits, y >> bits, 1);", "prediction": " raster.getDataElements(x, y, rgba);\n                 raster.getDataElements(x - 1, y, predictor);\n                 raster.getDataElements(x, y - 1, predictor2);\n                 raster.getDataElements(x - 1, y - 1, predictor3);\n                 addPixels(rgba, predictor);\n                 addPixels(rgba, predictor2);\n                 addPixels(rgba, predictor3);\n                 raster.setDataElements(x, y, rgba);\n            }\n        }\n\n        // Handle top and right border separately\n\n        // (x,0) TR predict\n        for (int x = width -", "first_line_groundtruth": "int transformType = data.getSample(x >> bits, y >> bits, 1);", "first_line_prediction": " raster.getDataElements(x, y, rgba);", "match": 0}
{"groundtruth": "return FileManager.getFileContents(connection.getInputStream());", "prediction": " String response = FileManager.getFileContents(connection.getInputStream());\n         JSONObject responseJsonObject = JSONObject.parseObject(response);", "first_line_groundtruth": "return FileManager.getFileContents(connection.getInputStream());", "first_line_prediction": " String response = FileManager.getFileContents(connection.getInputStream());", "match": 0}
{"groundtruth": "callback.onFailure(\"Failed to save replay: \" + e.getMessage());", "prediction": " e.printStackTrace();\n                 callback.onFailure(e.getMessage());\n             }\n        });\n    }\n\n    public static ReplayData loadFromFile(String path) {\n        try {\n            try (FileInputStream fis = new FileInputStream(path + \".replay\");\n                 DataInputStream dis = new DataInputStream(new XZInputStream(fis))) {\n\n                long recorderEntityRuntimeId = dis.readLong();\n                int packetBuffersByTickSize = dis.readInt();\n                ByteBuf packetBuffersByTick = Unpooled.buffer(packetBuffersByTickSize);\n                packetBuffersByTick.writeBytes(dis.readNBytes(packetBuffers", "first_line_groundtruth": "callback.onFailure(\"Failed to save replay: \" + e.getMessage());", "first_line_prediction": " e.printStackTrace();", "match": 0}
{"groundtruth": "= xbox.getDeviceToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate());", "prediction": " = xbox.getDeviceToken();\n        String gamertag = xbox.getGamertag();\n        String xuid = xbox.getXuid();\n        String accessToken = xbox.getAccessToken();\n        String refreshToken = xbox.getRefreshToken();\n\n        loginPacket.setUsername(gamertag);\n        loginPacket.setDeviceId(deviceToken);\n        loginPacket.setXuid(xuid);\n        loginPacket.setAccessToken(accessToken);\n        loginPacket.setRefreshToken(refreshToken);\n        loginPacket.setPublicKey(Base64.getEncoder().encodeToString(this.keyPair.get", "first_line_groundtruth": "= xbox.getDeviceToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate());", "first_line_prediction": " = xbox.getDeviceToken();", "match": 0}
{"groundtruth": "xbox.requestMinecraftChain(xsts, (ECPublicKey) this.keyPair.getPublic());", "prediction": " JwtUtils.createChainData(this.keyPair.getPublic(), this.keyPair.getPrivate());\n        String jwt = JwtUtils.createJwt(chainData, xsts);\n\n        loginPacket.setUsername(this.playerInfo.getUsername());\n        loginPacket.setXuid(this.playerInfo.getXuid());\n        loginPacket.setAccessToken(this.accessToken);\n        loginPacket.setRefreshToken(this.refreshToken);\n        loginPacket.setJwt(jwt);\n        loginPacket.setChainData(chainData);\n        loginPacket.setXsts(xsts);\n        loginPacket.set", "first_line_groundtruth": "xbox.requestMinecraftChain(xsts, (ECPublicKey) this.keyPair.getPublic());", "first_line_prediction": " JwtUtils.createChainData(this.keyPair.getPublic(), this.keyPair.getPrivate());", "match": 0}
{"groundtruth": "raster.getDataElements(trX, trY, predictor2);", "prediction": " raster.getDataElements(trX, trY, predictor2);\n                         raster.getDataElements(x, tY, predictor3);\n                         addPixels(rgba, predictor);\n                         addPixels(rgba, predictor2);\n                         addPixels(rgba, predictor3);\n                         break;\n                    case PREDICTOR_AVG_L_TL:\n                        raster.getDataElements(lX, y, predictor);\n                         raster.getDataElements(lX, tY, predictor2);\n                         addPixels(rgba, predictor);\n                         addPixels(rgba, predictor2);\n                         break;\n                    case PREDICTOR_AVG_L_T", "first_line_groundtruth": "raster.getDataElements(trX, trY, predictor2);", "first_line_prediction": " raster.getDataElements(trX, trY, predictor2);", "match": 0}
{"groundtruth": "CODEC_HELPER.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());", "prediction": "\n\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioDatagramChannel.class)\n                    .childHandler(new BedrockServerInitializer(BEDROCK_CODEC, new PacketHandler(this)));\n            b.bind(address).sync().channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n           ", "first_line_groundtruth": "CODEC_HELPER.setBlockDefinitions(FakeDefinitionRegistry.createBlockRegistry());", "first_line_prediction": "", "match": 0}
{"groundtruth": "raster.getDataElements(trX, trY, predictor3);", "prediction": " average2(predictor, predictor2);\n                        raster.getDataElements(trX, trY, predictor3);\n                        average2(predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_SELECT:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n                        select(predictor, predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_", "first_line_groundtruth": "raster.getDataElements(trX, trY, predictor3);", "first_line_prediction": " average2(predictor, predictor2);", "match": 0}
{"groundtruth": "xbox.getXBLToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate(), deviceToken);", "prediction": " xbox.getXsts(deviceToken);\n        String xuid = xbox.getXuid(xsts);\n        String accessToken = xbox.getAccessToken(xsts);\n        String refreshToken = xbox.getRefreshToken(accessToken);\n\n        loginPacket.setUsername(this.playerInfo.getUsername());\n        loginPacket.setXuid(xuid);\n        loginPacket.setAccessToken(accessToken);\n        loginPacket.setDeviceToken(deviceToken);\n        loginPacket.setXsts(xsts);\n        loginPacket.setRefreshToken(refreshToken);\n        loginPacket.setClientToken(JwtUtils.generateClient", "first_line_groundtruth": "xbox.getXBLToken((ECPublicKey) this.keyPair.getPublic(), (ECPrivateKey) this.keyPair.getPrivate(), deviceToken);", "first_line_prediction": " xbox.getXsts(deviceToken);", "match": 0}
{"groundtruth": "raster.getDataElements(lX, y, predictor);", "prediction": " raster.getDataElements(lX, tY, predictor);\n                         addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_T:\n                        raster.getDataElements(lX, tY, predictor);\n                        addPixels(rgba, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        addPixels(rgba, predictor2);\n                        break;\n                    case PREDICTOR_TR:\n                        raster.getDataElements(lX, tY, predictor);\n                        addPixels(rgba, predictor);\n                        raster.getDataElements(trX, trY, predictor2);\n                        add", "first_line_groundtruth": "raster.getDataElements(lX, y, predictor);", "first_line_prediction": " raster.getDataElements(lX, tY, predictor);", "match": 0}
{"groundtruth": "raster.getDataElements(x, tY, predictor2);", "prediction": " addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_TL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(lX, tY, predictor2);\n                        average2(predictor, predictor2);\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_AVG_L_T:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        average2(predictor, predictor2);\n                        addPixels(rgba, predictor);\n                        break", "first_line_groundtruth": "raster.getDataElements(x, tY, predictor2);", "first_line_prediction": " addPixels(rgba, predictor);", "match": 0}
{"groundtruth": "raster.getDataElements(lX, tY, predictor3);", "prediction": " raster.getDataElements(lX, tY, predictor3);\n                        select(predictor, predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB_FULL:\n                        raster.getDataElements(lX, y, predictor);\n                        raster.getDataElements(x, tY, predictor2);\n                        raster.getDataElements(lX, tY, predictor3);\n                        clampAddSubtractFull(predictor, predictor2, predictor3);\n\n                        addPixels(rgba, predictor);\n                        break;\n                    case PREDICTOR_CLAMP_ADD_SUB", "first_line_groundtruth": "raster.getDataElements(lX, tY, predictor3);", "first_line_prediction": " raster.getDataElements(lX, tY, predictor3);", "match": 0}
{"groundtruth": "lsbBitInputStream.readBits(14);", "prediction": "16 * lsbBitInputStream.readBits(16);\n        int height = 1 + (int) 16 * lsbBitInputStream.readBits(16);\n\n        int stride = width * 4;\n        int[] pixels = new int[stride * height];\n\n        VP8LDecoder decoder = new VP8LDecoder(lsbBitInputStream);\n        decoder.decode(pixels, width, height);\n\n        return new RGBABuffer(width, height, pixels);\n    }\n\n    private void decode(int[] pixels, int width, int height) throws IOException {\n        int num_layers =", "first_line_groundtruth": "lsbBitInputStream.readBits(14);", "first_line_prediction": "16 * lsbBitInputStream.readBits(16);", "match": 0}
{"groundtruth": "colorCacheBits = (int) lsbBitReader.readBits(4);", "prediction": " colorCacheBits = (int) lsbBitReader.readBits(3);\n        }\n\n        // Read color cache\n        int colorCacheSize = 1 << colorCacheBits;\n        int[] colorCache = new int[colorCacheSize];\n        for (int i = 0; i < colorCacheSize; i++) {\n            colorCache[i] = (int) lsbBitReader.readBits(8);\n        }\n\n        // Read color cache update\n        int colorCacheUpdate = (int) lsbBitReader.readBits(8);\n\n        // Read color cache update\n        int colorCacheUpdate2 =", "first_line_groundtruth": "colorCacheBits = (int) lsbBitReader.readBits(4);", "first_line_prediction": " colorCacheBits = (int) lsbBitReader.readBits(3);", "match": 0}
{"groundtruth": "lsbBitInputStream.readBit();", "prediction": "\n\n        VP8LDecoder decoder = new VP8LDecoder(lsbBitInputStream);\n        return decoder.decode(width, height);\n    }\n\n    private RGBABuffer decode(int width, int height) throws IOException {\n        RGBABuffer rgbaBuffer = new RGBABuffer(width, height);\n        ColorCache colorCache = new ColorCache(width, height);\n\n        int numHuffmanCodeGroups = lsbBitReader.readBits(5);\n        List<HuffmanCodeGroup> huffmanCodeGroups = new ArrayList<>(numHuffmanCodeGroups);\n        for (int i = 0; i", "first_line_groundtruth": "lsbBitInputStream.readBit();", "first_line_prediction": "", "match": 0}
{"groundtruth": "(int) lsbBitInputStream.readBits(3) != 0) {", "prediction": "lsbBitInputStream.readBit() != 0) {\n            throw new IOException(\"Invalid VP8L_VERSION\");\n        }\n\n        int version = (int) lsbBitInputStream.readBits(3);\n        if (version != 0) {\n            throw new IOException(\"Invalid VP8L_VERSION\");\n        }\n\n        int colorSpace = (int) lsbBitInputStream.readBits(2);\n        if (colorSpace != 0) {\n            throw new IOException(\"Invalid VP8L_COLORSPACE\");\n        }\n\n        int colorRange = (int) lsbBitInputStream.readBits(", "first_line_groundtruth": "(int) lsbBitInputStream.readBits(3) != 0) {", "first_line_prediction": "lsbBitInputStream.readBit() != 0) {", "match": 0}
{"groundtruth": "+ (int) lsbBitReader.readBits(extraBits) + 1;", "prediction": " + lsbBitReader.readBits(extraBits);\n        }\n    }", "first_line_groundtruth": "+ (int) lsbBitReader.readBits(extraBits) + 1;", "first_line_prediction": " + lsbBitReader.readBits(extraBits);", "match": 0}
{"groundtruth": "int transformType = (int) lsbBitReader.readBits(2);", "prediction": " // Read transform\n        int transformCode = lsbBitReader.readBits(3);\n\n        if (transformCode == 0) {\n            return 0;\n        }\n\n        int transformType = transformCode - 1;\n        int transformX = lsbBitReader.readBits(xSize);\n        int transformY = lsbBitReader.readBits(ySize);\n\n        transforms.add(new Transform(transformType, transformX, transformY));\n\n        return transformCode;\n    }\n\n    private void readHuffmanInfo(HuffmanInfo huffmanInfo) throws IOException {\n        // Read Huff", "first_line_groundtruth": "int transformType = (int) lsbBitReader.readBits(2);", "first_line_prediction": " // Read transform", "match": 0}
{"groundtruth": "decodeRaster = RGBABuffer.createRelativeImage(raster, 0, 0, xSize, height);", "prediction": " // and height is different from raster height\n             decodeRaster = RGBABuffer.createAbsoluteImage(xSize, height);\n        } else {\n            decodeRaster = raster;\n        }\n\n        // Read pixels\n        int y = 0;\n        while (y < height) {\n            int x = 0;\n            while (x < width) {\n                int index = readIndex(lsbBitReader, huffmanInfo, colorCache);\n                if (index == -1) {\n                    x++;\n                    continue;\n                }\n\n                int color = colorCache.getColor(index);\n                decodeRaster.setPixel(x, y,", "first_line_groundtruth": "decodeRaster = RGBABuffer.createRelativeImage(raster, 0, 0, xSize, height);", "first_line_prediction": " // and height is different from raster height", "match": 0}
{"groundtruth": "&& lsbBitReader.readBit() == 1) {", "prediction": " && colorCacheBits > 0) {\n            huffmanMetaCodes = RGBABuffer.createAbsoluteImage(xSize, ySize);\n        }\n\n        while (true) {\n            HuffmanCodeGroup curHuffmanGroup = huffmanCodeGroups[huffmanGroupNum];\n\n            if (curHuffmanGroup.xSize == xSize && curHuffmanGroup.ySize == ySize) {\n                break;\n            }\n\n            huffmanGroupNum++;\n        }\n\n        huffmanXSize = curHuffmanGroup.xSize;\n        huffmanYSize = curH", "first_line_groundtruth": "&& lsbBitReader.readBit() == 1) {", "first_line_prediction": " && colorCacheBits > 0) {", "match": 0}
{"groundtruth": "RGBABuffer outputBuffer = RGBABuffer.createAbsoluteImage(width, height);", "prediction": " int colorSpace = (int) lsbBitInputStream.readBits(2);\n        if (colorSpace != 0) {\n            throw new IOException(\"Invalid ColorSpace.\");\n        }\n\n        int colorRange = (int) lsbBitInputStream.readBits(2);\n        if (colorRange != 0) {\n            throw new IOException(\"Invalid ColorRange.\");\n        }\n\n        int alphaMode = (int) lsbBitInputStream.readBits(2);\n        if (alphaMode != 0) {\n            throw new IOException(\"Invalid AlphaMode.\");\n        }\n\n        int frameType = (int) lsbBitInputStream", "first_line_groundtruth": "RGBABuffer outputBuffer = RGBABuffer.createAbsoluteImage(width, height);", "first_line_prediction": " int colorSpace = (int) lsbBitInputStream.readBits(2);", "match": 0}
{"groundtruth": "byte) (lsbBitReader.readBits(3) + 2);", "prediction": "byte) lsbBitReader.readBits(2);\n                int size = 1 << sizeBits;\n\n                int xOff = (int) lsbBitReader.readBits(sizeBits);\n                int yOff = (int) lsbBitReader.readBits(sizeBits);\n\n                transforms.add(new Transform(transformType, xSize, ySize, xOff, yOff));\n\n                return size;\n            }\n            case SUBSAMPLE_TRANSFORM: {\n                byte xOffBits = (byte) lsbBitReader.readBits(2);\n                byte yOffBits = (byte) lsbBit", "first_line_groundtruth": "byte) (lsbBitReader.readBits(3) + 2);", "first_line_prediction": "byte) lsbBitReader.readBits(2);", "match": 0}
{"groundtruth": "colorTableSize = ((int) lsbBitReader.readBits(8)) + 1;", "prediction": " colorTableSize = (int) lsbBitReader.readBits(8);\n\n                // 8 bit value for color table\n                byte[] colorTable = new byte[colorTableSize];\n                for (int i = 0; i < colorTableSize; i++) {\n                    colorTable[i] = (byte) lsbBitReader.readBits(8);\n                }\n\n                // 8 bit value for color index\n                int colorIndex = (int) lsbBitReader.readBits(8);\n\n                // 8 bit value for alpha\n                int alpha = (int) lsbBitReader.readBits", "first_line_groundtruth": "colorTableSize = ((int) lsbBitReader.readBits(8)) + 1;", "first_line_prediction": " colorTableSize = (int) lsbBitReader.readBits(8);", "match": 0}
{"groundtruth": "configVariables.setClientID(System.getenv(\"BOT_CLIENT_ID\"));", "prediction": "\n\n        } else {\n            System.out.println(\"Using properties\");\n            try {\n                var properties = new Properties();\n                properties.load(new FileInputStream(BOT_CONFIG_PROPERTIES));\n                configVariables.setUser(properties.getProperty(\"bot.user\"));\n                configVariables.setToken(properties.getProperty(\"bot.token\"));\n                configVariables.setClientID(properties.getProperty(\"bot.clientID\"));\n                var splittedChatters = properties.getProperty(\"bot.chattersToIgnore\").split(\",\");\n                if (splittedChatters != null)\n                    Arrays.stream(splittedChatters)\n                             .forEach(", "first_line_groundtruth": "configVariables.setClientID(System.getenv(\"BOT_CLIENT_ID\"));", "first_line_prediction": "", "match": 0}
{"groundtruth": "(int) lsbBitReader.readBits(3) + 2;", "prediction": "8;\n            huffmanMetaCodes = RGBABuffer.createAbsoluteImage(xSize, ySize);\n            readVP8Lossless(huffmanMetaCodes, false, xSize, ySize);\n        }\n\n        if (lsbBitReader.readBit() == 1) {\n            // read in huffman codes\n            huffmanGroupNum = 2;\n            huffmanXSize = xSize / 2;\n            huffmanYSize = ySize / 2;\n        } else {\n            huffmanXSize = xSize;\n            huffmanYSize = ySize;", "first_line_groundtruth": "(int) lsbBitReader.readBits(3) + 2;", "first_line_prediction": "8;", "match": 0}
{"groundtruth": "configVariables.setUser(System.getenv(\"BOT_USER\"));", "prediction": " configVariables.setClientID(System.getenv(\"CLIENT_ID\"));\n             configVariables.setToken(System.getenv(\"BOT_TOKEN\"));\n             configVariables.setUser(System.getenv(\"BOT_USER\"));\n        } else {\n            System.out.println(\"Using file\");\n            try (var inputStream = new FileInputStream(BOT_CONFIG_PROPERTIES)) {\n                var properties = new Properties();\n                properties.load(inputStream);\n                configVariables.setClientID(properties.getProperty(\"clientID\"));\n                configVariables.setToken(properties.getProperty(\"token\"));\n                configVariables.setUser(properties.getProperty(\"user\"));", "first_line_groundtruth": "configVariables.setUser(System.getenv(\"BOT_USER\"));", "first_line_prediction": " configVariables.setClientID(System.getenv(\"CLIENT_ID\"));", "match": 0}
{"groundtruth": "RGBABuffer.createAbsoluteImage(blockWidth, blockHeight);", "prediction": " Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, blockWidth, blockHeight, 4 * blockWidth, 4, new int[]{0, 1, 2, 3}, null);\n\n                int[] data = new int[4 * blockWidth * blockHeight];\n                raster.getDataElements(0, 0, data);\n\n                for (int i = 0; i < data.length; i++) {\n                    data[i] = lsbBitReader.readBits(8);\n                }\n\n                transforms.add(new Transform(transformType, blockWidth, blockHeight,", "first_line_groundtruth": "RGBABuffer.createAbsoluteImage(blockWidth, blockHeight);", "first_line_prediction": " Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, blockWidth, blockHeight, 4 * blockWidth, 4, new int[]{0, 1, 2, 3}, null);", "match": 0}
{"groundtruth": "RGBABuffer colorTableRGBABuffer = RGBABuffer.createAbsoluteImage(colorTableSize, 1);", "prediction": " // The color table is stored in the following order:\n                 // 0x00000000, 0x00000000, 0x00000000, ...\n                 // 0x00000000, 0x00000000, 0x00000000, ...\n                 // ...\n                 // 0x00000000, 0x00000000, 0x0000000", "first_line_groundtruth": "RGBABuffer colorTableRGBABuffer = RGBABuffer.createAbsoluteImage(colorTableSize, 1);", "first_line_prediction": " // The color table is stored in the following order:", "match": 0}
{"groundtruth": "raster.getDataElements(x1, ySrc, rgba);", "prediction": " if (x1 < 0) {\n                ySrc--;\n                x1 += width;\n             } else if (x1 >= width) {\n                x1 -= width;\n                ySrc++;\n             }\n\n            int y1 = ySrc++;\n\n            if (y1 < 0) {\n                y1 += height;\n            } else if (y1 >= height) {\n                y1 -= height;\n            }\n\n            if (y1 < 0 || y1 >= height || x1 < 0 || x1 >= width) {\n                throw new IOException(\"Corrupt WebP stream, decodeBwRef: ySrc", "first_line_groundtruth": "raster.getDataElements(x1, ySrc, rgba);", "first_line_prediction": " if (x1 < 0) {", "match": 0}
{"groundtruth": "topLevel && lsbBitReader.readBit() == 1) {", "prediction": "true) {\n            int transformType = lsbBitReader.readBits(3);\n            if (transformType == 0) {\n                break;\n            }\n            Transform transform = TransformFactory.createTransform(transformType);\n            transform.read(lsbBitReader);\n            transforms.add(transform);\n        }\n\n        // Read Huffman codes\n        HuffmanInfo huffmanInfo = new HuffmanInfo();\n        huffmanInfo.read(lsbBitReader);\n        HuffmanCodeGroup[] codeGroups = huffmanInfo.getCodeGroups();\n\n        // Read color mapping\n        int colorMappingSize =", "first_line_groundtruth": "topLevel && lsbBitReader.readBit() == 1) {", "first_line_prediction": "true) {", "match": 0}
{"groundtruth": "colorTableRGBABuffer.getDataElements(x, 0, colorTableRGBACopyBuffer);", "prediction": " // Copy the color table to a copy buffer\n                    colorTableRGBABuffer.getDataElements(x, 0, colorTableRGBACopyBuffer);\n                    colorTable[x * 4] = colorTableRGBACopyBuffer[0];\n                    colorTable[x * 4 + 1] = colorTableRGBACopyBuffer[1];\n                    colorTable[x * 4 + 2] = colorTableRGBACopyBuffer[2];\n                    colorTable[x * 4 + 3] = colorTableRGBACopyBuffer[3];\n                }\n\n                // The color table is always subtraction-coded", "first_line_groundtruth": "colorTableRGBABuffer.getDataElements(x, 0, colorTableRGBACopyBuffer);", "first_line_prediction": " // Copy the color table to a copy buffer", "match": 0}
{"groundtruth": "userID = twitchAPI.getUserID(user).orElse(\"\");", "prediction": "userIDMap = new HashMap<>();\n        this.executor = Executors.newSingleThreadExecutor();\n        this.messageService = new MessageServiceImpl();\n    }\n\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        this.session.getAsyncRemote().sendText(MessageFormat.format(\"PASS {0}\", this.token));\n        this.session.getAsyncRemote().sendText(MessageFormat.format(\"NICK {0}\", this.user));\n        this.session.getAsyncRemote().sendText(MessageFormat.format(\"JOIN #{0}\", this.channelsTo", "first_line_groundtruth": "userID = twitchAPI.getUserID(user).orElse(\"\");", "first_line_prediction": "userIDMap = new HashMap<>();", "match": 0}
{"groundtruth": "int argb = colorCache.lookup(code - 256 - 24);", "prediction": " // TODO: Implement color cache\n    }\n\n    private void decodeLiteral(RGBABuffer raster, ColorCache colorCache, HuffmanCodeGroup curCodeGroup, byte[] rgba, int y, int x, short code) {\n        int color = curCodeGroup.colorTable[code - 256];\n        rgba[0] = (byte) (color >> 16);\n        rgba[1] = (byte) (color >> 8);\n        rgba[2] = (byte) (color);\n        rgba[3] = (byte) 0xff;\n\n        raster.setPixel(x,", "first_line_groundtruth": "int argb = colorCache.lookup(code - 256 - 24);", "first_line_prediction": " // TODO: Implement color cache", "match": 0}
{"groundtruth": "= botsAPI.getOnlineBots();", "prediction": " = botsAPI.getBotList(broadcasterID);\n                if (botList.isEmpty())\n                    return;\n\n                var botNames = new StringJoiner(\", \");\n                botList.forEach(bot -> botNames.add(bot.get(\"login\").asText()));\n                sendMessage(MessageFormat.format(\"!bots {0}\", botNames));\n            }\n        });\n    }\n\n    private void processUserJoin(String message) {\n        var channel = message.split(\" \")[1];\n        var userName = message.split(\" \")[2];\n        var broadcasterID = broadcasterIDMap.get(channel);", "first_line_groundtruth": "= botsAPI.getOnlineBots();", "first_line_prediction": " = botsAPI.getBotList(broadcasterID);", "match": 0}
{"groundtruth": "twitchAPI.getUserID(userName.trim());", "prediction": " twitchAPI.getUserID(userName.trim());\n\t\t\t\tif (userToBanID.isEmpty())\n\t\t\t\t\tcontinue;", "first_line_groundtruth": "twitchAPI.getUserID(userName.trim());", "first_line_prediction": " twitchAPI.getUserID(userName.trim());", "match": 0}
{"groundtruth": "broadcasterID = twitchAPI.getUserID(channel.trim());", "prediction": "ircChannel = channel.replace(\"#\", \"\");\n            var broadcasterID = twitchAPI.getBroadcasterID(ircChannel).orElse(\"\");\n            broadcasterIDMap.put(channel, broadcasterID);\n        });\n        System.out.println(\"Getting user ID\");\n        userIDMap.put(user, userID);\n    }\n\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        this.executor = Executors.newSingleThreadExecutor();\n        this.executor.submit(() -> {\n            try {\n                session.getBasicRemote().sendText(MessageFormat.format", "first_line_groundtruth": "broadcasterID = twitchAPI.getUserID(channel.trim());", "first_line_prediction": "ircChannel = channel.replace(\"#\", \"\");", "match": 0}
{"groundtruth": "Generator().generate(schemaVersion, scanPackages, outputDir, skipValidation);", "prediction": " Generator()\n        .generate(\n            schemaVersion,\n            scanPackages,\n            outputDir,\n            skipValidation);\n  }\n\n  private void setClasspath() throws MojoExecutionException {\n    try {\n      PluginDescriptor pluginDescriptor = project.getPlugin(GeneratorPlugin.class);\n      ClassRealm classRealm = pluginDescriptor.getClassRealm();\n      classRealm.addURL(new URL(SCHEMA_BASE_URL));\n    } catch (MalformedURLException | DependencyResolutionRequiredException e) {\n      throw new MojoExecutionException(\"Failed to set classpath\", e);\n    }\n  }", "first_line_groundtruth": "Generator().generate(schemaVersion, scanPackages, outputDir, skipValidation);", "first_line_prediction": " Generator()", "match": 0}
{"groundtruth": "template.setTemplateName(templateName);", "prediction": " template.setTemplateName(templateName);\n    }\n\n    String templateID = String.valueOf(methodParameters.get(TEMPLATE_ID));\n    if (!templateID.isBlank()) {\n      template.setTemplateID(templateID);\n    }\n\n    String functionName = String.valueOf(methodParameters.get(FUNCTION_NAME_PROPERTY));\n    if (!functionName.isBlank()) {\n      template.setFunctionName(functionName);\n    }\n\n    String description = String.valueOf(methodParameters.get(DESCRIPTION));\n    if (!description.isBlank()) {\n      template.setDescription(description);\n    }\n\n    List<Property> properties", "first_line_groundtruth": "template.setTemplateName(templateName);", "first_line_prediction": " template.setTemplateName(templateName);", "match": 0}
{"groundtruth": "template.setAppliesTo((String[]) methodParameters.get(APPLIES_TO));", "prediction": " String templateName = String.valueOf(methodParameters.get(NAME));\n     if (!templateName.isBlank()) {\n       template.setTemplateName(templateName);\n     }", "first_line_groundtruth": "template.setAppliesTo((String[]) methodParameters.get(APPLIES_TO));", "first_line_prediction": " String templateName = String.valueOf(methodParameters.get(NAME));", "match": 0}
{"groundtruth": "template.setEntriesVisible(((Boolean) (methodParameters.get(ENTRIES_VISIBLE))).booleanValue());", "prediction": " String templateId = String.valueOf(methodParameters.get(TEMPLATE_ID));\n     if (!templateId.isBlank()) {\n       template.setId(templateId);\n     }", "first_line_groundtruth": "template.setEntriesVisible(((Boolean) (methodParameters.get(ENTRIES_VISIBLE))).booleanValue());", "first_line_prediction": " String templateId = String.valueOf(methodParameters.get(TEMPLATE_ID));", "match": 0}
{"groundtruth": "treeMapPane = TreeMapPane.forTreeContent();", "prediction": "mpt = TreeMapPane.forTreeContent();\n\t\tmpt.setRoot(children);\n\t\tnode = mpt.rootProperty();", "first_line_groundtruth": "treeMapPane = TreeMapPane.forTreeContent();", "first_line_prediction": "mpt = TreeMapPane.forTreeContent();", "match": 0}
{"groundtruth": "(exemption != null && exemption.isExemptionActive()) {", "prediction": " (exemption != null && exemption.isExempted()) {\n            return;\n        }\n        long blockingTime = this.blockingTime.get();\n        if (blockingTime > 0) {\n            if (blockingTime >= threshold) {\n                reportEvent(blockingTime);\n            }\n        }\n    }", "first_line_groundtruth": "(exemption != null && exemption.isExemptionActive()) {", "first_line_prediction": " (exemption != null && exemption.isExempted()) {", "match": 0}
{"groundtruth": "final ThreadInfo threadInfo = ThreadInfo.fromThread(thread);", "prediction": " threadInfos[reported++] = threadAccessor.getThreadInfo(thread);\n            }\n            listener.onBlockedThread(new BlockedThreadEvent(blockedFor, threadInfos));\n        });\n    }", "first_line_groundtruth": "final ThreadInfo threadInfo = ThreadInfo.fromThread(thread);", "first_line_prediction": " threadInfos[reported++] = threadAccessor.getThreadInfo(thread);", "match": 0}
{"groundtruth": "(\"  executePrice=\" + DoubleUtils.toDouble(executePrice));", "prediction": "(\"  executePrice=\" + executePrice);\n    \tSystem.out.println(\"  executeId=\" + executeId);\n    \tSystem.out.println(\"  executeMatchId=\" + executeMatchId);\n    \tSystem.out.println();\n    \tSystem.out.println(\"  orderBook.getAskLevels()=\" + orderBook.getAskLevels());\n    \tSystem.out.println(\"  orderBook.getBidLevels()=\" + orderBook.getBidLevels());\n    \tSystem.out.println(\"  orderBook.getAskOrders()=\" + orderBook.getAskOrders());\n    \t", "first_line_groundtruth": "(\"  executePrice=\" + DoubleUtils.toDouble(executePrice));", "first_line_prediction": "(\"  executePrice=\" + executePrice);", "match": 0}
{"groundtruth": "messages = body.getMessages();", "prediction": " message = body.getMessages().get(body.getMessages().size() - 1);\n                  message.setResponse(response);\n                }\n              }\n\n              retryCounter++;\n              stream(requestBody, listeners);\n            }));\n  }", "first_line_groundtruth": "messages = body.getMessages();", "first_line_prediction": " message = body.getMessages().get(body.getMessages().size() - 1);", "match": 0}
{"groundtruth": "cancel(ts.nanoEpoch());", "prediction": "cancel(ts.nanoEpoch());\n\t\t\taskOrder.cancel(ts.nanoEpoch());\n\t\t\t\n\t\t\tbook.removeOrder(bidOrder);\n\t\t\tbook.removeOrder(askOrder);\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Done!\");", "first_line_groundtruth": "cancel(ts.nanoEpoch());", "first_line_prediction": "cancel(ts.nanoEpoch());", "match": 1}
{"groundtruth": "ts = book.getTimestamper();", "prediction": " timestamper = new Timestamper();\n\t\t\tOrder order = new Order(Side.BUY, TimeInForce.GTC, 100, 100, getClientOrderId(), timestamper.getTimestamp());\n\t\t\tbook.addOrder(order);\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Done!\");", "first_line_groundtruth": "ts = book.getTimestamper();", "first_line_prediction": " timestamper = new Timestamper();", "match": 0}
{"groundtruth": ".cancel(orderBook.getTimestamper().nanoEpoch());", "prediction": " = orderBook.getOrder(1);\n\t\torder.cancel(orderBook.getTimestamper().nanoEpoch());\n\t\t\n\t\t /*\n\t\t\t -----> onOrderCanceled called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731732573000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=100, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=100, price=150.44, type=", "first_line_groundtruth": ".cancel(orderBook.getTimestamper().nanoEpoch());", "first_line_prediction": " = orderBook.getOrder(1);", "match": 0}
{"groundtruth": "ts.nanoEpoch(), 100);", "prediction": "100);\n\t\t\taskOrder.reduceTo(100);\n\t\t\t\n\t\t\tbook.cancelOrder(bidOrder);\n\t\t\tbook.cancelOrder(askOrder);\n\t\t}", "first_line_groundtruth": "ts.nanoEpoch(), 100);", "first_line_prediction": "100);", "match": 0}
{"groundtruth": "if (!book.isEmpty()) throw new IllegalStateException(\"Book must be empty here!\");", "prediction": "\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Done!\");", "first_line_groundtruth": "if (!book.isEmpty()) throw new IllegalStateException(\"Book must be empty here!\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "(listeners, client.isRetryOnReadTimeout(), (response) -> {", "prediction": "(listeners, requestBody.isRetryOnReadTimeout(), this::onRetry));\n  }\n\n  private void onRetry(String message) {\n    retryCounter++;\n    if (retryCounter > MAX_RETRY_COUNT) {\n      throw new RuntimeException(\"Max retry count exceeded\");\n    }\n    System.out.println(\"Retrying: \" + message);\n  }\n\n  public static class CompletionEventSourceListener {\n\n    public void onMessage(String message) {\n      System.out.println(\"Message: \" + message);\n    }\n\n    public void onError(ErrorDetails errorDetails, Throwable throwable) {\n      System.out.println(\"", "first_line_groundtruth": "(listeners, client.isRetryOnReadTimeout(), (response) -> {", "first_line_prediction": "(listeners, requestBody.isRetryOnReadTimeout(), this::onRetry));", "match": 0}
{"groundtruth": "(orderBook.getTimestamper().nanoEpoch(), 100);", "prediction": "(100);\n\t\t\n\t\t/*\n\t\t\t -----> onOrderReduced called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731803569000000\n\t\t\t  order=Order [id=1, clientOrderId=1, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0, canceledSize=0, price=150.44, type=LIMIT, tif=DAY]\n\t\t\t  reduceSize=100\n\t\t\t  reducePrice=", "first_line_groundtruth": "(orderBook.getTimestamper().nanoEpoch(), 100);", "first_line_prediction": "(100);", "match": 0}
{"groundtruth": "orderBook.showOrders();", "prediction": "\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 200, 150.44, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t -----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006570000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0", "first_line_groundtruth": "orderBook.showOrders();", "first_line_prediction": "", "match": 0}
{"groundtruth": "listeners.onComplete(messageBuilder);", "prediction": " listeners.onComplete(messageBuilder);\n    } else if (throwable instanceof SocketTimeoutException) {\n      if (retryOnReadTimeout) {\n        LOG.info(\"Retrying request\");\n        onRetry.accept(format(\"Retrying request after timeout: %s\", response.request().url()));\n      } else {\n        LOG.info(\"Request timed out\");\n        listeners.onComplete(messageBuilder);\n      }\n    } else {\n      LOG.error(\"Request failed\", throwable);\n      listeners.onError(new ErrorDetails(throwable));\n    }\n  }", "first_line_groundtruth": "listeners.onComplete(messageBuilder);", "first_line_prediction": " listeners.onComplete(messageBuilder);", "match": 0}
{"groundtruth": "+= order.getOpenSize();", "prediction": " += order.getSize();\n        orders++;\n        \n        order.addListener(this);\n    }\n    \n    public void removeOrder(Order order) {\n        \n        if (order.getPriceLevel() == this) {\n            \n            if (order.getSide() == Side.BUY) {\n            \t\n            \tsize -= order.getSize();\n            \t\n            \torders--;\n            \t\n            \tif (order.prev != null) {\n            \t\t\n            \t\torder.prev.next = order.next;\n            \t}\n            \t\n            \tif (order.next != null) {\n            \t\t\n            \t\torder.next.prev = order.prev;\n            \t}\n            \t", "first_line_groundtruth": "+= order.getOpenSize();", "first_line_prediction": " += order.getSize();", "match": 0}
{"groundtruth": "proxyAuthenticator.getUsername(),\n                      proxyAuthenticator.getPassword()))\n                  .build());", "prediction": " proxyAuthenticator.getUsername(), proxyAuthenticator.getPassword()))\n                   .build());\n        }\n      }\n\n      return builder.build();\n    }\n\n    private void trustAllCertificates(OkHttpClient.Builder builder) {\n      try {\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        sslContext.init(null, new TrustManager[] {\n            new X509TrustManager() {\n              @Override\n              public void checkClientTrusted(X509Certificate[] chain, String authType) {\n              }\n\n              @Override\n              public void checkServerTrusted(X509Certificate[] chain, String authType) {\n             ", "first_line_groundtruth": "proxyAuthenticator.getUsername(),", "first_line_prediction": " proxyAuthenticator.getUsername(), proxyAuthenticator.getPassword()))", "match": 0}
{"groundtruth": "orderBookLogger.off();", "prediction": "\n\t\torderBook.showLevels();\n\t\t\n\t\t /*\n\t\t  200 @   150.44 (orders=1)\n\t\t  500 @   149.44 (orders=2)\n\t\t -------- \n\t\t */\n\t\t\n\t\torderBook.showOrders();\n\t\t\n\t\t /*\n\t\t  200 @   150.44 (id=1)\n\t\t  500 @   149.44 (id=2)\n\t\t -------- \t\t\t  \n\t\t */\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 100, 14", "first_line_groundtruth": "orderBookLogger.off();", "first_line_prediction": "", "match": 0}
{"groundtruth": "createFactory(client.getHttpClient())\n        .newEventSource(\n            request,\n            getEventListener(listeners, client.isRetryOnReadTimeout(), (response) -> {", "prediction": "eventSource(request, getEventListener(listeners, true, this::retry));\n  }\n\n  private void retry(String data) {\n    retryCounter++;\n    if (retryCounter > MAX_RETRY_COUNT) {\n      throw new RuntimeException(\"Max retry count exceeded\");\n    }\n    var message = getMessage(data);\n    if (message != null) {\n      throw new RuntimeException(message);\n    }\n  }\n\n  private String getMessage(String data) {\n    try {\n      var mapper = new ObjectMapper();\n      var map = mapper.readValue(data, new TypeReference<Map<String, Object>>() {});\n      var message = map", "first_line_groundtruth": "createFactory(client.getHttpClient())", "first_line_prediction": "eventSource(request, getEventListener(listeners, true, this::retry));", "match": 0}
{"groundtruth": "!= null && mDiracSound.getMusic() == 1;", "prediction": " != null && mDiracSound.isEnabled();\n    }\n\n    public void setScenario(int scenario) {\n        mDiracSound.setScenario(scenario);\n    }\n\n    public void setPreset(int preset) {\n        mDiracSound.setPreset(preset);\n    }\n\n    public void setHeadsetType(int type) {\n        mDiracSound.setHeadsetType(type);\n    }\n\n    public void setLevel(int band, float level) {\n        mDiracSound.setLevel(band, level);\n    }\n\n    public void setHifi(boolean enable) {\n        mDiracSound.set", "first_line_groundtruth": "!= null && mDiracSound.getMusic() == 1;", "first_line_prediction": " != null && mDiracSound.isEnabled();", "match": 0}
{"groundtruth": "orderBook.showLevels();", "prediction": "\n\t\t\n\t\torderBook.createLimit(String.valueOf(++orderId), orderId, Side.BUY, 200, 150.44, TimeInForce.DAY);\n\t\t\n\t\t/*\n\t\t\t -----> onOrderAccepted called:\n\t\t\t  orderBook=AAPL\n\t\t\t  time=1682731006574000000\n\t\t\t  order=Order [id=2, clientOrderId=2, side=BUY, security=AAPL, originalSize=200, openSize=200, \n\t\t\t  \t\t\t\texecutedSize=0", "first_line_groundtruth": "orderBook.showLevels();", "first_line_prediction": "", "match": 0}
{"groundtruth": "= client.getHttpClient().newCall(buildRequest(requestBody)).execute()) {", "prediction": " = client.call(createRequest(requestBody))) {\n      return response.body().string();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private <T extends CompletionRequest> Request createRequest(T requestBody) {\n    var headers = new HashMap<String, String>();\n    headers.putAll(getRequiredHeaders());\n    headers.put(\"Content-Type\", \"application/json\");\n    var requestBodyJson = requestBody.toJson();\n    var requestBodyBytes = requestBodyJson.getBytes();\n    var requestBody = RequestBody.create(MediaType.get(\"", "first_line_groundtruth": "= client.getHttpClient().newCall(buildRequest(requestBody)).execute()) {", "first_line_prediction": " = client.call(createRequest(requestBody))) {", "match": 0}
{"groundtruth": "DoubleUtils.toDouble(price);", "prediction": "1.0 * price / 100000000.0;", "first_line_groundtruth": "DoubleUtils.toDouble(price);", "first_line_prediction": "1.0 * price / 100000000.0;", "match": 0}
{"groundtruth": "mDiracUtils != null ? mDiracUtils.isDiracEnabled() : false;", "prediction": " mDiracUtils.isDiracEnabled();\n        mSwitchBar = (MainSwitchPreference) findPreference(PREF_ENABLE);\n        mSwitchBar.setChecked(enhancerEnabled);\n        mSwitchBar.setOnPreferenceChangeListener(this);\n\n        mHeadsetType = (ListPreference) findPreference(PREF_HEADSET);\n        mHeadsetType.setSummary(mHeadsetType.getEntry());\n        mHeadsetType.setOnPreferenceChangeListener(this);\n\n        mPreset = (ListPreference) findPreference(PREF_PRESET);\n        mPreset.setSummary(mPreset.getEntry());\n        mPreset.setOnPreference", "first_line_groundtruth": "mDiracUtils != null ? mDiracUtils.isDiracEnabled() : false;", "first_line_prediction": " mDiracUtils.isDiracEnabled();", "match": 0}
{"groundtruth": "orderBookLogger.on();", "prediction": "\n\t\t\n\t\torderBook.cancel(String.valueOf(orderId));\n\t\t\n\t\torderBook.showLevels();\n\t\t\n\t\t /*\n\t\t  100 @   148.14 (orders=1)\n\t\t  500 @   149.44 (orders=2)\n\t\t  100 @   149.44 (orders=3)\n\t\t  200 @   150.44 (orders=1)\n\t\t --------     2.80\n\t\t  300 @   153.24 (orders=1)\n\t\t  500 @   156.43 (", "first_line_groundtruth": "orderBookLogger.on();", "first_line_prediction": "", "match": 0}
{"groundtruth": "VoidAffordance.create(), afford(methodOn(ItemController.class).create(null))));", "prediction": " VoidAffordance.create(),\n                     afford(methodOn(ItemController.class).create())));\n    if (returnPreference == ReturnPreference.MINIMAL) {\n      return ResponseEntity.ok(\n          new RepresentationModel<>(\n              List.of(\n                  linkBuilders.linkTo(methodOn(ItemController.class).list(null)).withRel(\"items\"),\n                  linkBuilders.linkTo(methodOn(SpectaclesController.class).list(null))\n                      .withRel(\"spectacles\"))));\n    }\n    CollectionModel<EntityModel<Item>> items =\n        CollectionModel.of(\n            StreamSupport.stream(item", "first_line_groundtruth": "VoidAffordance.create(), afford(methodOn(ItemController.class).create(null))));", "first_line_prediction": " VoidAffordance.create(),", "match": 0}
{"groundtruth": "if (StringUtils.equals(s.getFixCode(), sb)) {", "prediction": " if (s.fixCode.equals(sb)) {\n\t\t\t\t\t return s;\n\t\t\t\t }\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static final TimeInForce fromChar(char b) {\n\t\t\treturn ALL.get(b);\n\t\t}\n\t\t\n\t\tpublic char getChar() {\n\t\t\treturn b;\n\t\t}\n\t\t\n\t\tpublic String getFixCode() {\n\t\t\treturn fixCode;\n\t\t}", "first_line_groundtruth": "if (StringUtils.equals(s.getFixCode(), sb)) {", "first_line_prediction": " if (s.fixCode.equals(sb)) {", "match": 0}
{"groundtruth": "class).findById(item.id())).toUri())\n        .build();", "prediction": "class).get(item.id())).toUri())\n        .build();\n  }\n\n  @GetMapping(\"/{id}\")\n  public ResponseEntity<?> get(@PathVariable(\"id\") Long id) {\n    Item item = itemRepository.findById(id).orElse(null);\n    if (item == null) {\n      return ResponseEntity.notFound().build();\n    }\n    return ResponseEntity.ok(new RepresentationModel<>(new Representation(item)));\n  }\n\n  @PostMapping(\"/{id}/frame\")\n  public ResponseEntity<?> selectFrame(@PathVariable(\"id\") Long id, @RequestBody EditItemCommand command) {\n    Item item = itemRepository.findById", "first_line_groundtruth": "class).findById(item.id())).toUri())", "first_line_prediction": "class).get(item.id())).toUri())", "match": 0}
{"groundtruth": "\"  restPrice=\" + DoubleUtils.toDouble(restPrice));", "prediction": "String.format(\"  restPrice=%.2f\", DoubleUtils.toDouble(restPrice)));\n    \tSystem.out.println();\n    \t// NOOP\n    }", "first_line_groundtruth": "\"  restPrice=\" + DoubleUtils.toDouble(restPrice));", "first_line_prediction": "String.format(\"  restPrice=%.2f\", DoubleUtils.toDouble(restPrice)));", "match": 0}
{"groundtruth": ".withDimension(milvusConfiguration.getDimensions())\n            .build();", "prediction": " .withDimension(128)\n             .build();\n\n        List<FieldType> fieldTypes = new ArrayList<>();\n        fieldTypes.add(fieldType1);\n        fieldTypes.add(fieldType2);\n        fieldTypes.add(fieldType3);\n        fieldTypes.add(fieldType4);\n\n        CreateCollectionParam createCollectionParam = CreateCollectionParam.newBuilder()\n             .withCollectionName(milvusConfiguration.getCollectionName())\n             .withShardsNum(1)\n             .withCollectionType(milvusConfiguration.getCollectionType())\n             .withDescription(milvusConfiguration.getCollectionDescription())\n             .withFields(field", "first_line_groundtruth": ".withDimension(milvusConfiguration.getDimensions())", "first_line_prediction": " .withDimension(128)", "match": 0}
{"groundtruth": "book.getBestBidOrder();", "prediction": " book.getBestBid();\n\t\t\tbook.cancel(bidOrder.getClientOrderId());\n\t\t\tbook.reduce(bidOrder.getClientOrderId(), 100);\n\t\t\tbook.cancel(bidOrder.getClientOrderId());\n\t\t\tbook.reduce(bidOrder.getClientOrderId(), 100);\n\t\t\tbook.cancel(bidOrder.getClientOrderId());\n\t\t\tbook.reduce(bidOrder.getClientOrderId(), 100);\n\t\t\tbook.cancel(bidOrder.getClientOrderId());\n\t\t\tbook.reduce(bidOrder.getClientOrderId(), 100);\n\t\t\tbook.cancel(", "first_line_groundtruth": "book.getBestBidOrder();", "first_line_prediction": " book.getBestBid();", "match": 0}
{"groundtruth": ".withTimeout(milvusConfiguration.getTimeout(), TimeUnit.MILLISECONDS)\n                .createCollection(createCollectionReq);", "prediction": ".createCollection(createCollectionReq);\n            if (response.ok()) {\n                LOGGER.info(\"Collection created successfully\");\n            } else {\n                LOGGER.error(\"Error creating collection: \" + response.getMessage());\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error creating collection: \" + e.getMessage());\n        }\n    }\n\n    private void loadCollection() throws Exception {\n        LoadCollectionParam loadCollectionReq = LoadCollectionParam.newBuilder()\n             .withCollectionName(milvusConfiguration.getCollection())\n             .withShardingKey(\"id\")\n             .build();\n\n        try {\n            R<", "first_line_groundtruth": ".withTimeout(milvusConfiguration.getTimeout(), TimeUnit.MILLISECONDS)", "first_line_prediction": ".createCollection(createCollectionReq);", "match": 0}
{"groundtruth": "if(milvusConfiguration.getDeleteOnStartup() && hasCollection) {", "prediction": "\n            \n            if(hasCollection) {\n                LOGGER.debug(\"Collection already exists\");\n            }\n            else {\n                createCollection();\n            }\n\n            LoadCollectionParam loadCollectionReq = LoadCollectionParam.newBuilder()\n                 .withCollectionName(milvusConfiguration.getCollection())\n                 .withFileName(milvusConfiguration.getCollection() + \".bin\")\n                 .build();\n\n            R<RpcStatus> response = milvusClient.withTimeout(milvusConfiguration.getTimeout(), TimeUnit.MILLISECONDS)\n                 .loadCollection(loadCollectionReq);\n\n            if(response.getStatus().equals(R.Status.Success.getCode())) {\n               ", "first_line_groundtruth": "if(milvusConfiguration.getDeleteOnStartup() && hasCollection) {", "first_line_prediction": "", "match": 0}
{"groundtruth": "(milvusConfiguration.getCollection())\n                .build());", "prediction": "(milvusConfiguration.getCollection())\n                 .withFileName(milvusConfiguration.getCollection() + \".bin\")\n                 .build());\n\n            if(response.getStatus().equals(R.Status.Success.getCode())) {\n                LOGGER.debug(\"Load collection response: \" + response.getData().getMsg());\n            }\n            else {\n                LOGGER.error(\"Error loading collection: \" + response.getData().getMsg());\n                if(response.getException() != null) {\n                    throw new Exception(\"Error loading collection\", response.getException());\n                }\n                else {\n                    throw new Exception(\"Error loading collection\");\n               ", "first_line_groundtruth": "(milvusConfiguration.getCollection())", "first_line_prediction": "(milvusConfiguration.getCollection())", "match": 1}
{"groundtruth": "new Entry(entry1.path, entry1.metadata, classMergerCooler.merge(entry1.data, entry2.data));", "prediction": " classMergerCooler.merge(entry1, entry2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = entry1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (entry1 != null) {\n\t\t\t\tresult = entry1;\n\t\t\t} else if (entry2 != null) {\n\t\t\t\tresult = entry2;\n\t\t\t} else {\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (result != null) {\n\t\t\t\tif (isMinecraft) {\n\t\t\t\t\tside = \"client\";\n\t\t\t\t} else {\n\t\t\t\t\tside = \"server\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t", "first_line_groundtruth": "new Entry(entry1.path, entry1.metadata, classMergerCooler.merge(entry1.data, entry2.data));", "first_line_prediction": " classMergerCooler.merge(entry1, entry2);", "match": 0}
{"groundtruth": "(MinivanPlugin.filenameSafe(name) + \".jar\");", "prediction": "(artifact.path);\n\t\t}\n\t\t\n\t\tpublic String getClassifier() {\n\t\t\treturn artifact.classifier;\n\t\t}\n\t\t\n\t\tpublic String getVersion() {\n\t\t\treturn artifact.version;\n\t\t}\n\t\t\n\t\tpublic String getURL() {\n\t\t\treturn forgeDownloadRoot + getURLSuffix();\n\t\t}\n\t\t\n\t\tpublic String getSha1() {\n\t\t\treturn downloads.get(\"sha1\").getAsString();\n\t\t}\n\t\t\n\t\tpublic String getSize() {\n\t\t\treturn downloads.get(\"size\").getAsString();\n\t\t}\n\t\t\n\t\tpublic String getSizeHuman() {\n\t\t\treturn Min", "first_line_groundtruth": "(MinivanPlugin.filenameSafe(name) + \".jar\");", "first_line_prediction": "(artifact.path);", "match": 0}
{"groundtruth": "sendInputMessage(uuid, request.getInput(), InputMessage.TIMEOUT);", "prediction": " /* Timeout reached, sending the timeout message. */\n            sendInputMessage(uuid, request.getInput(), InputMessage.TIMEOUT);\n\n            /* Completing the request. */\n            request.getFuture().complete(new AquaInputResponse(InputStatus.TIMEOUT));\n            requests.remove(request);\n        }, request.getInput().getTimeout());\n    }\n\n    /* Sends the message to the player. */\n    private static void sendInputMessage(@NotNull UUID uuid, @NotNull AquaInput input, @NotNull InputMessage type) {\n        Player player = plugin.getServer().getPlayer(uuid);\n        if (player == null) return;", "first_line_groundtruth": "sendInputMessage(uuid, request.getInput(), InputMessage.TIMEOUT);", "first_line_prediction": " /* Timeout reached, sending the timeout message. */", "match": 0}
{"groundtruth": ".get(uuid).forEach(request -> request.getFuture().complete(response));", "prediction": ".get(uuid).forEach(request -> request.getFuture().complete(response));\n        requestsQueue.remove(uuid);\n    }", "first_line_groundtruth": ".get(uuid).forEach(request -> request.getFuture().complete(response));", "first_line_prediction": ".get(uuid).forEach(request -> request.getFuture().complete(response));", "match": 1}
{"groundtruth": "request.getInput().getTimeout() * 20L);", "prediction": "20 * request.getInput().getTimeout());\n    }\n\n    /* Sends the input message to the player. */\n    private static void sendInputMessage(@NotNull UUID uuid, @NotNull AquaInput input, @NotNull InputMessage message) {\n        Player player = plugin.getServer().getPlayer(uuid);\n        if (player == null) return;\n        player.sendMessage(message.getMessage(input));\n    }\n\n    /* Completes the current request with the given response. */\n    private static void completeCurrentRequest(@NotNull UUID uuid, @NotNull AquaInputResponse response) {\n        Queue<AquaInputRequest> requests = requests", "first_line_groundtruth": "request.getInput().getTimeout() * 20L);", "first_line_prediction": "20 * request.getInput().getTimeout());", "match": 0}
{"groundtruth": "if (request.getInput().getTimeout() < 0) return;", "prediction": " plugin.getServer().getScheduler().runTaskLater(plugin, () -> {\n             /* Checking if the request is still valid. */\n             if (request.getInput().isValidInput(request.getInput().getMessage(InputMessage.PROMPT))) {\n                 /* Sending the response message. */\n                 sendInputMessage(uuid, request.getInput(), InputMessage.RESPONSE);\n             } else {\n                 /* Sending the error message. */\n                 sendInputMessage(uuid, request.getInput(), InputMessage.ERROR);\n             }", "first_line_groundtruth": "if (request.getInput().getTimeout() < 0) return;", "first_line_prediction": " plugin.getServer().getScheduler().runTaskLater(plugin, () -> {", "match": 0}
{"groundtruth": ", request.getInput(), InputMessage.PROMPT);", "prediction": ", request);\n\n        /* Setting the timeout task. */\n        plugin.getServer().getScheduler().runTaskLater(plugin, () -> {\n            if (request.isCancelled()) return;\n            request.getFuture().complete(new AquaInputResponse(InputStatus.TIMEOUT));\n        }, request.getTimeout());\n    }\n\n    /* Sends the prompt message to the player. */\n    private static void sendInputMessage(@NotNull UUID uuid, @NotNull AquaInputRequest request) {\n        Player player = plugin.getServer().getPlayer(uuid);\n        if (player == null) return;\n        player.sendMessage(request.getInput().", "first_line_groundtruth": ", request.getInput(), InputMessage.PROMPT);", "first_line_prediction": ", request);", "match": 0}
{"groundtruth": ".element().getInput();", "prediction": "\n                .peek();\n    }", "first_line_groundtruth": ".element().getInput();", "first_line_prediction": "", "match": 0}
{"groundtruth": "requests.element().getFuture().complete(response);", "prediction": " /* If the current head of the queue is not the one that was completed, return. */\n        if (requests.element() != requests.peek()) return;\n\n        /* If the current head of the queue is the one that was completed, remove it. */\n        requests.remove();\n\n        /* If the queue is empty, remove the player from the requests queue. */\n        if (requests.isEmpty()) requestsQueue.remove(uuid);\n\n        /* Complete the CompletableFuture of the current head of the queue. */\n        requests.element().getFuture().complete(response);\n    }", "first_line_groundtruth": "requests.element().getFuture().complete(response);", "first_line_prediction": " /* If the current head of the queue is not the one that was completed, return. */", "match": 0}
{"groundtruth": "request.getFuture();", "prediction": " request.future;\n    }\n\n    /**\n     * Initializes the plugin.\n     *\n     * @param plugin the plugin\n     * */\n    private static void initialize(@NotNull JavaPlugin plugin) {\n        AquaInputManager.plugin = plugin;\n    }\n\n    /**\n     * Initializes the input request.\n     *\n     * @param uuid the unique id\n     * @param request the request\n     * */\n    private static void initializeInputRequest(@NotNull UUID uuid, @NotNull AquaInputRequest request) {\n        request.future.whenComplete((response, throwable) -> {\n            if (throwable != null) {\n                request.future.complete", "first_line_groundtruth": "request.getFuture();", "first_line_prediction": " request.future;", "match": 0}
{"groundtruth": "d.getOriginalText().split(\"\\\\n\");", "prediction": " sb.toString().split(\" \");\n        for(int i = 0; i < splitText.length; i++) {\n            outputBuilder.append(splitText[i]).append(\" \");\n        }\n        d.setOutputText(outputBuilder.toString());\n        \n        return d;\n    }\n\n    @Override\n    public List<Document> loadDocuments() throws Exception {\n        LOGGER.debug(\"Loading documents from: \" + agencyConfiguration.getDocumentsPath());\n        List<Document> docs = new ArrayList<>();\n        File input = new File(agencyConfiguration.getDocumentsPath());\n        Scanner scanner = new Scanner(input);\n        \n        while(", "first_line_groundtruth": "d.getOriginalText().split(\"\\\\n\");", "first_line_prediction": " sb.toString().split(\" \");", "match": 0}
{"groundtruth": "(description.getName().equals(skillType)) {", "prediction": "(description.getName().equals(skillType)) {\n                    returnVal.put(skillType, currentSkill);\n                    break;\n                }\n            }\n        }\n        return returnVal;\n    }", "first_line_groundtruth": "(description.getName().equals(skillType)) {", "first_line_prediction": "(description.getName().equals(skillType)) {", "match": 1}
{"groundtruth": "conversation.formattedFullHistory(), null);", "prediction": "getLongInput(new Scanner(System.in)), conversation);\n        return historyAgentConversation;\n    }", "first_line_groundtruth": "conversation.formattedFullHistory(), null);", "first_line_prediction": "getLongInput(new Scanner(System.in)), conversation);", "match": 0}
{"groundtruth": "= currentSkill.describe();", "prediction": " = currentSkill.describe();\n                if(description.getName().equals(skillType)) {\n                    returnVal.put(skillType, currentSkill);\n                    break;\n                }\n            }\n        }\n        return returnVal;\n    }", "first_line_groundtruth": "= currentSkill.describe();", "first_line_prediction": " = currentSkill.describe();", "match": 0}
{"groundtruth": "conversation.getAllMessages().get(0).getRole().equals(ChatMessageRole.SYSTEM.value())) {", "prediction": "historyAgentConversation.hasSystemMessage()) {\n            summarized.addMessage(historyAgentConversation.getSystemMessage());\n        }\n\n        // copy the user messages\n        for(final var message : historyAgentConversation.getUserMessages()) {\n            summarized.addMessage(message);\n        }\n\n        // copy the agent messages\n        for(final var message : historyAgentConversation.getAgentMessages()) {\n            summarized.addMessage(message);\n        }\n\n        return summarized;\n    }", "first_line_groundtruth": "conversation.getAllMessages().get(0).getRole().equals(ChatMessageRole.SYSTEM.value())) {", "first_line_prediction": "historyAgentConversation.hasSystemMessage()) {", "match": 0}
{"groundtruth": ").infer(object, recordName));", "prediction": "recordName));\n        writer.write(object, encoder);\n        encoder.flush();\n        return ByteBuffer.wrap(outputStream.toByteArray());\n    }", "first_line_groundtruth": ").infer(object, recordName));", "first_line_prediction": "recordName));", "match": 0}
{"groundtruth": "conversation.getAllMessages())\n                    .maxTokens(agencyConfiguration.getChatRequestMaxTokens())\n                    .build();", "prediction": "conversation.getAllMessages())\n                     .build();\n        ChatCompletionResult chatCompletion = openAiService.createChatCompletion(chatCompletionRequest);\n        Usage usage = chatCompletion.getUsage();\n        LOGGER.debug(\"Used \" + usage.getPromptTokens() + \" tokens for prompt\");\n        LOGGER.debug(\"Used \" + usage.getCompletionTokens() + \" tokens for response\");\n        LOGGER.debug(\"Used \" + usage.getTotalTokens() + \" tokens total\");\n        String aiResponse = chatCompletion.getChoices().get(0).getMessage().getContent();\n        LOGGER.debug(\"Chat Agent Response > \" + aiResponse", "first_line_groundtruth": "conversation.getAllMessages())", "first_line_prediction": "conversation.getAllMessages())", "match": 1}
{"groundtruth": "var message : conversation.getAllMessages()) {", "prediction": " ChatMessage message : conversation.getAllMessages()) {\n            sum += encoding.countTokens(message.getContent());\n            sum += encoding.countTokens(message.getRole());\n            sum += encoding.countTokens(message.getName());\n        }\n        return sum / tokensPerMessage;\n    }\n\n    public String getChatResponse(ConversationHistory conversation) {\n        String aiResponse = getNextChatResponse(conversation).getContent();\n        return aiResponse;\n    }\n\n    public String getChatResponse(ConversationHistory conversation, String prompt) {\n        String aiResponse = getNextChatResponse(conversation).getContent();\n        return aiResponse;\n    }\n\n    public", "first_line_groundtruth": "var message : conversation.getAllMessages()) {", "first_line_prediction": " ChatMessage message : conversation.getAllMessages()) {", "match": 0}
{"groundtruth": "historyAgentConversation.getAllMessages().get(\n                        historyAgentConversation.getAllMessages().size()-1)));", "prediction": " historyAgentConversation.formattedFullHistory()));\n\n        return summarized;\n    }", "first_line_groundtruth": "historyAgentConversation.getAllMessages().get(", "first_line_prediction": " historyAgentConversation.formattedFullHistory()));", "match": 0}
{"groundtruth": "return mapper.deleteRegister(challengeSeq, id);", "prediction": " // TODO Auto-generated method stub\n\t\tint res = rmRepository.deleteBySeqAndId(challengeSeq, id);\n\t\tSystem.out.println(\"biz del res: \" + res);\n\t\treturn res;", "first_line_groundtruth": "return mapper.deleteRegister(challengeSeq, id);", "first_line_prediction": " // TODO Auto-generated method stub", "match": 0}
{"groundtruth": "dto.setOnOffNoty(\"Y\");", "prediction": "", "first_line_groundtruth": "dto.setOnOffNoty(\"Y\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "> challenges = challengeBiz.findbyCate(category);", "prediction": "> challenges = challengeBiz.findByCategory(category);\n\t      model.addAttribute(\"challenges\", challenges);\n\t      model.addAttribute(\"cate\", category);\n\t      return \"main\";\n\t   }\n\t   \n\t   @GetMapping(\"/main_work\")\n\t   public String getWorkChallenges(Model model) {\n\t      String category = \"\uc791\uc5c5\";\n\t      List<ChallengeDto> challenges = challengeBiz.findByCategory(category);\n\t      model.addAttribute(\"challenges\", challenges);\n\t      model.addAttribute(\"cate\", category);\n\t      return \"main\";\n\t   }\n\t   \n\t   @GetMapping(\"/main_etc\")\n\t   public String getEtcChallenges(Model model) {", "first_line_groundtruth": "> challenges = challengeBiz.findbyCate(category);", "first_line_prediction": "> challenges = challengeBiz.findByCategory(category);", "match": 0}
{"groundtruth": "historyAgentConversation.getAllMessages().size()-1)));", "prediction": "0).getContent()));\n\n        return summarized;\n    }", "first_line_groundtruth": "historyAgentConversation.getAllMessages().size()-1)));", "first_line_prediction": "0).getContent()));", "match": 0}
{"groundtruth": "conversation.getAllMessages().size()).toArray(new ChatMessage[0]);", "prediction": "\t\tconversation.getAllMessages().size())\n                    \t.toArray(new ChatMessage[0]);\n    }", "first_line_groundtruth": "conversation.getAllMessages().size()).toArray(new ChatMessage[0]);", "first_line_prediction": "\t\tconversation.getAllMessages().size())", "match": 0}
{"groundtruth": "dto.setUserLoginType(\"K\");", "prediction": "", "first_line_groundtruth": "dto.setUserLoginType(\"K\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "dto.setUserName(userName);", "prediction": "\ttry {\n\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\t\t\tdto.setUserBirth(sdf.parse(userBirth));\n\t\t\t} catch (ParseException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\tdto.setUserName(userName);\n\t\tdto.setUserPhone(userPhone);\n\t\tdto.setUserLoginType(\"kakao\");\n\t\tkakaoLogin.insertUser(dto);\n\t\treturn \"redirect:/\";", "first_line_groundtruth": "dto.setUserName(userName);", "first_line_prediction": "\ttry {", "match": 0}
{"groundtruth": ".put(\"userId\", dto.getUserId());", "prediction": ".put(\"redirect\", \"/kakaoAuth/findform\");\n\t\t}\n\t\treturn result;", "first_line_groundtruth": ".put(\"userId\", dto.getUserId());", "first_line_prediction": ".put(\"redirect\", \"/kakaoAuth/findform\");", "match": 0}
{"groundtruth": "dto.setUserPhone(userPhone);", "prediction": "\tdto.setUserPhone(userPhone);\n\t\tloginBiz.join(dto);\n\t\treturn \"redirect:/\";", "first_line_groundtruth": "dto.setUserPhone(userPhone);", "first_line_prediction": "\tdto.setUserPhone(userPhone);", "match": 0}
{"groundtruth": "user = loginBiz.findByUserId(userId);", "prediction": " user = loginBiz.login(userId, userPw);\n\t\tif(user != null) {\n\t\t\tsession.setAttribute(\"user\", user);\n\t\t\treturn \"redirect:/main\";\n\t\t}\n\t\telse {\n\t\t\tmodel.addAttribute(\"msg\", \"\uc544\uc774\ub514 \ub610\ub294 \ube44", "first_line_groundtruth": "user = loginBiz.findByUserId(userId);", "first_line_prediction": " user = loginBiz.login(userId, userPw);", "match": 0}
{"groundtruth": "&& user.getUserPw().equals(userPw)) {", "prediction": " && userPw.equals(user.getUserPw())) {\n\t\t\tsession.setAttribute(\"user\", user);\n\t\t\treturn \"redirect:/main\";\n\t\t} else {\n\t\t\tmodel.addAttribute(\"msg\", \"\uc544\uc774\ub514 \ub610\ub294 \ube44", "first_line_groundtruth": "&& user.getUserPw().equals(userPw)) {", "first_line_prediction": " && userPw.equals(user.getUserPw())) {", "match": 0}
{"groundtruth": "openAiConfiguration.chatModel(), \n            conversation);", "prediction": "0, \n            conversation.getAllMessages().size() - 1, \n            conversation.getAllMessages().get(0).getContent());\n\n        ChatCompletionRequest request = requestBuilder.build(\n            conversation.getAllMessages().get(0).getContent(), \n            tokenCount, \n            conversation.getAllMessages().get(0).getRole());\n\n        ChatCompletionResult result = openAiService.complete(request);\n\n        ChatMessage aiResponseMsg = new ChatMessage(\n            conversation.getAllMessages().get(0).getRole(), \n            result.getChoices().get(0).getText());\n\n        conversation.addMessage(aiResponseMsg);\n\n        return ai", "first_line_groundtruth": "openAiConfiguration.chatModel(), ", "first_line_prediction": "0, ", "match": 0}
{"groundtruth": "(conversation.getAllMessages().size() > agencyConfiguration.getChatSummaryRetainedMessageCount()) {", "prediction": "(historyAgentConversation.getAllMessages().size() > 1) {\n            for(int i = 1; i < historyAgentConversation.getAllMessages().size(); i++) {\n                recentMessagesSB.append(historyAgentConversation.getAllMessages().get(i).getContent());\n                recentMessagesSB.append(\"\\n\");\n            }\n        }\n        else {\n            recentMessagesSB.append(\"No messages yet.\");\n        }\n        \n        summarized.addMessage(\n            new ChatMessage(ChatMessageRole.SYSTEM.value(), recentMessagesSB.toString()));\n\n        return summarized;\n    }", "first_line_groundtruth": "(conversation.getAllMessages().size() > agencyConfiguration.getChatSummaryRetainedMessageCount()) {", "first_line_prediction": "(historyAgentConversation.getAllMessages().size() > 1) {", "match": 0}
{"groundtruth": "ChallengeDto currentChallenge = challengeBiz.selectOneBySeq(challengeSeq);", "prediction": "\tChallengeDto challengeDto = challengeBiz.selectOne(challengeSeq);\n\t\t\t\tUserDto userDto = loginBiz.selectOne(userId);\n\t\t\t\tRegisteredMemberDto registeredMemberDto = new RegisteredMemberDto();\n\t\t\t\tregisteredMemberDto.setChallengeDto(challengeDto);\n\t\t\t\tregisteredMemberDto.setUserDto(userDto);\n\t\t\t\tregisteredMemberDto.setJoinDate(new Date());\n\t\t\t\tregisteredMemberDto.setChallengeSeq(challengeSeq);\n\t\t\t\tregisteredMemberDto.setUserId(userId);\n\t\t\t\tregisteredMemberDto.setChallengeName(challengeDto.getChallengeName());\n\t\t\t\tregisteredMemberDto", "first_line_groundtruth": "ChallengeDto currentChallenge = challengeBiz.selectOneBySeq(challengeSeq);", "first_line_prediction": "\tChallengeDto challengeDto = challengeBiz.selectOne(challengeSeq);", "match": 0}
{"groundtruth": "challenge = challengeBiz.selectOne(challengeName);", "prediction": " challenge = challengeBiz.selectOne(challengeName);\n\t\tmodel.addAttribute(\"challenge\", challenge);\n\t\treturn \"detail\";", "first_line_groundtruth": "challenge = challengeBiz.selectOne(challengeName);", "first_line_prediction": " challenge = challengeBiz.selectOne(challengeName);", "match": 0}
{"groundtruth": "return redisOps.getValue(getApiKeyRedisKey());", "prediction": " return redisOps.getValue(apiKeyRedisKey);\n    }\n\n    @Override\n    public String getOpenAIApiKeyId() {\n        return openAIApiKeyId;\n    }\n\n    @Override\n    public OkHttpClientUtils getOkHttpClientUtils() {\n        return okHttpClientUtils;\n    }\n\n    @Override\n    public void setOkHttpClientUtils(OkHttpClientUtils okHttpClientUtils) {\n        this.okHttpClientUtils = okHttpClientUtils;\n    }\n\n    @Override\n    public String getLockRedisKey() {\n        return lockRedisKey;\n    }\n\n    @Override\n    public String getApiKeyRedisKey() {\n        return apiKeyRedisKey;\n    }", "first_line_groundtruth": "return redisOps.getValue(getApiKeyRedisKey());", "first_line_prediction": " return redisOps.getValue(apiKeyRedisKey);", "match": 0}
{"groundtruth": "redisOps.setValue(apiKeyRedisKey, openApiKey);", "prediction": " redisOps.setValue(lockRedisKey, \"1\", 1, TimeUnit.SECONDS);\n         redisOps.setValue(apiKeyRedisKey, openApiKey);\n         redisOps.expire(lockRedisKey, 1, TimeUnit.SECONDS);\n    }\n\n    @Override\n    public String getOpenAIApiKey() {\n        return redisOps.getValue(apiKeyRedisKey);\n    }\n\n    @Override\n    public String getOpenAIApiKeyId() {\n        return openAIApiKeyId;\n    }\n\n    @Override\n    public OkHttpClientUtils getOkHttpClientUtils() {\n        return okHttpClientUtils;\n    }\n\n    @Override\n    public void setOk", "first_line_groundtruth": "redisOps.setValue(apiKeyRedisKey, openApiKey);", "first_line_prediction": " redisOps.setValue(lockRedisKey, \"1\", 1, TimeUnit.SECONDS);", "match": 0}
{"groundtruth": "int currentMember = registeredBiz.coutBySeq(challengeSeq);", "prediction": "\n\t\t\t\n\t\t\t// \ucc38\uc5ec\ud558\uae30\n\t\t\tchallengeBiz.joinUser(currentChallenge, currentUser);", "first_line_groundtruth": "int currentMember = registeredBiz.coutBySeq(challengeSeq);", "first_line_prediction": "", "match": 0}
{"groundtruth": "registeredBiz.coutBySeq(challengeSeq);", "prediction": "0;\n\t\t\t\tif (currentChallenge.getChallengeMaxMember() == 1) {\n\t\t\t\t\tmember = 1;\n\t\t\t\t} else {\n\t\t\t\t\tmember = currentMember + 1;\n\t\t\t\t}\n\t\t\t\tif (member == currentChallenge.getChallengeMaxMember()) {\n\t\t\t\t\tcurrentChallenge.setChallengeEnabled(\"N\");\n\t\t\t\t\tchallengeBiz.update(currentChallenge);\n\t\t\t\t}\n\t\t\t\treturn \"success\";\n\t\t\t} else {\n\t\t\t\treturn \"fail\";\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"fail\";\n\t\t}", "first_line_groundtruth": "registeredBiz.coutBySeq(challengeSeq);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "registeredBiz.challengeStart(challengeSeq);", "prediction": "\tchallengeBiz.updateChallengeEnabled(challengeSeq);\n\t\t\t\t}\n\t\t\t\treturn \"success\";\n\t\t\t} else {\n\t\t\t\treturn \"fail\";\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"fail\";\n\t\t}", "first_line_groundtruth": "registeredBiz.challengeStart(challengeSeq);", "first_line_prediction": "\tchallengeBiz.updateChallengeEnabled(challengeSeq);", "match": 0}
{"groundtruth": "if (currentChallenge.getChallengeEnabled().equals(\"Y\")\n\t\t\t\t\t&& currentMember < currentChallenge.getChallengeMaxMember()) {", "prediction": "\tif (currentMember == 0) {\n\t\t\t\t\t//", "first_line_groundtruth": "if (currentChallenge.getChallengeEnabled().equals(\"Y\")", "first_line_prediction": "\tif (currentMember == 0) {", "match": 0}
{"groundtruth": "return currentChallenge.getChallengeName() + \"\uc5d0 \ucc38\uc5ec\ud558\uc600\uc2b5\ub2c8\ub2e4. \";", "prediction": "\treturn \"success\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"fail\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn \"fail\";\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"fail\";\n\t\t}", "first_line_groundtruth": "return currentChallenge.getChallengeName() + \"\uc5d0 \ucc38\uc5ec\ud558\uc600\uc2b5\ub2c8\ub2e4. \";", "first_line_prediction": "\treturn \"success\";", "match": 0}
{"groundtruth": "currentChallenge.getChallengeMaxMember()) {", "prediction": "3\n\t\t\t\t\t&& currentChallenge.getChallengeCate().equals(currentUser.getUserCate())) {\n\t\t\t\t// \ucc38\uc5ec\ud558\uae30\n\t\t\t\tregisteredBiz.insert(challengeSeq, userId);\n\t\t\t\treturn \"success\";\n\t\t\t} else {\n\t\t\t\treturn \"fail\";\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"fail\";\n\t\t}", "first_line_groundtruth": "currentChallenge.getChallengeMaxMember()) {", "first_line_prediction": "3", "match": 0}
{"groundtruth": ".equals(settings.sopsExecutable, settingsComponent.getSopsExecutable()) ||\n\t\t\t!Objects.equals(settings.sopsFilesReadOnly, settingsComponent.getSopsFilesReadOnly());", "prediction": ".equals(settings.sopsExecutable, settingsComponent.getSopsExecutable()) ||\n\t\t\t\tsettings.sopsFilesReadOnly != settingsComponent.getSopsFilesReadOnly();", "first_line_groundtruth": ".equals(settings.sopsExecutable, settingsComponent.getSopsExecutable()) ||", "first_line_prediction": ".equals(settings.sopsExecutable, settingsComponent.getSopsExecutable()) ||", "match": 1}
{"groundtruth": "settingsComponent.getSopsFilesReadOnly());", "prediction": " settingsComponent.getSopsFilesReadOnly());", "first_line_groundtruth": "settingsComponent.getSopsFilesReadOnly());", "first_line_prediction": " settingsComponent.getSopsFilesReadOnly());", "match": 0}
{"groundtruth": "if (currentChallenge.getChallengeEnabled().equals(\"Y\")) {", "prediction": "\n\t\t\tint res = registeredBiz.delete(challengeSeq, currentUser.getId());\n\t\t\tSystem.out.println(\"controller delete res: \" + res);\n\t\t\t\n\t\t\t// \ub514\ube44 \ubc18\uc601 \ud6c4", "first_line_groundtruth": "if (currentChallenge.getChallengeEnabled().equals(\"Y\")) {", "first_line_prediction": "", "match": 0}
{"groundtruth": "SettingsState.getInstance().sopsEnvironment.split(\"\\\\s(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\");", "prediction": " Arrays.stream(EnvironmentUtil.getEnvironmentVariables())\n\t\t\t\t.filter(Predicate.not(e -> e.startsWith(\"PATH\")))\n\t\t\t\t.toArray(String[]::new);", "first_line_groundtruth": "SettingsState.getInstance().sopsEnvironment.split(\"\\\\s(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\");", "first_line_prediction": " Arrays.stream(EnvironmentUtil.getEnvironmentVariables())", "match": 0}
{"groundtruth": "currentChallenge.getChallengeMaxMember() <= member) {", "prediction": "member == currentChallenge.getChallengeMaxMember()) {\n\t\t\t\t\tchallengeBiz.updateChallengeEnabled(challengeSeq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn \"success\";\n\t\t\t} else {\n\t\t\t\treturn \"fail\";\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"fail\";\n\t\t}", "first_line_groundtruth": "currentChallenge.getChallengeMaxMember() <= member) {", "first_line_prediction": "member == currentChallenge.getChallengeMaxMember()) {", "match": 0}
{"groundtruth": "+ \" &3&o\u2192 &r\" + blockItem.getDisplayName());", "prediction": " + \" &7&o- &f&o\" + blockItem.getName());\n        }\n\n        Helpers.sendFormattedMessage(sender,\"\");\n        return true;\n    }", "first_line_groundtruth": "+ \" &3&o\u2192 &r\" + blockItem.getDisplayName());", "first_line_prediction": " + \" &7&o- &f&o\" + blockItem.getName());", "match": 0}
{"groundtruth": "world.dropItemNaturally(location, blockItem.getItem(1));", "prediction": " world.setBlockData(location, BROKEN_MATERIAL.createBlockData());\n            }\n\n            Helpers.sendMessage(this.plugin, player, Keys.MESSAGES_BLOCK_BROKEN);\n            Helpers.sendMessage(this.plugin, player, Keys.MESSAGES_BLOCK_BROKEN_ITEM, blockItem.getItem(1));\n        }\n    }\n\n    public void preload () {\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                for (int z = -1; z <= 1; z", "first_line_groundtruth": "world.dropItemNaturally(location, blockItem.getItem(1));", "first_line_prediction": " world.setBlockData(location, BROKEN_MATERIAL.createBlockData());", "match": 0}
{"groundtruth": "player.getInventory().addItem(blockItem.getItem(amount));", "prediction": " if (amount > blockItem.getAmount()) {\n            Helpers.sendMessage(this.plugin, player, Keys.MESSAGES_CMD_BLOCK_NOT_ENOUGH);\n            return false;\n        }\n\n        blockItem.setAmount(blockItem.getAmount() - amount);\n        player.getInventory().addItem(blockItem.getItemStack());\n\n        return true;\n    }\n\n    public boolean onCommand (CommandSender sender, String[] args) {\n        if (args.length < 2) {\n            Helpers.sendMessage(this.plugin, sender, Keys.MESSAGES_CMD_BLOCK_USAGE);\n            return false", "first_line_groundtruth": "player.getInventory().addItem(blockItem.getItem(amount));", "first_line_prediction": " if (amount > blockItem.getAmount()) {", "match": 0}
{"groundtruth": "edgarSectorEnrichService.exportToCSV(writer);", "prediction": " writer.println(\"CIK,Ticker,Name,Sector,SIC\");\n             List<Stock> stockCiks = stockCikRepository.findAll();\n             stockCiks.stream().map(stockCik -> String.format(\"%s,%s,%s,%s,%s\",\n                     stockCik.getCik(),\n                     stockCik.getTicker(),\n                     stockCik.getName(),\n                     stockCik.getSector(),\n                     stockCik.getSic())).forEach(writer::println);\n        }\n    }", "first_line_groundtruth": "edgarSectorEnrichService.exportToCSV(writer);", "first_line_prediction": " writer.println(\"CIK,Ticker,Name,Sector,SIC\");", "match": 0}
{"groundtruth": "edgarSectorEnrichService.enrichCik(ticker);", "prediction": " stockCikRepository.findByTicker(ticker);\n        if (stockCikOptional.isPresent()) {\n            Stock stockCik = stockCikOptional.get();\n            return enrichCik(stockCik);\n        } else {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();\n        }\n    }", "first_line_groundtruth": "edgarSectorEnrichService.enrichCik(ticker);", "first_line_prediction": " stockCikRepository.findByTicker(ticker);", "match": 0}
{"groundtruth": "fullIndexDownloadService.processFillings(filingTypesList);", "prediction": " filingsDownloadService.downloadFilings(filingTypesList);\n             fullIndexDownloadService.downloadFullIndex();\n             edgarSectorEnrichService.enrichStockWithCusips();\n             return ResponseEntity.ok().build();\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n    }", "first_line_groundtruth": "fullIndexDownloadService.processFillings(filingTypesList);", "first_line_prediction": " filingsDownloadService.downloadFilings(filingTypesList);", "match": 0}
{"groundtruth": "String> formTypes = fullIndexRepository.findDistinctFormTypes();", "prediction": "String> formTypes = filingsDownloadService.getDistinctFormTypes();\n        return new ResponseEntity<>(formTypes, HttpStatus.OK);\n    }", "first_line_groundtruth": "String> formTypes = fullIndexRepository.findDistinctFormTypes();", "first_line_prediction": "String> formTypes = filingsDownloadService.getDistinctFormTypes();", "match": 0}
{"groundtruth": "filingsDownloadService.downloadFullIndex();", "prediction": " String result = fullIndexDownloadService.downloadFullIndex();\n         return new ResponseEntity<>(result, HttpStatus.OK);\n     }", "first_line_groundtruth": "filingsDownloadService.downloadFullIndex();", "first_line_prediction": " String result = fullIndexDownloadService.downloadFullIndex();", "match": 0}
{"groundtruth": "<String> allFormTypes = fullIndexRepository.findDistinctFormTypes();", "prediction": "<String> filingTypes = fullIndexRepository.findByFormTypeContaining(\"13\").stream()\n                .map(FullIndex::getFormType)\n                .collect(Collectors.toSet());\n\n        int newFilings = 0;\n        int existingFilings = 0;\n\n        for (String filingType : filingTypes) {\n            log.info(\"Downloading filings of type {}\", filingType);\n            String result = downloadFilingsOfType(filingType);\n            newFilings += result.split(\"New filings: \")[1].split(\",\")[0].trim();\n            existingFilings += result", "first_line_groundtruth": "<String> allFormTypes = fullIndexRepository.findDistinctFormTypes();", "first_line_prediction": "<String> filingTypes = fullIndexRepository.findByFormTypeContaining(\"13\").stream()", "match": 0}
{"groundtruth": "IAPKAnalyzer.createFor(inputFile);", "prediction": " IAPKAnalyzer.createFor(inputFile);\n        var result = analyzer.analyzeAPK();\n        var gson = new GsonBuilder().setPrettyPrinting().create();\n        return gson.toJson(result);\n    }", "first_line_groundtruth": "IAPKAnalyzer.createFor(inputFile);", "first_line_prediction": " IAPKAnalyzer.createFor(inputFile);", "match": 0}
{"groundtruth": "targetFilings = fullIndexRepository.findByFormType(filingType);", "prediction": " fullIndices = fullIndexRepository.findByFormType(filingType);\n        if (fullIndices.isEmpty()) {\n            log.info(\"No full indices found for filing type {}\", filingType);\n            return null;\n        }\n\n        List<String> cikList = fullIndices.stream()\n                .map(FullIndex::getCik)\n                .map(String::valueOf)\n                .collect(Collectors.toList());\n\n        List<String> cikCusipPairs = cikList.stream()\n                .map(cik -> Pair.of(cik, cikCusipMapsRepository.find", "first_line_groundtruth": "targetFilings = fullIndexRepository.findByFormType(filingType);", "first_line_prediction": " fullIndices = fullIndexRepository.findByFormType(filingType);", "match": 0}
{"groundtruth": "nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "prediction": " nativeLibDirField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");\n            final File[] origNativeLibDirs = (File[]) nativeLibDirField.get(dexPathList);\n\n            final List<File> newNativeLibDirList = new ArrayList<>(origNativeLibDirs.length + 1);\n            newNativeLibDirList.add(folder);\n            for (File origNativeLibDir : origNativeLibDirs) {\n                if (!folder.equals(origNativeLibDir)) {\n                    newNativeLibDirList.add(origNativeLibDir);\n                }\n            }\n            native", "first_line_groundtruth": "nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "first_line_prediction": " nativeLibDirField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "match": 0}
{"groundtruth": "Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"systemNativeLibraryDirectories\");", "prediction": " Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");\n            nativeLibraryDirectoriesField.set(dexPathList, origLibDirs);\n        }\n    }\n\n    private static final class V25 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "first_line_groundtruth": "Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, \"systemNativeLibraryDirectories\");", "first_line_prediction": " Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "match": 0}
{"groundtruth": "Field nativeLibDirField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "prediction": " Method addDexPathElementMethod = ShareReflectUtil.findMethod(dexPathList.getClass(), \"addDexPathElement\", String.class);\n            addDexPathElementMethod.invoke(dexPathList, folder.getPath());\n        }\n    }\n\n    private static final class V23 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final  Method addDexPathElementMethod = ShareReflectUtil.", "first_line_groundtruth": "Field nativeLibDirField = ShareReflectUtil.findField(dexPathList, \"nativeLibraryDirectories\");", "first_line_prediction": " Method addDexPathElementMethod = ShareReflectUtil.findMethod(dexPathList.getClass(), \"addDexPathElement\", String.class);", "match": 0}
{"groundtruth": "= ShareReflectUtil.findField(classLoader, \"libPath\");", "prediction": " = ClassLoader.class.getDeclaredField(\"path\");\n            pathField.setAccessible(true);\n            String oldPath = (String) pathField.get(classLoader);\n            String newPath = oldPath + File.pathSeparator + addPath;\n            pathField.set(classLoader, newPath);\n        }\n    }\n\n    private static final class V14 {\n        private static void install(ClassLoader classLoader, File folder) throws Throwable {\n            String addPath = folder.getPath();\n            Class<?> classLoaderClass = classLoader.getClass();\n            Method method = classLoaderClass.getDeclaredMethod(\"addPath\", String.", "first_line_groundtruth": "= ShareReflectUtil.findField(classLoader, \"libPath\");", "first_line_prediction": " = ClassLoader.class.getDeclaredField(\"path\");", "match": 0}
{"groundtruth": "= parser.readLong(buffer, baseOffset);", "prediction": " = parser.readWord(buffer, baseOffset);\n        val  = parser.readLong(buffer, baseOffset + 0x8);\n        ptr  = parser.readLong(buffer, baseOffset + 0x10);\n    }", "first_line_groundtruth": "= parser.readLong(buffer, baseOffset);", "first_line_prediction": " = parser.readWord(buffer, baseOffset);", "match": 0}
{"groundtruth": "val = parser.readWord(buffer, baseOffset + 0x4);", "prediction": " val = parser.readWord(buffer, baseOffset + 0x4);\n    }", "first_line_groundtruth": "val = parser.readWord(buffer, baseOffset + 0x4);", "first_line_prediction": " val = parser.readWord(buffer, baseOffset + 0x4);", "match": 0}
{"groundtruth": "= parser.readWord(buffer, 0x1C);", "prediction": " = parser.readLong(buffer, 0x20);\n        shoff  = parser.readLong(buffer, 0x28);\n        phentsize = parser.readHalf(buffer, 0x36);\n        phnum = parser.readHalf(buffer, 0x38);\n        shentsize = parser.readHalf(buffer, 0x3a);\n        shnum = parser.readHalf(buffer, 0x3c);\n        shstrndx = parser.readHalf(buffer, 0x3e);\n    }\n\n    public Elf32", "first_line_groundtruth": "= parser.readWord(buffer, 0x1C);", "first_line_prediction": " = parser.readLong(buffer, 0x20);", "match": 0}
{"groundtruth": "final Method makeElements = ShareReflectUtil.findMethod(dexPathList, \"makePathElements\", List.class);", "prediction": " final Method makeElements = ShareReflectUtil.findMethod(dexPathList,\n                     \"makePathElements\", List.class, File.class, List.class);\n            final ArrayList<IOException> suppressedExceptions = new ArrayList<>();\n\n            final Object[] elements = (Object[]) makeElements.invoke(dexPathList, newLibDirs, null, suppressedExceptions);\n\n            final Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, \"nativeLibraryPathElements\");\n            nativeLibraryPathElements.set(dexPathList, elements);\n        }\n    }", "first_line_groundtruth": "final Method makeElements = ShareReflectUtil.findMethod(dexPathList, \"makePathElements\", List.class);", "first_line_prediction": " final Method makeElements = ShareReflectUtil.findMethod(dexPathList,", "match": 0}
{"groundtruth": "libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, \"libraryPathElements\");", "prediction": " pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final List<String> pathList = (List<String>) pathListField.get(classLoader);\n            final List<String> newPathList = new ArrayList<>(pathList.size() + 1);\n            newPathList.addAll(pathList);\n            newPathList.add(addPath);\n            pathListField.set(classLoader, newPathList);\n        }\n    }\n\n    private static final class V14 {\n        private static void install(ClassLoader classLoader, File folder) throws Throwable {\n            String", "first_line_groundtruth": "libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, \"libraryPathElements\");", "first_line_prediction": " pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");", "match": 0}
{"groundtruth": "ShareTinkerLog.e(TAG, \"installNativeLibraryPath, folder %s is illegal\", folder);", "prediction": " return;\n        }\n        String[] files = folder.list();\n        if (files == null) {\n            return;\n        }\n        for (String file : files) {\n            File f = new File(folder, file);\n            if (f.isDirectory()) {\n                installNativeLibraryPath(classLoader, f);\n            } else {\n                if (file.endsWith(\".so\")) {\n                    installNativeLibrary(classLoader, f);\n                }\n            }\n        }\n    }\n\n    public static void installNativeLibrary(ClassLoader classLoader, File file) throws Throwable {\n        if (file == null || !file.exists()) {", "first_line_groundtruth": "ShareTinkerLog.e(TAG, \"installNativeLibraryPath, folder %s is illegal\", folder);", "first_line_prediction": " return;", "match": 0}
{"groundtruth": "parser.readWord(buffer, 0x20);", "prediction": "0;\n        phentsize = parser.readHalf(buffer, 0x20);\n        phnum = parser.readHalf(buffer, 0x22);\n        shentsize = 0;\n        shnum = 0;\n        shstrndx = 0;\n    }\n\n    public Elf32Header(final ElfParser parser, final Elf.Header header) throws IOException {\n        this(header.bigEndian, parser);\n    }\n\n    public Elf32Header(final ElfParser parser, final Elf.Header header, final long index) throws IOException {\n        this(header.bigEndian", "first_line_groundtruth": "parser.readWord(buffer, 0x20);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");", "prediction": " libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, \"libraryPathElements\");\n            final List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);\n            final Iterator<String> libPathElementIt = libraryPathElements.iterator();\n            while (libPathElementIt.hasNext()) {\n                final String libPath = libPathElementIt.next();\n                if (folder.getPath().equals(libPath)) {\n                    libPathElementIt.remove();\n                    break;\n                }\n            }\n            libraryPathElements.add(0, folder.getPath", "first_line_groundtruth": "pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");", "first_line_prediction": " libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, \"libraryPathElements\");", "match": 0}
{"groundtruth": "makeElements = ShareReflectUtil.findMethod(dexPathList,\n                    \"makePathElements\", List.class, File.class, List.class);", "prediction": " addNativeLibraryDirectoryMethod = ShareReflectUtil.findMethod(dexPathList, \"addNativeLibraryDirectory\", File.class);\n            addNativeLibraryDirectoryMethod.invoke(dexPathList, newLibDirs.toArray(new File[0]));\n        }\n    }\n\n    private static final class V25 {\n        private static void install(ClassLoader classLoader, File folder)  throws Throwable {\n            final Field pathListField = ShareReflectUtil.findField(classLoader, \"pathList\");\n            final Object dexPathList = pathListField.get(classLoader);\n\n            final Field nativeLibraryDirectories = ShareReflectUtil", "first_line_groundtruth": "makeElements = ShareReflectUtil.findMethod(dexPathList,", "first_line_prediction": " addNativeLibraryDirectoryMethod = ShareReflectUtil.findMethod(dexPathList, \"addNativeLibraryDirectory\", File.class);", "match": 0}
{"groundtruth": "= parser.readHalf(buffer, 0x2A);", "prediction": " = parser.readHalf(buffer, 0x24);\n        phnum = parser.readHalf(buffer, 0x26);\n        shentsize = parser.readHalf(buffer, 0x28);\n        shnum = parser.readHalf(buffer, 0x2A);\n        shstrndx = parser.readHalf(buffer, 0x2C);\n    }\n\n    public Elf32Header(final ElfParser parser, final Elf.Header header) throws IOException {\n        this(header.bigEndian, parser);\n    }\n\n    public Elf32Header(final", "first_line_groundtruth": "= parser.readHalf(buffer, 0x2A);", "first_line_prediction": " = parser.readHalf(buffer, 0x24);", "match": 0}
{"groundtruth": "= parser.readHalf(buffer, 0x2E);", "prediction": " = parser.readHalf(buffer, 0x2E);\n        shnum = parser.readHalf(buffer, 0x30);\n        shstrndx = parser.readHalf(buffer, 0x32);\n    }\n\n    @Override\n    public Elf.SectionHeader getSectionHeader(final int index) throws IOException {\n        return new Section32Header(parser, this, index);\n    }\n\n    @Override\n    public Elf.ProgramHeader getProgramHeader(final int index) throws IOException {\n        return new Program32Header(parser, this, index);\n    }", "first_line_groundtruth": "= parser.readHalf(buffer, 0x2E);", "first_line_prediction": " = parser.readHalf(buffer, 0x2E);", "match": 0}
{"groundtruth": "parser.readLong(buffer, 0x20);", "prediction": " parser.readWord(buffer, 0x1C);\n        shoff = parser.readWord(buffer, 0x20);\n        phentsize = parser.readHalf(buffer, 0x2A);\n        phnum = parser.readHalf(buffer, 0x2C);\n        shentsize = parser.readHalf(buffer, 0x2E);\n        shnum = parser.readHalf(buffer, 0x30);\n        shstrndx = parser.readHalf(buffer, 0x32);\n    }\n\n    public Elf64Header(", "first_line_groundtruth": "parser.readLong(buffer, 0x20);", "first_line_prediction": " parser.readWord(buffer, 0x1C);", "match": 0}
{"groundtruth": "parser.readLong(buffer, baseOffset + 0x28);", "prediction": " parser.readLong(buffer, baseOffset + 0x18);\n        flags = parser.readWord(buffer, baseOffset + 0x20);\n        align = parser.readWord(buffer, baseOffset + 0x24);\n    }", "first_line_groundtruth": "parser.readLong(buffer, baseOffset + 0x28);", "first_line_prediction": " parser.readLong(buffer, baseOffset + 0x18);", "match": 0}
{"groundtruth": "= parser.readHalf(buffer, 0x36);", "prediction": " = parser.readHalf(buffer, 0x30);\n        phnum = parser.readHalf(buffer, 0x32);\n        shentsize = parser.readHalf(buffer, 0x34);\n        shnum = parser.readHalf(buffer, 0x36);\n        shstrndx = parser.readHalf(buffer, 0x38);\n    }\n\n    public Elf64Header(final ElfParser parser, final Elf.Header header) throws IOException {\n        this(header.bigEndian, parser);\n    }\n\n    public Elf64Header(final", "first_line_groundtruth": "= parser.readHalf(buffer, 0x36);", "first_line_prediction": " = parser.readHalf(buffer, 0x30);", "match": 0}
{"groundtruth": "parser.readWord(buffer, baseOffset + 0x8);", "prediction": "0;\n        memsz = parser.readWord(buffer, baseOffset + 0x8);\n        flags = parser.readWord(buffer, baseOffset + 0xC);\n        align = parser.readWord(buffer, baseOffset + 0x10);\n    }", "first_line_groundtruth": "parser.readWord(buffer, baseOffset + 0x8);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "offset = parser.readLong(buffer, baseOffset + 0x8);", "prediction": " offset = parser.readWord(buffer, baseOffset + 0x4);\n         vaddr = parser.readWord(buffer, baseOffset + 0x8);\n         paddr = parser.readWord(buffer, baseOffset + 0x10);\n         filesz = parser.readWord(buffer, baseOffset + 0x18);\n         memsz = parser.readWord(buffer, baseOffset + 0x20);\n         flags = parser.readWord(buffer, baseOffset + 0x28);\n         align = parser.readWord(buffer, baseOffset", "first_line_groundtruth": "offset = parser.readLong(buffer, baseOffset + 0x8);", "first_line_prediction": " offset = parser.readWord(buffer, baseOffset + 0x4);", "match": 0}
{"groundtruth": "= parser.readWord(buffer, baseOffset + 0x14);", "prediction": " = parser.readWord(buffer, baseOffset + 0xC);\n        flags  = parser.readWord(buffer, baseOffset + 0x10);\n        align  = parser.readWord(buffer, baseOffset + 0x14);\n    }", "first_line_groundtruth": "= parser.readWord(buffer, baseOffset + 0x14);", "first_line_prediction": " = parser.readWord(buffer, baseOffset + 0xC);", "match": 0}
{"groundtruth": "offset = parser.readWord(buffer, baseOffset + 0x4);", "prediction": " offset = parser.readWord(buffer, baseOffset + 0x4);\n         vaddr = parser.readWord(buffer, baseOffset + 0x8);\n         memsz = parser.readWord(buffer, baseOffset + 0xC);\n         flags = parser.readWord(buffer, baseOffset + 0x10);\n         align = parser.readWord(buffer, baseOffset + 0x14);\n    }", "first_line_groundtruth": "offset = parser.readWord(buffer, baseOffset + 0x4);", "first_line_prediction": " offset = parser.readWord(buffer, baseOffset + 0x4);", "match": 0}
{"groundtruth": "= StartupMode.fromString(properties.get(\"scan.startup.mode\"));", "prediction": " = StartupMode.valueOf(properties.get(\"scan.startup.mode\"));\n    this.transactionalIdPrefix = properties.get(\"transactional.id.prefix\");\n    this.deliveryGuarantee = properties.get(\"delivery.guarantee\");\n    this.properties = properties;\n  }\n\n  public String getId() {\n    return id;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getBootstrapServers() {\n    return bootstrapServers;\n  }\n\n  public String getTopic() {\n    return topic;\n  }\n\n  public StartupMode getStartupMode() {\n    return startupMode;", "first_line_groundtruth": "= StartupMode.fromString(properties.get(\"scan.startup.mode\"));", "first_line_prediction": " = StartupMode.valueOf(properties.get(\"scan.startup.mode\"));", "match": 0}
{"groundtruth": "(streamConfig.transactionalIdPrefix())\n            .setKafkaProducerConfig(toProperties(streamConfig.kafkaProperties()))\n            .build();", "prediction": "(streamConfig.transactionalIdPrefix())\n             .setProperties(toProperties(streamConfig.kafkaProperties()))\n             .build();\n\n    return new DecodableStreamSinkImpl<>(delegate);\n  }\n\n  private static Properties toProperties(Map<String, String> map) {\n    Properties p = new Properties();\n\n    for (Map.Entry<String, String> entry : map.entrySet()) {\n      p.setProperty(entry.getKey(), entry.getValue());\n    }\n\n    return p;\n  }", "first_line_groundtruth": "(streamConfig.transactionalIdPrefix())", "first_line_prediction": "(streamConfig.transactionalIdPrefix())", "match": 1}
{"groundtruth": ".subscribe(Collections.singleton(testEnvironment.topicFor(name)));", "prediction": ".subscribe(Collections.singletonList(name));\n    return new DecodableStreamImpl(name, consumer);\n  }\n\n  /**\n   * Returns a stream for the given name, with the given configuration.\n   *\n   * @param name The name of the stream.\n   * @param config The configuration for the stream.\n   */\n  public DecodableStream<String> stream(String name, StreamConfiguration config) {\n    KafkaConsumer<String, String> consumer =\n        new KafkaConsumer<String, String>(consumerProperties(testEnvironment.bootstrapServers()));\n    consumer.subscribe(Collections.singletonList(name));\n    return new Decodable", "first_line_groundtruth": ".subscribe(Collections.singleton(testEnvironment.topicFor(name)));", "first_line_prediction": ".subscribe(Collections.singletonList(name));", "match": 0}
{"groundtruth": "setTopics(streamConfig.topic())\n            .setProperties(toProperties(streamConfig.kafkaProperties()))\n            .setValueOnlyDeserializer(deserializationSchema);", "prediction": "setGroupId(streamConfig.groupId())\n             .setStartingOffsets(OffsetsInitializer.earliest())\n             .setCommitOffsetsOnCheckpoints(true)\n             .setCommitOffsetsOnCheckpointFailure(true)\n             .setCommitOffsetsOnClose(true)\n             .setTransactionalIdPrefix(streamConfig.transactionalIdPrefix())\n             .setKafkaConsumerConfig(toProperties(streamConfig.kafkaProperties()))\n             .setDeserializationSchema(deserializationSchema);\n\n    if (startupMode == StartupMode.EARLY) {\n      builder.setStartupMode(KafkaSource.StartupMode.EARLY);\n    } else if (startup", "first_line_groundtruth": "setTopics(streamConfig.topic())", "first_line_prediction": "setGroupId(streamConfig.groupId())", "match": 0}
{"groundtruth": "((DecodableSourceSplitImpl) obj).getDelegate());", "prediction": "obj.getDelegate());\n  }\n\n  @Override\n  public DecodableSourceSplit deserialize(int version, byte[] serialized) throws IOException {\n    return new DecodableSourceSplitImpl(delegate.deserialize(version, serialized));\n  }", "first_line_groundtruth": "((DecodableSourceSplitImpl) obj).getDelegate());", "first_line_prediction": "obj.getDelegate());", "match": 0}
{"groundtruth": "producerProperties(testEnvironment.bootstrapServers()));", "prediction": "\n            testEnvironment.getProducerProperties(),\n            testEnvironment.getProducerProperties().getProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));\n    this.streams = new HashMap<>();\n    this.executorService = Executors.newCachedThreadPool();\n  }\n\n  /**\n   * Creates a new testing context, using the given {@link TestEnvironment}.\n   *\n   * @param bootstrapServers The Kafka bootstrap servers to use.\n   * @param streams The streams to use.\n   */\n  public PipelineTestContext(String bootstrapServers, Map<String, StreamConfiguration> streams) {\n    this(new TestEnvironment(bootstrapServers, streams", "first_line_groundtruth": "producerProperties(testEnvironment.bootstrapServers()));", "first_line_prediction": "", "match": 0}
{"groundtruth": ".setKafkaProducerConfig(toProperties(streamConfig.kafkaProperties()))\n            .build();", "prediction": " .setProperties(toProperties(streamConfig.kafkaProperties()))\n             .build();\n\n    return new DecodableStreamSinkImpl<>(delegate);\n  }\n\n  private static Properties toProperties(Map<String, String> map) {\n    Properties p = new Properties();\n\n    for (Map.Entry<String, String> entry : map.entrySet()) {\n      p.setProperty(entry.getKey(), entry.getValue());\n    }\n\n    return p;\n  }", "first_line_groundtruth": ".setKafkaProducerConfig(toProperties(streamConfig.kafkaProperties()))", "first_line_prediction": " .setProperties(toProperties(streamConfig.kafkaProperties()))", "match": 0}
{"groundtruth": "(testEnvironment.topicFor(streamName), streamRecord.value()));", "prediction": "\n                  (testEnvironment.topicFor(streamName), streamRecord.key(), streamRecord.value()));\n      try {\n        sent.get();\n      } catch (InterruptedException | ExecutionException e) {\n        throw new RuntimeException(\"Couldn't send record to Kafka\", e);\n      }\n    }\n\n    @Override\n    public Future<StreamRecord<String>> takeOne() {\n      return take(1).thenApply(records -> records.get(0));\n    }\n\n    @Override\n    public Future<List<StreamRecord<String>>> take(int n) {\n      CompletableFuture<List<StreamRecord<String>>> future = new CompletableFuture<>();", "first_line_groundtruth": "(testEnvironment.topicFor(streamName), streamRecord.value()));", "first_line_prediction": "", "match": 0}
{"groundtruth": "toProperties(streamConfig.kafkaProperties()))\n            .setValueOnlyDeserializer(deserializationSchema);", "prediction": "toProperties(streamConfig.kafkaProperties()))\n             .setGroupId(streamConfig.groupId())\n             .setStartingOffsets(OffsetsInitializer.earliest());\n\n    if (startupMode == StartupMode.EARLIEST) {\n      builder.setStartingOffsets(OffsetsInitializer.earliest());\n    } else if (startupMode == StartupMode.LATEST) {\n      builder.setStartingOffsets(OffsetsInitializer.latest());\n    } else if (startupMode == StartupMode.TIMESTAMP) {\n      builder.setStartingOffsets(OffsetsInitializer.timestamp(streamConfig.timestamp()));\n    }\n\n    KafkaSource<T> source = builder.", "first_line_groundtruth": "toProperties(streamConfig.kafkaProperties()))", "first_line_prediction": "toProperties(streamConfig.kafkaProperties()))", "match": 1}
{"groundtruth": "if (streamConfig.startupMode() != null) {", "prediction": " if (startupMode != null) {\n       builder.setStartupMode(startupMode);\n     }", "first_line_groundtruth": "if (streamConfig.startupMode() != null) {", "first_line_prediction": " if (startupMode != null) {", "match": 0}
{"groundtruth": "tbApikeyDAO.useOnece(key);", "prediction": " // \u8c03\u7528\u63a5\u53e3\n        genImage(message, key, send);\n    }", "first_line_groundtruth": "tbApikeyDAO.useOnece(key);", "first_line_prediction": " // \u8c03\u7528\u63a5\u53e3", "match": 0}
{"groundtruth": "Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");", "prediction": " Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        }\n                    }\n                } else {\n                    if (actionInfo.isHasParameterType()) {\n                        Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameterType()).get(\"PG_COUNT\");\n                        localPage.setTotal(Long.parseLong(cnt.toString()));\n                    } else {\n                        Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql", "first_line_groundtruth": "Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");", "first_line_prediction": " Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");", "match": 0}
{"groundtruth": "() != null && methodInfo.getArgs().length > 0) {", "prediction": "() != null && methodInfo.getArgs().length > 0) {\n                        methodInfo.resolveSql(0, this.toStr(methodInfo.getActionInfo().getBatchSql()));\n                        methodInfo.resolveParameter(0, this.toStr(methodInfo.getActionInfo().getBatchParameter()));\n                    }\n                    break;\n                }\n            }\n        }\n\n        Object result = null;\n        try {\n            result = method.invoke(methodInvocation.getThis(), args);\n        } catch (Exception e) {\n            log.error(\"method==>name:{},actionType:{}\", methodInfo.getName(), methodInfo", "first_line_groundtruth": "() != null && methodInfo.getArgs().length > 0) {", "first_line_prediction": "() != null && methodInfo.getArgs().length > 0) {", "match": 1}
{"groundtruth": "), actionInfo.getParameter(), actionInfo.getParameterType()).get(\"PG_COUNT\");", "prediction": "), (Object[]) methodInfo.getArgs()[actionInfo.getParameterTypeIndex()]).get(\"PG_COUNT\");\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        } else {\n                            Object cnt = jdbcTemplate.queryForObject(dialect.getCountSql(sql), new Object[]{}, Long.class);\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        }\n                    }\n                } else {\n                    if (actionInfo.isHasParameterType()) {\n                        Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), (Object[]) methodInfo", "first_line_groundtruth": "), actionInfo.getParameter(), actionInfo.getParameterType()).get(\"PG_COUNT\");", "first_line_prediction": "), (Object[]) methodInfo.getArgs()[actionInfo.getParameterTypeIndex()]).get(\"PG_COUNT\");", "match": 0}
{"groundtruth": "cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");", "prediction": " cnt = jdbcTemplate.queryForObject(dialect.getCountSql(sql), actionInfo.getParameter(), actionInfo.getParameterType());\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                        }\n                    }\n                } else {\n                    if (actionInfo.isHasParameterType()) {\n                        Object cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameterType()).get(\"PG_COUNT\");\n                        localPage.setTotal(Long.parseLong(cnt.toString()));\n                    } else {\n                        Object cnt = jdbcTemplate.queryForObject(dialect.getCountSql(", "first_line_groundtruth": "cnt = jdbcTemplate.queryForMap(dialect.getCountSql(sql), actionInfo.getParameter()).get(\"PG_COUNT\");", "first_line_prediction": " cnt = jdbcTemplate.queryForObject(dialect.getCountSql(sql), actionInfo.getParameter(), actionInfo.getParameterType());", "match": 0}
{"groundtruth": ".debug(\"finish sql==>{", "prediction": ".debug(\"after sql==>{}\", this.toStr(methodInfo.getActionInfo().getBatchSql()));\n        log.debug(\"after parameters==>{}\", this.toStr(methodInfo.getActionInfo().getBatchParameter()));\n\n        //\u6267\u884c\u539f\u751f\u65b9\u6cd5\n        Object result = methodInvocation.proceed();\n\n        //\u903b\u8f91\u5904\u7406\uff08\u6838\u5fc3\u65b9\u6cd5\uff1a\u4e3b\u8981\u5904\u7406\u8fd4\u56de\u503c\uff09\n        if (this.interceptors != null && this.interceptors.size() > 0) {\n            for (IInterceptor interceptor : this.interceptors) {\n                if (interceptor.supportMethod(methodInfo)) {\n                    interceptor.afterPrepare(method", "first_line_groundtruth": ".debug(\"finish sql==>{", "first_line_prediction": ".debug(\"after sql==>{}\", this.toStr(methodInfo.getActionInfo().getBatchSql()));", "match": 0}
{"groundtruth": "cpuPattern.matcher(location.fileContent());", "prediction": " cpuPattern.matcher(location.getFileContent()); cpuMatcher.find(); ) {\n\t\t\tresult.add(new Match(\n\t\t\t\t\tcpuMatcher.group(\"container\"),\n\t\t\t\t\tcpuMatcher.group(\"cluster\"),\n\t\t\t\t\tcpuMatcher.group(\"cpu\"),\n\t\t\t\t\tK8sResourceType.Cpu\n\t\t\t));\n\t\t}", "first_line_groundtruth": "cpuPattern.matcher(location.fileContent());", "first_line_prediction": " cpuPattern.matcher(location.getFileContent()); cpuMatcher.find(); ) {", "match": 0}
{"groundtruth": "pages = page.getPages();", "prediction": "size = page.getSize();\n            this.startRow = page.getStartRow();\n            this.endRow = page.getEndRow();\n            this.pages = page.getPages();\n\n            this.prePage = page.getPrePage();\n            this.nextPage = page.getNextPage();\n\n            this.isFirstPage = page.isIsFirstPage();\n            this.isLastPage = page.isIsLastPage();\n            this.hasPreviousPage = page.isHasPreviousPage();\n            this.hasNextPage = page.isHasNextPage();\n\n            this.navigatePages = navigatePages;\n            this.", "first_line_groundtruth": "pages = page.getPages();", "first_line_prediction": "size = page.getSize();", "match": 0}
{"groundtruth": "] = this.actionInfo.getParameter();", "prediction": "][0] = this.actionInfo.getBatchParameter().get(0);\n                    }\n                } else {\n                    this.args[this.actionInfo.getParameterIndex()] = this.actionInfo.getBatchParameter();\n                }\n            }\n        }\n    }\n\n    public void resolveParameter(int i, Object[] parameter) {\n        if (this.actionInfo != null) {\n            if (parameter == null || parameter.length == 0) {\n                throw new RuntimeException(\"parameter\u4e0d\u80fd\u4e3a\u7a7a\");\n            }\n            this.actionInfo.getBatchParameter().set(i, parameter);\n\n            if (this.actionInfo.", "first_line_groundtruth": "] = this.actionInfo.getParameter();", "first_line_prediction": "][0] = this.actionInfo.getBatchParameter().get(0);", "match": 0}
{"groundtruth": "MethodActionInfo actionInfo = methodInfo.getActionInfo();", "prediction": " methodInfo.setPage(localPage);\n             methodInfo.setDialect(Dialect.getDialect(methodInfo.getDialect()));\n             methodInfo.setPageHelper(PageHelper.getPageHelper(methodInfo.getDialect()));\n             methodInfo.setPageHelperDialect(PageHelper.getPageHelperDialect(methodInfo.getDialect()));\n             methodInfo.setPageHelperDialectPrefix(PageHelper.getPageHelperDialectPrefix(methodInfo.getDialect()));\n             methodInfo.setPageHelperDialectSuffix(PageHelper.getPageHelperDialectSuffix(methodInfo.getDialect()));\n             methodInfo.setPageHelperDialectType(Page", "first_line_groundtruth": "MethodActionInfo actionInfo = methodInfo.getActionInfo();", "first_line_prediction": " methodInfo.setPage(localPage);", "match": 0}
{"groundtruth": ".debug(\"method==>name:{", "prediction": ".info(\"\u6267\u884cSQL\u5f00\u59cb\u65f6\u95f4\uff1a{}\", LocalDateTime.now());\n        log.info(\"\u539f\u59cbSQL\uff1a{}\", Arrays.toString(methodInfo.getActionInfo().getBatchSql()));\n\n        for (IInterceptor interceptor : interceptors) {\n            if (interceptor.supportMethod(methodInfo)) {\n                interceptor.beforePrepare(methodInfo, jdbcTemplate);\n            }\n        }\n\n        Object result = methodInvocation.proceed();\n\n        for (IInterceptor interceptor : interceptors) {\n            if (interceptor.supportMethod(methodInfo)) {\n                result = interceptor.beforeFinish(result, methodInfo, jdbcTemplate);\n            }\n        }\n\n       ", "first_line_groundtruth": ".debug(\"method==>name:{", "first_line_prediction": ".info(\"\u6267\u884cSQL\u5f00\u59cb\u65f6\u95f4\uff1a{}\", LocalDateTime.now());", "match": 0}
{"groundtruth": "queryForMap(dialect.getCountSql(sql), actionInfo.getParameter(), actionInfo.getParameterType()).get(\"PG_COUNT\");", "prediction": "query(dialect.getCountSql(sql), (PreparedStatementSetter) methodInfo.getArgs()[actionInfo.getParameterTypeIndex()], new ResultSetExtractor<Map>() {\n                                @Override\n                                public Map extractData(ResultSet rs) throws SQLException, DataAccessException {\n                                    while (rs.next()) {\n                                        Map<String, Object> map = new HashMap<>();\n                                        map.put(\"PG_COUNT\", rs.getLong(\"PG_COUNT\"));\n                                        return map;\n                                    }\n                                    return new HashMap<>();\n                                }\n                            })\n                                    .get(\"PG_COUNT\");\n                            localPage.setTotal(Long.parseLong(cnt.toString()));\n                       ", "first_line_groundtruth": "queryForMap(dialect.getCountSql(sql), actionInfo.getParameter(), actionInfo.getParameterType()).get(\"PG_COUNT\");", "first_line_prediction": "query(dialect.getCountSql(sql), (PreparedStatementSetter) methodInfo.getArgs()[actionInfo.getParameterTypeIndex()], new ResultSetExtractor<Map>() {", "match": 0}
{"groundtruth": "Repository repository : gitLabRepositoryApi.findRepositories()) {", "prediction": "Repository repository : gitLabRepositoryApi.findRepositories()) {\n\t\t\tfor (Location location : gitLabRepositoryApi.readLocationsFrom(repository)) {\n\t\t\t\tSystem.out.println(location);\n\t\t\t}\n\t\t}\n\t\treturn List.of();", "first_line_groundtruth": "Repository repository : gitLabRepositoryApi.findRepositories()) {", "first_line_prediction": "Repository repository : gitLabRepositoryApi.findRepositories()) {", "match": 1}
{"groundtruth": "String sql = actionInfo.getSql();", "prediction": " if (dialect.isPagination()) {\n                if (actionInfo.getActionType() == MethodType.QUERY) {\n                    actionInfo.setActionType(MethodType.SELECT);\n                    actionInfo.setSql(dialect.getPaginationSql(actionInfo.getSql(), localPage));\n                } else if (actionInfo.getActionType() == MethodType.UPDATE) {\n                    actionInfo.setActionType(MethodType.UPDATE_BATCH);\n                    actionInfo.setSql(dialect.getPaginationSql(actionInfo.getSql(), localPage));\n                } else if (actionInfo.getActionType() == MethodType.DELETE) {", "first_line_groundtruth": "String sql = actionInfo.getSql();", "first_line_prediction": " if (dialect.isPagination()) {", "match": 0}
{"groundtruth": "() && methodInfo.getActionInfo().isReturnIsList()) {", "prediction": "()) {\n                sql = dialect.getCountSql(sql);\n            }\n\n            //\u67e5\u8be2\u5206\u9875\n            if (localPage.isPage()) {\n                sql = dialect.getPageSql(sql, localPage.getPageNum(), localPage.getPageSize());\n            }\n\n            //\u67e5\u8be2\u6392\u5e8f\n            if (localPage.isOrderBy()) {\n                sql = dialect.getOrderBySql(sql, localPage.getOrderBy());\n            }\n\n            //\u67e5\u8be2\u67e5\u8be2\u6761\u4ef6\n            if (localPage.isWhere()) {\n                sql = dialect.getWhereSql(sql, localPage.getWhere());\n            }\n\n            //\u67e5\u8be2\u67e5\u8be2\u6761\u4ef6\n            if (local", "first_line_groundtruth": "() && methodInfo.getActionInfo().isReturnIsList()) {", "first_line_prediction": "()) {", "match": 0}
{"groundtruth": "sql), (PreparedStatementSetter) methodInfo.getArgs()[actionInfo.getParameterIndex()], new ResultSetExtractor<Map>() {", "prediction": "sql), actionInfo.getParameterType(), actionInfo.getParameterValue(), new ResultSetExtractor<Object>() {\n                            @Override\n                            public Object extractData(ResultSet rs) throws SQLException, DataAccessException {\n                                return rs.next() ? rs.getObject(1) : null;\n                            }\n                        });\n                        localPage.setTotal(Long.parseLong(cnt.toString()));\n                    } else {\n                        Object cnt = jdbcTemplate.queryForObject(dialect.getCountSql(sql), actionInfo.getParameterValue(), new ResultSetExtractor<Object>() {\n                            @Override\n                            public Object extractData(ResultSet rs) throws SQLException, DataAccessException {", "first_line_groundtruth": "sql), (PreparedStatementSetter) methodInfo.getArgs()[actionInfo.getParameterIndex()], new ResultSetExtractor<Map>() {", "first_line_prediction": "sql), actionInfo.getParameterType(), actionInfo.getParameterValue(), new ResultSetExtractor<Object>() {", "match": 0}
{"groundtruth": "(methodInfo.getActionInfo().getBatchParameter()));", "prediction": "(methodInfo.getActionInfo().getBatchParameters()));\n\n        // \u8c03\u7528", "first_line_groundtruth": "(methodInfo.getActionInfo().getBatchParameter()));", "first_line_prediction": "(methodInfo.getActionInfo().getBatchParameters()));", "match": 0}
{"groundtruth": "page.getStartRow() + 1;", "prediction": "1 + page.getStartRow();\n                this.endRow = this.startRow + page.size() - 1;\n            }\n            this.prePage = page.getPrePage();\n            this.nextPage = page.getNextPage();\n            this.isFirstPage = page.isIsFirstPage();\n            this.isLastPage = page.isIsLastPage();\n            this.hasPreviousPage = page.isHasPreviousPage();\n            this.hasNextPage = page.isHasNextPage();\n            this.navigatePages = navigatePages;\n            this.navigatepageNums = page.getNavigatepageNums", "first_line_groundtruth": "page.getStartRow() + 1;", "first_line_prediction": "1 + page.getStartRow();", "match": 0}
{"groundtruth": "if (methodInfo.getArgs() != null && methodInfo.getArgs().length > 0) {", "prediction": " //methodInfo.resolveSql(i, this.parserMulti(methodInfo.getActionInfo().getBatchSql()[i], null));\n                     //methodInfo.resolveParameter(i, this.parserMulti(methodInfo.getActionInfo().getBatchParameter()[i], null));\n                }\n            }\n        }\n\n        //\u6267\u884c\u539f\u751f\u65b9\u6cd5\n        Object result = methodInvocation.proceed();\n\n        //\u903b\u8f91\u5904\u7406\uff08\u6838\u5fc3\u65b9\u6cd5\uff1a\u4e3b\u8981\u5904\u7406\u8fd4\u56de\u503c\uff09\n        if (this.interceptors != null && this.interceptors.size() > 0) {\n            for (IInterceptor interceptor : this.interceptors) {\n                if", "first_line_groundtruth": "if (methodInfo.getArgs() != null && methodInfo.getArgs().length > 0) {", "first_line_prediction": " //methodInfo.resolveSql(i, this.parserMulti(methodInfo.getActionInfo().getBatchSql()[i], null));", "match": 0}
{"groundtruth": "toStr(methodInfo.getActionInfo().getBatchSql()));", "prediction": "getOriginSql(methodInfo));\n\n        for (IInterceptor interceptor : interceptors) {\n            if (interceptor.supportMethod(methodInfo)) {\n                interceptor.beforePrepare(methodInfo, jdbcTemplate);\n            }\n        }\n\n        Object result = methodInvocation.proceed();\n\n        for (IInterceptor interceptor : interceptors) {\n            if (interceptor.supportMethod(methodInfo)) {\n                result = interceptor.beforeFinish(result, methodInfo, jdbcTemplate);\n            }\n        }\n\n        return result;\n    }\n\n    private String getOriginSql(MethodInvocationInfo methodInfo) {\n        return Arrays.toString(methodInfo.getAction", "first_line_groundtruth": "toStr(methodInfo.getActionInfo().getBatchSql()));", "first_line_prediction": "getOriginSql(methodInfo));", "match": 0}
{"groundtruth": "methodInfo.resolveSql(sql);", "prediction": " //\u8bbe\u7f6e\u5206\u9875\u53c2\u6570\n            actionInfo.setSql(sql);\n            actionInfo.setHasParameter(true);\n            actionInfo.setParameterIndex(localPage.getPageNum() - 1);\n            actionInfo.setParameter(localPage.getPageSize());\n            actionInfo.setParameterType(Integer.class);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void afterPrepare(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n\n    }\n\n    @Override\n    public void afterExecute(final MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n\n    }", "first_line_groundtruth": "methodInfo.resolveSql(sql);", "first_line_prediction": " //\u8bbe\u7f6e\u5206\u9875\u53c2\u6570", "match": 0}
{"groundtruth": "String.format(\"%s-- key: %s\\n\", prefix, keyType.getTypeName()));", "prediction": "String.format(\"%s-- key: %s (containsNull = %b)\\n\", prefix, keyType.getTypeName(),\n\t\t\tkeyType.containsNull()));\n\t\tbuilder.append(String.format(\"%s-- value: %s (containsNull = %b)\\n\", prefix, valueType.getTypeName(),\n\t\t\tvalueType.containsNull()));", "first_line_groundtruth": "String.format(\"%s-- key: %s\\n\", prefix, keyType.getTypeName()));", "first_line_prediction": "String.format(\"%s-- key: %s (containsNull = %b)\\n\", prefix, keyType.getTypeName(),", "match": 0}
{"groundtruth": "equalsTo.setRightExpression(this.tenantLineHandler.getTenantId());", "prediction": " ExpressionList expressionList = new ExpressionList();\n             expressionList.getExpressions().add(equalsTo);\n             MultiExpressionList multiExpressionList = new MultiExpressionList();\n             multiExpressionList.getExpressions().add(expressionList);\n             insert.setDuplicateUpdateExpressionList(multiExpressionList);\n        }\n        this.processInsertBody(insert.getItemsList(), insert.getTable().getName(), tenantIdColumn);\n    }\n\n    @Override\n    protected void processUpdate(Update update, int index, String sql, Object obj) {\n        if (this.tenantLineHandler.ignoreTable(update.getTable().getName())) {\n           ", "first_line_groundtruth": "equalsTo.setRightExpression(this.tenantLineHandler.getTenantId());", "first_line_prediction": " ExpressionList expressionList = new ExpressionList();", "match": 0}
{"groundtruth": "DataType.buildFormattedString(elementType, nextPrefix, builder);", "prediction": "\telementType.buildFormattedString(nextPrefix, builder);", "first_line_groundtruth": "DataType.buildFormattedString(elementType, nextPrefix, builder);", "first_line_prediction": "\telementType.buildFormattedString(nextPrefix, builder);", "match": 0}
{"groundtruth": "new EqualsTo(this.getAliasColumn(table), this.tenantLineHandler.getTenantId());", "prediction": " this.andExpression(table, where, whereSegment);\n    }\n\n    /**\n     * \u6784\u5efa", "first_line_groundtruth": "new EqualsTo(this.getAliasColumn(table), this.tenantLineHandler.getTenantId());", "first_line_prediction": " this.andExpression(table, where, whereSegment);", "match": 0}
{"groundtruth": "DataType.buildFormattedString(dataType, nextPrefix, builder);", "prediction": "\tdataType.buildFormattedString(nextPrefix, builder);", "first_line_groundtruth": "DataType.buildFormattedString(dataType, nextPrefix, builder);", "first_line_prediction": "\tdataType.buildFormattedString(nextPrefix, builder);", "match": 0}
{"groundtruth": "(methodInfo.getActionInfo().isReturnIsList()) {", "prediction": " (methodInfo.getActionInfo().isReturnIsList()) {\n                if (result instanceof Collection) {\n                    Collection<Object> list = (Collection<Object>) result;\n                    if (localPage.isCount()) {\n                        list.add(localPage.getTotal());\n                    }\n                    if (localPage.isPage()) {\n                        list.add(localPage.getPageNum());\n                        list.add(localPage.getPageSize());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            PageHelper.clearPage();\n            throw e;\n        }\n\n        return result;\n    }", "first_line_groundtruth": "(methodInfo.getActionInfo().isReturnIsList()) {", "first_line_prediction": " (methodInfo.getActionInfo().isReturnIsList()) {", "match": 0}
{"groundtruth": "prefix, valueType.getTypeName(),\n\t\t\t\tvalueContainsNull));", "prediction": " prefix, valueType.getTypeName(),\n\t\t\tvalueContainsNull));\n\t\tDataType.buildFormattedString(valueType, nextPrefix, builder);", "first_line_groundtruth": "prefix, valueType.getTypeName(),", "first_line_prediction": " prefix, valueType.getTypeName(),", "match": 0}
{"groundtruth": "(new SelectExpressionItem(new Column(this.tenantLineHandler.getTenantIdColumn())));", "prediction": "(new SelectExpressionItem(new StringValue(StringPool.ASTERISK)));\n    }\n\n    /**\n     * \u5904\u7406 select \u8bed\u53e5\n     *\n     * @param selectBody SelectBody\n     * @param whereSegment where \u6761\u4ef6\n     */\n    protected void processSelectBody(SelectBody selectBody, String whereSegment) {\n        if (selectBody instanceof PlainSelect) {\n            this.processPlainSelect((PlainSelect) selectBody, whereSegment);\n        } else if (selectBody instanceof WithItem) {\n            this.processWithItem((WithItem) selectBody, whereSegment);\n        }\n    }\n\n    /**\n     *", "first_line_groundtruth": "(new SelectExpressionItem(new Column(this.tenantLineHandler.getTenantIdColumn())));", "first_line_prediction": "(new SelectExpressionItem(new StringValue(StringPool.ASTERISK)));", "match": 0}
{"groundtruth": ".format(\"%s-- element: %s (containsNull = %b)\\n\", prefix, elementType.getTypeName(),\n\t\t\t\tcontainsNull));", "prediction": ".format(\"%s-- %s: %s (containsNull = %b)\\n\", prefix, elementType.getTypeName(),\n\t\t\t\tcontainsNull));\n\t\telementType.buildFormattedString(nextPrefix, builder);", "first_line_groundtruth": ".format(\"%s-- element: %s (containsNull = %b)\\n\", prefix, elementType.getTypeName(),", "first_line_prediction": ".format(\"%s-- %s: %s (containsNull = %b)\\n\", prefix, elementType.getTypeName(),", "match": 0}
{"groundtruth": "(!dbHero.getId().equals(heroToUpdate.getId())) {", "prediction": " (dbHero == null) {\n            throw new NotFoundException();\n        }\n        heroToUpdate.setId(dbHero.getId());\n        heroToUpdate.setXp(dbHero.getXp());\n        return this.heroRepository.save(heroToUpdate);\n    }\n\n    public void delete(Long id) {\n        Hero dbHero = this.findById(id);\n        if  (dbHero == null) {\n            throw new NotFoundException();\n        }\n        this.heroRepository.delete(dbHero);\n    }", "first_line_groundtruth": "(!dbHero.getId().equals(heroToUpdate.getId())) {", "first_line_prediction": " (dbHero == null) {", "match": 0}
{"groundtruth": "dataType.getTypeName(), nullable, metadata.toString()));", "prediction": "\tdataType.getTypeName(), nullable, metadata.toString()));\n\t\tdataType.buildFormattedString(nextPrefix, builder);", "first_line_groundtruth": "dataType.getTypeName(), nullable, metadata.toString()));", "first_line_prediction": "\tdataType.getTypeName(), nullable, metadata.toString()));", "match": 0}
{"groundtruth": "dbHero.getXp() + 2);", "prediction": "dbHero.getXp() + 1);\n        this.heroRepository.save(dbHero);\n    }", "first_line_groundtruth": "dbHero.getXp() + 2);", "first_line_prediction": "dbHero.getXp() + 1);", "match": 0}
{"groundtruth": "DataType.buildFormattedString(keyType, nextPrefix, builder);", "prediction": "\tvalueType.buildFormattedString(nextPrefix, builder);", "first_line_groundtruth": "DataType.buildFormattedString(keyType, nextPrefix, builder);", "first_line_prediction": "\tvalueType.buildFormattedString(nextPrefix, builder);", "match": 0}
{"groundtruth": ").equals(heroToUpdate.getId())) {", "prediction": " ).equals(heroToUpdate.getId( ))) {\n            throw new BusinessException(\"Hero ID does not match\");\n        }\n        heroToUpdate.setXp(dbHero.getXp( ));\n        return this.heroRepository.save(heroToUpdate);\n    }\n\n    public void delete(Long id) {\n        this.heroRepository.deleteById(id);\n    }", "first_line_groundtruth": ").equals(heroToUpdate.getId())) {", "first_line_prediction": " ).equals(heroToUpdate.getId( ))) {", "match": 0}
{"groundtruth": "Insets insets = UIUtils.getInsets(\"Toast.shadowInsets\", new Insets(0, 0, 6, 6));", "prediction": " return new DropShadowBorder(color, FlatUIUtils.getUIInsets(\"Toast.shadowInsets\", new Insets(5, 5, 5, 5)), 0.5f);\n    }\n\n    protected void installIconComponent(JComponent c) {\n        iconComponent = new JPanel();\n        iconComponent.setOpaque(false);\n        iconComponent.setLayout(new BorderLayout());\n        iconComponent.setBorder(createDefaultBorder());\n        iconComponent.setAlignmentX(Component.LEFT_ALIGNMENT);\n        iconComponent.setAlignmentY(Component.TOP_ALIGNMENT);\n        iconComponent.setFocusable(false", "first_line_groundtruth": "Insets insets = UIUtils.getInsets(\"Toast.shadowInsets\", new Insets(0, 0, 6, 6));", "first_line_prediction": " return new DropShadowBorder(color, FlatUIUtils.getUIInsets(\"Toast.shadowInsets\", new Insets(5, 5, 5, 5)), 0.5f);", "match": 0}
{"groundtruth": "UIUtils.getString(prefix + \".effectAlignment\", \"left\");", "prediction": " FlatUIUtils.getUIString(prefix + \".effectAlignment\", \"left\");\n    }\n\n    @Override\n    protected void uninstallDefaults(JPanel p) {\n        super.uninstallDefaults(p);\n        iconTextGap = 0;\n        closeButtonGap = 0;\n        minimumWidth = 0;\n        maximumWidth = -1;\n        arc = 0;\n        outlineWidth = 0;\n        outlineColor = null;\n        margin = null;\n        showCloseButton = false;\n        closeIconColor = null;\n        closeButtonIcon = null;\n        useEffect = false;\n        effectColor = null;\n        effect", "first_line_groundtruth": "UIUtils.getString(prefix + \".effectAlignment\", \"left\");", "first_line_prediction": " FlatUIUtils.getUIString(prefix + \".effectAlignment\", \"left\");", "match": 0}
{"groundtruth": "notificationHolder.clearHold();", "prediction": " for (Map.Entry<Location, List<NotificationAnimation>> set : lists.entrySet()) {\n            for (int i = 0; i < set.getValue().size(); i++) {\n                NotificationAnimation an = set.getValue().get(i);\n                if (an != null) {\n                    an.cancel();\n                }\n            }\n        }\n        notificationHolder.clear();\n    }\n\n    public void clear(Location location) {\n        List<NotificationAnimation> list = lists.get(location);\n        if (list != null) {\n            for (int i = 0; i < list.size(); i++)", "first_line_groundtruth": "notificationHolder.clearHold();", "first_line_prediction": " for (Map.Entry<Location, List<NotificationAnimation>> set : lists.entrySet()) {", "match": 0}
{"groundtruth": "UIUtils.getInsets(\"Toast.frameInsets\", new Insets(10, 10, 10, 10));", "prediction": " new Insets(FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0));\n            horizontalSpace = FlatUIUtils.getUIInt(\"Toast.horizontalSpace\", 0);\n            animationMove = FlatUIUtils.getUIInt(\"Toast.animationMove\", 0);\n            top = location.equals(Location.TOP_LEFT) || location.equals(Location.", "first_line_groundtruth": "UIUtils.getInsets(\"Toast.frameInsets\", new Insets(10, 10, 10, 10));", "first_line_prediction": " new Insets(FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0), FlatUIUtils.getUIInt(\"Toast.frameInsets\", 0));", "match": 0}
{"groundtruth": "notificationHolder.removeHold(hold);", "prediction": " hold.close();\n            }\n        } else {\n            notificationAnimation.close();\n        }\n    }\n\n    public void close(NotificationAnimation notificationAnimation) {\n        notificationClose(notificationAnimation);\n    }\n\n    public void close(NotificationAnimation notificationAnimation, long duration) {\n        notificationClose(notificationAnimation);\n    }\n\n    public void close(NotificationAnimation notificationAnimation, long duration, Consumer<NotificationAnimation> callback) {\n        notificationClose(notificationAnimation);\n        if (callback != null) {\n            callback.accept(notificationAnimation);\n        }\n    }\n\n    public void close(NotificationAnimation notificationAnimation, Consumer<NotificationAnimation> callback)", "first_line_groundtruth": "notificationHolder.removeHold(hold);", "first_line_prediction": " hold.close();", "match": 0}
{"groundtruth": "toastNotificationPanel.setDialog(window);", "prediction": "\n            \n            if (location == Location.TOP_LEFT || location == Location.BOTTOM_LEFT) {\n                top = true;\n            }\n            if (location == Location.TOP_RIGHT || location == Location.BOTTOM_RIGHT) {\n                top = false;\n            }\n            if (location == Location.TOP_CENTER || location == Location.BOTTOM_CENTER) {\n                top = true;\n            }\n            if (location == Location.TOP_LEFT || location == Location.TOP_CENTER || location == Location.TOP_RIGHT) {\n                horizontalSpace = 0;\n            }\n            if (location == Location.BOTTOM_LEFT", "first_line_groundtruth": "toastNotificationPanel.setDialog(window);", "first_line_prediction": "", "match": 0}
{"groundtruth": "+ \".closeIcon\", UIUtils.createIcon(\"raven/toast/svg/close.svg\", closeIconColor, 0.75f));", "prediction": " + \".closeButtonIcon\", \"icons/close.png\");\n        useEffect = FlatUIUtils.getUIBoolean(prefix + \".useEffect\", true);\n        effectColor = FlatUIUtils.getUIColor(prefix + \".effectColor\", new Color(255, 255, 255, 100));\n        effectWidth = FlatUIUtils.getUIFloat(prefix + \".effectWidth\", 1.0f);\n        effectOpacity = FlatUIUtils.getUIFloat(prefix + \".effectOpacity\", 0.5f);\n        effectAlignment = FlatUIUtils.get", "first_line_groundtruth": "+ \".closeIcon\", UIUtils.createIcon(\"raven/toast/svg/close.svg\", closeIconColor, 0.75f));", "first_line_prediction": " + \".closeButtonIcon\", \"icons/close.png\");", "match": 0}
{"groundtruth": "hold = notificationHolder.getHold(notificationAnimation.getLocation());", "prediction": " an = notificationHolder.remove(notificationAnimation);\n        if (an != null) {\n            an.close();\n        }\n    }\n\n    public void close(NotificationAnimation notificationAnimation) {\n        notificationClose(notificationAnimation);\n    }\n\n    public void close(NotificationAnimation notificationAnimation, long duration) {\n        notificationClose(notificationAnimation);\n        notificationAnimation.start();\n    }\n\n    public void close(NotificationAnimation notificationAnimation, long duration, Consumer<NotificationAnimation> onClose) {\n        notificationClose(notificationAnimation);\n        notificationAnimation.start(duration, onClose);\n    }\n\n    public void close(NotificationAnimation notificationAnimation, long duration", "first_line_groundtruth": "hold = notificationHolder.getHold(notificationAnimation.getLocation());", "first_line_prediction": " an = notificationHolder.remove(notificationAnimation);", "match": 0}
{"groundtruth": "UIUtils.getInsets(prefix + \".margin\", new Insets(8, 8, 8, 8));", "prediction": " FlatUIUtils.getUIInsets(prefix + \".margin\", new Insets(8, 8, 8, 8));\n        closeButtonIcon = FlatUIUtils.getUIIcon(prefix + \".closeButtonIcon\", null);\n        showCloseButton = FlatUIUtils.getUIBoolean(prefix + \".showCloseButton\", true);\n        closeIconColor = FlatUIUtils.getUIColor(prefix + \".closeIconColor\", \"Component.focusColor\");\n        useEffect = FlatUIUtils.getUIBoolean(prefix + \".useEffect\", true);\n        effectColor = FlatUIUtils.getUIColor(", "first_line_groundtruth": "UIUtils.getInsets(prefix + \".margin\", new Insets(8, 8, 8, 8));", "first_line_prediction": " FlatUIUtils.getUIInsets(prefix + \".margin\", new Insets(8, 8, 8, 8));", "match": 0}
{"groundtruth": "notificationHolder.clearHold(location);", "prediction": " List<NotificationAnimation> list = lists.get(location);\n         if (list != null) {\n             for (int i = 0; i < list.size(); i++) {\n                 NotificationAnimation an = list.get(i);\n                 if (an != null) {\n                     an.close();\n                 }\n             }\n         }\n    }\n\n    public void clear(Type type) {\n        for (Map.Entry<Location, List<NotificationAnimation>> set : lists.entrySet()) {\n            for (int i = 0; i < set.getValue().size(); i++) {\n                NotificationAnimation an = set.", "first_line_groundtruth": "notificationHolder.clearHold(location);", "first_line_prediction": " List<NotificationAnimation> list = lists.get(location);", "match": 0}
{"groundtruth": "toastNotificationPanel.set(type, message);", "prediction": " toastNotificationPanel.setDuration(FlatUIUtils.getUIInt(\"Toast.duration\", 2500));\n        toastNotificationPanel.setEffectWidth(FlatUIUtils.getUIFloat(\"Toast.effectWidth\", 0.5f));\n        toastNotificationPanel.setEffectOpacity(FlatUIUtils.getUIFloat(\"Toast.effectOpacity\", 0.2f));\n        toastNotificationPanel.setEffectAlignment(FlatUIUtils.getUIString(\"Toast.effectAlignment\", \"left\"));\n        toastNotificationPanel.setEffectColor(FlatUIUtils.getUIColor(\"Toast.effectColor\"));", "first_line_groundtruth": "toastNotificationPanel.set(type, message);", "first_line_prediction": " toastNotificationPanel.setDuration(FlatUIUtils.getUIInt(\"Toast.duration\", 2500));", "match": 0}
{"groundtruth": "lowerLeft.getY()).transform(new GenericShape(originalPoints)).getPoints();", "prediction": "0).transform(originalPoints);\n    }", "first_line_groundtruth": "lowerLeft.getY()).transform(new GenericShape(originalPoints)).getPoints();", "first_line_prediction": "0).transform(originalPoints);", "match": 0}
{"groundtruth": "notificationHolder.hold(notificationAnimation);", "prediction": " return false;\n        }\n    }\n\n    public void show(Notification notification) {\n        show(notification, FlatUIUtils.getUIInt(\"Toast.duration\", 2500));\n    }\n\n    public void show(Notification notification, long duration) {\n        initStart(new NotificationAnimation(notification, duration), duration);\n    }\n\n    public void show(Notification notification, Consumer<Notification> onShow) {\n        show(notification, FlatUIUtils.getUIInt(\"Toast.duration\", 2500), onShow);\n    }\n\n    public void show(Notification notification, long duration, Consumer<Notification>", "first_line_groundtruth": "notificationHolder.hold(notificationAnimation);", "first_line_prediction": " return false;", "match": 0}
{"groundtruth": "lowerLeft.getX(), lowerLeft.getY()).transform(new GenericShape(originalPoints)).getPoints();", "prediction": "lowerLeft.getX(), lowerLeft.getY()).transform(originalPoints);\n    }", "first_line_groundtruth": "lowerLeft.getX(), lowerLeft.getY()).transform(new GenericShape(originalPoints)).getPoints();", "first_line_prediction": "lowerLeft.getX(), lowerLeft.getY()).transform(originalPoints);", "match": 0}
{"groundtruth": "y][x].isSet()) {", "prediction": "y][x].isOn()) {\n                    System.out.print(SET);\n                } else {\n                    System.out.print(UNSET);\n                }\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        TextCanvas canvas = new TextCanvas(10, 10);\n        Shape shape = new Shape(Arrays.asList(\n                new Point(0, 0),\n                new Point(1, 1),\n                new Point(2, 2),\n                new Point(3, 3),\n                new Point(4, 4", "first_line_groundtruth": "y][x].isSet()) {", "first_line_prediction": "y][x].isOn()) {", "match": 0}
{"groundtruth": "(point.getX(), point.getY());", "prediction": "Pixel(point);\n        }\n    }\n\n    public void show() {\n        for (Pixel[] row : pixels) {\n            for (Pixel pixel : row) {\n                System.out.print(pixel.isOn() ? SET : UNSET);\n            }\n            System.out.println();\n        }\n    }\n\n    private void setPixel(Point point) {\n        if (point.getX() < 0 || point.getX() >= width || point.getY() < 0 || point.getY() >= height) {\n            return;\n        }\n        pixels[point.getY()][point.getX()].setOn(true", "first_line_groundtruth": "(point.getX(), point.getY());", "first_line_prediction": "Pixel(point);", "match": 0}
{"groundtruth": "getX() * factor, point.getY() * factor + 50, factor, factor);", "prediction": "getX() - factor, point.getY() - factor, factor * 2, factor * 2);\n            }\n        }\n    }", "first_line_groundtruth": "getX() * factor, point.getY() * factor + 50, factor, factor);", "first_line_prediction": "getX() - factor, point.getY() - factor, factor * 2, factor * 2);", "match": 0}
{"groundtruth": ".drawOval(point.getX() * factor, point.getY() * factor + 50, factor, factor);", "prediction": ".setColor(Color.BLACK);\n                g.drawLine(point.getX(), point.getY(), point.getX(), point.getY());\n            }\n        }\n    }", "first_line_groundtruth": ".drawOval(point.getX() * factor, point.getY() * factor + 50, factor, factor);", "first_line_prediction": ".setColor(Color.BLACK);", "match": 0}
{"groundtruth": "param.put(item.getValue(), hParam);", "prediction": " param.put(item.getValue(),hParam);\n            }\n        }\n        paramLocal.set(param);\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        paramLocal.remove();\n    }", "first_line_groundtruth": "param.put(item.getValue(), hParam);", "first_line_prediction": " param.put(item.getValue(),hParam);", "match": 0}
{"groundtruth": ", this.parserMulti(methodInfo.getActionInfo().getBatchSql()[i], null));", "prediction": ", this.changeTable(methodInfo.getActionInfo().getBatchSql()[i]));\n            }\n        }\n    }\n\n    @Override\n    public Object beforeFinish(Object result, MethodInvocationInfo methodInfo, JdbcTemplate jdbcTemplate) {\n        if (methodInfo.getActionInfo() != null && methodInfo.getActionInfo().getBatchSql() != null) {\n            for (int i = 0; i < methodInfo.getActionInfo().getBatchSql().length; i++) {\n                methodInfo.resolveSql(i, this.changeTable(methodInfo.getActionInfo().getBatchSql()[i]));\n            }", "first_line_groundtruth": ", this.parserMulti(methodInfo.getActionInfo().getBatchSql()[i], null));", "first_line_prediction": ", this.changeTable(methodInfo.getActionInfo().getBatchSql()[i]));", "match": 0}
{"groundtruth": "GrayParamHolder.putValues(param);", "prediction": " //\u5c06", "first_line_groundtruth": "GrayParamHolder.putValues(param);", "first_line_prediction": " //\u5c06", "match": 0}
{"groundtruth": "ExceptionUtils.mpe(\"Failed to process multiple-table update, please exclude the tableName or statementId\");", "prediction": " ExceptionUtils.createException(\"insert sql must have select or itemsList\");\n        }\n    }\n\n    @Override\n    protected void processUpdate(Update update, int index, String sql, Object obj) {\n        if (this.tenantLineHandler.ignoreTable(update.getTable().getName())) {\n            // \u8fc7\u6ee4\u9000\u51fa\u6267\u884c\n            return;\n        }\n        List<Column> columns = update.getColumns();\n        if (CollectionUtils.isEmpty(columns)) {\n            // \u9488\u5bf9\u4e0d\u7ed9\u5217\u540d\u7684update \u4e0d\u5904\u7406\n            return;\n        }\n        String tenantIdColumn = this.tenantLineHandler.getTenantIdColumn();\n       ", "first_line_groundtruth": "ExceptionUtils.mpe(\"Failed to process multiple-table update, please exclude the tableName or statementId\");", "first_line_prediction": " ExceptionUtils.createException(\"insert sql must have select or itemsList\");", "match": 0}
{"groundtruth": "= GrayUtil.isGrayRequest();", "prediction": " = GrayUtil.isGrayRequest();\n                grayGroup=GrayUtil.getGrayGroup();\n            }\n            if (isGrayRequest) {\n                return instances.stream()\n                        .filter(instance -> Objects.equals(grayGroup, instance.getMetadata().get(GrayscaleConstant.GRAY_GROUP)))\n                        .collect(Collectors.toList());\n            } else {\n                return instances;\n            }\n        }\n    }\n\n    @Override\n    public void initWithNiwsConfig(IClientConfig clientConfig) {\n        // TODO Auto-generated method stub\n\n    }", "first_line_groundtruth": "= GrayUtil.isGrayRequest();", "first_line_prediction": " = GrayUtil.isGrayRequest();", "match": 0}
{"groundtruth": "if(GrayUtil.isGrayPod()){", "prediction": " paramLocal.set(paramMap);\n        }\n        return paramMap;\n    }\n\n    /**\n     * \u8bbe\u7f6e\u5355\u4e2a\u53c2\u6570\u503c\n     *\n     * @param key\n     * @param value\n     */\n    public static void setValue(String key, String value) {\n        Map<String, String> paramMap = GrayParamHolder.paramLocal.get();\n        if (Objects.nonNull(paramMap)) {\n            paramMap.put(key, value);\n        }\n    }\n\n    /**\n     * \u8bbe\u7f6e\u6240\u6709\u53c2\u6570\n     *\n     * @param paramMap\n     */\n    public static void putValues(Map<String, String>", "first_line_groundtruth": "if(GrayUtil.isGrayPod()){", "first_line_prediction": " paramLocal.set(paramMap);", "match": 0}
{"groundtruth": "info(\"\u5f53\u524d\u5b9e\u4f8b\u76d1\u542cmq\u961f\u5217\u7684\u72b6\u6001:{", "prediction": "info(\"\u5f53\u524d\u5b9e\u4f8b", "first_line_groundtruth": "info(\"\u5f53\u524d\u5b9e\u4f8b\u76d1\u542cmq\u961f\u5217\u7684\u72b6\u6001:{", "first_line_prediction": "info(\"\u5f53\u524d\u5b9e\u4f8b", "match": 0}
{"groundtruth": "=GrayUtil.requestGroup();", "prediction": "=GrayUtil.getGrayGroup();\n                }\n            }\n            if (isGrayRequest) {\n                return instances.stream()\n                        .filter(instance -> Objects.equals(grayGroup, instance.getMetadata().get(GrayscaleConstant.GRAY_GROUP)))\n                        .collect(Collectors.toList());\n            } else {\n                return instances;\n            }\n        }\n    }\n\n    @Override\n    public void initWithNiwsConfig(IClientConfig clientConfig) {\n        // TODO Auto-generated method stub\n\n    }", "first_line_groundtruth": "=GrayUtil.requestGroup();", "first_line_prediction": "=GrayUtil.getGrayGroup();", "match": 0}
{"groundtruth": "String> attributes= GrayParamHolder.getGrayMap();", "prediction": "String> paramMap = GrayParamHolder.paramLocal.get();\n        if (Objects.nonNull(paramMap) && !paramMap.isEmpty()) {\n            return Objects.equals(paramMap.get(GrayscaleConstant.HEADER_KEY), GrayscaleConstant.HEADER_VALUE);\n        }\n        return false;\n    }", "first_line_groundtruth": "String> attributes= GrayParamHolder.getGrayMap();", "first_line_prediction": "String> paramMap = GrayParamHolder.paramLocal.get();", "match": 0}
{"groundtruth": "getName() + \"\u7070\u5ea6\u73af\u5883\u53d8\u66f4:\" + listenerStateEnum.getValue());", "prediction": "getName() + \"\u76d1\u542c\u4e8b\u4ef6\uff1a{}\", listenerStateEnum.getValue());\n        if (listenerStateEnum.equals(currentState)) {\n            log.info(this.getClass().getName() + \"\u76d1\u542c\u4e8b\u4ef6\uff1a{} \u65e0\u9700\u5904\u7406\", listenerStateEnum.getValue());\n            return;\n        }\n        currentState = listenerStateEnum;\n        if (listenerStateEnum.equals(ListenerStateEnum.PRODUCTION)) {\n            initConsumerProduction();\n        } else {\n            initConsumerGray();\n        }\n    }\n\n    /**\n     * \u8ba2\u9605\u6d88\u606f\n     *\n     * @param subscribes \u8ba2\u9605\u4fe1\u606f\n     */\n    public", "first_line_groundtruth": "getName() + \"\u7070\u5ea6\u73af\u5883\u53d8\u66f4:\" + listenerStateEnum.getValue());", "first_line_prediction": "getName() + \"\u76d1\u542c\u4e8b\u4ef6\uff1a{}\", listenerStateEnum.getValue());", "match": 0}
{"groundtruth": "getHeader(item.getValue());", "prediction": "getHeader(item.getValue());\n            if (StringUtils.hasText(hParam)) {\n                param.put(item.getValue(),hParam);\n            }\n        }\n        GrayParamHolder.putValue(GrayscaleConstant.GRAY_PARAM_KEY,param);\n        return true;\n    }", "first_line_groundtruth": "getHeader(item.getValue());", "first_line_prediction": "getHeader(item.getValue());", "match": 1}
{"groundtruth": "(\"\u5f53\u524d\u5b9e\u4f8b\u662f\u5426\u4e3a\u7070\u5ea6\u73af\u5883\uff1a{", "prediction": "(\"\u5f53\u524d\u5b9e\u4f8b\u662f\u5426\u4e3a", "first_line_groundtruth": "(\"\u5f53\u524d\u5b9e\u4f8b\u662f\u5426\u4e3a\u7070\u5ea6\u73af\u5883\uff1a{", "first_line_prediction": "(\"\u5f53\u524d\u5b9e\u4f8b\u662f\u5426\u4e3a", "match": 0}
{"groundtruth": "RtcMsg.createContractTransaction(\n                        subject, application, content, to));", "prediction": " new RtcMsg(subject, application, content, to));\n    }\n\n    public static RawRtcMsg createContractTransaction(\n            String subject, String application, String content, String to) {\n        return new RawRtcMsg(\n                new RtcMsg(subject, application, content, to));\n    }\n\n    public List<RlpType> asRlpValues(Sign.SignatureData signatureData) {\n        return transaction.asRlpValues(signatureData);\n    }", "first_line_groundtruth": "RtcMsg.createContractTransaction(", "first_line_prediction": " new RtcMsg(subject, application, content, to));", "match": 0}
{"groundtruth": "rawTransaction = RawTelegram.createTransaction(nonce, gasPrice, gasLimit, contractAddress, value, data);", "prediction": " rawTelegram = RawTelegram.createTransaction(nonce, gasPrice, gasLimit, contractAddress, value, data);\n        String telegram = TelegramEncoder.encode(rawTelegram);\n        String telegramHash = Numeric.toHexString(rawTelegram.getTelegramHash());\n        String telegramHashHex = Numeric.toHexStringNoPrefix(rawTelegram.getTelegramHash());\n        String telegramHashHexPrefix = Numeric.toHexStringNoPrefix(rawTelegram.getTelegramHash());\n        String telegramHashHexPrefixPrefix = Numeric.toHexStringNoPrefix(rawTelegram.getTelegramHash());\n        String telegramHashHexPrefix", "first_line_groundtruth": "rawTransaction = RawTelegram.createTransaction(nonce, gasPrice, gasLimit, contractAddress, value, data);", "first_line_prediction": " rawTelegram = RawTelegram.createTransaction(nonce, gasPrice, gasLimit, contractAddress, value, data);", "match": 0}
{"groundtruth": "(config.getValueOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING\n        && !(recordValue instanceof String)) {", "prediction": " (config.getValueOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING\n         && ! (recordValue instanceof String)) {\n      recordValue = objectMapper.writeValueAsString(recordValue);\n    } else if (!(recordValue instanceof String)) {\n      recordValue = Util.convertJsonNodeToYTree((JsonNode) recordValue);\n    }\n\n    return YTree.node(recordValue);\n  }\n\n  protected void writeRecord(ApiServiceTransaction transaction, SinkRecord record)\n      throws Exception {\n    var recordKey = convertRecordKeyToNode(record);\n    var recordValue = convertRecordValueToNode(record);\n\n    var", "first_line_groundtruth": "(config.getValueOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING", "first_line_prediction": " (config.getValueOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING", "match": 0}
{"groundtruth": "Util.parseHumanReadableDuration(value.toString());", "prediction": " Util.parseHumanReadableDuration(value.toString());\n      } catch (Exception ex) {\n        throw new ConfigException(name, value, ex.toString());\n      }\n    }\n  }\n\n  public static class ValidUpperString extends ConfigDef.Validator {\n\n    private final Set<String> validValues;\n\n    public ValidUpperString(String... validValues) {\n      this.validValues = new HashSet<>(Arrays.asList(validValues));\n    }\n\n    @Override\n    public void ensureValid(String name, Object value) {\n      if (!validValues.contains(value.toString().toUpperCase())) {\n        throw new ConfigException", "first_line_groundtruth": "Util.parseHumanReadableDuration(value.toString());", "first_line_prediction": " Util.parseHumanReadableDuration(value.toString());", "match": 0}
{"groundtruth": "if (usuario.getPassword().equals(Senha)) {", "prediction": " if (usuario.getEmail().equals(Email) && usuario.getSenha().equals(Senha)) {\n                             senhaCorreta = true;\n                             break;\n                         }\n                    }\n                    if (senhaCorreta) {\n                        // Se a senha for correta, redirecionar para a tela principal\n                        RedirecionaLogin();\n                    } else {\n                        // Se a senha for incorreta, mostrar um toast de erro\n                        Toast.makeText(Login.this, \"Senha incorreta\", Toast.LENGTH_SHORT).show();\n                    }\n                } else {\n                    // Se o usu\u00e1rio", "first_line_groundtruth": "if (usuario.getPassword().equals(Senha)) {", "first_line_prediction": " if (usuario.getEmail().equals(Email) && usuario.getSenha().equals(Senha)) {", "match": 0}
{"groundtruth": "(config.getKeyOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING\n        && !(recordKey instanceof String)) {", "prediction": " (recordKey instanceof JsonNode) {\n      return convertJsonNodeToYTree((JsonNode) recordKey);\n    } else {\n      throw new DataException(\"Record key must be a JsonNode\");\n    }\n  }\n\n  protected Object convertRecordValue(SinkRecord record) throws Exception {\n    if (record.value() == null) {\n      return JsonNodeFactory.instance.nullNode();\n    }\n    if (record.value() instanceof String) {\n      return record.value();\n    }\n\n    byte[] jsonBytes = JSON_CONVERTER.fromConnectData(record.topic(), record.valueSchema(),\n        record.value());\n    var", "first_line_groundtruth": "(config.getKeyOutputFormat() == BaseTableWriterConfig.OutputFormat.STRING", "first_line_prediction": " (recordKey instanceof JsonNode) {", "match": 0}
{"groundtruth": "RA_atual = usuario.getMatricula();", "prediction": "setUsuario(usuario);\n                            return;\n                        }\n                    }\n                    // Senha incorreta, mostrar um toast de erro\n                    Toast.makeText(Login.this, \"Senha incorreta\", Toast.LENGTH_SHORT).show();\n                } else {\n                    // Usu\u00e1rio n\u00e3o encontrado, mostrar um toast de erro\n                    Toast.makeText(Login.this, \"Usu\u00e1rio n\u00e3o encontrado\", Toast.LENGTH_SHORT).show();\n                }\n            }\n\n            @Override\n            public void onCancelled(@NonNull DatabaseError error) {\n                Toast.makeText(Login.this, \"Erro ao verificar se o email", "first_line_groundtruth": "RA_atual = usuario.getMatricula();", "first_line_prediction": "setUsuario(usuario);", "match": 0}
{"groundtruth": "!twilioService.validatePhoneNumber(from)) {", "prediction": "twilioService.validatePhoneNumber(from)) {\n            logger.info(\"Phone number \" + from + \" is valid.\");\n            return chatGPTService.processMessage(body);\n        } else {\n            logger.info(\"Phone number \" + from + \" is not valid.\");\n            throw new RestException(\"Invalid phone number\", 400);\n        }\n    }", "first_line_groundtruth": "!twilioService.validatePhoneNumber(from)) {", "first_line_prediction": "twilioService.validatePhoneNumber(from)) {", "match": 0}
{"groundtruth": "array.validateShape(String.valueOf(key), expectedShape);", "prediction": " if (array != null) {\n             array.validateShape(expectedShape);\n         }\n         return array;\n     }", "first_line_groundtruth": "array.validateShape(String.valueOf(key), expectedShape);", "first_line_prediction": " if (array != null) {", "match": 0}
{"groundtruth": "String response = chatGPTService.askQuestion(message);", "prediction": " ChatMessage chatMessage = chatGPTService.sentChatMessage(message);\n             return chatMessage;\n        }\n\n        else {\n            throw new RestException(\"message is empty. Please enter a message to send to the ChatGPTService.\");\n        }\n\n    }", "first_line_groundtruth": "String response = chatGPTService.askQuestion(message);", "first_line_prediction": " ChatMessage chatMessage = chatGPTService.sentChatMessage(message);", "match": 0}
{"groundtruth": "myJavaInputStream    = in.getInputStream();", "prediction": " myJavaInputStream  = in.getInputStream();\n             myJavaOutputStream = out.getOutputStream();\n             myPythonInputStream = in.getOutputStream();\n             myPythonOutputStream = out.getInputStream();\n        }", "first_line_groundtruth": "myJavaInputStream    = in.getInputStream();", "first_line_prediction": " myJavaInputStream  = in.getInputStream();", "match": 0}
{"groundtruth": "chatGPTService.askQuestion(body);", "prediction": " chatGPTService.askQuestion(body);\n        logger.info(\"Response from ChatGPTService: \" + response);\n        return response;\n    }", "first_line_groundtruth": "chatGPTService.askQuestion(body);", "first_line_prediction": " chatGPTService.askQuestion(body);", "match": 0}
{"groundtruth": "myPythonInputStream  = out.getInputStream();", "prediction": " myPythonInputStream  = in.getOutputStream();\n            myPythonOutputStream = out.getInputStream();\n        }\n\n        /**\n         * Close the pipe.\n         */\n        public void close()\n        {\n            myIsClosed = true;\n        }\n\n        /**\n         * Get the input stream.\n         *\n         * @return The input stream.\n         */\n        public InputStream getInputStream()\n        {\n            return myJavaInputStream;\n        }\n\n        /**\n         * Get the output stream.\n         *\n         * @return The output stream.\n         */\n        public OutputStream getOutputStream()\n        {\n            return myJavaOutputStream;\n        }\n\n        /**\n         * Get the input", "first_line_groundtruth": "myPythonInputStream  = out.getInputStream();", "first_line_prediction": " myPythonInputStream  = in.getOutputStream();", "match": 0}
{"groundtruth": "chatGPTConfiguration.setApiKey(ConfigUtils.obfuscateApiKey(chatGPTConfiguration.getApiKey()));", "prediction": " return chatGPTConfiguration;\n        }\n    }\n\n    /** This method sends a message to the ChatGPTService */\n    @Get(\"/message\")\n    public ChatMessage sendMessage(@QueryValue String message) {\n        ChatMessage chatMessage = new ChatMessage();\n        chatMessage.setMessage(message);\n        chatMessage.setResponse(chatGPTService.askQuestion(message));\n        return chatMessage;\n    }", "first_line_groundtruth": "chatGPTConfiguration.setApiKey(ConfigUtils.obfuscateApiKey(chatGPTConfiguration.getApiKey()));", "first_line_prediction": " return chatGPTConfiguration;", "match": 0}
{"groundtruth": "= StringUtil.stackTraceToString(t);", "prediction": " = t;\n                arg     = \"Exception: \" + t;\n            }\n\n            // Do the invoke\n            try {\n                result = python.invoke(arg);\n            }\n            catch (Throwable t) {\n                result  = t;\n                arg     = \"Exception: \" + t;\n            }\n\n            // Print the result\n            System.out.println(arg + \" -> \" + result);\n        }\n\n        System.out.println();\n        System.out.println(\"Done!\");\n        System.out.println();\n\n        python.close();\n    }", "first_line_groundtruth": "= StringUtil.stackTraceToString(t);", "first_line_prediction": " = t;", "match": 0}
{"groundtruth": "(request.getTo());", "prediction": "(request.getFrom());\n\t\tresponse.setTo(request.getTo());", "first_line_groundtruth": "(request.getTo());", "first_line_prediction": "(request.getFrom());", "match": 0}
{"groundtruth": "responseFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);", "prediction": " currentFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);", "first_line_groundtruth": "responseFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);", "first_line_prediction": " currentFrame = FrameMapper.mapFromBytesToInstance(currentFrameBytes);", "match": 0}
{"groundtruth": "UDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(incomingRequestPacket.getData());", "prediction": "\tUDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(incomingRequestPacket.getData());", "first_line_groundtruth": "UDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(incomingRequestPacket.getData());", "first_line_prediction": "\tUDPFrame currentFrame = FrameMapper.mapFromBytesToInstance(incomingRequestPacket.getData());", "match": 0}
{"groundtruth": ", List<UDPFrame>> completedRequestFrameList : map.findCompletedRequestsFrameLists())\n\t\t\t\t{", "prediction": ", List<UDPFrame>> pair : map.findCompletedRequestsFrameLists())\n\t\t\t\t{\n\t\t\t\t\tSocketAddress sender = pair.getKey();\n\t\t\t\t\tList<UDPFrame> frames = pair.getValue();", "first_line_groundtruth": ", List<UDPFrame>> completedRequestFrameList : map.findCompletedRequestsFrameLists())", "first_line_prediction": ", List<UDPFrame>> pair : map.findCompletedRequestsFrameLists())", "match": 0}
{"groundtruth": "sendResponseWithOverhead(responseBytes, response.getTo());", "prediction": "\tsendResponseWithOverhead(responseBytes);\n\t\t\telse\n\t\t\t\tsendResponseNoOverhead(responseBytes);\n\t\t}\n\t\tcatch (MappingException e)\n\t\t{\n\t\t\tlogger.log(Level.SEVERE, \"Failed to map response to bytes\", e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tlogger.log(Level.SEVERE, \"Failed to send response\", e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tlogger.log", "first_line_groundtruth": "sendResponseWithOverhead(responseBytes, response.getTo());", "first_line_prediction": "\tsendResponseWithOverhead(responseBytes);", "match": 0}
{"groundtruth": "return execute(api.getModel(modelId));", "prediction": " return execute(api.getModel(modelId)).data;\n    }\n\n    public Single<CompletionResult> complete(CompletionRequest request) {\n        return execute(api.complete(request));\n    }\n\n    public Single<ChatCompletionResult> chatComplete(ChatCompletionRequest request) {\n        return execute(api.chatComplete(request));\n    }\n\n    public Single<EditResult> edit(EditRequest request) {\n        return execute(api.edit(request));\n    }\n\n    public Single<EmbeddingResult> embed(EmbeddingRequest request) {\n        return execute(api.embed(request));\n    }\n\n    public Single<File>", "first_line_groundtruth": "return execute(api.getModel(modelId));", "first_line_prediction": " return execute(api.getModel(modelId)).data;", "match": 0}
{"groundtruth": "myByteList.clear();", "prediction": " myStream.write(myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN).putFloat(0, o));\n    }", "first_line_groundtruth": "myByteList.clear();", "first_line_prediction": " myStream.write(myFourByteBuffer.order(ByteOrder.LITTLE_ENDIAN).putFloat(0, o));", "match": 0}
{"groundtruth": "return execute(api.listModels()).data;", "prediction": " return api.listModels().execute().body();\n    }\n\n    public Model getModel(String modelId) {\n        return api.getModel(modelId).execute().body();\n    }\n\n    public Model createModel(Model model) {\n        return api.createModel(model).execute().body();\n    }\n\n    public Model updateModel(String modelId, Model model) {\n        return api.updateModel(modelId, model).execute().body();\n    }\n\n    public DeleteResult deleteModel(String modelId) {\n        return api.deleteModel(modelId).execute().body();\n    }\n\n    public List<Fine", "first_line_groundtruth": "return execute(api.listModels()).data;", "first_line_prediction": " return api.listModels().execute().body();", "match": 0}
{"groundtruth": "(myByteList.toArray());", "prediction": "(myByteList.array(), 0, myByteList.size());\n    }", "first_line_groundtruth": "(myByteList.toArray());", "first_line_prediction": "(myByteList.array(), 0, myByteList.size());", "match": 0}
{"groundtruth": "if (infoFilter.isStudentIdValid(studentId)) {", "prediction": " if (infoFilter.isStudentIdValid(studentId)) {\n                 this.studentId = studentId;\n             }\n        } catch (InvalidStudentIdException ex) {\n            throw ex;\n        }\n    }\n\n    public String getStudentClass() {\n        return studentClass;\n    }\n\n    public void setStudentClass(String studentClass) {\n        this.studentClass = studentClass;\n    }\n\n    public String getMajor() {\n        return major;\n    }\n\n    public void setMajor(String major) {\n        this.major = major;\n    }\n\n    public String getSchoolYear() {\n        return schoolYear;\n   ", "first_line_groundtruth": "if (infoFilter.isStudentIdValid(studentId)) {", "first_line_prediction": " if (infoFilter.isStudentIdValid(studentId)) {", "match": 0}
{"groundtruth": "PythonMinion.byValue(foo);", "prediction": "1234567890;\n            start = System.nanoTime();\n            for (int i=0; i < count; i++) {\n                python.invoke(\"len\", Integer.class, foo);\n            }\n            end = System.nanoTime();\n            System.out.println(\"  time(len(\" + foo + \")) = \" +\n                               ((end - start) / count / 1000) + \"us\");\n        }\n\n        // Close the connection\n        python.close();\n    }", "first_line_groundtruth": "PythonMinion.byValue(foo);", "first_line_prediction": "1234567890;", "match": 0}
{"groundtruth": "infoFilter.isPersonIdValid(id)) {", "prediction": "infoFilter.isPersonIdValid(id)) {\n                this.id = id;\n            }\n        } catch (InvalidPersonIdException e) {\n            throw e;\n        }\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) throws InvalidEmailException {\n        var infoFilter = new InfoFilterImp();\n        try {\n            if (infoFilter.isEmailValid(email)) {\n                this.email", "first_line_groundtruth": "infoFilter.isPersonIdValid(id)) {", "first_line_prediction": "infoFilter.isPersonIdValid(id)) {", "match": 1}
{"groundtruth": "python.invoke(\"len\", Integer.class, foo);", "prediction": " python.invoke(\"len\", Integer.class, foo);\n            }\n            long end = System.nanoTime();\n            System.out.println(\"  \" + count + \" calls in \" +\n                               (end - start) / 1000000 + \" ms\");\n        }\n\n        // Close the connection\n        python.close();\n    }", "first_line_groundtruth": "python.invoke(\"len\", Integer.class, foo);", "first_line_prediction": " python.invoke(\"len\", Integer.class, foo);", "match": 0}
{"groundtruth": "[]     shape   = {", "prediction": "       ndim    = rawData.data().getInt();\n                final int[]     shape   = new int[ndim];\n                for (int i = 0; i < ndim; i++) {\n                    shape[i] = rawData.data().getInt();\n                }\n\n                initArray(dtype, false, shape, null, rawData.data());\n            }\n            catch (ClassCastException e) {\n                throw new MalformedPickleException(\n                     \"Invalid arguments passed to numpy.fromstring: \" +\n                     \"expecting (data, dtype), got \" + tuple,\n                     e\n                 );\n            }\n            catch", "first_line_groundtruth": "[]     shape   = {", "first_line_prediction": "       ndim    = rawData.data().getInt();", "match": 0}
{"groundtruth": "if (subject.getKind().compareTo(\n                    comboSubjectType.getItemAt(i).toString()) == 0) {", "prediction": " if (comboSubjectType.getItemAt(i).equals(subject.getKind())) {\n                 comboSubjectType.setSelectedIndex(i);\n             }\n        }\n    }", "first_line_groundtruth": "if (subject.getKind().compareTo(", "first_line_prediction": " if (comboSubjectType.getItemAt(i).equals(subject.getKind())) {", "match": 0}
{"groundtruth": "python.invoke(\"len\", Integer.class, arg);", "prediction": " python.invoke(arg, \"upper\");\n            }\n            catch (Throwable t) {\n                result = StringUtil.stackTraceToString(t);\n            }\n            System.out.println(\"  \\\"\" + arg + \".upper()\\\" -> \" + result);\n        }\n\n        System.out.println();\n        System.out.println(\"Closing...\");\n        python.close();\n        System.out.println(\"Closed.\");\n    }", "first_line_groundtruth": "python.invoke(\"len\", Integer.class, arg);", "first_line_prediction": " python.invoke(arg, \"upper\");", "match": 0}
{"groundtruth": "txtMajor.setText(student.getMajor());", "prediction": "\n                \n            } else {\n                txtStudentId.setText(\"\");\n                txtFullName.setText(\"\");\n                var msg = \"Sinh vi\u00ean c\u1ea7n t\u00ecm kh\u00f4ng t\u1ed3n t\u1ea1i. Vui l\u00f2ng th\u1eed l\u1ea1i!\";\n                showMessage(msg);\n            }\n        }\n    }", "first_line_groundtruth": "txtMajor.setText(student.getMajor());", "first_line_prediction": "", "match": 0}
{"groundtruth": "System.out.println(\"[ \" + raiz.getElement() + \" ]\");", "prediction": " System.out.println(\"[ \"+raiz.getElement() + \" ]\");\n             preOrden(raiz.getLeftSon());\n             preOrden(raiz.getRightSon());\n        }\n    }\n\n    public void deleteNodo(int element, Nodo raiz, Nodo father) {\n        if (element == raiz.getElement()) {\n            if (father == null) {\n                setRoot(null);\n            } else {\n                if (element < father.getElement()) {\n                    father.setLeftSon(null);\n                } else {\n                    father.setRightSon(null);\n                }\n            }\n       ", "first_line_groundtruth": "System.out.println(\"[ \" + raiz.getElement() + \" ]\");", "first_line_prediction": " System.out.println(\"[ \"+raiz.getElement() + \" ]\");", "match": 0}
{"groundtruth": "o.getNoCheck(i));", "prediction": "o.get(i));\n        }\n\n        addNumpyArrayEnding(DType.Type.INT8, o);\n    }", "first_line_groundtruth": "o.getNoCheck(i));", "first_line_prediction": "o.get(i));", "match": 0}
{"groundtruth": "nodo.setRightSon(raiz.getRightSon());", "prediction": "\n                    } else {\n                        Nodo nodo = searchNodoToReplace(raiz.getRightSon());\n                        nodo.setRightSon(raiz.getRightSon());\n                    }\n                }\n            } else if (element < raiz.getElement()) {\n                deleteNodo(element, raiz.getLeftSon(), raiz);\n            } else {\n                deleteNodo(element, raiz.getRightSon(), raiz);\n            }\n        }\n    }\n\n    public boolean validateLeftSon(Nodo raiz) {\n        if (raiz == null) {\n            return false;\n        } else", "first_line_groundtruth": "nodo.setRightSon(raiz.getRightSon());", "first_line_prediction": "", "match": 0}
{"groundtruth": "subject.getKind().compareTo(\n                    comboSubjectType.getItemAt(i).toString()) == 0) {", "prediction": "comboSubjectType.getItemAt(i).equals(subject.getKind())) {\n                comboSubjectType.setSelectedIndex(i);\n                break;\n            }\n        }\n    }", "first_line_groundtruth": "subject.getKind().compareTo(", "first_line_prediction": "comboSubjectType.getItemAt(i).equals(subject.getKind())) {", "match": 0}
{"groundtruth": "myByteList.append(Float.toString(o).getBytes());", "prediction": " myByteList.append(MARK_V);\n         myByteList.append(Operations.FLOAT.code);\n         myByteList.append(Float.floatToRawIntBits(o));\n         write(myByteList.array());\n    }", "first_line_groundtruth": "myByteList.append(Float.toString(o).getBytes());", "first_line_prediction": " myByteList.append(MARK_V);", "match": 0}
{"groundtruth": "if (element == raiz.getElement()) {", "prediction": " if (element < raiz.getElement()) {\n                 if (raiz.getLeftSon() != null) {\n                     deleteNodo(element, raiz.getLeftSon(), raiz);\n                 }\n             } else if (element > raiz.getElement()) {\n                 if (raiz.getRightSon() != null) {\n                     deleteNodo(element, raiz.getRightSon(), raiz);\n                 }\n             } else {\n                 if (raiz.getLeftSon() == null && raiz.getRightSon() == null) {\n                     if (previousNode == null) {\n                         set", "first_line_groundtruth": "if (element == raiz.getElement()) {", "first_line_prediction": " if (element < raiz.getElement()) {", "match": 0}
{"groundtruth": "ect.getName() + \" tr\u01b0\u1edbc \u0111\u00f3.\";", "prediction": ".getSubjectName() + \" v\u00e0o l\u00fac \" + dateFormat.format(currentTime);\n                showMessage(msg);\n            } else {\n                registerings.add(r);\n                var msg = \"\u0110\u0103ng k\u00fd m\u00f4n h\u1ecdc \" + subj.getSubjectName() + \" th\u00e0nh c\u00f4ng!\";\n                showMessage(msg);\n            }\n        }\n    }\n\n    private void searchStudent() {\n        var checker = new InfoFilterImp();\n        var student = checker.searchStudent(registerings, txtStudentIdToSearch.getText());\n        if(student != null) {\n            this.student =", "first_line_groundtruth": "ect.getName() + \" tr\u01b0\u1edbc \u0111\u00f3.\";", "first_line_prediction": ".getSubjectName() + \" v\u00e0o l\u00fac \" + dateFormat.format(currentTime);", "match": 0}
{"groundtruth": "raiz.isLeaf()) {", "prediction": "raiz.getLeftSon() == null && raiz.getRightSon() == null) {\n                    if (previousNode == null) {\n                        setRoot(null);\n                    } else {\n                        if (previousNode.getLeftSon() == raiz) {\n                            previousNode.setLeftSon(null);\n                        } else {\n                            previousNode.setRightSon(null);\n                        }\n                    }\n                } else if (raiz.getLeftSon() == null) {\n                    if (previousNode == null) {\n                        setRoot(raiz.getRightSon());\n                    } else {\n                        if (previousNode", "first_line_groundtruth": "raiz.isLeaf()) {", "first_line_prediction": "raiz.getLeftSon() == null && raiz.getRightSon() == null) {", "match": 0}
{"groundtruth": ", SCALAR_ARRAY_SHAPE, rawData.data());", "prediction": ", SCALAR_ARRAY_SHAPE);\n            dummyArray.visit(rawData, new int[] { 0 });\n            return dummyArray;\n        }", "first_line_groundtruth": ", SCALAR_ARRAY_SHAPE, rawData.data());", "first_line_prediction": ", SCALAR_ARRAY_SHAPE);", "match": 0}
{"groundtruth": "if (infoFilter.isDateOfBirthValid(dob)) {", "prediction": " if (infoFilter.isDateOfBirthValid(dob)) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\");\n                this.dob = sdf.parse(dob);\n             }\n        } catch (ParseException ex) {\n            throw new InvalidDateOfBirthException(dob, ex.getMessage());\n        }\n    }\n\n    public void setDob(Date dob) {\n        this.dob = dob;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 89 * hash + Objects.hashCode(this.id);\n        return hash;\n    }\n\n    @", "first_line_groundtruth": "if (infoFilter.isDateOfBirthValid(dob)) {", "first_line_prediction": " if (infoFilter.isDateOfBirthValid(dob)) {", "match": 0}
{"groundtruth": "if (s.getStudentId().compareTo(studentId) == 0) {", "prediction": " if (s.getId().toUpperCase().equals(studentId)) {\n                    student = s;\n                    break;\n                 }\n            }\n            if (student != null) {\n                txtFullName.setText(student.getFullName());\n                txtStudentId.setText(student.getId());\n            } else {\n                txtFullName.setText(\"\");\n                txtStudentId.setText(\"\");\n                var msg = \"Sinh vi\u00ean c\u1ea7n t\u00ecm kh\u00f4ng t\u1ed3n t\u1ea1i. Vui l\u00f2ng th\u1eed l\u1ea1i!\";\n                showMessage(msg);\n            }\n        }\n    }", "first_line_groundtruth": "if (s.getStudentId().compareTo(studentId) == 0) {", "first_line_prediction": " if (s.getId().toUpperCase().equals(studentId)) {", "match": 0}
{"groundtruth": "(element < previousNode.getElement()) {", "prediction": " (previousNode.getLeftSon() == raiz) {\n                            previousNode.setLeftSon(null);\n                        } else {\n                            previousNode.setRightSon(null);\n                        }\n                    }\n                } else {\n                    // Cuando es un nodo con dos hijos\n                    Nodo aux = raiz.getRightSon();\n                    while (aux.getLeftSon() != null) {\n                        aux = aux.getLeftSon();\n                    }\n                    raiz.setElement(aux.getElement());\n                    deleteNodo(aux.getElement(), aux, raiz);\n                }\n            } else if (element <", "first_line_groundtruth": "(element < previousNode.getElement()) {", "first_line_prediction": " (previousNode.getLeftSon() == raiz) {", "match": 0}
{"groundtruth": "else if (raiz.hasOnlyRightSon()) {", "prediction": " else {\n                    // Cuando es un nodo con dos hijos\n                    Nodo son = raiz.getSons()[0];\n                    if (son.isLeaf()) {\n                        if (element < son.getElement()) {\n                            previousNode.setLeftSon(son);\n                        } else {\n                            previousNode.setRightSon(son);\n                        }\n                    } else {\n                        deleteNodo(element, son, son);\n                    }\n                }\n            } else {\n                if (element < raiz.getElement()) {\n                    deleteNodo(element, raiz.getLeftSon(), raiz);\n                } else {", "first_line_groundtruth": "else if (raiz.hasOnlyRightSon()) {", "first_line_prediction": " else {", "match": 0}
{"groundtruth": "raiz.getRightSon() != null;", "prediction": " raiz != null && raiz.getLeftSon() != null;\n    }\n    \n    public Nodo searchNodoToReplace(Nodo raiz) {\n        Nodo nodo = raiz;\n        while (nodo.getLeftSon() != null) {\n            nodo = nodo.getLeftSon();\n        }\n        return nodo;\n    }\n\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    public void insert(int element) {\n        if (isEmpty()) {\n            setRoot(new Nodo(element));\n        } else {\n            insertNodoRecursive(element, root", "first_line_groundtruth": "raiz.getRightSon() != null;", "first_line_prediction": " raiz != null && raiz.getLeftSon() != null;", "match": 0}
{"groundtruth": "return dummyArray.getLong(0);", "prediction": " return dummyArray.getLong(0);\n            case FLOAT32:\n            case FLOAT64:\n                 return dummyArray.getDouble(0);\n            default:\n                 throw new UnsupportedOperationException(\n                     \"Unsupported numpy scalar type: \" + dtype\n                 );\n            }\n        }", "first_line_groundtruth": "return dummyArray.getLong(0);", "first_line_prediction": " return dummyArray.getLong(0);", "match": 0}
{"groundtruth": "nodo.setLeftSon(raiz.getLeftSon());", "prediction": "\n                    } else {\n                        Nodo nodo = searchNodoToReplace(raiz.getRightSon());\n                        \n                    }\n                }\n            } else if (element < raiz.getElement()) {\n                deleteNodo(element, raiz.getLeftSon(), raiz);\n            } else {\n                deleteNodo(element, raiz.getRightSon(), raiz);\n            }\n        }\n    }\n\n    public boolean validateLeftSon(Nodo raiz) {\n        if (raiz == null) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    public Nodo search", "first_line_groundtruth": "nodo.setLeftSon(raiz.getLeftSon());", "first_line_prediction": "", "match": 0}
{"groundtruth": "Nodo nodo = searchNodoToReplace(raiz.getLeftSon());", "prediction": " // Si el nodo izquierdo tiene hijos a la derecha\n                        Nodo rightSon = raiz.getLeftSon();\n                        while (rightSon.getRightSon() != null) {\n                            rightSon = rightSon.getRightSon();\n                        }\n                        rightSon.setRightSon(raiz.getRightSon());\n                        raiz.setLeftSon(null);\n                        raiz.setRightSon(null);\n                    } else {\n                        // Si el nodo izquierdo tiene hijos a la izquierda\n                        Nodo leftSon = raiz.getLeftSon();\n                        while", "first_line_groundtruth": "Nodo nodo = searchNodoToReplace(raiz.getLeftSon());", "first_line_prediction": " // Si el nodo izquierdo tiene hijos a la derecha", "match": 0}
{"groundtruth": "validateLeftSon(raiz.getLeftSon());", "prediction": " raiz.getRightSon() != null;\n                    boolean haveLeftSons = raiz.getLeftSon() != null;\n                    Nodo aux = raiz;\n                    if (haveRightSons) {\n                        if (haveLeftSons) {\n                            // Tiene dos hijos\n                            if (element < aux.getRightSon().getElement()) {\n                                aux.setLeftSon(aux.getRightSon());\n                                aux.setRightSon(null);\n                            } else {\n                                aux.setRightSon(aux.getRightSon());\n                                aux.setLeftSon(null);\n                            }\n                        } else", "first_line_groundtruth": "validateLeftSon(raiz.getLeftSon());", "first_line_prediction": " raiz.getRightSon() != null;", "match": 0}
{"groundtruth": ".setRightSon(raiz.getRightSon());", "prediction": ".setLeftSon(raiz.getRightSon());\n                        nodo.setRightSon(raiz.getLeftSon());\n                        if (element < previousNode.getElement()) {\n                            previousNode.setLeftSon(nodo);\n                        } else {\n                            previousNode.setRightSon(nodo);\n                        }\n                    }\n                }\n            } else if (element < raiz.getElement()) {\n                deleteNodo(element, raiz.getLeftSon(), raiz);\n            } else {\n                deleteNodo(element, raiz.getRightSon(), raiz);\n            }\n        }\n    }\n\n   ", "first_line_groundtruth": ".setRightSon(raiz.getRightSon());", "first_line_prediction": ".setLeftSon(raiz.getRightSon());", "match": 0}
{"groundtruth": "Nodo nodo = raiz.getLeftSon();", "prediction": " // Si no tiene hijo derecho, se puede eliminar el nodo\n                        if (element < previousNode.getElement()) {\n                            previousNode.setLeftSon(raiz.getRightSon());\n                        } else {\n                            previousNode.setRightSon(raiz.getRightSon());\n                        }\n                    }\n                }\n            } else if (element < raiz.getElement()) {\n                deleteNodo(element, raiz.getLeftSon(), raiz);\n            } else {\n                deleteNodo(element, raiz.getRightSon(), raiz);\n            }\n        }\n    }\n\n    public boolean validate", "first_line_groundtruth": "Nodo nodo = raiz.getLeftSon();", "first_line_prediction": " // Si no tiene hijo derecho, se puede eliminar el nodo", "match": 0}
{"groundtruth": "while(raiz.getRightSon() != null) {", "prediction": " Nodo nodo = raiz;\n         while(nodo.getRightSon() != null){\n             nodo = nodo.getRightSon();\n         }\n         return nodo;\n    }\n\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    public void insert(int element) {\n        if (isEmpty()) {\n            setRoot(new Nodo(element));\n        } else {\n            insertNodoRecursive(element, root);\n        }\n    }\n\n    public void delete(int element) {\n        if (isEmpty()) {\n            System.out.println(\"There are not elements to delete\");\n       ", "first_line_groundtruth": "while(raiz.getRightSon() != null) {", "first_line_prediction": " Nodo nodo = raiz;", "match": 0}
{"groundtruth": "[] newSons = new Nodo[father.getSons().length + 1];", "prediction": "[] sons = new Nodo[father.getSons().length + 1];\n        for (int i = 0; i < father.getSons().length; i++) {\n            sons[i] = father.getSons()[i];\n        }\n        sons[sons.length - 1] = nodo;\n        father.setSons(sons);\n    }\n    \n    public void insertIterative(Integer element, int fatherElement) {\n        Nodo nodo = new Nodo(element);\n        if (isEmpty()) {\n            setRoot(nodo);\n        } else {\n           ", "first_line_groundtruth": "[] newSons = new Nodo[father.getSons().length + 1];", "first_line_prediction": "[] sons = new Nodo[father.getSons().length + 1];", "match": 0}
{"groundtruth": "pointer.getElement() == fatherElement) {", "prediction": "element < fatherElement) {\n                if (pointer.getLeftSon() == null) {\n                    pointer.setLeftSon(nodo);\n                } else {\n                    insertRecursive(element, fatherElement, pointer.getLeftSon());\n                }\n            } else {\n                if (pointer.getRightSon() == null) {\n                    pointer.setRightSon(nodo);\n                } else {\n                    insertRecursive(element, fatherElement, pointer.getRightSon());\n                }\n            }\n        }\n    }\n    \n    public void insert(Integer element) {\n        if (isEmpty()) {\n            setRoot(new Nodo(element", "first_line_groundtruth": "pointer.getElement() == fatherElement) {", "first_line_prediction": "element < fatherElement) {", "match": 0}
{"groundtruth": "if (pointer.getSons()[i].getElement() == fatherElement) {", "prediction": " // Recursividad\n                    insertRecursive(element, fatherElement, pointer.getSons()[i]);\n                }\n            }\n        }\n    }\n    \n    public void increaseSons(Nodo nodo, Nodo father) {\n        Nodo[] sons = new Nodo[father.getSons().length + 1];\n        for (int i = 0; i < father.getSons().length; i++) {\n            sons[i] = father.getSons()[i];\n        }\n        sons[sons.length - 1] = nodo;\n        father.setSons(son", "first_line_groundtruth": "if (pointer.getSons()[i].getElement() == fatherElement) {", "first_line_prediction": " // Recursividad", "match": 0}
{"groundtruth": "out.println(\"[ \"+raiz.getElement() + \" ]\");", "prediction": "out.print(raiz.getElement() + \" \");\n        if (raiz.getSons() != null) {\n            for (int i = 0; i < raiz.getSons().length; i++) {\n                printPreOrden(raiz.getSons()[i]);\n            }\n        }\n    }\n    \n    public void printInOrden(Nodo raiz) {\n        if (raiz.getSons() != null) {\n            for (int i = 0; i < raiz.getSons().length; i++) {\n                printInOrden(raiz.getSons()[i]);\n           ", "first_line_groundtruth": "out.println(\"[ \"+raiz.getElement() + \" ]\");", "first_line_prediction": "out.print(raiz.getElement() + \" \");", "match": 0}
{"groundtruth": "33, bst.getRoot());", "prediction": "60, bst.getRoot());\n        bst.insertNodoRecursive(70, bst.getRoot());\n        bst.insertNodoRecursive(80, bst.getRoot());\n        bst.insertNodoRecursive(90, bst.getRoot());\n        bst.insertNodoRecursive(15, bst.getRoot());\n        bst.insertNodoRecursive(17, bst.getRoot());\n        bst.insertNodoRecursive(19, bst.getRoot());\n        bst.insertNodoRecursive(21, bst.getRoot());\n       ", "first_line_groundtruth": "33, bst.getRoot());", "first_line_prediction": "60, bst.getRoot());", "match": 0}
{"groundtruth": ".preOrden(bst.getRoot());", "prediction": ".insertNodoRecursive(35, bst.getRoot());\n        bst.insertNodoRecursive(45, bst.getRoot());\n        bst.insertNodoRecursive(47, bst.getRoot());\n        bst.insertNodoRecursive(50, bst.getRoot());\n        bst.insertNodoRecursive(55, bst.getRoot());\n        bst.insertNodoRecursive(60, bst.getRoot());\n        bst.insertNodoRecursive(65, bst.getRoot());\n        bst.insertNodoRecursive(70,", "first_line_groundtruth": ".preOrden(bst.getRoot());", "first_line_prediction": ".insertNodoRecursive(35, bst.getRoot());", "match": 0}
{"groundtruth": "(25, bst.getRoot());", "prediction": "(15, bst.getRoot());\n        bst.insertNodoRecursive(25, bst.getRoot());\n        bst.insertNodoRecursive(40, bst.getRoot());\n        bst.insertNodoRecursive(60, bst.getRoot());\n        bst.insertNodoRecursive(70, bst.getRoot());\n        bst.insertNodoRecursive(80, bst.getRoot());\n        bst.insertNodoRecursive(90, bst.getRoot());\n        bst.insertNodoRecursive(110, bst.getRoot", "first_line_groundtruth": "(25, bst.getRoot());", "first_line_prediction": "(15, bst.getRoot());", "match": 0}
{"groundtruth": ".deleteNodo(30, bst.getRoot(), null);", "prediction": ".eliminarNodo(20, bst.getRoot());\n        bst.preOrden(bst.getRoot());\n        \n        System.out.println(\"Buscar\");\n        bst.buscarNodo(20, bst.getRoot());\n        bst.preOrden(bst.getRoot());\n        \n        System.out.println(\"Buscar\");\n        bst.buscarNodo(25, bst.getRoot());\n        bst.preOrden(bst.getRoot());\n        \n        System.out.println(\"Buscar\");\n        bst.buscarNodo(40, bst.getRoot());", "first_line_groundtruth": ".deleteNodo(30, bst.getRoot(), null);", "first_line_prediction": ".eliminarNodo(20, bst.getRoot());", "match": 0}
{"groundtruth": "(getPeek().getNext());", "prediction": "((Nodo) pointer.getNext());\n            pointer.setNext(null);\n            length--;\n        }\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return peek == null;\n    }\n\n    @Override\n    public Nodo getPeek() {\n        return peek;\n    }\n\n    @Override\n    public void setPeek(Nodo nodo) {\n        this.peek = nodo;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public void printStack() {\n        Nodo pointer = peek;\n        while (pointer != null) {\n            System.out.", "first_line_groundtruth": "(getPeek().getNext());", "first_line_prediction": "((Nodo) pointer.getNext());", "match": 0}
{"groundtruth": "(pointer.getNext() != pointer2) {", "prediction": " (pointer.getNext() != pointer2) {\n                pointer = pointer.getNext();\n                pointer2 = pointer2.getNext();\n            }\n            pointer.setNext(getHead());\n        }\n        length++;\n    }\n    \n    public void insertFinal(int element) {\n        Nodo node = new Nodo(element);\n        if (isEmpty()) {\n            setHead(node);\n        } else {\n            Nodo pointer = getHead();\n            while (pointer.getNext() != getHead()) {\n                pointer = pointer.getNext();\n            }\n            pointer.setNext(node);\n        }\n        length++;\n    }\n    \n    public void", "first_line_groundtruth": "(pointer.getNext() != pointer2) {", "first_line_prediction": " (pointer.getNext() != pointer2) {", "match": 0}
{"groundtruth": ".println(\"[ \"+pointer.getElement()+\" ]\");", "prediction": ".print(\"[ \"+pointer.getElement()+\" ]\");\n            pointer = pointer.getNext();\n        }\n    }", "first_line_groundtruth": ".println(\"[ \"+pointer.getElement()+\" ]\");", "first_line_prediction": ".print(\"[ \"+pointer.getElement()+\" ]\");", "match": 0}
{"groundtruth": ").setNext(getHead());", "prediction": "node);\n        } else {\n            node.setNext(getHead());\n            setHead(node);\n        }\n        length++;\n    }\n    \n    public void insertBegin(Object element) {\n        Nodo node = new Nodo(element);\n        if (isEmpty()) {\n            setHead(node);\n            getHead(node);\n        } else {\n            node.setNext(getHead());\n            setHead(node);\n        }\n        length++;\n    }\n    \n    public void insertFinal(int element) {\n        Nodo node = new Nodo(element);\n        if (isEmpty()) {\n            setHead(node);\n            get", "first_line_groundtruth": ").setNext(getHead());", "first_line_prediction": "node);", "match": 0}
{"groundtruth": "while (pointer.getNext() != getHead()) {", "prediction": " while (pointer.getNext() != pointer) {\n                pointer = (Nodo) pointer.getNext();\n            }\n            pointer.setNext(node);\n        }\n        length++;\n    }\n    \n    public void insertBegin(Object element) {\n        Nodo node = new Nodo(element);\n        if (isEmpty()) {\n            setHead(node);\n            getHead().setNext(getHead());\n        } else {\n            Nodo pointer = getHead();\n            Nodo pointer2 = getHead();\n            node.setNext(getHead());\n            setHead(node);\n            while (pointer.getNext() != pointer2)", "first_line_groundtruth": "while (pointer.getNext() != getHead()) {", "first_line_prediction": " while (pointer.getNext() != pointer) {", "match": 0}
{"groundtruth": "pointer.getNext())).getNext() != getHead()) {", "prediction": "pointer.getNext())).getNext() != null) {\n                    pointer = (Nodo) pointer.getNext();\n                }\n                pointer2 = (Nodo) pointer.getNext();\n                pointer.setNext(null);\n            } else {\n                pointer2 = getHead();\n                setHead(null);\n            }\n            return pointer2;\n        }\n        return null;\n    }\n    \n    public Nodo deleteBegin(){\n        if (isEmpty()) {\n            System.out.println(\"List is Empty\");\n        } else {\n            Nodo pointer = getHead();\n            setHead((Nodo) getHead().getNext());\n        }\n        return pointer", "first_line_groundtruth": "pointer.getNext())).getNext() != getHead()) {", "first_line_prediction": "pointer.getNext())).getNext() != null) {", "match": 0}
{"groundtruth": "pointer.setNext(getHead());", "prediction": " pointer.setNext(node);\n        }\n        length++;\n    }\n    \n    public void insertEnd(int element) {\n        Nodo node = new Nodo(element);\n        if (isEmpty()) {\n            setHead(node);\n            getHead().setNext(getHead());\n        } else {\n            Nodo pointer = getHead();\n            Nodo pointer2 = getHead();\n            node.setNext(getHead());\n            setHead(node);\n            while (pointer.getNext() != pointer2) {\n                pointer = (Nodo) pointer.getNext();\n            }\n             pointer.setNext(node);\n        }", "first_line_groundtruth": "pointer.setNext(getHead());", "first_line_prediction": " pointer.setNext(node);", "match": 0}
{"groundtruth": "list.deleteInIndex(3);", "prediction": " list.printList();\n        list.deleteInIndex(6);\n        System.out.println(\"\");\n        list.printList();\n        list.deleteInIndex(25);\n        System.out.println(\"\");\n        list.printList();\n        list.deleteInIndex(25);\n        System.out.println(\"\");\n        list.printList();\n        list.deleteInIndex(25);\n        System.out.println(\"\");\n        list.printList();\n        list.deleteInIndex(25);\n        System.out.println(\"\");\n        list.printList();\n        list.deleteInIndex(25", "first_line_groundtruth": "list.deleteInIndex(3);", "first_line_prediction": " list.printList();", "match": 0}
{"groundtruth": "while (pointer.getNext() != pointer2) {", "prediction": "\n            \n            if (length > 1){\n                while (((Nodo) (pointer.getNext())).getNext() != getHead()) {\n                    pointer = (Nodo) pointer.getNext();\n                }\n                pointer2 = (Nodo) pointer.getNext();\n                pointer.setNext(getHead());\n            } else {\n                pointer2 = deleteFinal();\n            }\n            length--;\n            return pointer2;\n        }\n        \n        return null;\n    }\n    \n    public Nodo deleteInIndex(int index){\n        if (isEmpty()) {\n            System.out.println(\"List is Empty\");\n        } else {\n            if (index == 0", "first_line_groundtruth": "while (pointer.getNext() != pointer2) {", "first_line_prediction": "", "match": 0}
{"groundtruth": ".getNext())).getNext() != getHead()) {", "prediction": ".getNext())).getNext() != null) {\n                    pointer = (Nodo) pointer.getNext();\n                }\n                pointer2 = (Nodo) pointer.getNext();\n                pointer.setNext(null);\n            } else {\n                pointer2 = getHead();\n                setHead(null);\n            }\n            length--;\n            return pointer2;\n        }\n        return null;\n    }\n    \n    public Nodo deleteBegin(){\n        if (isEmpty()) {\n            System.out.println(\"List is Empty\");\n        } else {\n            Nodo pointer = getHead();\n            setHead((Nodo) getHead().getNext());\n        }\n       ", "first_line_groundtruth": ".getNext())).getNext() != getHead()) {", "first_line_prediction": ".getNext())).getNext() != null) {", "match": 0}
{"groundtruth": "int) pointer1.getElement();", "prediction": "int) pointer1.getElement();\n                pointer1 = (Nodo) pointer1.getNext();\n            }\n            if (pointer2 != null){\n                value += (int) pointer2.getElement();\n                pointer2 = (Nodo) pointer2.getNext();\n            }\n            if (pointer3 != null){\n                value += (int) pointer3.getElement();\n                pointer3 = (Nodo) pointer3.getNext();\n            }\n            list.insertFinal(value);\n        }\n        return list;\n    }", "first_line_groundtruth": "int) pointer1.getElement();", "first_line_prediction": "int) pointer1.getElement();", "match": 1}
{"groundtruth": "pointer1 = lista1.getHead();", "prediction": " nodo = new Nodo(0);\n        nodo.setSiguiente(null);\n        nodo.setAnterior(null);\n        nodo.setValor(0);\n        nodo.setSiguiente(null);\n        nodo.setAnterior(null);\n        nodo.setValor(0);\n        nodo.setSiguiente(null);\n        nodo.setAnterior(null);\n        nodo.setValor(0);\n        nodo.setSiguiente(null);\n        nodo.setAnterior(null);\n        nodo.setValor(0", "first_line_groundtruth": "pointer1 = lista1.getHead();", "first_line_prediction": " nodo = new Nodo(0);", "match": 0}
{"groundtruth": "Nodo pointer3 = lista3.getHead();", "prediction": " Nodo pointer3 = lista3.getHead();\n        while(pointer1 != null && pointer2 != null && pointer3 != null){\n            int suma = pointer1.getData() + pointer2.getData() + pointer3.getData();\n            Nodo nodo = new Nodo(suma);\n            list.insertFinal(nodo);\n            pointer1 = pointer1.getNext();\n            pointer2 = pointer2.getNext();\n            pointer3 = pointer3.getNext();\n        }\n        return list;\n    }", "first_line_groundtruth": "Nodo pointer3 = lista3.getHead();", "first_line_prediction": " Nodo pointer3 = lista3.getHead();", "match": 0}
{"groundtruth": ").setPrevious(node);", "prediction": "node);\n            setHead(node);\n        }\n        size++;\n    }\n\n    @Override\n    public void insertBegin(int element) {\n        NodoDoble node = new NodoDoble(element);\n        if (isEmpty()) {\n            setHead(node);\n            setTail(node);\n        } else {\n            getHead(node);\n            setHead(node);\n        }\n        size++;\n    }\n\n    @Override\n    public void insertFinal(Object element) {\n        NodoDoble node = new NodoDoble(element);\n        if (isEmpty()) {\n            setHead(node);", "first_line_groundtruth": ").setPrevious(node);", "first_line_prediction": "node);", "match": 0}
{"groundtruth": "node.setPrevious(pointer);", "prediction": " node.setPrevious(pointer);\n             pointer.setNext(node);\n             setTail(node);\n        }\n        size++;\n    }\n\n    @Override\n    public void insertInIndex(Object element, int index) {\n        NodoDoble node = new NodoDoble(element);\n        if(isEmpty()) {\n            setHead(node);\n            setTail(node);\n        } else {\n            NodoDoble pointer = getHead();\n            for(int i = 0; i < index; i++) {\n                pointer = pointer.getNext();\n            }\n            node.setPrevious(pointer);", "first_line_groundtruth": "node.setPrevious(pointer);", "first_line_prediction": " node.setPrevious(pointer);", "match": 0}
{"groundtruth": "= (NodoDoble) pointer.getNext();", "prediction": " = (NodoDoble) pointer.getNext();\n                        cont++;\n                    }\n                    pointer2 = (NodoDoble) pointer.getNext();\n                    pointer.setNext((NodoDoble) pointer2.getNext());\n                    pointer2.setNext(null);\n                    return pointer2;\n                }\n            } else {\n                NodoDoble pointer = getTail();\n                if (index == getSize()-1) {\n                    deleteFinal();\n                } else {\n                    NodoDoble pointer2;\n                    int cont = 0;\n                    while ( cont< index-1 ) {\n                        pointer =", "first_line_groundtruth": "= (NodoDoble) pointer.getNext();", "first_line_prediction": " = (NodoDoble) pointer.getNext();", "match": 0}
{"groundtruth": "pointer2 = pointer.getPrevious();", "prediction": " previous = pointer.getPrevious();\n                previous.setNext(null);\n                setTail(previous);\n            }\n            size--;\n            return pointer;\n        }\n        return null;\n    }\n\n    @Override\n    public NodoDoble deleteBegin() {\n        if(isEmpty()) {\n            System.out.println(\"No hay elementos en la lista\");\n        } else {\n            NodoDoble pointer = getHead();\n            if (getSize() == 1) {\n                setHead(null);\n                setTail(null);\n            } else {\n                NodoDoble next = pointer.getNext();\n                next.", "first_line_groundtruth": "pointer2 = pointer.getPrevious();", "first_line_prediction": " previous = pointer.getPrevious();", "match": 0}
{"groundtruth": "pointer.setPrevious(null);", "prediction": " pointer2.setNext(null);\n                 setTail(pointer2);\n            }\n            size--;\n            return pointer;\n        }\n        return null;\n    }\n\n    @Override\n    public NodoDoble deleteBegin() {\n        if(isEmpty()) {\n            System.out.println(\"No hay elementos en la lista\");\n        } else {\n            NodoDoble pointer = getHead();\n            if (getSize() == 1) {\n                setHead(null);\n                setTail(null);\n            } else {\n                NodoDoble pointer2 = pointer.getNext();\n                pointer2.setPrevious(null", "first_line_groundtruth": "pointer.setPrevious(null);", "first_line_prediction": " pointer2.setNext(null);", "match": 0}
{"groundtruth": "pointer2 = pointer.getNext();", "prediction": " pointer2 = (NodoDoble) pointer.getNext();\n                     pointer.setNext((NodoDoble) pointer2.getNext());\n                     pointer2.setNext(null);\n                     return pointer2;\n                }\n            } else {\n                NodoDoble pointer = getTail();\n                if (index == getSize()-1) {\n                    deleteFinal();\n                } else {\n                    NodoDoble pointer2;\n                    int cont = 0;\n                    while ( cont< index-1 ) {\n                        pointer = (NodoDoble) pointer.getPrevious();\n                        cont++;\n                    }\n                   ", "first_line_groundtruth": "pointer2 = pointer.getNext();", "first_line_prediction": " pointer2 = (NodoDoble) pointer.getNext();", "match": 0}
{"groundtruth": "emoji.getSubgroup() == subgroup).collect(Collectors.toSet());", "prediction": " emoji.getSubGroup() == subgroup).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets all emojis that are part of the given category.\n     *\n     * @param category The category to get the emojis for.\n     * @return A set of all emojis that are part of the given category.\n     */\n    public static Set<Emoji> getAllEmojisByCategory(final EmojiCategory category) {\n        return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getCategory() == category).collect(Collectors.toSet());\n    }\n\n    /**\n     * Gets", "first_line_groundtruth": "emoji.getSubgroup() == subgroup).collect(Collectors.toSet());", "first_line_prediction": " emoji.getSubGroup() == subgroup).collect(Collectors.toSet());", "match": 0}
{"groundtruth": "pointer2.getNext().setPrevious(pointer);", "prediction": " pointer2.setNext(null);\n                     return pointer2;\n                }\n            } else {\n                NodoDoble pointer = getTail();\n                if (index == getSize()-1) {\n                    deleteFinal();\n                } else {\n                    NodoDoble pointer2;\n                    int cont = 0;\n                    while ( cont< index-1 ) {\n                        pointer = (NodoDoble) pointer.getPrevious();\n                        cont++;\n                    }\n                    pointer2 = pointer.getPrevious();\n                    pointer.setPrevious(pointer2.getPrevious());\n                    pointer2.setPrevious(null);\n                    return pointer", "first_line_groundtruth": "pointer2.getNext().setPrevious(pointer);", "first_line_prediction": " pointer2.setNext(null);", "match": 0}
{"groundtruth": "(emoji -> emoji.getDiscordAliases().contains(aliasWithoutColon) || emoji.getDiscordAliases().contains(aliasWithColon))\n                .findFirst();", "prediction": "(emoji -> emoji.getAllDiscordAliases().contains(aliasWithoutColon) || emoji.getAllDiscordAliases().contains(aliasWithColon))\n                 .findFirst();\n    }\n\n    /**\n     * Gets an emoji for the given unicode.\n     *\n     * @param emoji The unicode of the emoji.\n     * @return The emoji.\n     */\n    public static Optional<Emoji> getByUnicode(final String emoji) {\n        if (isStringNullOrEmpty(emoji)) return Optional.empty();\n        return Optional.ofNullable(EMOJI_UNICODE_TO_EMOJI.get(emoji));\n    }\n\n    /**\n     * Gets all", "first_line_groundtruth": "(emoji -> emoji.getDiscordAliases().contains(aliasWithoutColon) || emoji.getDiscordAliases().contains(aliasWithColon))", "first_line_prediction": "(emoji -> emoji.getAllDiscordAliases().contains(aliasWithoutColon) || emoji.getAllDiscordAliases().contains(aliasWithColon))", "match": 0}
{"groundtruth": "emoji.getAllAliases().contains(aliasWithoutColon) || emoji.getAllAliases().contains(aliasWithColon))\n                .findFirst();", "prediction": " emoji.getAliases().contains(aliasWithoutColon) || emoji.getAliases().contains(aliasWithColon))\n                 .findFirst();\n    }\n\n    /**\n     * Gets all emojis that match the given pattern.\n     *\n     * @param pattern The pattern to match.\n     * @return A list of all emojis that match the given pattern.\n     */\n    public static List<Emoji> getByPattern(final String pattern) {\n        if (isStringNullOrEmpty(pattern)) return Collections.emptyList();\n        return EMOJI_PATTERN.matcher(pattern).results().stream()\n                 .map(m -> EMOJI_", "first_line_groundtruth": "emoji.getAllAliases().contains(aliasWithoutColon) || emoji.getAllAliases().contains(aliasWithColon))", "first_line_prediction": " emoji.getAliases().contains(aliasWithoutColon) || emoji.getAliases().contains(aliasWithColon))", "match": 0}
{"groundtruth": "return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toSet());", "prediction": " return new HashSet<>(EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toList()));\n    }\n\n    /**\n     * Gets all emojis that are part of the given subgroup.\n     *\n     * @param subgroup The subgroup to get the emojis for.\n     * @return A set of all emojis that are part of the given subgroup.\n     */\n    public static Set<Emoji> getAllEmojisBySubgroup(final EmojiSubgroup subgroup) {\n        return new HashSet<>(EMOJIS_LENGTH_DESCENDING", "first_line_groundtruth": "return EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toSet());", "first_line_prediction": " return new HashSet<>(EMOJIS_LENGTH_DESCENDING.stream().filter(emoji -> emoji.getGroup() == group).collect(Collectors.toList()));", "match": 0}
{"groundtruth": ".removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji));", "prediction": ".removeHairStyle(Fitzpatrick.removeFitzpatrick(getEmoji()));\n        final List<Emoji> variations = new ArrayList<>();\n        variations.add(new Emoji(baseEmoji, getUnicode(), getDiscordAliases(), getGithubAliases(), getSlackAliases(), hasFitzpatrick, hasHairStyle, version, qualification, description, group, subgroup));\n        if (hasFitzpatrick) {\n            variations.add(new Emoji(Fitzpatrick.removeFitzpatrick(baseEmoji), getUnicode(), getDiscordAliases(), getGithubAliases(), getSlackAliases(), has", "first_line_groundtruth": ".removeHairStyle(Fitzpatrick.removeFitzpatrick(emoji));", "first_line_prediction": ".removeHairStyle(Fitzpatrick.removeFitzpatrick(getEmoji()));", "match": 0}
{"groundtruth": "mListener.onCancelledAuth();", "prediction": " mListener.onLoggedOut();\n                }\n            }\n        })\n        .addOnFailureListener(new OnFailureListener() {\n            @Override\n            public void onFailure(Exception e) {\n                Log.i(TAG, \"cancelAuthorization fail\");\n                if (mListener != null) {\n                    mListener.onException(Constants.CANCEL_AUTHORIZATION_ACTION, e.getMessage());\n                }\n            }\n        });\n    }\n\n    public static void getAuthAccount() {\n        int action = mSharedPreferences.getInt(MODE, Constants.LOGIN_ACTION);\n        AccountAuthService authService = createAuthService(action);\n        Task", "first_line_groundtruth": "mListener.onCancelledAuth();", "first_line_prediction": " mListener.onLoggedOut();", "match": 0}
{"groundtruth": "mListener.onLoggedOut();", "prediction": " mListener.onLogOutSuccess();\n                }\n            }\n        }).addOnFailureListener(new OnFailureListener() {\n            @Override\n            public void onFailure(Exception e) {\n                Log.i(TAG, \"signOut Failed\");\n                if (mListener != null) {\n                     mListener.onLogOutFailed(e.getMessage());\n                }\n            }\n        });\n    }\n\n    public static void getAuthAccount() {\n        int action = mSharedPreferences.getInt(MODE, Constants.LOGIN_ACTION);\n        AccountAuthService authService = createAuthService(action);\n        Task<AuthAccount> authAccountTask", "first_line_groundtruth": "mListener.onLoggedOut();", "first_line_prediction": " mListener.onLogOutSuccess();", "match": 0}
{"groundtruth": "HuaweiPushPlugin.handleReceiveMessage(messageData);", "prediction": " // Check whether the message is empty.\n        if (messageData == null) {\n            Log.e(TAG, \"Received message data is null!\");\n            HuaweiPushPlugin.handleException(Constants.UNKNOWN_ERROR, Constants.ON_MESSAGE_RECEIVED, \"Received null message data\");\n            return;\n        }\n        Log.i(TAG, \"Received message data: \" + messageData);\n        try {\n            JSONObject messageJson = new JSONObject(messageData);\n            HuaweiPushPlugin.handleMessageReceived(messageJson);\n        } catch (JSONException e) {\n            Log.e(TAG, \"Received message", "first_line_groundtruth": "HuaweiPushPlugin.handleReceiveMessage(messageData);", "first_line_prediction": " // Check whether the message is empty.", "match": 0}
{"groundtruth": "mAdStatusListener.onRewarded(rewardName, rewardAmount);", "prediction": " mAdStatusListener.onRewarded(rewardAmount, rewardName);\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void setRewardVerifyConfig(RewardVerifyConfig rewardVerifyConfig) {\n        mRewardAd.setRewardVerifyConfig(rewardVerifyConfig);\n    }\n\n    public void setRewardAdListener(IRewardAdStatusListener adStatusListener) {\n        mAdStatusListener = adStatusListener;\n    }\n\n    public void setRewardAdLoadListener(IRewardAdLoadListener adLoadListener) {\n        mAdLoadListener = adLoadListener;\n    }", "first_line_groundtruth": "mAdStatusListener.onRewarded(rewardName, rewardAmount);", "first_line_prediction": " mAdStatusListener.onRewarded(rewardAmount, rewardName);", "match": 0}
{"groundtruth": "CipherUtil.doCheck(inAppPurchaseDataStr, inAppPurchaseDataSignature, mPublicKey)) {", "prediction": "TextUtils.isEmpty(inAppPurchaseDataSignature)) {\n            return new Pair<>(false, null);\n        }\n        InAppPurchaseData inAppPurchaseData = null;\n        try {\n            inAppPurchaseData = InAppPurchaseData.parse(inAppPurchaseDataStr);\n        } catch (Exception e) {\n            Log.e(TAG, \"verifyPurchaseStatus, parse inAppPurchaseDataStr fail, \" + e.getMessage());\n            return new Pair<>(false, null);\n        }\n        if (inAppPurchaseData == null) {\n            Log.e(TAG, \"verifyPurchaseStatus, inAppPurchaseData", "first_line_groundtruth": "CipherUtil.doCheck(inAppPurchaseDataStr, inAppPurchaseDataSignature, mPublicKey)) {", "first_line_prediction": "TextUtils.isEmpty(inAppPurchaseDataSignature)) {", "match": 0}
{"groundtruth": "list.deleteInIndex(6);", "prediction": "\n        \n    }\n    ", "first_line_groundtruth": "list.deleteInIndex(6);", "first_line_prediction": "", "match": 0}
{"groundtruth": "iapApiCallback.onFail(e);", "prediction": " iapApiCallback.onFailure(e);\n            }\n        });\n    }\n\n    /**\n     * To start the in-app purchase activity.\n     *\n     * @param activity Activity instance.\n     * @param mClient IapClient instance to call the startIapActivity API.\n     * @param iapApiCallback IapApiCallback.\n     */\n    public static void startIapActivity(Activity activity, IapClient mClient, final IapApiCallback iapApiCallback) {\n        Log.i(TAG, \"call startIapActivity\");\n        Task<StartIapActivityResult> task = m", "first_line_groundtruth": "iapApiCallback.onFail(e);", "first_line_prediction": " iapApiCallback.onFailure(e);", "match": 0}
{"groundtruth": "list.deleteInIndex(2);", "prediction": "\n        \n    }\n    ", "first_line_groundtruth": "list.deleteInIndex(2);", "first_line_prediction": "", "match": 0}
{"groundtruth": ").compareTo(cont.getTitular()) < 0) {", "prediction": "cont.getTitular()) < 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;", "first_line_groundtruth": ").compareTo(cont.getTitular()) < 0) {", "first_line_prediction": "cont.getTitular()) < 0) {", "match": 0}
{"groundtruth": "out.printf(\"Saldo atualizado: R$%.2f%n\", conta.getSaldo());", "prediction": "out.println(\"Saldo: \" + String.format(\"R$ %.2f\", this.getSaldo()));\n\t\tSystem.out.println(\"Data: \" + sdf.format(date));\n\t\tSystem.out.println(\"**************************************************\");\n\t\tEscritor.comprovanteSaldo(conta);", "first_line_groundtruth": "out.printf(\"Saldo atualizado: R$%.2f%n\", conta.getSaldo());", "first_line_prediction": "out.println(\"Saldo: \" + String.format(\"R$ %.2f\", this.getSaldo()));", "match": 0}
{"groundtruth": ".getTitular().compareTo(cont.getTitular()) > 0) {", "prediction": ".getTipoDeConta().equals(cont.getTipoDeConta())) {\n\t\t\treturn this.getNumConta().compareTo(cont.getNumConta());\n\t\t} else {\n\t\t\treturn this.getTipoDeConta().compareTo(cont.getTipoDeConta());\n\t\t}", "first_line_groundtruth": ".getTitular().compareTo(cont.getTitular()) > 0) {", "first_line_prediction": ".getTipoDeConta().equals(cont.getTipoDeConta())) {", "match": 0}
{"groundtruth": "conta.sacar(valor, conta);", "prediction": "", "first_line_groundtruth": "conta.sacar(valor, conta);", "first_line_prediction": "", "match": 0}
{"groundtruth": "printf(\"Saldo atual: R$ %.2f\", conta.getSaldo());", "prediction": "println(\"Dep\u00f3sito efetuado com sucesso!\");\n\t\t\t\tmenuCliente(conta, cliente);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Insira o valor da transfer\u00eancia: R$ \");\n\t\t\t\tvalor = sc.nextDouble();", "first_line_groundtruth": "printf(\"Saldo atual: R$ %.2f\", conta.getSaldo());", "first_line_prediction": "println(\"Dep\u00f3sito efetuado com sucesso!\");", "match": 0}
{"groundtruth": "pointer2 = (Nodo) pointer2.getNext();", "prediction": " pointer2 = (Nodo) pointer2.getNext();\n                 cont2++;\n            }\n            cont3 += (int) pointer2.getElement();\n            pointer2 = (Nodo) pointer2.getNext();\n            cont--;\n            cont2=0;\n        }\n        System.out.println(\"El promedio es:\"+(double)(cont3/queue.getSize()));\n    }\n    \n    public void Ejercicio2(Queue queue) {\n        Nodo pointer = queue.getHead();\n        int cont = 0;\n        while (pointer != null) {\n            cont++;\n            pointer = (Nodo) pointer", "first_line_groundtruth": "pointer2 = (Nodo) pointer2.getNext();", "first_line_prediction": " pointer2 = (Nodo) pointer2.getNext();", "match": 0}
{"groundtruth": "System.out.println(\"Valor de tarifa cobrado no dep\u00f3sito: R$ \" + ContaCorrente.getTarifaDeposito());", "prediction": "\tSystem.out.println(\"Valor de tarifa cobrado no deposito: R$ \" + ContaCorrente.getTarifaDeposito());\n\t\t\tSystem.out.println(\"Total de dep\u00f3sitos: \" + conta.getTotalDepositos());\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Valor de seguro ap\u00f3s tributa\u00e7\u00e3o: R$ \" + SeguroDeVida.getValorSeguroAposTaxa());\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Saldo atualizado: R$ \" + conta", "first_line_groundtruth": "System.out.println(\"Valor de tarifa cobrado no dep\u00f3sito: R$ \" + ContaCorrente.getTarifaDeposito());", "first_line_prediction": "\tSystem.out.println(\"Valor de tarifa cobrado no deposito: R$ \" + ContaCorrente.getTarifaDeposito());", "match": 0}
{"groundtruth": "(cpfDestinatario.equals(conta.getCpf())) {", "prediction": " (cpfDestinatario.length() != 11) {\n\t\t\t\t\tSystem.out.println(\"Insira um CPF v\u00e1lido.\");\n\t\t\t\t\tSystem.out.printf(\"Insira o CPF do destinat\u00e1rio: \");\n\t\t\t\t\tcpfDestinatario = sc.nextLine();\n\t\t\t\t}", "first_line_groundtruth": "(cpfDestinatario.equals(conta.getCpf())) {", "first_line_prediction": " (cpfDestinatario.length() != 11) {", "match": 0}
{"groundtruth": "conta.transferir(contaDestino, valor, conta);", "prediction": "", "first_line_groundtruth": "conta.transferir(contaDestino, valor, conta);", "first_line_prediction": "", "match": 0}
{"groundtruth": "printf(\"NOME: %s\\t| AG\u00caNCIA: %s\\n\", c.getTitular(), c.getAgencia());", "prediction": "println(c);\n\t\t}\n\t\tSystem.out.println(\"****************************************************\");\n\t\tEscritor.relatorioClientes(conta, funcionario);", "first_line_groundtruth": "printf(\"NOME: %s\\t| AG\u00caNCIA: %s\\n\", c.getTitular(), c.getAgencia());", "first_line_prediction": "println(c);", "match": 0}
{"groundtruth": "etTitular(), c.getAgencia());", "prediction": ".getNome(), c.getAgencia().getNumAgencia());\n\t\t}\n\t\tSystem.out.println(\"****************************************************\");\n\t\tEscritor.relatorioClientes(conta, funcionario);", "first_line_groundtruth": "etTitular(), c.getAgencia());", "first_line_prediction": ".getNome(), c.getAgencia().getNumAgencia());", "match": 0}
{"groundtruth": "Escritor.registroDeDadosAtualizados();", "prediction": "\tSystem.out.println(\"Obrigado por utilizar o sistema!\");\n\t\t\t\t\tSystem.out.println(\"At\u00e9 logo!\");\n\t\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"Op\u00e7\u00e3o inv\u00e1lida!\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (InputMismatchException e) {\n\t\t\tSystem.out.println(\"Erro na leitura dos dados: \" + e.getMessage());\n\t\t}", "first_line_groundtruth": "Escritor.registroDeDadosAtualizados();", "first_line_prediction": "\tSystem.out.println(\"Obrigado por utilizar o sistema!\");", "match": 0}
{"groundtruth": "println(\"Total de saques: \" + conta.getTotalSaques());", "prediction": "println(\"Valor de tarifa cobrado no dep\u00f3sito: R$ \" + ContaCorrente.getTarifaDeposito());\n\t\tSystem.out.println(\"Valor de tarifa cobrado no pagamento de seguro de vida: R$ \"\n\t\t\t\t+ SeguroDeVida.getValorSeguroAposTaxa());\n\t\tSystem.out.println(\"Valor de tarifa cobrado no pagamento de imposto de renda: R$ \"\n\t\t\t\t+ ((ContaCorrente) conta).getTotalTarifas());\n\t\tSystem.out.println(\"", "first_line_groundtruth": "println(\"Total de saques: \" + conta.getTotalSaques());", "first_line_prediction": "println(\"Valor de tarifa cobrado no dep\u00f3sito: R$ \" + ContaCorrente.getTarifaDeposito());", "match": 0}
{"groundtruth": "capitalBancoSaldo += lista.getSaldo();", "prediction": "\tcapitalBancoSaldo += lista.getSaldo();\n\t\t}\n\t\tSystem.out.printf(\"O valor total do capital do banco \u00e9: R$ %.2f%n\", capitalBancoSaldo);\n\t\tSystem.out.println(\"**************************************************\");\n\t\tSystem.out.println();", "first_line_groundtruth": "capitalBancoSaldo += lista.getSaldo();", "first_line_prediction": "\tcapitalBancoSaldo += lista.getSaldo();", "match": 0}
{"groundtruth": ".out.println(pointer2.getElement());", "prediction": ".out.println(\"El promedio de los \"+cont3+\" elementos es: \"+(double)(pointer2.getElement()/cont));\n            cont3++;\n            cont2=0;\n            pointer2 = (Nodo) pointer2.getNext();\n        }\n    }\n    \n    public void Ejercicio2(Queue queue) {\n        Nodo pointer = queue.getHead();\n        int cont = 0;\n        while (pointer != null) {\n            cont++;\n            pointer = (Nodo) pointer.getNext();\n        }\n        System.out.println(\"La longitud de la cola es: \"+cont", "first_line_groundtruth": ".out.println(pointer2.getElement());", "first_line_prediction": ".out.println(\"El promedio de los \"+cont3+\" elementos es: \"+(double)(pointer2.getElement()/cont));", "match": 0}
{"groundtruth": "(\"Valor de tarifa cobrado na tranfer\u00eancia: R$ \" + ContaCorrente.getTarifaTransferencia());", "prediction": "(\"Valor de tarifa cobrado na transfer\u00eancia: R$ \" + ContaCorrente.getTarifaTransferencia());\n\t\tSystem.out.println(\"Total de transfer\u00eancias: \" + conta.getTotalTransferencias());\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Valor de tarifa cobrado no pagamento do Seguro de Vida: R$ \" + SeguroDeVida.getValorTributacao());\n\t\tSystem.out.println(\"Valor do Seguro de Vida: R$ \" + String.format(\"%.2f\",", "first_line_groundtruth": "(\"Valor de tarifa cobrado na tranfer\u00eancia: R$ \" + ContaCorrente.getTarifaTransferencia());", "first_line_prediction": "(\"Valor de tarifa cobrado na transfer\u00eancia: R$ \" + ContaCorrente.getTarifaTransferencia());", "match": 0}
{"groundtruth": "conta.imprimeExtrato(conta);", "prediction": "\tEscritor.extrato(conta);\n\t\t\t\t\tmenuCliente(conta, cliente);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println(\"******** Menu Relat\u00f3rios e Saldo ********\");\n\t\t\t\tSystem.out.println(\"Escolha entre as op\u00e7\u00f5es abaixo:\");\n\t\t\t\tSystem.out.println(\"[1] Relat\u00f3rio de informa\u00e7\u00f5es dos clientes do banco\");\n\t\t\t\tSystem.out.println(\"[2] Relat\u00f3rio do capital total armazenado\");\n\t\t\t\tSystem.out.println(\"[3] Retornar ao", "first_line_groundtruth": "conta.imprimeExtrato(conta);", "first_line_prediction": "\tEscritor.extrato(conta);", "match": 0}
{"groundtruth": "= \"Ag\u00eancia: \" + conta.getAgencia();", "prediction": " = \"Agencia: \" + conta.getAgencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "= \"Ag\u00eancia: \" + conta.getAgencia();", "first_line_prediction": " = \"Agencia: \" + conta.getAgencia();", "match": 0}
{"groundtruth": "= valorSimulado * ((ContaPoupanca.getTaxaRendimento() / 30) * dias);", "prediction": " = 0.0;\n\t\tDouble rendimentoTotal = 0.0;\n\t\tDouble rendimentoMensal = 0.0;\n\t\tDouble rendimentoAnual = 0.0;\n\t\tDouble rendimentoAnualMensal = 0.0;\n\t\tDouble rendimentoAnualTotal = 0.0;\n\t\tDouble rendimentoAnualTotalMensal = 0.0;\n\t\tDouble rendimentoAnualTotalMensalTotal = 0.0;\n\t\tDouble rendimentoAnualTotalMensalTotalTotal = 0.0;\n\t\tDouble rend", "first_line_groundtruth": "= valorSimulado * ((ContaPoupanca.getTaxaRendimento() / 30) * dias);", "first_line_prediction": " = 0.0;", "match": 0}
{"groundtruth": "tarifaTotalSaque = conta.getTotalSaques() * ContaCorrente.getTarifaSaque();", "prediction": "ate = 0;\n\t\tfor (int i = 0; i < conta.getContasPoupanca().size(); i++) {\n\t\t\tate += conta.getContasPoupanca().get(i).getSaldo();\n\t\t}\n\t\tSystem.out.println(\"Valor de rendimento da conta poupan\u00e7a: R$ \" + ate);\n\t\tSystem.out.println(\"**************************************\");\n\t\tSystem.out.println();", "first_line_groundtruth": "tarifaTotalSaque = conta.getTotalSaques() * ContaCorrente.getTarifaSaque();", "first_line_prediction": "ate = 0;", "match": 0}
{"groundtruth": "ag.getNumAgencia());", "prediction": " ag.getNumAgencia() + \";\" + ag.getNome() + \";\" + ag.getEndereco() + \";\"\n\t\t\t\t\t\t+ ag.getCidade() + \";\" + ag.getEstado() + \";\" + ag.getTelefone() + \";\" + ag.getCep() + \"\\n\");\n\t\t\t}", "first_line_groundtruth": "ag.getNumAgencia());", "first_line_prediction": " ag.getNumAgencia() + \";\" + ag.getNome() + \";\" + ag.getEndereco() + \";\"", "match": 0}
{"groundtruth": ").getNome() + \"_\" + conta.getTitular().getTipoDeUsuario();", "prediction": "ContasEnum.CLIENTE).getNome() + \"_\"\n\t\t\t\t+ conta.getTitular(ContasEnum.CLIENTE).getTipoDeUsuario();\n\t\tnew File(CAMINHO + \"\\\\\" + SUB_CAMINHO).mkdir();", "first_line_groundtruth": ").getNome() + \"_\" + conta.getTitular().getTipoDeUsuario();", "first_line_prediction": "ContasEnum.CLIENTE).getNome() + \"_\"", "match": 0}
{"groundtruth": "queue.getSize()){", "prediction": "1000000000){\n                cont3 = 0;\n                System.out.println(\"cont \"+cont);\n            }\n        }\n    }\n    \n    public void Ejercicio2(Queue queue) {\n        Nodo pointer = queue.getHead();\n        int cont = 0;\n        while (pointer != null) {\n            pointer = (Nodo) pointer.getNext();\n            cont++;\n        }\n        System.out.println(\"El tama\u00f1o de la cola es: \"+cont);\n    }\n    \n    public void Ejercicio3(Queue queue) {\n        Nodo pointer", "first_line_groundtruth": "queue.getSize()){", "first_line_prediction": "1000000000){", "match": 0}
{"groundtruth": "= (Nodo) queue.getHead().getNext();", "prediction": " = (Nodo) pointer2.getNext();\n            cont3++;\n        }\n        System.out.println(\"El promedio es:\"+(double)(acum/queue.getSize()));\n    }\n    \n    public void Ejercicio2(Queue queue) {\n        Nodo pointer = queue.getHead();\n        int cont = 0;\n        int cont2 = 0;\n        int cont3 =0;\n        boolean firstTime = true;\n        while ((pointer != queue.getHead() || firstTime)){\n            firstTime = false;\n            while (cont2 < cont) {\n                pointer = (Nodo", "first_line_groundtruth": "= (Nodo) queue.getHead().getNext();", "first_line_prediction": " = (Nodo) pointer2.getNext();", "match": 0}
{"groundtruth": "\"Ag\u00eancia : \" + conta.getAgencia();", "prediction": " \"Ag\u00eancia: \" + conta.getAgencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "\"Ag\u00eancia : \" + conta.getAgencia();", "first_line_prediction": " \"Ag\u00eancia: \" + conta.getAgencia();", "match": 0}
{"groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteTransferencia\";", "prediction": "ContasEnum.CONTA_CORRENTE) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado\n\t\t\t\t+ \"_comprovanteTransferencia\";", "first_line_groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteTransferencia\";", "first_line_prediction": "ContasEnum.CONTA_CORRENTE) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado", "match": 0}
{"groundtruth": "String arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteExtrato\";", "prediction": "", "first_line_groundtruth": "String arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteExtrato\";", "first_line_prediction": "", "match": 0}
{"groundtruth": ".getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteExtrato\";", "prediction": ".getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_extratoConta\";", "first_line_groundtruth": ".getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteExtrato\";", "first_line_prediction": ".getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_extratoConta\";", "match": 0}
{"groundtruth": "conta.getTipoDeConta();", "prediction": "1;\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "conta.getTipoDeConta();", "first_line_prediction": "1;", "match": 0}
{"groundtruth": "\"Titular: \" + conta.getTitular().getNome() + \" | CPF: \" + conta.imprimeCPF(conta.getCpf());", "prediction": " \"Nome: \" + conta.getTitular().getNome();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "\"Titular: \" + conta.getTitular().getNome() + \" | CPF: \" + conta.imprimeCPF(conta.getCpf());", "first_line_prediction": " \"Nome: \" + conta.getTitular().getNome();", "match": 0}
{"groundtruth": "conta.getAgencia().getNumAgencia() + \" | Conta: \" + conta.getNumConta();", "prediction": " conta.getAgencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "conta.getAgencia().getNumAgencia() + \" | Conta: \" + conta.getNumConta();", "first_line_prediction": " conta.getAgencia();", "match": 0}
{"groundtruth": "+ conta.imprimeCPF(conta.getCpf());", "prediction": " + conta.getCpf();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "+ conta.imprimeCPF(conta.getCpf());", "first_line_prediction": " + conta.getCpf();", "match": 0}
{"groundtruth": "+ conta.getAgencia().getNumAgencia() + \" | Conta: \" + conta.getNumConta();", "prediction": " + conta.getAgencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "+ conta.getAgencia().getNumAgencia() + \" | Conta: \" + conta.getNumConta();", "first_line_prediction": " + conta.getAgencia();", "match": 0}
{"groundtruth": "Extrato listaMovimentacao : conta.getlistaDeMovimentacoes()) {", "prediction": "int i = 0; i < 10; i++) {\n\t\t\t\tlinha = \"Dia: \" + i + \" | Valor: R$\" + conta.getSaldo(i);\n\t\t\t\tbw.append(linha + \"\\n\");\n\t\t\t}\n\t\t\tbw.append(\"\\n\");", "first_line_groundtruth": "Extrato listaMovimentacao : conta.getlistaDeMovimentacoes()) {", "first_line_prediction": "int i = 0; i < 10; i++) {", "match": 0}
{"groundtruth": "linha = \"Saldo: R$\" + String.format(\"%.2f\", conta.getSaldo());", "prediction": "\n\t\t\tlinha = \"Valor total de dep\u00f3sitos = R$\" + String.format(\"%.2f\", ((ContaCorrente) conta).getTotalDepositos());\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "linha = \"Saldo: R$\" + String.format(\"%.2f\", conta.getSaldo());", "first_line_prediction": "", "match": 0}
{"groundtruth": ") + \"_\" + conta.getTitular().getTipoDeUsuario();", "prediction": "conta.getTitular().getTipoDeUsuario());\n\t\tnew File(CAMINHO + \"\\\\\" + SUB_CAMINHO).mkdir();", "first_line_groundtruth": ") + \"_\" + conta.getTitular().getTipoDeUsuario();", "first_line_prediction": "conta.getTitular().getTipoDeUsuario());", "match": 0}
{"groundtruth": "= \"Agencia: \" + conta.getAgencia();", "prediction": " = \"Titular: \" + conta.getTitular().getNome() + \" | CPF: \" + conta.imprimeCPF(conta.getCpf());\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "= \"Agencia: \" + conta.getAgencia();", "first_line_prediction": " = \"Titular: \" + conta.getTitular().getNome() + \" | CPF: \" + conta.imprimeCPF(conta.getCpf());", "match": 0}
{"groundtruth": "linha = \"Tipo: \" + conta.getTipoDeConta();", "prediction": "\n\t\t\tlinha = \"Tipo: \" + conta.getTipoDeConta();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "linha = \"Tipo: \" + conta.getTipoDeConta();", "first_line_prediction": "", "match": 0}
{"groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteSaldo\";", "prediction": "conta.getCpf()) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteSaldo\";", "first_line_groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteSaldo\";", "first_line_prediction": "conta.getCpf()) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_comprovanteSaldo\";", "match": 0}
{"groundtruth": "String arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado\n\t\t\t\t+ \"_relatorioRendimentoPoupanca\";", "prediction": "\tString arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_\"\n\t\t\t\t\t+ \"rendimentDaPoupanca\";", "first_line_groundtruth": "String arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado", "first_line_prediction": "\tString arquivo = conta.getCpf() + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_\"", "match": 0}
{"groundtruth": "\"Saldo: R$\" + String.format(\"%.2f\", (conta.getSaldo()));", "prediction": " \"Saldo: R$\" + String.format(\"%.2f\", conta.getSaldo());\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "\"Saldo: R$\" + String.format(\"%.2f\", (conta.getSaldo()));", "first_line_prediction": " \"Saldo: R$\" + String.format(\"%.2f\", conta.getSaldo());", "match": 0}
{"groundtruth": "= \"Simula\u00e7\u00e3o para CPF: \" + conta.getCpf();", "prediction": " = \"CPF = \" + conta.getCpf();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "= \"Simula\u00e7\u00e3o para CPF: \" + conta.getCpf();", "first_line_prediction": " = \"CPF = \" + conta.getCpf();", "match": 0}
{"groundtruth": "\"Ag\u00eancia : \" + conta.getAgencia().getNumAgencia();", "prediction": " \"Ag\u00eancia: \" + conta.getAgencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "\"Ag\u00eancia : \" + conta.getAgencia().getNumAgencia();", "first_line_prediction": " \"Ag\u00eancia: \" + conta.getAgencia();", "match": 0}
{"groundtruth": "= \"Total gasto em transa\u00e7\u00f5es = R$\" + conta.getTotalTarifas();", "prediction": " = \"Tipo: \" + conta.getTipoDeConta();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "= \"Total gasto em transa\u00e7\u00f5es = R$\" + conta.getTotalTarifas();", "first_line_prediction": " = \"Tipo: \" + conta.getTipoDeConta();", "match": 0}
{"groundtruth": "\"%.2f\", ((ContaCorrente) conta).getTotalTarifas());", "prediction": "Locale.US, \"%.2f\", conta.getTotalGastoTributos());\n\t\t\t\tbw.append(linha + \"\\n\");\n\t\t\t}", "first_line_groundtruth": "\"%.2f\", ((ContaCorrente) conta).getTotalTarifas());", "first_line_prediction": "Locale.US, \"%.2f\", conta.getTotalGastoTributos());", "match": 0}
{"groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado\n\t\t\t\t+ \"_relatorioRendimentoPoupanca\";", "prediction": "cliente) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_\"\n\t\t\t\t\t+ \"rendimentDaPoupanca\";", "first_line_groundtruth": ") + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado", "first_line_prediction": "cliente) + \"_\" + conta.getAgencia() + \"_\" + hojeFormatado + \"_\"", "match": 0}
{"groundtruth": "linha = \"Taxa para deposito = \" + ContaCorrente.getTarifaDeposito();", "prediction": "\n\t\t\tlinha = \"Taxa para pagamento = \" + ContaCorrente.getTarifaPagamento();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "linha = \"Taxa para deposito = \" + ContaCorrente.getTarifaDeposito();", "first_line_prediction": "", "match": 0}
{"groundtruth": "= \"Taxa para saque = \" + ContaCorrente.getTarifaSaque();", "prediction": " = \"Total gasto em tributos = R$\" + String.format(\"%.2f\", conta.getTotalTarifas());\n\t\t\tbw.append(linha + \"\\n\\n\");", "first_line_groundtruth": "= \"Taxa para saque = \" + ContaCorrente.getTarifaSaque();", "first_line_prediction": " = \"Total gasto em tributos = R$\" + String.format(\"%.2f\", conta.getTotalTarifas());", "match": 0}
{"groundtruth": "= \"Taxa para tranfer\u00eancia = \" + ContaCorrente.getTarifaTransferencia();", "prediction": " = \"Taxa para transfer\u00eancia = \" + ContaCorrente.getTarifaTransferencia();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "= \"Taxa para tranfer\u00eancia = \" + ContaCorrente.getTarifaTransferencia();", "first_line_prediction": " = \"Taxa para transfer\u00eancia = \" + ContaCorrente.getTarifaTransferencia();", "match": 0}
{"groundtruth": "\"Total de saques realizados = \" + conta.getTotalSaques();", "prediction": " \"Taxa para deposito = \" + ContaCorrente.getTarifaDeposito();\n\t\t\tbw.append(linha + \"\\n\");", "first_line_groundtruth": "\"Total de saques realizados = \" + conta.getTotalSaques();", "first_line_prediction": " \"Taxa para deposito = \" + ContaCorrente.getTarifaDeposito();", "match": 0}
{"groundtruth": "main = CheckHostAPI.performGetRequest(\"https://check-host.net/check-result/\" + URLEncoder.encode(id, StandardCharsets.UTF_8));", "prediction": " main = performGetRequest(\"https://check-host.net/check-ping?id=\" + id);\n        if(!main.has(\"nodes\")) throw new IOException(\"Invalid response!\");\n        JsonObject nodes = main.get(\"nodes\").getAsJsonObject();\n        Map<CHServer, PingResult> results = new HashMap<>();\n        for(Entry<String, JsonElement> entry : nodes.entrySet()) {\n            JsonArray list = entry.getValue().getAsJsonArray();\n            for(JsonElement element : list) {\n                JsonObject object = element.getAsJsonObject();\n                String ip = object.get(\"ip\").getAsString();\n                int", "first_line_groundtruth": "main = CheckHostAPI.performGetRequest(\"https://check-host.net/check-result/\" + URLEncoder.encode(id, StandardCharsets.UTF_8));", "first_line_prediction": " main = performGetRequest(\"https://check-host.net/check-ping?id=\" + id);", "match": 0}
{"groundtruth": "\"Total de tranfer\u00eancias realizadas = \" + conta.getTotalTransferencias();", "prediction": " \"Total de transfer\u00eancias realizadas = \" + conta.getTotalTransferencias();\n\t\t\tbw.append(linha + \"\\n\\n\");", "first_line_groundtruth": "\"Total de tranfer\u00eancias realizadas = \" + conta.getTotalTransferencias();", "first_line_prediction": " \"Total de transfer\u00eancias realizadas = \" + conta.getTotalTransferencias();", "match": 0}
{"groundtruth": "cookieStore.appendCookies(builder).build();", "prediction": " cookieStore.appendCookies(builder);\n    }", "first_line_groundtruth": "cookieStore.appendCookies(builder).build();", "first_line_prediction": " cookieStore.appendCookies(builder);", "match": 0}
{"groundtruth": "cookieStore.mergeFromResponse(response);", "prediction": " cookieStore.merge(response.cookies());\n    }", "first_line_groundtruth": "cookieStore.mergeFromResponse(response);", "first_line_prediction": " cookieStore.merge(response.cookies());", "match": 0}
{"groundtruth": "new FXMLLoader(DownfallUtil.getInstance().getURLDownfallMainFXML());", "prediction": " new FXMLLoader(DownfallUtil.getInstance().getURLMainFXML());\n        loader.setController(new DungeonMasterController());\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n        stage.show();\n    }", "first_line_groundtruth": "new FXMLLoader(DownfallUtil.getInstance().getURLDownfallMainFXML());", "first_line_prediction": " new FXMLLoader(DownfallUtil.getInstance().getURLMainFXML());", "match": 0}
{"groundtruth": "selectedProperty()  .unbindBidirectional(tag.isFactionalProperty());", "prediction": "selectedProperty().unbindBidirectional(tag.isFactionalProperty());\n    }\n\n    /**\n     * Unbinds the properties of a given tag from all TextFields and CheckBoxes.\n     * @param tag Tag to be unbound.\n     */\n    private void displayTag(Tag tag) {\n        tagTextField.setText(tag.getTag());\n        isFactionalCheckBox.setSelected(tag.isFactional());\n    }\n\n    /**\n     * Binds the properties of a given tag to all TextFields and CheckBoxes.\n     * @param tag Tag to be bound.\n     */\n    private void bindTag(Tag tag) {", "first_line_groundtruth": "selectedProperty()  .unbindBidirectional(tag.isFactionalProperty());", "first_line_prediction": "selectedProperty().unbindBidirectional(tag.isFactionalProperty());", "match": 0}
{"groundtruth": ", null, null, defConstructionCost, null, defConstructionTime, operatesImmediately, Configurator.getInstance().getDefBuildingGFXPathname());", "prediction": ", -1, -1, defConstructionCost, defConstructionTime, operatesImmediately);\n    }\n\n    /**\n     *\n     * @param id unique identifier used to differentiate different templates\n     * @param name a human-readable name of the template.\n     * @param inputMaterials a list of input materials that are used in production in this building per turn\n     * @param outputMaterials a list of output materials that are produced in this building per turn\n     * @param defConstructionCost construction cost per turn of construction\n     * @param constructionMaterials a list of materials consumed during construction per turn of construction\n     * @param def", "first_line_groundtruth": ", null, null, defConstructionCost, null, defConstructionTime, operatesImmediately, Configurator.getInstance().getDefBuildingGFXPathname());", "first_line_prediction": ", -1, -1, defConstructionCost, defConstructionTime, operatesImmediately);", "match": 0}
{"groundtruth": ").setUserRealm(savegame.getUserRealm());", "prediction": "savegame.getRules()).loadRules(savegame.getRulesPathname());\n            Configurator.getInstance().setLastSavegamePathname(new PathRelativisor(pathname).relativize());\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING,\"Savegame loading failed, attempting to save a default savegame\");\n            saveTo(pathname);\n        }\n    }\n\n    /**\n     * Saves the current state of the Configurator to the last pathname used.\n     */\n    @Override\n    public void saveToLast", "first_line_groundtruth": ").setUserRealm(savegame.getUserRealm());", "first_line_prediction": "savegame.getRules()).loadRules(savegame.getRulesPathname());", "match": 0}
{"groundtruth": ").loadAndApplyRules(savegame.getPathToRules());", "prediction": "savegame.getUserRealm()).setLastSavegamePathname(new PathRelativisor(pathname).relativize());\n            Configurator.getInstance(savegame.getUserRealm()).setLastRulesPathname(new PathRelativisor(pathname).relativize());\n\n            Rules rules = Configurator.getInstance(savegame.getUserRealm()).getRules();\n            if (rules != null) {\n                Configurator.getInstance(savegame.getUserRealm()).setRules(rules);\n            }\n        } catch (JAXBException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Logger.getLogger(DownfallUtil.DEFAULT_LOGGER).log(", "first_line_groundtruth": ").loadAndApplyRules(savegame.getPathToRules());", "first_line_prediction": "savegame.getUserRealm()).setLastSavegamePathname(new PathRelativisor(pathname).relativize());", "match": 0}
{"groundtruth": "this.pathToGFXProperty.setValue(Configurator.getInstance().getDefBuildingGFXPathname());", "prediction": " this.GFX = null;\n    }\n\n    /**\n     *\n     * @return String pathname to an image file that represents this building. That Image should be square, but isn't required to be square\n     */\n    @XmlElement(name=\"path-to-gfx\")\n    public String getPathToGFX() {\n        return this.pathToGFXProperty.getValue();\n    }\n\n    /**\n     *\n     * @return JavaFX Image that represents this building. That Image should be square, but isn't required to be square\n     */\n    public Image getGFX() {\n        if(!this.gfxInitialized) {\n            this.GFX = new", "first_line_groundtruth": "this.pathToGFXProperty.setValue(Configurator.getInstance().getDefBuildingGFXPathname());", "first_line_prediction": " this.GFX = null;", "match": 0}
{"groundtruth": "configurator.loadAndApplyRules();", "prediction": "\n\n        FXMLLoader loader = new FXMLLoader(DownfallMain.class.getResource(\"/fxml/main/main.fxml\"));\n        loader.setController(new DownfallMainController(configurator));\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n        stage.initStyle(StageStyle.UNDECORATED);\n        stage.show();\n    }", "first_line_groundtruth": "configurator.loadAndApplyRules();", "first_line_prediction": "", "match": 0}
{"groundtruth": "configurator.saveRules();", "prediction": " configurator.saveConfiguration();\n             configurator.saveRules();\n        });\n\n        FXMLLoader loader = new FXMLLoader(DownfallMain.class.getResource(\"/fxml/main/DownfallMain.fxml\"));\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n\n        stage.show();\n    }", "first_line_groundtruth": "configurator.saveRules();", "first_line_prediction": " configurator.saveConfiguration();", "match": 0}
{"groundtruth": ".getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.SEVERE, \"No Template found for id = \"+material.getTemplateId());", "prediction": ".getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"No ID found for template with id = \"+material.getTemplateId());\n        }\n        return list.get(0);\n    }", "first_line_groundtruth": ".getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.SEVERE, \"No Template found for id = \"+material.getTemplateId());", "first_line_prediction": ".getLogger(DownfallUtil.DEFAULT_LOGGER).log(Level.WARNING, \"No ID found for template with id = \"+material.getTemplateId());", "match": 0}
{"groundtruth": "= Configurator.getInstance();", "prediction": " = Configurator.getInstance();\n        configurator.load();\n        configurator.loadRules();\n        configurator.loadActorTags();\n        configurator.loadActorMaterials();\n        configurator.loadActorVisuals();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.loadActorVisualTemplates();\n        configurator.", "first_line_groundtruth": "= Configurator.getInstance();", "first_line_prediction": " = Configurator.getInstance();", "match": 0}
{"groundtruth": ", defImportPrice, isExportable, isEphemeral, Configurator.getInstance().getDefMaterialGFXPathname());", "prediction": ", defImportPrice, isExportable, isEphemeral, Configurator.getMaterialGFXPathname());\n    }\n\n    /**\n     * Initializes pathToGFX to the default MaterialGFXPathname defined in the current configuration.\n     * @param name Human-readable name of the materials to be generated with this template\n     * @param id Unique identifier used to differentiate different material templates\n     * @param defExportPrice Default export price\n     * @param defImportPrice Default import price\n     * @param isExportable Value that determines if the material will be exportable from the realm\n     * @param isEphemeral Value that determines if the", "first_line_groundtruth": ", defImportPrice, isExportable, isEphemeral, Configurator.getInstance().getDefMaterialGFXPathname());", "first_line_prediction": ", defImportPrice, isExportable, isEphemeral, Configurator.getMaterialGFXPathname());", "match": 0}
{"groundtruth": "DownfallUtil.getInstance().loadImage(item));", "prediction": "DownfallUtil.getImage(item));\n                        super.updateItem(item, empty);\n                    } else {\n                        super.updateItem(item, empty);\n                    }\n                }\n            };\n            return cell;\n        });\n    }", "first_line_groundtruth": "DownfallUtil.getInstance().loadImage(item));", "first_line_prediction": "DownfallUtil.getImage(item));", "match": 0}
{"groundtruth": "()  .bindBidirectional(tag.isFactionalProperty());", "prediction": "()  .bindBidirectional(tag.isFactionalProperty());\n    }", "first_line_groundtruth": "()  .bindBidirectional(tag.isFactionalProperty());", "first_line_prediction": "()  .bindBidirectional(tag.isFactionalProperty());", "match": 1}
{"groundtruth": ".unbindBidirectional(tag.tagProperty());", "prediction": " .unbindBidirectional(tag.tagProperty());\n        isFactionalCheckBox.selectedProperty().unbindBidirectional(tag.isFactionalProperty());\n    }\n\n    /**\n     * Binds the properties of a given tag to all TextFields and CheckBoxes.\n     * @param tag Tag to be displayed.\n     */\n    private void displayTag(Tag tag) {\n        tagTextField.setText(tag.getTag());\n        isFactionalCheckBox.setSelected(tag.isFactional());\n    }\n\n    /**\n     * Unbinds the properties of a given tag from all TextFields and CheckBoxes.\n     * @param tag Tag to", "first_line_groundtruth": ".unbindBidirectional(tag.tagProperty());", "first_line_prediction": " .unbindBidirectional(tag.tagProperty());", "match": 0}
{"groundtruth": "(relativisor.relativize());", "prediction": "(relativisor.relativize(DownfallUtil.getInstallationDirectory()));\n                }\n        });\n    }", "first_line_groundtruth": "(relativisor.relativize());", "first_line_prediction": "(relativisor.relativize(DownfallUtil.getInstallationDirectory()));", "match": 0}
{"groundtruth": "tag.setTag(\"New Tag\");", "prediction": " tag.setTag(\"New Tag\");\n         return tag;\n    }", "first_line_groundtruth": "tag.setTag(\"New Tag\");", "first_line_prediction": " tag.setTag(\"New Tag\");", "match": 0}
{"groundtruth": "Configurator.getInstance().getUserRealm();", "prediction": " Configurator.getInstance().getUserRealm();\n        realmNameLabel.setText(userRealm.getName());\n        realmImageView.setImage(new Image(userRealm.getRealmImagePath()));\n        realmPane.setPrefHeight(IMAGE_PANE_HEIGHT + IMAGE_PANE_GAP);\n        realmPane.setPrefWidth(IMAGE_PANE_HEIGHT + IMAGE_PANE_GAP);\n        realmPane.setMinHeight(IMAGE_PANE_HEIGHT + IMAGE_PANE_GAP);\n        realmPane.setMinWidth(IMAGE_PANE_HEIGHT + IMAGE_PANE_GAP);\n        realmPane.", "first_line_groundtruth": "Configurator.getInstance().getUserRealm();", "first_line_prediction": " Configurator.getInstance().getUserRealm();", "match": 0}
{"groundtruth": "tag.setId(1);", "prediction": " tag.setId(1);\n        tag.setTag(\"New Tag\");\n        return tag;\n    }", "first_line_groundtruth": "tag.setId(1);", "first_line_prediction": " tag.setId(1);", "match": 0}
{"groundtruth": ".setText(userRealm.getDiplomaticReputation().toString());", "prediction": " .setText(userRealm.getDiplomaticReputation());\n        prestigeLabel            .setText(userRealm.getPrestige());\n        legitimacyLabel          .setText(userRealm.getLegitimacy());\n        powerProjectionLabel     .setText(userRealm.getPowerProjection());\n        nuicpLabel               .setText(userRealm.getNuicp());\n        govRankLabel             .setText(userRealm.getGovernmentRank());\n        infamyLabel              .setText(userRealm.getInfamy());\n        nationalUnrestLabel      .setText(userRealm.getNationalUnrest());", "first_line_groundtruth": ".setText(userRealm.getDiplomaticReputation().toString());", "first_line_prediction": " .setText(userRealm.getDiplomaticReputation());", "match": 0}
{"groundtruth": "(s -> s.gameVersion().equals(gameVersion)).toList();", "prediction": "(s -> s.gameVersion().equals(gameVersion)).toList();\n    }", "first_line_groundtruth": "(s -> s.gameVersion().equals(gameVersion)).toList();", "first_line_prediction": "(s -> s.gameVersion().equals(gameVersion)).toList();", "match": 1}
{"groundtruth": "BCVersion.fromString(versionIdentifier);", "prediction": " BCVersion.fromIdentifier(versionIdentifier);\n\n            if (version == null) {\n                continue;\n            }\n\n            final String gameVersion = urlParts[2];\n            final int playerCount = Integer.parseInt(urlParts[1]);\n            final int playerLimit = Integer.parseInt(urlParts[1]);\n            final boolean onlineMode = true;\n\n            servers.add(new BCServerInfo(\n                    serverElement.text(),\n                    playerCount,\n                    playerLimit,\n                    host,\n                    port,\n                    version,\n                    onlineMode,\n                    joinUrl,\n                    gameVersion\n            ));\n        }\n\n        return new BCServerList(servers);", "first_line_groundtruth": "BCVersion.fromString(versionIdentifier);", "first_line_prediction": " BCVersion.fromIdentifier(versionIdentifier);", "match": 0}
{"groundtruth": "configurator.loadConfiguration();", "prediction": " // load the fxml file and create a new stage for the editor\n        FXMLLoader loader = new FXMLLoader(DownfallMain.class.getResource(\"/fxml/main/DownfallMain.fxml\"));\n        loader.setControllerFactory(param -> {\n            DownfallMainController controller = new DownfallMainController();\n            controller.setStage(stage);\n            return controller;\n        });\n        Scene scene = new Scene(loader.load());\n        stage.setScene(scene);\n        stage.initStyle(StageStyle.UNDECORATED);\n        stage.show();\n    }", "first_line_groundtruth": "configurator.loadConfiguration();", "first_line_prediction": " // load the fxml file and create a new stage for the editor", "match": 0}
{"groundtruth": ".setValue(template.getId());", "prediction": ".setValue(template.getId());\n        amountProperty.setValue(amount);\n    }\n\n    /**\n     *\n     * @return Unique identifier used to differentiate different material templates\n     */\n    @XmlElement\n    public IntegerProperty idProperty() {\n        return idProperty;\n    }\n\n    /**\n     *\n     * @return Amount of materials in this bundle.\n     */\n    @XmlElement\n    public IntegerProperty amountProperty() {\n        return amountProperty;\n    }\n\n    /**\n     *\n     * @return Template from which this material will be generated from\n     */\n    @XmlElement\n    public MaterialTemplate getTemplate() {\n        return Realm.getInstance().getTemplate(", "first_line_groundtruth": ".setValue(template.getId());", "first_line_prediction": ".setValue(template.getId());", "match": 1}
{"groundtruth": "joinServerInterface.sendAuthRequest(sha1(server.getBytes()));", "prediction": " final String response = WebRequests.HTTP_CLIENT.send(GET_MP_PASS, HttpResponse.BodyHandlers.ofString()).join().body();\n             final Scanner scanner = new Scanner(response);\n             scanner.useDelimiter(\"\\\\|\");\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next();\n             scanner.next", "first_line_groundtruth": "joinServerInterface.sendAuthRequest(sha1(server.getBytes()));", "first_line_prediction": " final String response = WebRequests.HTTP_CLIENT.send(GET_MP_PASS, HttpResponse.BodyHandlers.ofString()).join().body();", "match": 0}
{"groundtruth": "= FXCollections.observableList(Configurator.getInstance().getRules().getActorTags());", "prediction": " = FXCollections.observableList(Configurator.getInstance().getRules().getTags());\n\n        //Configuring Tag Editor\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Tag\"));\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Description\"));\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Is Factional\"));\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Is Non-Factional\"));\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Is Non-Player\"));\n        tagTableEditor.setTableHeader(new TableColumn<>(\"Is", "first_line_groundtruth": "= FXCollections.observableList(Configurator.getInstance().getRules().getActorTags());", "first_line_prediction": " = FXCollections.observableList(Configurator.getInstance().getRules().getTags());", "match": 0}
{"groundtruth": "legitimacyLabel         .setText(userRealm.getLegitimacy().toString());", "prediction": "\n\n        //update ImageViews\n        realmImageView.setImage(new Image(DownfallUtil.getResourcePath(userRealm.getRealmImagePath())));\n        dynastyImageView.setImage(new Image(DownfallUtil.getResourcePath(userRealm.getDynastyImagePath())));\n\n        //update stability\n        stabilityCirclePane.setPrefSize(IMAGE_PANE_HEIGHT, IMAGE_PANE_HEIGHT);\n        stabilityCirclePane.setMinSize(IMAGE_PANE_HEIGHT, IMAGE_PANE_HEIGHT);\n        stabilityCirclePane.setMaxSize(IMAGE_PANE_HEIGHT, IMAGE_PANE_HEIGHT);\n       ", "first_line_groundtruth": "legitimacyLabel         .setText(userRealm.getLegitimacy().toString());", "first_line_prediction": "", "match": 0}
{"groundtruth": ".pathToGFXProperty.setValue(Configurator.getInstance().getDefMaterialGFXPathname());", "prediction": ".pathToGFXProperty.setValue(Configurator.getInstance().getDefMaterialGFXPathname());\n    }\n\n    /**\n     * Lightweight Accessor Method\n     * @return pathname to an image file that represents this material. That Image should be square, but isn't required to be square\n     */\n    @XmlElement(name = \"pathToGFX\")\n    public String getPathToGFX() {\n        return pathToGFXProperty.get();\n    }\n\n    /**\n     * Lightweight Mutator Method\n     * @param pathToGFX String pathname to an image file that represents this material. That Image should be square, but isn't required to be", "first_line_groundtruth": ".pathToGFXProperty.setValue(Configurator.getInstance().getDefMaterialGFXPathname());", "first_line_prediction": ".pathToGFXProperty.setValue(Configurator.getInstance().getDefMaterialGFXPathname());", "match": 1}
{"groundtruth": "setLegitimacy(realm.getLegitimacy());", "prediction": "setPrestige(realm.getPrestige());\n        userRealm.setGouvernmentRank(realm.getGouvernmentRank());\n        userRealm.setRealmPathToGFX(realm.getRealmPathToGFX());\n        userRealm.setRulerPathToGFX(realm.getRulerPathToGFX());\n        userRealm.setRealmPathToRules(realm.getRealmPathToRules());\n        userRealm.setRulerPathToRules(realm.getRulerPathToRules());\n        userRealm.setRealmPathToRules(realm.getRealmPathToRules());\n        user", "first_line_groundtruth": "setLegitimacy(realm.getLegitimacy());", "first_line_prediction": "setPrestige(realm.getPrestige());", "match": 0}
{"groundtruth": "prompter.findCommand(commandText, commands);", "prediction": "\tcommands.get().stream()\n\t\t\t\t.filter(c -> c.getName().equals(commandText))\n\t\t\t\t.findFirst()\n\t\t\t\t.orElse(createErrorCommand(\"No response\"));", "first_line_groundtruth": "prompter.findCommand(commandText, commands);", "first_line_prediction": "\tcommands.get().stream()", "match": 0}
{"groundtruth": ", prompter.getSystemPrompt(commands));", "prediction": " + \" \", userInput);\n\t\tmessages.add(systemMessage);\n\t\treturn messages;", "first_line_groundtruth": ", prompter.getSystemPrompt(commands));", "first_line_prediction": " + \" \", userInput);", "match": 0}
{"groundtruth": "userRealm.setPowerProjection(realm.getPowerProjection());", "prediction": " userRealm.setPrestige(realm.getPrestige());\n        userRealm.setGouvernmentRank(realm.getGouvernmentRank());\n        userRealm.setRealmPathToGFX(realm.getRealmPathToGFX());\n        userRealm.setRulerPathToGFX(realm.getRulerPathToGFX());\n        userRealm.setVisualMaterialTemplates(realm.getVisualMaterialTemplates());\n        userRealm.setVisualBuildingTemplates(realm.getVisualBuildingTemplates());\n        userRealm.setVisualMaterialTemplates(realm.getVisualMaterialTemplates());\n        userRealm.setVisual", "first_line_groundtruth": "userRealm.setPowerProjection(realm.getPowerProjection());", "first_line_prediction": " userRealm.setPrestige(realm.getPrestige());", "match": 0}
{"groundtruth": "return DEFAULT_SYSTEM_PROMPT.replaceAll(PREFIX_TEMPLATE, delimiter.getPrefix())//\n\t\t\t\t.replaceAll(POSTFIX_TEMPLATE, delimiter.getPostfix());", "prediction": "\treturn DEFAULT_SYSTEM_PROMPT.replace(PREFIX_TEMPLATE, delimiter.getPrefix()) //\n\t\t\t\t\t.replace(POSTFIX_TEMPLATE, delimiter.getPostfix()) //\n\t\t\t\t\t.replace(COMMAND_LIST_TEMPLATE, getCommandListTemplate(delimiter));", "first_line_groundtruth": "return DEFAULT_SYSTEM_PROMPT.replaceAll(PREFIX_TEMPLATE, delimiter.getPrefix())//", "first_line_prediction": "\treturn DEFAULT_SYSTEM_PROMPT.replace(PREFIX_TEMPLATE, delimiter.getPrefix()) //", "match": 0}
{"groundtruth": "loadAndApplyRules(configuration.getLastRulesPathname());", "prediction": " loadAndApplyRules(configuration.getLastRulesPathname().get());\n    }\n\n    /**\n     * loads and applies rules stored as lastLoadedRules in the current configuration\n     * @param pathname the path to the rules file\n     */\n    public void loadAndApplyRules(String pathname) {\n        try {\n            rules = loadRules(pathname);\n            Configurator.getInstance().applyRules(rules);\n        } catch (IOException | JAXBException ex) {\n            Logger.getLogger(Configurator.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    /**\n     * loads the rules from the given pathname\n     *", "first_line_groundtruth": "loadAndApplyRules(configuration.getLastRulesPathname());", "first_line_prediction": " loadAndApplyRules(configuration.getLastRulesPathname().get());", "match": 0}
{"groundtruth": ".setRulerPathToGFX(realm.getRulerPathToGFX());", "prediction": ".setRealmPathToRules(realm.getRealmPathToRules());\n        userRealm.setRealmPathToMaterials(realm.getRealmPathToMaterials());\n        userRealm.setRealmPathToBuildings(realm.getRealmPathToBuildings());\n        userRealm.setRealmPathToBuildingsTemplates(realm.getRealmPathToBuildingsTemplates());\n        userRealm.setRealmPathToMaterialsTemplates(realm.getRealmPathToMaterialsTemplates());\n        userRealm.setRealmPathToRulesTemplates(realm.getRealmPathToRulesTemplates());\n        userRealm.setRealmPathToRulesTemplates(realm.", "first_line_groundtruth": ".setRulerPathToGFX(realm.getRulerPathToGFX());", "first_line_prediction": ".setRealmPathToRules(realm.getRealmPathToRules());", "match": 0}
{"groundtruth": "return commandWrapper.unwrapCommand(commandString);", "prediction": "\treturn commandString.replace(commandWrapper.getPrefix(), \"\").replace(commandWrapper.getPostfix(), \"\");", "first_line_groundtruth": "return commandWrapper.unwrapCommand(commandString);", "first_line_prediction": "\treturn commandString.replace(commandWrapper.getPrefix(), \"\").replace(commandWrapper.getPostfix(), \"\");", "match": 0}
{"groundtruth": ".textProperty()        .bindBidirectional(realm.diplomaticReputationProperty(),    new NumberStringConverter());", "prediction": ".textProperty()         .bindBidirectional(realm.diplomaticReputationProperty(), new NumberStringConverter());\n        prestigeTextField.textProperty()          .bindBidirectional(realm.prestigeProperty(),             new NumberStringConverter());\n        legitimacyTextField.textProperty()       .bindBidirectional(realm.legitimacyProperty(),          new NumberStringConverter());\n        powerProjectionTextField.textProperty()   .bindBidirectional(realm.powerProjectionProperty(),     new NumberStringConverter());\n        infamyTextField.textProperty()            .bindBidirectional(realm.infamyProperty(),               new", "first_line_groundtruth": ".textProperty()        .bindBidirectional(realm.diplomaticReputationProperty(),    new NumberStringConverter());", "first_line_prediction": ".textProperty()         .bindBidirectional(realm.diplomaticReputationProperty(), new NumberStringConverter());", "match": 0}
{"groundtruth": "textProperty()        .bindBidirectional(realm.prestigeProperty(),                new NumberStringConverter());", "prediction": "textProperty()         .bindBidirectional(realm.prestigeProperty(),                new NumberStringConverter());\n        stabilityTextField.textProperty()         .bindBidirectional(realm.stabilityProperty(),                new NumberStringConverter());\n        infamyTextField.textProperty()           .bindBidirectional(realm.infamyProperty(),                  new NumberStringConverter());\n        rulerGFXTextField.textProperty()         .bindBidirectional(realm.rulerGFXProperty());\n        realmGFXTextField.textProperty()          .bindBidirectional(realm.realmGFXProperty());\n\n        //bind buttons\n        realmGFXButton.imageProperty()           .", "first_line_groundtruth": "textProperty()        .bindBidirectional(realm.prestigeProperty(),                new NumberStringConverter());", "first_line_prediction": "textProperty()         .bindBidirectional(realm.prestigeProperty(),                new NumberStringConverter());", "match": 0}
{"groundtruth": "BCServerListRequest.send().whenComplete((bcServerList, throwable) -> {", "prediction": " BCServerListRequest.send().whenComplete((bcServerList, throwable) -> {\n             if (throwable != null) {\n                 throwableConsumer.accept(throwable);\n                 return;\n             }\n             complete.accept(bcServerList);\n         });\n    }", "first_line_groundtruth": "BCServerListRequest.send().whenComplete((bcServerList, throwable) -> {", "first_line_prediction": " BCServerListRequest.send().whenComplete((bcServerList, throwable) -> {", "match": 0}
{"groundtruth": "authenticationData = new CCAuthenticationData(account.username(), account.password(), previousResponse.token, loginCode);", "prediction": " data = new CCAuthenticationData(account.username, account.password, loginCode);\n            final HttpRequest request = WebRequests.buildWithCookies(account.cookieStore, HttpRequest.newBuilder().POST(WebRequests.BodyPublishers.ofString(data.toString())).uri(ClassiCubeHandler.AUTHENTICATION_LOGIN_URI));\n            final HttpResponse<String> response = WebRequests.HTTP_CLIENT.sendAsync(request, HttpResponse.BodyHandlers.ofString()).join();\n            WebRequests.updateCookies(account.cookieStore, response);\n            return new CCAuthenticationResponse(response.headers().map(), response.", "first_line_groundtruth": "authenticationData = new CCAuthenticationData(account.username(), account.password(), previousResponse.token, loginCode);", "first_line_prediction": " data = new CCAuthenticationData(account.username, account.password, loginCode);", "match": 0}
{"groundtruth": "textProperty()       .bindBidirectional(materialTemplate.pathToGFXProperty());", "prediction": "textProperty()        .bindBidirectional(materialTemplate.pathToGFXProperty());\n        exportPriceTextField.textProperty()      .bindBidirectional(materialTemplate.defExportPriceProperty());\n        importPriceTextField.textProperty()      .bindBidirectional(materialTemplate.defImportPriceProperty());\n    }\n\n    /**\n     * Validates the material template to ensure that the user has not entered invalid data.\n     * @param materialTemplate template to be validated.\n     * @return true if the material template is valid, false otherwise.\n     */\n    private boolean validateMaterial(VisualMaterialTemplate materialTemplate) {\n        return materialTemplate", "first_line_groundtruth": "textProperty()       .bindBidirectional(materialTemplate.pathToGFXProperty());", "first_line_prediction": "textProperty()        .bindBidirectional(materialTemplate.pathToGFXProperty());", "match": 0}
{"groundtruth": "<>(\"login_code\", authenticationData.loginCode())\n            );", "prediction": "<>(\"loginCode\", authenticationData.loginCode())\n            );\n\n            final HttpRequest request = WebRequests.createRequest(\n                    \"https://classicube.net/api/auth/login\",\n                    \"POST\",\n                    requestBody\n            );\n\n            final HttpResponse<String> response = ClassiCubeHandler.sendRequest(request);\n\n            return CCAuthenticationResponse.fromJson(response.body());\n        });\n    }", "first_line_groundtruth": "<>(\"login_code\", authenticationData.loginCode())", "first_line_prediction": "<>(\"loginCode\", authenticationData.loginCode())", "match": 0}
{"groundtruth": ", account.password(), previousResponse.token, loginCode);", "prediction": " + \":\" + account.password());\n            final HttpRequest request = WebRequests.buildWithCookies(account.cookieStore, HttpRequest.newBuilder().POST(HttpRequest.BodyPublishers.ofString(authenticationData.toString())).uri(ClassiCubeHandler.AUTHENTICATION_LOGIN_URI));\n            final HttpResponse<String> response = WebRequests.HTTP_CLIENT.sendAsync(request, HttpResponse.BodyHandlers.ofString()).join();\n            WebRequests.updateCookies(account.cookieStore, response);\n            if (response.statusCode() == 200) {\n                final String cookie = response.headers().firstValue(\"", "first_line_groundtruth": ", account.password(), previousResponse.token, loginCode);", "first_line_prediction": " + \":\" + account.password());", "match": 0}
{"groundtruth": ".textProperty()        .bindBidirectional(realm.rulerPathToGFXProperty());", "prediction": ".textProperty()         .bindBidirectional(realm.rulerPathToGFXProperty());\n\n        //bind buttons\n        realmGFXButton.imageProperty().bindBidirectional(realm.realmPathToGFXProperty());\n        rulerGFXButton.imageProperty().bindBidirectional(realm.rulerPathToGFXProperty());\n\n        //bind tables\n        stockpileEditor.setTable(FXCollections.observableArrayList(realm.getStockpile()));\n        stockpileEditor.addColumn(new LogoTableColumn(STOCKPILE_NAME_COLUMN_NAME, Material::getName));\n        stockpileEditor.addColumn(new Logo", "first_line_groundtruth": ".textProperty()        .bindBidirectional(realm.rulerPathToGFXProperty());", "first_line_prediction": ".textProperty()         .bindBidirectional(realm.rulerPathToGFXProperty());", "match": 0}
{"groundtruth": ".textProperty()        .bindBidirectional(realm.realmPathToGFXProperty());", "prediction": ".textProperty()         .bindBidirectional(realm.pathToGFXProperty());\n        rulerGFXTextField.textProperty()         .bindBidirectional(realm.rulerPathToGFXProperty());\n\n        //bind table editors\n        stockpileEditor.setTable(FXCollections.observableArrayList(realm.getStockpile()));\n        stockpileEditor.setColumn(new LogoTableColumn(STOCKPILE_NAME_COLUMN_NAME, Material::getName));\n        stockpileEditor.setColumn(new LogoTableColumn(STOCKPILE_AMOUNT_COLUMN_NAME, Material::getAmount));\n\n        tagEditor", "first_line_groundtruth": ".textProperty()        .bindBidirectional(realm.realmPathToGFXProperty());", "first_line_prediction": ".textProperty()         .bindBidirectional(realm.pathToGFXProperty());", "match": 0}
{"groundtruth": "StatusBarHelper.setStatusBarLightMode(this);", "prediction": " break;\n            case R.id.btn_2:\n                StatusBarHelper.setStatusBarLightMode(this);\n                break;\n            case R.id.btn_3:\n                StatusBarHelper.setStatusBarDarkMode(this);\n                break;\n            case R.id.btn_4:\n                StatusBarHelper.setStatusBarLightMode(this);\n                break;\n            case R.id.btn_5:\n                StatusBarHelper.setStatusBarDarkMode(this);\n                break;\n            case R.id.btn_6:\n                StatusBarHelper.setStatusBarLightMode(this);\n                break;\n           ", "first_line_groundtruth": "StatusBarHelper.setStatusBarLightMode(this);", "first_line_prediction": " break;", "match": 0}
{"groundtruth": "product0 = productRepository.findById(id);", "prediction": " productModel = productRepository.findById(id);\n        if (productModel.isEmpty()) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Produto nao encontrado\");\n        }\n        return ResponseEntity.status(HttpStatus.OK).body(productModel.get());\n    }", "first_line_groundtruth": "product0 = productRepository.findById(id);", "first_line_prediction": " productModel = productRepository.findById(id);", "match": 0}
{"groundtruth": "StatusBarHelper.translucent(this);", "prediction": " titleBar2.setBackgroundColor(Color.RED);\n                break;\n            case R.id.btn_2:\n                titleBar2.setBackgroundColor(Color.GREEN);\n                break;\n            case R.id.btn_3:\n                titleBar2.setBackgroundColor(Color.BLUE);\n                break;\n            case R.id.btn_4:\n                titleBar2.setBackgroundColor(Color.YELLOW);\n                break;\n            case R.id.btn_5:\n                titleBar2.setBackgroundColor(Color.CYAN);\n                break;\n            case R.id.btn_6:\n                titleBar", "first_line_groundtruth": "StatusBarHelper.translucent(this);", "first_line_prediction": " titleBar2.setBackgroundColor(Color.RED);", "match": 0}
{"groundtruth": "user0 = userRepository.findByIdentifier(identifier);", "prediction": " user0 = userRepository.findByIdentifier(identifier);\n        if (user0 == null) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"usuario nao encontrado\");\n        }\n        return ResponseEntity.status(HttpStatus.OK).body(user0);\n    }", "first_line_groundtruth": "user0 = userRepository.findByIdentifier(identifier);", "first_line_prediction": " user0 = userRepository.findByIdentifier(identifier);", "match": 0}
{"groundtruth": "d(\"TitleBar\",\"onCreate-getStatusbarHeight\"+StatusBarHelper.getStatusbarHeight(this));", "prediction": "e(\"MainActivity\", \"onCreate: \" + titleBar2.getBackgroundColor());\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2.setBackgroundColor(Color.RED);\n        titleBar2", "first_line_groundtruth": "d(\"TitleBar\",\"onCreate-getStatusbarHeight\"+StatusBarHelper.getStatusbarHeight(this));", "first_line_prediction": "e(\"MainActivity\", \"onCreate: \" + titleBar2.getBackgroundColor());", "match": 0}
{"groundtruth": "== null || !Objects.equals(user0.getPassword(), senha)) {", "prediction": " == null) {\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"Usu\u00e1rio n\u00e3o encontrado\");\n        }\n\n        if (!senha.equals(user0.getPassword())) {\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"Senha incorreta\");\n        }\n\n        UserModel user = new UserModel();\n        BeanUtils.copyProperties(user0, user);\n        return ResponseEntity.ok(user);\n    }\n\n    /**\n     * Metodo/Rota responsavel por realizar o cadastro do usuario\n     * @param userRecordDto - DTO que contem os dados do", "first_line_groundtruth": "== null || !Objects.equals(user0.getPassword(), senha)) {", "first_line_prediction": " == null) {", "match": 0}
{"groundtruth": "user0 = userRepository.findByEmail(email);", "prediction": " user = userRepository.findByEmail(email);\n        if(user == null){\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"usuario nao encontrado.\");\n        }\n        if(!senha.equals(user.getPassword())){\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"senha incorreta.\");\n        }\n        return ResponseEntity.status(HttpStatus.OK).body(user);\n    }\n\n    /**\n     * Metodo/Rota responsavel por realizar o cadastro do usuario\n     * @param userRecordDto - DTO que contem os dados do usuario para realizar o cad", "first_line_groundtruth": "user0 = userRepository.findByEmail(email);", "first_line_prediction": " user = userRepository.findByEmail(email);", "match": 0}
{"groundtruth": ".OK).body(userRepository.findByIdentifier(identifier));", "prediction": ".OK).body(user0);\n    }", "first_line_groundtruth": ".OK).body(userRepository.findByIdentifier(identifier));", "first_line_prediction": ".OK).body(user0);", "match": 0}
{"groundtruth": "(plugin.getParticleManager(), lobbyParticles, player);", "prediction": "(this, lobbyParticles, player);\n        playParticleRunnableHashMap.put(player.getUniqueId(), playParticleRunnable);\n        plugin.getServer().getScheduler().runTaskAsynchronously(plugin, playParticleRunnable);\n    }\n\n    /**\n     * Remove a particle from the player.\n     * @param player Player\n     */\n    public void removeParticleFromPlayer(Player player) {\n        playerLobbyParticles.remove(player.getUniqueId());\n        if (playParticleRunnableHashMap.containsKey(player.getUniqueId())) {\n            playParticleRunnableHashMap.get(player.getUniqueId()).cancel();\n            playParticleRunnableHashMap.remove", "first_line_groundtruth": "(plugin.getParticleManager(), lobbyParticles, player);", "first_line_prediction": "(this, lobbyParticles, player);", "match": 0}
{"groundtruth": "DiscordVerifier.getInstance().getConfig().getBoolean(\"code-numbers-only\")) {", "prediction": "length < 1) {\n            return VOID_FUTURE;\n        }\n        return generateString(length);\n    }\n\n    /**\n     * Gets the code from the specified {@link UUID}\n     * @param uuid The {@link UUID} of the player\n     * @return The code of the player\n     */\n    public static @NotNull String get(@NotNull UUID uuid) {\n        return DiscordVerifier.getDiscordCodes().get(uuid).getLeft();\n    }\n\n    /**\n     * Gets the code from the specified {@link UUID}\n     * @param uuid The {@link UUID} of the player\n     * @return The code of", "first_line_groundtruth": "DiscordVerifier.getInstance().getConfig().getBoolean(\"code-numbers-only\")) {", "first_line_prediction": "length < 1) {", "match": 0}
{"groundtruth": "DiscordVerifier.getInstance().getLogger().severe(\"Failed to save player \" + uuid + \" to database\");", "prediction": " }\n        });\n        return future;\n    }\n\n    /**\n     * Gets the discord ID of a player\n     * @param uuid The UUID of the player\n     * @return The discord ID of the player\n     */\n    public static @NotNull String getDiscordId(final @NotNull UUID uuid) {\n        return DiscordVerifier.getDiscordCodes().get(uuid);\n    }\n\n    /**\n     * Gets the discord ID of a player\n     * @param uuid The UUID of the player\n     * @return The discord ID of the player\n     */\n    public static @NotNull CompletableFuture<String> getDiscordIdAsync(final @NotNull UUID uuid) {", "first_line_groundtruth": "DiscordVerifier.getInstance().getLogger().severe(\"Failed to save player \" + uuid + \" to database\");", "first_line_prediction": " }", "match": 0}
{"groundtruth": "if (DiscordVerifier.getDiscordCodes().containsValue(sb.toString())) {", "prediction": " future.complete(sb.toString());\n        });\n        return future;\n    }\n\n    /**\n     * Generates a random code\n     * @param length The length of the code\n     * @return The generated code\n     */\n    public static @NotNull CompletableFuture<String> generateCode(int length) {\n        return generateString(length);\n    }\n\n    /**\n     * Gets the code from the database\n     * @param code The code to get\n     * @return The code\n     */\n    public static @NotNull CompletableFuture<String> get(CompletableFuture<String> code) {\n        return code;\n    }\n\n    /**\n     * Gets the code from", "first_line_groundtruth": "if (DiscordVerifier.getDiscordCodes().containsValue(sb.toString())) {", "first_line_prediction": " future.complete(sb.toString());", "match": 0}
{"groundtruth": "Connection connection = DiscordVerifier.getDatabaseConnection();", "prediction": " Connection connection = DiscordVerifier.getDatabaseConnection();\n                 PreparedStatement statement = connection.prepareStatement(\"INSERT INTO discord_codes (discord_id, uuid) VALUES (?, ?)\");\n                 statement.setString(1, discordId);\n                 statement.setString(2, uuid.toString());\n                 statement.executeUpdate();\n                 statement.close();\n                 connection.close();\n                 future.complete(null);\n            } catch (SQLException e) {\n                future.completeExceptionally(e);\n            }\n        });\n        return future;\n    }\n\n    /**\n     * Gets the discord ID of a player\n     * @param uuid The UUID of the player\n     *", "first_line_groundtruth": "Connection connection = DiscordVerifier.getDatabaseConnection();", "first_line_prediction": " Connection connection = DiscordVerifier.getDatabaseConnection();", "match": 0}
{"groundtruth": "lobbyParticles.getParticle(), playerLocation, lobbyParticles.getCount());", "prediction": "lobbyParticles.getParticle(), playerLocation, 1);\n    }", "first_line_groundtruth": "lobbyParticles.getParticle(), playerLocation, lobbyParticles.getCount());", "first_line_prediction": "lobbyParticles.getParticle(), playerLocation, 1);", "match": 0}
{"groundtruth": "sendMessage(CustomColor.translate(\"&7Invalid usage.. Try &e/gmp (player)&7.\"));", "prediction": "sendMessage(CustomColor.translate(\"&cInvalid usage!\"));\n            return false;\n        }\n    }", "first_line_groundtruth": "sendMessage(CustomColor.translate(\"&7Invalid usage.. Try &e/gmp (player)&7.\"));", "first_line_prediction": "sendMessage(CustomColor.translate(\"&cInvalid usage!\"));", "match": 0}
{"groundtruth": "UUID, Integer> idsProducts = cartModel.getIdsProducts();", "prediction": "UUID, Integer> products = cartRecordDto.getIdsProducts();\n        for (Map.Entry<UUID, Integer> entry : products.entrySet()) {\n            Optional<ProductModel> product = productRepository.findById(entry.getKey());\n            if (product.isPresent()) {\n                amount += product.get().getPrice() * entry.getValue();\n            }\n        }\n\n        cartModel.setAmount(amount);\n\n        return ResponseEntity.status(HttpStatus.CREATED).body(cartRepository.save(cartModel));\n    }\n\n    /**\n     * Metodo/Rota responsavel por listar todos os carrinhos de", "first_line_groundtruth": "UUID, Integer> idsProducts = cartModel.getIdsProducts();", "first_line_prediction": "UUID, Integer> products = cartRecordDto.getIdsProducts();", "match": 0}
{"groundtruth": "sender.sendMessage(CustomColor.translate(\"&a\" + args[0] + \" &7is &cnot &7online.\"));", "prediction": " sender.sendMessage(CustomColor.translate(\"&eTarget not found\"));\n                 return true;\n            }\n\n            target.getInventory().addItem(megaphone);\n            sender.sendMessage(CustomColor.translate(\"&7Congrats! &aYou &7now have a megaphone.\"));\n            return true;\n\n        } else {\n            sender.sendMessage(CustomColor.translate(\"&cInvalid usage!\"));\n            return false;\n        }\n    }", "first_line_groundtruth": "sender.sendMessage(CustomColor.translate(\"&a\" + args[0] + \" &7is &cnot &7online.\"));", "first_line_prediction": " sender.sendMessage(CustomColor.translate(\"&eTarget not found\"));", "match": 0}
{"groundtruth": "= userRepository.findByIdentifier(identifier);", "prediction": " = userRepository.findByIdentifier(identifier);\n        BeanUtils.copyProperties(userRecordDto, userModel);\n        return ResponseEntity.status(HttpStatus.OK).body(userRepository.save(userModel));\n    }", "first_line_groundtruth": "= userRepository.findByIdentifier(identifier);", "first_line_prediction": " = userRepository.findByIdentifier(identifier);", "match": 0}
{"groundtruth": "playerLocation, lobbyParticles.getCount());", "prediction": "1, playerLocation, 0, 0, 0);\n    }", "first_line_groundtruth": "playerLocation, lobbyParticles.getCount());", "first_line_prediction": "1, playerLocation, 0, 0, 0);", "match": 0}
{"groundtruth": "> list = userRepository.findByType(type);", "prediction": "> userList = userRepository.findByType(type);\n        if (userList.isEmpty()) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Usuario nao encontrado.\");\n        }\n        return ResponseEntity.status(HttpStatus.OK).body(userList);\n     }", "first_line_groundtruth": "> list = userRepository.findByType(type);", "first_line_prediction": "> userList = userRepository.findByType(type);", "match": 0}
{"groundtruth": "asList(manager.getItemsAsArray()), new ArrayList<>());", "prediction": "asList(manager.getItemNames()), new ArrayList<>());\n        }\n        return null;\n    }", "first_line_groundtruth": "asList(manager.getItemsAsArray()), new ArrayList<>());", "first_line_prediction": "asList(manager.getItemNames()), new ArrayList<>());", "match": 0}
{"groundtruth": ".delete(userRepository.findByIdentifier(identifier));", "prediction": ".deleteByIdentifier(identifier);\n        return ResponseEntity.status(HttpStatus.OK).body(\"Usuario deletado com sucesso.\");\n     }", "first_line_groundtruth": ".delete(userRepository.findByIdentifier(identifier));", "first_line_prediction": ".deleteByIdentifier(identifier);", "match": 0}
{"groundtruth": "size = plugin.getParticleManager().getParticlesMapSize()+1;", "prediction": " rows = 9;\n        int  columns = 9;\n        inventory = Bukkit.createInventory(null, rows * columns, Color.translate(\"&6Particle Menu\"));\n        addItemsToInventory();\n    }\n\n    /**\n     * Method to create a gui item.\n     * @param material Material\n     * @param name Name\n     * @return ItemStack\n     */\n    private ItemStack createGuiItem(Material material, String name) {\n        ItemStack item = new ItemStack(material);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(Color.translate(name));\n        item.setItemMeta(meta);\n       ", "first_line_groundtruth": "size = plugin.getParticleManager().getParticlesMapSize()+1;", "first_line_prediction": " rows = 9;", "match": 0}
{"groundtruth": ".get().addProduct(idProduct, 1);", "prediction": ".get().getIdsProducts().put(idProduct, 1);\n                }\n            }\n            else if (action.equals(\"remove\")){\n                if (products.containsKey(idProduct)){\n                    products.put(idProduct, products.get(idProduct) - 1);\n                }\n                else {\n                    newCart.get().getIdsProducts().put(idProduct, 0);\n                }\n            }\n            else {\n                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"Acao invalida\");\n            }\n\n            newCart.get().setAmount(newCart.get().getAmount());\n\n            return", "first_line_groundtruth": ".get().addProduct(idProduct, 1);", "first_line_prediction": ".get().getIdsProducts().put(idProduct, 1);", "match": 0}
{"groundtruth": ": mainInstance.getYmlDataFile().getConfigurationSection(\"\").getKeys(false)){", "prediction": " : mainInstance.getYmlDataFile().getKeys(false)){\n            final ItemStack itemStack = mainInstance.getYmlDataFile().getItemStack(itemStackName);\n            customItems.put(itemStackName, itemStack);\n        }\n    }", "first_line_groundtruth": ": mainInstance.getYmlDataFile().getConfigurationSection(\"\").getKeys(false)){", "first_line_prediction": " : mainInstance.getYmlDataFile().getKeys(false)){", "match": 0}
{"groundtruth": "DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getRight();", "prediction": "0;\n        while (time < DiscordVerifier.getInstance().getConfig().getInt(\"code-timeout\")) {\n            player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent\") + time));\n            time++;\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent-timeout\")));\n    }", "first_line_groundtruth": "DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getRight();", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "(DiscordVerifier.getInstance().getConfig().getBoolean(\"should-minecraft-chat-copyable\")) {", "prediction": " (time > 0) {\n            builder.append(\"\\n\\n\")\n                    .append(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-time-left\")))\n                    .append(\" \")\n                    .append(time)\n                    .append(\" \")\n                    .append(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-time-left-seconds\")));\n        }\n        builder.event(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, \"/discord verify \" + code));\n        player.spigot().sendMessage(builder.", "first_line_groundtruth": "(DiscordVerifier.getInstance().getConfig().getBoolean(\"should-minecraft-chat-copyable\")) {", "first_line_prediction": " (time > 0) {", "match": 0}
{"groundtruth": "mainInstance.getYmlDataFile().save(mainInstance.getDatafile());", "prediction": " mainInstance.getYmlDataFile().save(mainInstance.getDatafile());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "first_line_groundtruth": "mainInstance.getYmlDataFile().save(mainInstance.getDatafile());", "first_line_prediction": " mainInstance.getYmlDataFile().save(mainInstance.getDatafile());", "match": 0}
{"groundtruth": "manager.saveFile();", "prediction": "\n\n        return true;\n    }", "first_line_groundtruth": "manager.saveFile();", "first_line_prediction": "", "match": 0}
{"groundtruth": ".setDisplayName(Color.translate(name));", "prediction": ".setDisplayName(Color.translate(\"&6\"+name));\n        itemStack.setItemMeta(itemMeta);\n\n        return itemStack;\n    }\n\n    /**\n     * Method to get the inventory\n     * @return Inventory\n     */\n    public Inventory getInventory() {\n        return inventory;\n    }\n\n    /**\n     * Method to get the loadedParticlesMaterial\n     * @return HashMap\n     */\n    public HashMap<ItemStack, LobbyParticles> getLoadedParticlesMaterial() {\n        return loadedParticlesMaterial;\n    }\n\n    /**\n     * Method to get the plugin\n     * @return Particles\n     */\n    public Particles getPlugin() {\n        return plugin", "first_line_groundtruth": ".setDisplayName(Color.translate(name));", "first_line_prediction": ".setDisplayName(Color.translate(\"&6\"+name));", "match": 0}
{"groundtruth": ".requireNonNull(e.getGuild()).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-given\"));", "prediction": ".requireNonNull(DiscordVerifier.getInstance().getJDA().getGuildById(DiscordVerifier.getInstance().getConfig().getString(\"discord.guild-id\")).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-id\")));\n        player.addRole(given).queue();\n    }\n\n    private void attemptSendMCMessage(UUID uuid) {\n        Player player = Bukkit.getPlayer(uuid);\n        if (player == null) return;\n        String rawMsg = DiscordVerifier.getInstance().getConfig().getString(\"messages.code-generated\");\n        String msg = rawMsg.replace(\"{code}\", DiscordVerifier.", "first_line_groundtruth": ".requireNonNull(e.getGuild()).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-given\"));", "first_line_prediction": ".requireNonNull(DiscordVerifier.getInstance().getJDA().getGuildById(DiscordVerifier.getInstance().getConfig().getString(\"discord.guild-id\")).getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-id\")));", "match": 0}
{"groundtruth": ".save(mainInstance.getDatafile());", "prediction": "\n                    .save(mainInstance.getDatafile());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "first_line_groundtruth": ".save(mainInstance.getDatafile());", "first_line_prediction": "", "match": 0}
{"groundtruth": "(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-discord\")).queue();", "prediction": "(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-valid\")).queue();\n        DiscordVerifierAPI.setDiscordId(uuid, e.getUser().getId());\n        DiscordVerifierAPI.setDiscordCode(uuid, code);\n        DiscordVerifierAPI.setDiscordVerified(uuid, true);\n        DiscordVerifierAPI.setDiscordVerifiedAt(uuid, System.currentTimeMillis());\n        DiscordVerifierAPI.setDiscordVerifiedRole(uuid, DiscordVerifier.getInstance().getConfig().getString(\"discord.verified-role\"));\n        DiscordVerifierAPI.setDiscordVerifiedChannel(uuid, DiscordVerifier.getInstance().getConfig().getString(\"discord.verified", "first_line_groundtruth": "(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-discord\")).queue();", "first_line_prediction": "(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-valid\")).queue();", "match": 0}
{"groundtruth": ".teleport(main.getWarpManager().getWarp(args[0]));", "prediction": ".teleport(warps.getLocation(args[0]));\n        player.sendMessage(ChatColor.GOLD + \"Warp \" + args[0] + \" has been teleported!\");\n        return true;\n    }", "first_line_groundtruth": ".teleport(main.getWarpManager().getWarp(args[0]));", "first_line_prediction": ".teleport(warps.getLocation(args[0]));", "match": 0}
{"groundtruth": "<= configManager.getTalkRange()) {", "prediction": " <= configManager.getChatRange()) {\n                    if(configManager.showPlayerDistance()) {\n                        target.sendMessage(CustomColor.translate(\"&8[&e\" + distance + \"m&8] &a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                        return;\n                    }\n                    target.sendMessage(CustomColor.translate(\"&a\" + player.getName() + \" &8\u2192 &7\" + event.getMessage()));\n                }\n            }\n        });\n    }", "first_line_groundtruth": "<= configManager.getTalkRange()) {", "first_line_prediction": " <= configManager.getChatRange()) {", "match": 0}
{"groundtruth": ".cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-mc\")));", "prediction": ".cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-minecraft\")));\n    }\n\n    private boolean hasCode(Player player) {\n        return DiscordVerifier.getDiscordCodes().containsKey(player.getUniqueId());\n    }", "first_line_groundtruth": ".cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-mc\")));", "first_line_prediction": ".cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.verification-successful-minecraft\")));", "match": 0}
{"groundtruth": "DiscordVerifier.getDiscordCodes().forEach((uuid, data) -> {", "prediction": " DiscordVerifierAPI.verify(code).whenComplete((result, error) -> {\n            if (error != null) {\n                e.getHook().editOriginal(\"An error occurred while verifying your code!\").queue();\n                return;\n            }\n            if (result.isVerified()) {\n                e.getHook().editOriginal(\"Successfully verified!\").queue();\n                Player player = Bukkit.getPlayer(result.getUuid());\n                if (player != null) {\n                    player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-verified\")));\n                    player.sendMessage(", "first_line_groundtruth": "DiscordVerifier.getDiscordCodes().forEach((uuid, data) -> {", "first_line_prediction": " DiscordVerifierAPI.verify(code).whenComplete((result, error) -> {", "match": 0}
{"groundtruth": "String code = DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getLeft();", "prediction": " player.sendMessage(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent\") + \" \" + time + \" \" + DiscordVerifier.getInstance().getConfig().getString(\"messages.seconds\"));\n         player.spigot().sendMessage(new ComponentBuilder(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent\") + \" \" + time + \" \" + DiscordVerifier.getInstance().getConfig().getString(\"messages.seconds\")).color(DiscordVerifier.getInstance().getConfig().getString(\"messages.color\")).event(new ClickEvent(ClickEvent.Action.RUN_COMMAND, \"/discord verify\")).create());\n   ", "first_line_groundtruth": "String code = DiscordVerifier.getDiscordCodes().get(player.getUniqueId()).getLeft();", "first_line_prediction": " player.sendMessage(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent\") + \" \" + time + \" \" + DiscordVerifier.getInstance().getConfig().getString(\"messages.seconds\"));", "match": 0}
{"groundtruth": "main.getWarpManager().setWarp(args[0], loc);", "prediction": " warps.set(args[0], loc);\n         main.getWarpManager().saveWarps();\n         player.sendMessage(ChatColor.GOLD + \"Warp \" + args[0] + \" has been set!\");\n         return true;\n    }", "first_line_groundtruth": "main.getWarpManager().setWarp(args[0], loc);", "first_line_prediction": " warps.set(args[0], loc);", "match": 0}
{"groundtruth": "cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-generated\"))\n                .replace(\"{", "prediction": "cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-message\"));\n        String msg = rawMsg.replace(\"{code}\", code);\n        msg = msg.replace(\"{time}\", String.valueOf(time));\n        player.spigot().sendMessage(ComponentBuilder.create()\n                .append(msg)\n                .color(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-message-color\"))\n                .event(new ClickEvent(ClickEvent.Action.RUN_COMMAND, \"/discord verify\"))\n                .event(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, \"/discord", "first_line_groundtruth": "cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-generated\"))", "first_line_prediction": "cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-message\"));", "match": 0}
{"groundtruth": "if (DiscordVerifier.getInstance().getConfig().getBoolean(\"discord.sync-name\")){", "prediction": " // DiscordVerification/src/main/java/xyz/alonefield/discordverifier/DiscordVerifier.java\n        //         DiscordVerification.getInstance().getLogger().info(\"Player \" + name + \" has been verified!\");\n    }\n\n    private void attemptSendMCMessage(UUID uuid) {\n        List<String> messages = DiscordVerifier.getInstance().getConfig().getStringList(\"discord.messages\");\n        if (messages.isEmpty()) return;\n        String message = messages.get(0);\n        message = message.replace(\"{player}\", Bukkit.getPlayer(uuid).getName());\n        message = message.replace(\"{uuid}\", uuid.toString", "first_line_groundtruth": "if (DiscordVerifier.getInstance().getConfig().getBoolean(\"discord.sync-name\")){", "first_line_prediction": " // DiscordVerification/src/main/java/xyz/alonefield/discordverifier/DiscordVerifier.java", "match": 0}
{"groundtruth": "return DiscordVerifier.getDiscordCodes().get(player.getUniqueId()) != null;", "prediction": " return DiscordVerifier.getDiscordCodes().containsKey(player.getUniqueId());\n    }\n\n    private void sendCodeMessage(Player player) {\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-sent\")));\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.click-to-copy\")));\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().getConfig().getString(\"messages.click-to-copy-2\")));\n        player.sendMessage(DiscordVerifierAPI.cc(DiscordVerifier.getInstance().", "first_line_groundtruth": "return DiscordVerifier.getDiscordCodes().get(player.getUniqueId()) != null;", "first_line_prediction": " return DiscordVerifier.getDiscordCodes().containsKey(player.getUniqueId());", "match": 0}
{"groundtruth": ", Color.translate(\"&6Particle Menu\"));", "prediction": ", Color.translate(\"&6Particle Menu\"));\n        addItemsToInventory();\n    }\n\n    /**\n     * Method to create a gui item with the desired material and name.\n     * @param material Material\n     * @param name Name\n     * @return ItemStack\n     */\n    private ItemStack createGuiItem(Material material, String name) {\n        ItemStack item = new ItemStack(material);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(Color.translate(name));\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    /**\n     * Method to get the inventory\n     * @return Inventory\n     */", "first_line_groundtruth": ", Color.translate(\"&6Particle Menu\"));", "first_line_prediction": ", Color.translate(\"&6Particle Menu\"));", "match": 1}
{"groundtruth": "().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-invalid\")).queue();", "prediction": "().editOriginal(\"Invalid code!\").queue();\n        }\n    }\n\n    private void setSuccessful(SlashCommandInteractionEvent e, String code, AtomicBoolean failed, UUID uuid) {\n        Player player = Bukkit.getPlayer(uuid);\n        if (player == null || !player.isOnline()) {\n            e.getHook().editOriginal(\"This player is not online!\").queue();\n            return;\n        }\n        if (!player.isValid()) {\n            e.getHook().editOriginal(\"This player is not valid!\").queue();\n            return;\n        }\n        if (!DiscordVerifierAPI.verify(player, code", "first_line_groundtruth": "().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.code-invalid\")).queue();", "first_line_prediction": "().editOriginal(\"Invalid code!\").queue();", "match": 0}
{"groundtruth": "DiscordVerifier.getDiscordCodes().remove(uuid);", "prediction": " // Check if the player is already verified\n        if (DiscordVerifierAPI.isVerified(uuid)) {\n            e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.already-verified\")).queue();\n            return;\n        }\n        // Check if the player is already verified\n        if (DiscordVerifierAPI.isVerified(uuid)) {\n            e.getHook().editOriginal(DiscordVerifier.getInstance().getConfig().getString(\"messages.already-verified\")).queue();\n            return;\n        }\n        // Check if the player is already verified\n        if (DiscordVerifierAPI.isVerified(uuid)) {\n           ", "first_line_groundtruth": "DiscordVerifier.getDiscordCodes().remove(uuid);", "first_line_prediction": " // Check if the player is already verified", "match": 0}
{"groundtruth": "List<String> commands = DiscordVerifier.getInstance().getConfig().getStringList(\"Minecraft.Command\");", "prediction": "\n\n    }\n\n    private void attemptSendMCMessage(UUID uuid) {\n        String message = DiscordVerifier.getInstance().getConfig().getString(\"discord.message-on-success\");\n        if (message.isEmpty()) return;\n        Bukkit.getScheduler().runTaskAsynchronously(DiscordVerifier.getInstance(), () -> {\n            Player player = Bukkit.getPlayer(uuid);\n            if (player == null) return;\n            player.sendMessage(ChatColor.translateAlternateColorCodes('&', message));\n        });\n    }", "first_line_groundtruth": "List<String> commands = DiscordVerifier.getInstance().getConfig().getStringList(\"Minecraft.Command\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "DiscordVerifier.getInstance().getConfig().getBoolean(\"should-code-be-case-sensitive\");", "prediction": " DiscordVerifier.getInstance().getConfig().getBoolean(\"code-case-sensitive\");\n            if (caseSensitive) {\n                if (code.equals(data.getLeft())) {\n                    failed.set(false);\n                    e.getHook().editOriginal(\"Verified!\").queue();\n                    Bukkit.getScheduler().runTask(DiscordVerifier.getInstance(), () -> {\n                        DiscordVerifier.getDiscordCodes().remove(uuid);\n                        DiscordVerifier.getDiscordRoles().forEach((discordId, role) -> {\n                            if (discordId.equals(data.getRight())) {\n                                e.getGuild().getRoleById(role", "first_line_groundtruth": "DiscordVerifier.getInstance().getConfig().getBoolean(\"should-code-be-case-sensitive\");", "first_line_prediction": " DiscordVerifier.getInstance().getConfig().getBoolean(\"code-case-sensitive\");", "match": 0}
{"groundtruth": "Bukkit.getScheduler().runTask(DiscordVerifier.getInstance(), () -> {", "prediction": " for (String command : commands) {\n             Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command.replace(\"%player%\", name).replace(\"%code%\", code));\n         }\n    }\n\n    private void attemptSendMCMessage(UUID uuid) {\n        String channelId = DiscordVerifier.getInstance().getConfig().getString(\"discord.mc-channel\");\n        if (channelId.isEmpty()) return;\n        if (channelId.equals(\"none\")) return;\n        String message = DiscordVerifier.getInstance().getConfig().getString(\"discord.mc-message\");\n        if (message.isEmpty()) return;\n        DiscordVerifierAPI.sendMessage(channelId", "first_line_groundtruth": "Bukkit.getScheduler().runTask(DiscordVerifier.getInstance(), () -> {", "first_line_prediction": " for (String command : commands) {", "match": 0}
{"groundtruth": "Player player = DiscordVerifier.getInstance().getServer().getPlayer(uuid);", "prediction": " Player player = Bukkit.getPlayer(uuid);\n        if (player == null) return;\n        String message = DiscordVerifier.getInstance().getConfig().getString(\"Minecraft.Message\");\n        if (message.isEmpty()) return;\n        Bukkit.dispatchCommand(Bukkit.getConsoleSender(), message.replace(\"{player}\", player.getName()));\n    }", "first_line_groundtruth": "Player player = DiscordVerifier.getInstance().getServer().getPlayer(uuid);", "first_line_prediction": " Player player = Bukkit.getPlayer(uuid);", "match": 0}
{"groundtruth": "megaphoneMeta.setDisplayName(CustomColor.translate(\"&a&lMegaphone\"));", "prediction": " megaphoneMeta.setDisplayName(CustomColor.translate(\"&aMegaphone\"));\n             megaphoneMeta.setLore(Collections.singletonList(CustomColor.translate(\"&7Click to give a megaphone to a player\")));\n             megaphone.setItemMeta(megaphoneMeta);\n        }\n\n        return megaphone;\n    }", "first_line_groundtruth": "megaphoneMeta.setDisplayName(CustomColor.translate(\"&a&lMegaphone\"));", "first_line_prediction": " megaphoneMeta.setDisplayName(CustomColor.translate(\"&aMegaphone\"));", "match": 0}
{"groundtruth": "if (newCart.get().getIdsProducts().isEmpty()){", "prediction": "\n\n            }\n            return ResponseEntity.status(HttpStatus.OK).body(cartRepository.save(newCart.get()));\n        }\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Carrinho de compras n\u00e3o encontrado\");\n    }", "first_line_groundtruth": "if (newCart.get().getIdsProducts().isEmpty()){", "first_line_prediction": "", "match": 0}
{"groundtruth": "Role removed = e.getGuild().getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-removed\"));", "prediction": " if (given != null) {\n             player.addRole(given).queue();\n         }\n    }\n\n    private void attemptSendMCMessage(UUID uuid) {\n        Player player = Bukkit.getPlayer(uuid);\n        if (player == null) return;\n        String rawMsg = DiscordVerifier.getInstance().getConfig().getString(\"messages.code-generated\");\n        String msg = rawMsg.replace(\"{code}\", DiscordVerifierAPI.get(DiscordVerifierAPI.generateCode(DiscordVerifier.getInstance().getConfig().getInt(\"code-length\"))));\n        player.sendMessage(msg);\n    }", "first_line_groundtruth": "Role removed = e.getGuild().getRoleById(DiscordVerifier.getInstance().getConfig().getString(\"discord.role-removed\"));", "first_line_prediction": " if (given != null) {", "match": 0}
{"groundtruth": ").getAmount() - value);", "prediction": "idProduct).getAmount() - value);\n            }\n\n            return ResponseEntity.status(HttpStatus.OK).body(cartRepository.save(newCart.get()));\n        }\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Carrinho de compras n\u00e3o encontrado\");\n    }", "first_line_groundtruth": ").getAmount() - value);", "first_line_prediction": "idProduct).getAmount() - value);", "match": 0}
{"groundtruth": "+ getConfigManager().getMegaphoneRange()\n                            + \" &7blocks!\")));", "prediction": " + getConfigManager().getTalkRange() + \"&7\")));\n            megaphone.setItemMeta(megaphoneMeta);\n        }\n\n        return megaphone;\n    }", "first_line_groundtruth": "+ getConfigManager().getMegaphoneRange()", "first_line_prediction": " + getConfigManager().getTalkRange() + \"&7\")));", "match": 0}
{"groundtruth": "Optional<CartModel> cart = cartRepository.findByIdClient(idClient);", "prediction": " Optional<CartModel> cart = cartRepository.findByIdClient(idClient);", "first_line_groundtruth": "Optional<CartModel> cart = cartRepository.findByIdClient(idClient);", "first_line_prediction": " Optional<CartModel> cart = cartRepository.findByIdClient(idClient);", "match": 0}
{"groundtruth": "saleModel.addProduct(idProduct, quantidade);", "prediction": " /**\n             * Verifica se o produto esta cadastrado no banco de dados\n             */\n            Optional<ProductModel> product = productRepository.findById(idProduct);\n            if (product.isPresent()){\n                saleModel.addProduct(idProduct, quantidade);\n            }\n        }\n\n        /**\n         * Salva a venda no banco de dados\n         */\n        saleRepository.save(saleModel);\n\n        /**\n         * Remove o carrinho de compras do cliente\n         */\n        cartRepository.deleteByIdClient(saleModel.getIdClient());\n\n        return ResponseEntity.status(HttpStatus.CREATED).body(saleModel", "first_line_groundtruth": "saleModel.addProduct(idProduct, quantidade);", "first_line_prediction": " /**", "match": 0}
{"groundtruth": "saleModel.getIdClient());", "prediction": "saleRecordDto.getClientId()).orElseThrow();\n        var product = productRepository.findById(saleRecordDto.getProductId()).orElseThrow();\n\n        saleModel.setCart(cart);\n        saleModel.setProduct(product);\n\n        var date = new SimpleDateFormat(\"dd/MM/yyyy\");\n        try {\n            saleModel.setDate(date.parse(saleRecordDto.getDate()));\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n\n        return ResponseEntity.status(HttpStatus.CREATED).body(saleRepository.save(saleModel));\n    }", "first_line_groundtruth": "saleModel.getIdClient());", "first_line_prediction": "saleRecordDto.getClientId()).orElseThrow();", "match": 0}
{"groundtruth": "saleModel.setDate(java.sql.Date.valueOf(date));", "prediction": " try {\n             SimpleDateFormat format = new SimpleDateFormat(\"dd/MM/yyyy\");\n             saleModel.setDate(format.parse(date.toString()));\n         } catch (ParseException e) {\n             e.printStackTrace();\n         }\n\n        return ResponseEntity.status(HttpStatus.CREATED).body(saleRepository.save(saleModel));\n    }\n\n    /**\n     * Metodo/Rota responsavel por realizar a busca de todas as vendas\n     * @return - Retorna uma lista com todas as vendas\n     */\n    @GetMapping(\"sale/listAll\")\n    public ResponseEntity<Object> listAll(){\n        return ResponseEntity.status", "first_line_groundtruth": "saleModel.setDate(java.sql.Date.valueOf(date));", "first_line_prediction": " try {", "match": 0}
{"groundtruth": "productRepository.findById(idProduct).get().getValue();", "prediction": "0F;\n                for (Map.Entry<UUID, Integer> entry : products.entrySet()) {\n                    UUID idProduct = entry.getKey();\n                    int quantidade = entry.getValue();\n\n                    Optional<ProductModel> product = productRepository.findById(idProduct);\n\n                    if (product.isPresent()){\n                        value += product.get().getValue() * quantidade;\n                    }\n                }\n                newCart.get().setAmount(value);\n            }\n            else if (action.equals(\"remove\")){\n                if (products.containsKey(idProduct)){\n                    products.put(idProduct, products.get(idProduct) -", "first_line_groundtruth": "productRepository.findById(idProduct).get().getValue();", "first_line_prediction": "0F;", "match": 0}
{"groundtruth": ": thoughts.getPlan().split(\"\\n\")) {", "prediction": " : thoughts.getPlan().split(\"\\n\")) {\n                        System.out.println(agent.getName() + \": \" + plan);\n                    }\n                }\n                if (thoughts.hasCriticism()) {\n                    System.out.println(agent.getName() + \": Criticism: \" + thoughts.getCriticism());\n                }\n                if (thoughts.hasSpeak()) {\n                    System.out.println(agent.getName() + \": \" + thoughts.getSpeak());\n                }\n            }\n            if (resp.hasCommand()) {\n                String command = resp.getCommand();\n                System", "first_line_groundtruth": ": thoughts.getPlan().split(\"\\n\")) {", "first_line_prediction": " : thoughts.getPlan().split(\"\\n\")) {", "match": 0}
{"groundtruth": "= agent.chat(\"GENERATE NEXT COMMAND JSON\", true);", "prediction": " = agent.executeCommand(resp.getCommand());\n                            break;\n                        } else {\n                            break;\n                        }\n                    } else {\n                        System.out.println(\"Invalid input. Please enter Y or N.\");\n                    }\n                }\n            }\n            if (resp.hasResponse()) {\n                System.out.println(\"Agent says: \\n\" + resp.getResponse());\n            }\n            if (resp.hasThoughts()) {\n                System.out.println(\"Agent has thoughts: \" + resp.hasThoughts());\n            }\n            if (resp.hasResponse()) {\n                System.out.println(\"Agent", "first_line_groundtruth": "= agent.chat(\"GENERATE NEXT COMMAND JSON\", true);", "first_line_prediction": " = agent.executeCommand(resp.getCommand());", "match": 0}
{"groundtruth": "agent.chat(feedback, false);", "prediction": " agent.chat(feedback, true);\n                            break;\n                        }\n                    } else {\n                        System.out.println(\"Please enter Y or N.\");\n                    }\n                }\n            }\n            if (resp.hasFeedback()) {\n                System.out.println(\"Agent wants to give feedback: \" + resp.getFeedback());\n                while (true) {\n                    System.out.print(\"(Y/N)? \");\n                    String yn = scanner.nextLine().toLowerCase().trim();\n                    if (\"y\".equals(yn) || \"n\".equals(yn)) {\n                        if (\"y\".equals(yn)) {\n                            resp = agent", "first_line_groundtruth": "agent.chat(feedback, false);", "first_line_prediction": " agent.chat(feedback, true);", "match": 0}
{"groundtruth": "+= product.get().getValue() * quantidade;", "prediction": " += product.get().getPrice() * quantidade;\n            }\n        }\n\n        cartModel.setAmount(amount);\n\n        return ResponseEntity.status(HttpStatus.CREATED).body(cartRepository.save(cartModel));\n    }\n\n    /**\n     * Metodo/Rota responsavel por listar todos os carrinhos de compras\n     * @return Lista de carrinhos de compras\n     */\n    @GetMapping(\"/cart/list\")\n    public ResponseEntity<Object> listCart(){\n        List<CartModel> carts = cartRepository.findAll();\n        return ResponseEntity.status(HttpStatus.OK).body", "first_line_groundtruth": "+= product.get().getValue() * quantidade;", "first_line_prediction": " += product.get().getPrice() * quantidade;", "match": 0}
{"groundtruth": "saleModel.setIdSeller(idSeller);", "prediction": " /**\n         * Verifica se o vendedor da venda esta cadastrado\n         */\n        if (productRepository.findByIdSeller(idSeller).isEmpty()){\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Vendedor n\u00e3o cadastrado\");\n        }\n\n        saleModel.setIdSeller(idSeller);\n\n        /**\n         * Verifica se a data da venda esta no futuro\n         */\n        if (saleModel.getDate().isBefore(LocalDate.now())){\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"Data da venda invalida\");\n        }\n\n       ", "first_line_groundtruth": "saleModel.setIdSeller(idSeller);", "first_line_prediction": " /**", "match": 0}
{"groundtruth": "<String> relevantMemory = memory.get(10);", "prediction": "<Map<String, String>> memory = this.memory.getMemory();\n        prompt.addAll(memory);\n\n        // Build user input prompt\n        Prompt userInputPrompt = new Prompt.Builder(\"user_input\")\n                .withRole(\"user\")\n                .withUserInput(userInput)\n                .build();\n        prompt.add(userInputPrompt.getPrompt());\n\n        // Build footer prompt\n        Map<String, String> footer = buildPrompts(\"system\", footerPrompt());\n        prompt.add(footer);\n\n        return prompt;\n    }\n\n    private String headerPrompt() {\n        return \"Hello! I am \"", "first_line_groundtruth": "<String> relevantMemory = memory.get(10);", "first_line_prediction": "<Map<String, String>> memory = this.memory.getMemory();", "match": 0}
{"groundtruth": "(HttpStatus.OK).body(saleRepository.findByIdSeller(id));", "prediction": "(HttpStatus.OK).body(saleRepository.findByIdSeller(id));\n        }\n\n        /**\n         * Verifica se a busca das vendas sera pelo cliente\n         */\n        if (((String) request.get(\"form\")).equals(\"client\")){\n            UUID id = UUID.fromString((String) request.get(\"value\"));\n            return ResponseEntity.status(HttpStatus.OK).body(saleRepository.findByIdClient(id));\n        }\n\n        /**\n         * Verifica se a busca das vendas sera pela data\n         */\n        if (((String) request.get(\"form\")).equals(\"date\")){\n           ", "first_line_groundtruth": "(HttpStatus.OK).body(saleRepository.findByIdSeller(id));", "first_line_prediction": "(HttpStatus.OK).body(saleRepository.findByIdSeller(id));", "match": 1}
{"groundtruth": "(thoughts.hasCriticism()) {", "prediction": " (thoughts.hasCriticism()) {\n                    System.out.println(agent.getName() + \": Criticism: \" + thoughts.getCriticism());\n                }\n                if (thoughts.hasSpeak()) {\n                    System.out.println(agent.getName() + \": \" + thoughts.getSpeak());\n                }\n            }\n            if (resp.hasCommand()) {\n                String command = resp.getCommand();\n                System.out.println(agent.getName() + \": \" + command);\n                if (command.equals(\"exit\")) {\n                    break;\n                }\n                if (command", "first_line_groundtruth": "(thoughts.hasCriticism()) {", "first_line_prediction": " (thoughts.hasCriticism()) {", "match": 0}
{"groundtruth": "thoughts.hasSpeak()) {", "prediction": "thoughts.hasSpeak()) {\n                    System.out.println(agent.getName() + \": \" + thoughts.getSpeak());\n                }\n            }\n            if (resp.hasCommand()) {\n                String command = resp.getCommand();\n                System.out.println(agent.getName() + \": \" + command);\n                if (command.equals(\"exit\")) {\n                    break;\n                }\n                if (command.equals(\"help\")) {\n                    System.out.println(\"help\");\n                }\n                if (command.equals(\"quit\")) {\n                    break;\n                }\n                if (command.equals(\"restart\")) {", "first_line_groundtruth": "thoughts.hasSpeak()) {", "first_line_prediction": "thoughts.hasSpeak()) {", "match": 1}
{"groundtruth": "out.println(agent.getName() + \": (voice) \" + thoughts.getSpeak());", "prediction": "out.println(agent.getName() + \": \" + thoughts.getSpeak());\n                }\n            }\n            if (resp.hasCommand()) {\n                String command = resp.getCommand();\n                System.out.println(agent.getName() + \": \" + command);\n                String respStr = agent.respond(command);\n                resp = Response.getResponseFromRaw(respStr);\n            }\n        }\n    }", "first_line_groundtruth": "out.println(agent.getName() + \": (voice) \" + thoughts.getSpeak());", "first_line_prediction": "out.println(agent.getName() + \": \" + thoughts.getSpeak());", "match": 0}
{"groundtruth": "resp.hasCommand()) {", "prediction": "resp.hasCommand()) {\n                String command = resp.getCommand();\n                System.out.println(agent.getName() + \": \" + command);\n                String commandArgs = \"\";\n                while (true) {\n                    System.out.print(agent.getName() + \": \");\n                    commandArgs += scanner.nextLine() + \" \";\n                    if (commandArgs.endsWith(\"\\n\")) {\n                        break;\n                    }\n                }\n                commandArgs = commandArgs.trim();\n                if (commandArgs.length() > 0) {\n                    resp = agent.chat(command, commandArgs);\n                }\n            }\n        }\n   ", "first_line_groundtruth": "resp.hasCommand()) {", "first_line_prediction": "resp.hasCommand()) {", "match": 1}
{"groundtruth": "return openAIModel.chat(prompts);", "prediction": " return chat(prompts, maxTokens, 0.8);\n    }\n\n    private String chat(List<ChatMessage> messages, int maxTokens, double temperature) {\n        return chat(messages, maxTokens, temperature, 0.9);\n    }\n\n    private String chat(List<ChatMessage> messages, int maxTokens, double temperature, double topP) {\n        return chat(messages, maxTokens, temperature, topP, 0.9);\n    }\n\n    private String chat(List<ChatMessage> messages, int maxTokens, double temperature, double topP, double frequencyPenalty) {\n        return", "first_line_groundtruth": "return openAIModel.chat(prompts);", "first_line_prediction": " return chat(prompts, maxTokens, 0.8);", "match": 0}
{"groundtruth": "consumerAccessor.setPickupDelay(Math.max(consumerAccessor.getPickupDelay(), supplierAccessor.getPickupDelay()));", "prediction": " var consumerItem = consumer.getItem();\n         var supplierItem = supplier.getItem();\n         var consumerCount = consumerItem.getCount();\n         var supplierCount = supplierItem.getCount();\n         var consumerExtraCount = getExtraItemCount(consumer);\n         var supplierExtraCount = getExtraItemCount(supplier);", "first_line_groundtruth": "consumerAccessor.setPickupDelay(Math.max(consumerAccessor.getPickupDelay(), supplierAccessor.getPickupDelay()));", "first_line_prediction": " var consumerItem = consumer.getItem();", "match": 0}
{"groundtruth": ".add(PromptUtils.buildPrompts(role, content));", "prediction": ".add(buildPrompts(role, content));\n    }\n\n    public void addNewPrompt(Prompt prompt) {\n        this.values.add(prompt.build());\n    }\n\n    public void addNewPrompts(List<Prompt> prompts) {\n        prompts.forEach(this::addNewPrompt);\n    }\n\n    public void addNewPrompts(PromptHistory history) {\n        history.values.forEach(this::addNewPrompt);\n    }\n\n    public void addNewPrompts(PromptHistory history, int start, int end) {\n        history.values.subList(start,", "first_line_groundtruth": ".add(PromptUtils.buildPrompts(role, content));", "first_line_prediction": ".add(buildPrompts(role, content));", "match": 0}
{"groundtruth": "return chat(seedInput.getContent(), false);", "prediction": " String seedInputString = seedInput.getContent();\n        List<Map<String, String>> prompt = getFullPrompt(seedInputString);\n        String response = chat(prompt, 300);\n        return new Response(response);\n    }\n\n    public String chat(List<Map<String, String>> prompt, int maxTokens) {\n        String response = \"\";\n        try {\n            List<Map<String, String>> prompts = prompt;\n            if (stagingTool != null) {\n                prompts = new ArrayList<>(stagingTool.entrySet());\n            }\n            stagingTool = null;\n            stagingResponse = null;", "first_line_groundtruth": "return chat(seedInput.getContent(), false);", "first_line_prediction": " String seedInputString = seedInput.getContent();", "match": 0}
{"groundtruth": "var age = accessor.getAge();", "prediction": " if (pickupDelay > 0) {\n             return false;\n         }\n         var age = accessor.getAge();\n         if (age > 0) {\n             return false;\n         }\n         var itemStack = entity.getItem();\n         if (isBlackListItem(itemStack)) {\n             return false;\n         }\n         return true;\n    }\n\n    public static int getTotalCount(ItemEntity entity) {\n        var itemStack = entity.getItem();\n        var extraItemCount = getExtraItemCount(entity);\n        return itemStack.getCount() + extraItemCount;\n    }\n\n    public static int getExtraItemCount(ItemEntity entity)", "first_line_groundtruth": "var age = accessor.getAge();", "first_line_prediction": " if (pickupDelay > 0) {", "match": 0}
{"groundtruth": "|| Staaaaaaaaaaaack.getItemBlackList().contains(itemStack.getItem());", "prediction": " || Staaaaaaaaaaaack.commonConfig.getItemBlackList().stream()\n                     .anyMatch(item -> itemStack.is(item));\n    }", "first_line_groundtruth": "|| Staaaaaaaaaaaack.getItemBlackList().contains(itemStack.getItem());", "first_line_prediction": " || Staaaaaaaaaaaack.commonConfig.getItemBlackList().stream()", "match": 0}
{"groundtruth": "openAIModel.getTokenLimit();", "prediction": "2500;\n        if (tokenCount > tokenLimit) {\n            fullPrompt.remove(fullPrompt.size() - 1);\n        }\n        String response = this.chat(fullPrompt);\n        return new Response(response, this.history.getValues());\n    }\n\n    /**\n     * The chat function is a method that performs a chat interaction between a user and an assistant. Here's a breakdown of what it does:\n     * The prompt parameter is a list of dictionaries, each of which contains a \"role\" and \"content\" field. The \"role\" field indicates the role of the message in the", "first_line_groundtruth": "openAIModel.getTokenLimit();", "first_line_prediction": "2500;", "match": 0}
{"groundtruth": ".summarizer.summarize(extractedText, question);", "prediction": ".summarizer.summarize(extractedText, question);\n            result.put(\"text\", summary);\n            result.put(\"links\", extractedLinks);\n        }\n        return result;\n    }", "first_line_groundtruth": ".summarizer.summarize(extractedText, question);", "first_line_prediction": ".summarizer.summarize(extractedText, question);", "match": 1}
{"groundtruth": "min(consumerAccessor.getAge(), supplierAccessor.getAge()));", "prediction": "max(consumerAccessor.getAge(), supplierAccessor.getAge()));\n        consumerAccessor.setOwner(supplierAccessor.getOwner());\n        supplierAccessor.setPickupDelay(32767);\n        supplierAccessor.setAge(-32768);\n        supplierAccessor.setOwner(null);\n        consumer.setItem(supplier.getItem());\n        supplier.setItem(ItemStack.EMPTY);\n        setExtraItemCount(consumer, getExtraItemCount(consumer) + getExtraItemCount(supplier));\n    }\n\n    public static boolean isBlackListItem(Item item) {\n        return Staaaaaaaaaaaack.commonConfig.isBlackListed", "first_line_groundtruth": "min(consumerAccessor.getAge(), supplierAccessor.getAge()));", "first_line_prediction": "max(consumerAccessor.getAge(), supplierAccessor.getAge()));", "match": 0}
{"groundtruth": "(Math.max(consumerAccessor.getPickupDelay(), supplierAccessor.getPickupDelay()));", "prediction": "(32767);\n        supplierAccessor.setPickupDelay(32767);\n\n        var consumerItem = consumer.getItem();\n        var supplierItem = supplier.getItem();\n        var consumerCount = consumerItem.getCount();\n        var supplierCount = supplierItem.getCount();\n        var consumerExtraCount = getExtraItemCount(consumer);\n        var supplierExtraCount = getExtraItemCount(supplier);\n\n        var newCount = consumerCount + supplierCount;\n        var newExtraCount = consumerExtraCount + supplierExtraCount;\n\n        consumer.setItem(supplierItem.copy());\n        supplier.setItem(consumerItem.copy());", "first_line_groundtruth": "(Math.max(consumerAccessor.getPickupDelay(), supplierAccessor.getPickupDelay()));", "first_line_prediction": "(32767);", "match": 0}
{"groundtruth": "= openAIModel.countTokens(updatedPrompt);", "prediction": " = context.get(\"content\").length();\n                if (tokenCount + tokenLimit < 2500) {\n                    prompt = updatedPrompt;\n                    break;\n                }\n                relevantMemory = relevantMemory.subList(1, relevantMemory.size());\n            }\n        }\n\n        // Build current date and time prompt\n        Prompt currentDatePrompt = new Prompt.Builder(\"current_date\")\n                 .withRole(\"system\")\n                 .formattedWithCurrentDate(0)\n                 .build();\n        prompt.add(currentDatePrompt.getPrompt());\n\n        // Build current date and time prompt\n        Prompt currentLocationPrompt = new Prompt", "first_line_groundtruth": "= openAIModel.countTokens(updatedPrompt);", "first_line_prediction": " = context.get(\"content\").length();", "match": 0}
{"groundtruth": "= openAIModel.chat(fullPrompt, tokenLimit - tokenCount);", "prediction": " = this.chat(fullPrompt, tokenCount, tokenLimit);\n        return new Response(resp);\n    }\n\n    /**\n     * The chat function is a method that performs a chat interaction between a user and an assistant. Here's a breakdown of what it does:\n     * The chat function is called with a list of prompts. The prompts are used to construct the prompt for the chat interaction. The prompt is then passed to the openAIModel to generate a response.\n     * The response is then printed and stored in the assistant's history as a user message and an assistant message.\n     * The response is returned from", "first_line_groundtruth": "= openAIModel.chat(fullPrompt, tokenLimit - tokenCount);", "first_line_prediction": " = this.chat(fullPrompt, tokenCount, tokenLimit);", "match": 0}
{"groundtruth": ".memory.add(humanFeedbackPrompt.getContent());", "prediction": ".memory.add(humanFeedbackPrompt.getPrompt());\n                this.stagingResponse = null;\n                this.stagingTool = null;\n                return new Response(humanFeedbackPrompt.getPrompt());\n            } else {\n                Prompt humanFeedbackPrompt = new Prompt.Builder(\"human_feedback\")\n                         .withRole(\"system\")\n                         .formatted(0, this.stagingResponse, message)\n                         .build();\n                this.memory.add(humanFeedbackPrompt.getPrompt());\n                this.stagingResponse = null;\n                this.stagingTool = null;\n                return new Response(humanFeedbackPrompt.getPrompt());\n            }\n       ", "first_line_groundtruth": ".memory.add(humanFeedbackPrompt.getContent());", "first_line_prediction": ".memory.add(humanFeedbackPrompt.getPrompt());", "match": 0}
{"groundtruth": "int tokenLimit = openAIModel.getTokenLimit() - 1000;", "prediction": " return prompt;\n    }\n\n    private String headerPrompt() {\n        return \"Hi, I am \" + name + \". I am a \" + description + \". I am here to help you \" + String.join(\", \", goals) + \".\";\n    }\n\n    private String chat(String[] prompts, int maxTokens) {\n        return openAIModel.chat(prompts);\n    }\n\n    private String prompt(String text, String query) {\n        return \"{\\\"role\\\": \\\"user\\\", \\\"content\\\": \\\"\\\"\\\"\"\n                + text\n                + \"\\\"\\\"\\\" Using the above text, please answer the following question: \\\"\"\n               ", "first_line_groundtruth": "int tokenLimit = openAIModel.getTokenLimit() - 1000;", "first_line_prediction": " return prompt;", "match": 0}
{"groundtruth": "return defaultResponsePrompt.getContent();", "prediction": " return defaultResponsePrompt.getPrompt();\n    }\n\n    public String evaluationPrompt() {\n        String evaluation = Prompt.getEvaluation();\n        Prompt evaluationPrompt = new Prompt.Builder(\"evaluation\")\n                 .formatted(0, evaluation)\n                 .build();\n         return evaluationPrompt.getPrompt();\n    }\n\n    public String resourcesPrompt() {\n        String resources = Prompt.getResources();\n        Prompt resourcesPrompt = new Prompt.Builder(\"resources\")\n                 .formatted(0, resources)\n                 .build();\n         return resourcesPrompt.getPrompt();\n    }\n\n    public String toolsPrompt() {\n        String tools = Prompt.getTools();\n        Prompt tools", "first_line_groundtruth": "return defaultResponsePrompt.getContent();", "first_line_prediction": " return defaultResponsePrompt.getPrompt();", "match": 0}
{"groundtruth": "(currentTimePrompt.getPrompt());", "prediction": "(currentTimePrompt.getPrompt());\n\n        // Build user input prompt\n        Prompt userInputPrompt = new Prompt.Builder(\"user_input\")\n                .withRole(\"user\")\n                .withUserInput(userInput)\n                .build();\n        prompt.add(userInputPrompt.getPrompt());\n\n        // Build goal prompt\n        Prompt goalPrompt = new Prompt.Builder(\"goal\")\n                .withRole(\"system\")\n                .withGoal(goals)\n                .build();\n        prompt.add(goalPrompt.getPrompt());\n\n        // Build footer prompt\n        Map<String, String> footer = buildPrompts(\"system\", footer", "first_line_groundtruth": "(currentTimePrompt.getPrompt());", "first_line_prediction": "(currentTimePrompt.getPrompt());", "match": 1}
{"groundtruth": "Prompt.getDefaultResponse();", "prediction": " \"I'm sorry, I didn't understand that. Please try again.\";\n        Prompt defaultResponsePrompt = new Prompt.Builder(\"default_response\")\n                .formatted(0, defaultResponse)\n                .withRole(\"system\")\n                .build();\n        return defaultResponsePrompt.getPrompt();\n    }\n\n    public String evaluationPrompt() {\n        String evaluation = \"I'm sorry, I didn't understand that. Please try again.\";\n        Prompt evaluationPrompt = new Prompt.Builder(\"evaluation\")\n                .formatted(0, evaluation)\n                .withRole(\"system\")\n                .build();\n        return evaluationPrompt.getPrompt();\n    }", "first_line_groundtruth": "Prompt.getDefaultResponse();", "first_line_prediction": " \"I'm sorry, I didn't understand that. Please try again.\";", "match": 0}
{"groundtruth": "return seeMore.getSchedulerHook().runTaskDelayed(() -> updateDistance(player, 0, attempts, distanceMap, taskMap, distanceConsumer), delay);", "prediction": " task = seeMore.getSchedulerHook().runDelayed(this, task -> updateDistance(player, delay, attempts + 1, distanceMap, taskMap, distanceConsumer), delay);\n            } else {\n                task = seeMore.getSchedulerHook().runEntityTaskAsap(task -> updateDistance(player, delay, attempts + 1, distanceMap, taskMap, distanceConsumer), null, player);\n            }\n            return task;\n        });\n        distanceConsumer.accept(player, distance);\n    }\n\n    private void cleanMaps() {\n        targetViewDistanceMap.entrySet().removeIf(entry -> entry.", "first_line_groundtruth": "return seeMore.getSchedulerHook().runTaskDelayed(() -> updateDistance(player, 0, attempts, distanceMap, taskMap, distanceConsumer), delay);", "first_line_prediction": " task = seeMore.getSchedulerHook().runDelayed(this, task -> updateDistance(player, delay, attempts + 1, distanceMap, taskMap, distanceConsumer), delay);", "match": 0}
{"groundtruth": "viewDistanceController.updateAllPlayers();", "prediction": " for (Player player : Bukkit.getOnlinePlayers()) {\n                 viewDistanceController.updateTargetViewDistance(player);\n             }\n        }\n    }\n\n    public SeeMoreConfig getConfig() {\n        return config;\n    }\n\n    public SchedulerHook getSchedulerHook() {\n        return schedulerHook;\n    }\n\n    public ViewDistanceController getViewDistanceController() {\n        return viewDistanceController;\n    }", "first_line_groundtruth": "viewDistanceController.updateAllPlayers();", "first_line_prediction": " for (Player player : Bukkit.getOnlinePlayers()) {", "match": 0}
{"groundtruth": "updateTask = seeMore.getSchedulerHook().runEntityTaskAsap(() -> {", "prediction": " newTask = seeMore.getSchedulerHook().runEntityTaskAsap(() -> {\n                distanceConsumer.accept(player, distance);\n                taskMap.remove(player.getUniqueId());\n                retryTask.complete(null);\n            }, null, player);\n            return newTask == null ? null : new RegionisedScheduledTask(newTask);\n        });\n        taskMap.compute(player.getUniqueId(), (uuid, task) -> {\n            if (task == null) {\n                return retryTask.join();\n            }\n            return task;\n        });\n    }\n\n    private void cleanMaps() {\n        for (Map.", "first_line_groundtruth": "updateTask = seeMore.getSchedulerHook().runEntityTaskAsap(() -> {", "first_line_prediction": " newTask = seeMore.getSchedulerHook().runEntityTaskAsap(() -> {", "match": 0}
{"groundtruth": "seeMore.getSeeMoreConfig().updateDelay.get();", "prediction": "100;\n            }\n        } catch (Throwable ignored) {}\n        if (delay > 0) {\n            ScheduledTask task = seeMore.getSchedulerHook().runRepeatingTask(() -> {\n                setTargetViewDistance(player, player.getClientViewDistance(), true);\n            }, delay, delay);\n            viewDistanceUpdateTasks.put(player.getUniqueId(), task);\n        }\n    }\n\n    public void setTargetSendDistance(Player player, int clientSendDistance, boolean testDelay) {\n        int floor = 2;\n        int ceiling = Math.min(seeMore.getSeeMoreConfig().", "first_line_groundtruth": "seeMore.getSeeMoreConfig().updateDelay.get();", "first_line_prediction": "100;", "match": 0}
{"groundtruth": "parsedReport.getAverages().get(test.getTestName()));", "prediction": " parsedReport.getAverage(test.getName())\n                    );\n                    reports.sort(averageComparator.reversed());\n                    System.out.println(test.getName() + \" \" + reports.get(0).getAverage(test.getName()));\n                });\n            } else {\n                List<PerformanceReport> reports = Arrays.asList(\n                        new PerformanceReport(gson, Paths.get(files[0].getAbsolutePath())),\n                        new PerformanceReport(gson, Paths.get(files[1].getAbsolutePath()))\n                );\n\n                performanceTests.forEach(test -> {\n                    Comparator<PerformanceReport> averageComparator = Comparator.comparingDouble(", "first_line_groundtruth": "parsedReport.getAverages().get(test.getTestName()));", "first_line_prediction": " parsedReport.getAverage(test.getName())", "match": 0}
{"groundtruth": ".out.println(\"Successfully completed \" + test.getTestName() + \" in \" + timeElapsed + \" ms!\");", "prediction": ".out.printf(\"Test %s took %d ms to run.%n\", test.getTestName(), timeElapsed);\n\n            report.add(test, results);\n        });\n\n        System.out.println(\"Writing report...\");\n\n        try {\n            Files.write(outputDirectory.resolve(\"report-native.json\"), gson.toJson(report).getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"Report written!\");\n    }", "first_line_groundtruth": ".out.println(\"Successfully completed \" + test.getTestName() + \" in \" + timeElapsed + \" ms!\");", "first_line_prediction": ".out.printf(\"Test %s took %d ms to run.%n\", test.getTestName(), timeElapsed);", "match": 0}
{"groundtruth": "\"results for \" + test.getTestName() + \"!\");", "prediction": " \" results!\");\n                    }\n\n                    ParsedReport slowerReport = slowerOptional.get();\n                    ParsedReport fasterReport = fasterOptional.get();\n\n                    if (reportToAverage.apply(slowerReport) > reportToAverage.apply(fasterReport)) {\n                        System.out.println(\"Test \" + test.getTestName() + \" is slower than \" + slowerReport.getTestName() + \"!\");\n                    } else {\n                        System.out.println(\"Test \" + test.getTestName() + \" is faster than \" + fasterReport.getTestName() + \"!\");\n                    }\n                });\n            } else {\n                throw new", "first_line_groundtruth": "\"results for \" + test.getTestName() + \"!\");", "first_line_prediction": " \" results!\");", "match": 0}
{"groundtruth": "toJson(report.getResults()).getBytes());", "prediction": "toJson(report).getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"Performance report written to \" + outputFile.toAbsolutePath().toString());\n    }", "first_line_groundtruth": "toJson(report.getResults()).getBytes());", "first_line_prediction": "toJson(report).getBytes());", "match": 0}
{"groundtruth": "executor.awaitTermination(30, TimeUnit.SECONDS);", "prediction": " executor.awaitTermination(10, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      log.error(\"Interrupted while waiting for executor to finish\", e);\n    }\n  }", "first_line_groundtruth": "executor.awaitTermination(30, TimeUnit.SECONDS);", "first_line_prediction": " executor.awaitTermination(10, TimeUnit.SECONDS);", "match": 0}
{"groundtruth": "executor.shutdown();", "prediction": " executor.close();\n  }", "first_line_groundtruth": "executor.shutdown();", "first_line_prediction": " executor.close();", "match": 0}
{"groundtruth": ".put(identity.getId(), entry.memberId());", "prediction": ".put(entry.memberId(), identity.toString());\n    }\n\n    assignmentSnapshot = assignmentManager.onElected(members, skipAssignment);\n\n    Map<String, ByteBuffer> result = new HashMap<>();\n    for (M member : members) {\n      ByteBuffer assignment = leaderProtocol.serializeAssignment(assignmentSnapshot);\n      result.put(memberIds.get(member.toString()), assignment);\n    }\n\n    return result;\n  }\n\n  @Override\n  public void close() {\n    assignmentManager.close();\n  }", "first_line_groundtruth": ".put(identity.getId(), entry.memberId());", "first_line_prediction": ".put(entry.memberId(), identity.toString());", "match": 0}
{"groundtruth": "properties.getConsumerConfig();", "prediction": " new ConsumerConfig(properties.getProperties());\n    clientConfig.put(CommonClientConfigs.CLIENT_ID_CONFIG, clientId);\n    clientConfig.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, properties.getBootstrapServers());\n    clientConfig.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, sessionTimeout.toMillis());\n    clientConfig.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, heartbeatInterval.toMillis());\n    clientConfig.put(ConsumerConfig.REBALANCE_TIMEOUT_MS_CONFIG, rebalanceTimeout.toMillis());\n    client", "first_line_groundtruth": "properties.getConsumerConfig();", "first_line_prediction": " new ConsumerConfig(properties.getProperties());", "match": 0}
{"groundtruth": "().getId());", "prediction": "().getId());\n      ByteBuffer assignment = leaderProtocol.serializeAssignment(entry.getValue());\n      groupAssignment.put(memberId, assignment);\n    }\n\n    if (!skipAssignment) {\n      assignmentSnapshot = assignments.get(identity);\n      assignmentManager.onAssigned(assignmentSnapshot, generation);\n    }\n\n    return groupAssignment;\n  }\n\n  @Override\n  public void close() {\n    assignmentManager.close();\n  }", "first_line_groundtruth": "().getId());", "first_line_prediction": "().getId());", "match": 1}
{"groundtruth": "identity.getId() + \"-\" + BD_CLIENT_ID_SEQUENCE.getAndIncrement();", "prediction": " BD_CLIENT_ID_SEQUENCE.getAndIncrement() + \"-\" + identity.getId();\n    this.logContext = new LogContext(clientId);\n    this.client = new ConsumerNetworkClient(logContext, clientId);\n    this.retryBackoffMs = properties.getRetryBackoffMs();\n    this.metrics = new Metrics();\n    this.leaderProtocol = leaderProtocol;\n    this.time = Time.SYSTEM;\n    this.rebalanceTimeout = rebalanceTimeout;\n    this.sessionTimeout = sessionTimeout;\n    this.heartbeatInterval = heartbeatInterval;\n\n    this.pollingThread = new Thread(this::poll);", "first_line_groundtruth": "identity.getId() + \"-\" + BD_CLIENT_ID_SEQUENCE.getAndIncrement();", "first_line_prediction": " BD_CLIENT_ID_SEQUENCE.getAndIncrement() + \"-\" + identity.getId();", "match": 0}
{"groundtruth": "[j].spawn();", "prediction": " = null;\n                    particles[i][j] = null;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void despawn() {\n        ParticleConstructDespawnEvent event = new ParticleConstructDespawnEvent(this);\n        Bukkit.getPluginManager().callEvent(event);\n        if (event.isCancelled()) return;\n        for (int i = 0; i < particles.length; i++) {\n            for (int j = 0; j < particles[0].length; j++) {\n                if (particles[i][j] != null) {\n                    particles[i] = null", "first_line_groundtruth": "[j].spawn();", "first_line_prediction": " = null;", "match": 0}
{"groundtruth": "if (!particleSpawnEvent.isCancelled()) {", "prediction": " if (!particleSpawnEvent.isCancelled()) {\n             getLocation().getWorld().spawnParticle(getType(), getLocation(), 0, note);\n         }\n    }", "first_line_groundtruth": "if (!particleSpawnEvent.isCancelled()) {", "first_line_prediction": " if (!particleSpawnEvent.isCancelled()) {", "match": 0}
{"groundtruth": "[j].clone();", "prediction": " == null ? null : particles[i][j].clone();\n                clonedParticle.setLocation(locations[i][j]);\n                this.particles[i][j] = clonedParticle;\n            }\n        }\n    }\n\n    public void setLocations(Location[][] locations) {\n        if (locations.length != particles.length || locations[0].length != particles[0].length) {\n            throw new IllegalArgumentException(\"Location[][] lengths must be equal to RegularParticle[][] lengths\");\n        }\n\n        for (int i = 0; i < locations.length; i++) {\n            for (int j = 0; j < locations", "first_line_groundtruth": "[j].clone();", "first_line_prediction": " == null ? null : particles[i][j].clone();", "match": 0}
{"groundtruth": "ToyController.instance().setScalarLevel(intensity);", "prediction": "\tif (intensity > 0.5f) {\n\t\t\t\tif (intensity > 0.9f) {\n\t\t\t\t\tif (intensity > 0.99f) {\n\t\t\t\t\t\tif (intensity > 0.999f) {\n\t\t\t\t\t\t\tif (intensity > 0.9999f) {\n\t\t\t\t\t\t\t\tif (intensity > 0.99999f) {\n\t\t\t\t\t\t\t\t\tif (intensity > 0.999999f) {\n\t\t\t\t\t\t\t\t\t\tif (intensity > 0.9999999f) {\n\t\t\t\t\t\t\t\t\t\t\tif (", "first_line_groundtruth": "ToyController.instance().setScalarLevel(intensity);", "first_line_prediction": "\tif (intensity > 0.5f) {", "match": 0}
{"groundtruth": "ToyController.instance().setScalarLevel(0);", "prediction": "\tToyController.instance().setLinearLevel(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}", "first_line_groundtruth": "ToyController.instance().setScalarLevel(0);", "first_line_prediction": "\tToyController.instance().setLinearLevel(0);", "match": 0}
{"groundtruth": "masochistPointsCounter.onHurt(amount);", "prediction": "\tminingPointsCounter.onHurt(amount);", "first_line_groundtruth": "masochistPointsCounter.onHurt(amount);", "first_line_prediction": "\tminingPointsCounter.onHurt(amount);", "match": 0}
{"groundtruth": "abstractPointsCounter.getInstantPoints(), instanPoints);", "prediction": "instanPoints, abstractPointsCounter.getInstantPoints());\n\t\t}", "first_line_groundtruth": "abstractPointsCounter.getInstantPoints(), instanPoints);", "first_line_prediction": "instanPoints, abstractPointsCounter.getInstantPoints());", "match": 0}
{"groundtruth": "skipDownTick += abstractPointsCounter.getSkipDownTicks();", "prediction": "\tskipDownTick = Math.max(abstractPointsCounter.getSkipDownTicks(), skipDownTick);\n\t\t}\n\t\treturn skipDownTick;", "first_line_groundtruth": "skipDownTick += abstractPointsCounter.getSkipDownTicks();", "first_line_prediction": "\tskipDownTick = Math.max(abstractPointsCounter.getSkipDownTicks(), skipDownTick);", "match": 0}
{"groundtruth": "= Math.max(abstractPointsCounter.getPoints(), points);", "prediction": " = Math.max(abstractPointsCounter.getPoints(), points);\n\t\t}\n\t\treturn points;", "first_line_groundtruth": "= Math.max(abstractPointsCounter.getPoints(), points);", "first_line_prediction": " = Math.max(abstractPointsCounter.getPoints(), points);", "match": 0}
{"groundtruth": "ToyController.instance().setLinearLevel(intensity);", "prediction": "\tToyController.instance().setFeedback(true);\n\t\t} else {\n\t\t\tToyController.instance().setFeedback(false);\n\t\t}", "first_line_groundtruth": "ToyController.instance().setLinearLevel(intensity);", "first_line_prediction": "\tToyController.instance().setFeedback(true);", "match": 0}
{"groundtruth": "abstractPointsCounter.onTick();", "prediction": "\tabstractPointsCounter.onPlayerTick();\n\t\t}", "first_line_groundtruth": "abstractPointsCounter.onTick();", "first_line_prediction": "\tabstractPointsCounter.onPlayerTick();", "match": 0}
{"groundtruth": "masochistPointsCounter.onDeath();", "prediction": "\t// experienceCounter.onDeath();", "first_line_groundtruth": "masochistPointsCounter.onDeath();", "first_line_prediction": "\t// experienceCounter.onDeath();", "match": 0}
{"groundtruth": ", file.genThumbnailPath());", "prediction": ", file.getThumbnailPath());\n    BaseFile newFileMeta = createOrUpdateFileMeta(tags, fileId, file.getPath(), file.getName(),\n        newFile.getSize());\n    BaseFile newFileData = createOrUpdateFile(newFile, tags, fileId, file.getPath(),\n        newFile.getSize());\n    return newFileData;\n  }", "first_line_groundtruth": ", file.genThumbnailPath());", "first_line_prediction": ", file.getThumbnailPath());", "match": 0}
{"groundtruth": "= LdsUtil.getFileBucketPath(basePath, newFileId);", "prediction": " = LdsUtil.getPathId(fileId);\n    FileMeta fileMeta = new FileMeta(fileId, newFileId, fileName, size, tags);\n    firestoreService.createOrUpdateFileMeta(fileMeta);\n    return new BaseFile(fileId, fileBucketPath, fileName, size, tags);\n  }", "first_line_groundtruth": "= LdsUtil.getFileBucketPath(basePath, newFileId);", "first_line_prediction": " = LdsUtil.getPathId(fileId);", "match": 0}
{"groundtruth": "(newFile.checkImageFileType()) {", "prediction": " (file.getContentType().startsWith(\"image\")) {\n      Thumbnails.of(file.getBytes())\n          .size(THUMBNAIL_SIZE, THUMBNAIL_SIZE)\n          .toFile(newFile.genThumbnailPath());\n    }\n    return newFile;\n  }\n\n  /**\n    * Create or update a file meta in Firestore with the given fileId.\n    *\n    * @param tags list of tags label the file\n    * @param fileId unique ID of the file\n    * @param newFileId unique ID of the new file (for referencing Cloud Storage)\n    * @param name name", "first_line_groundtruth": "(newFile.checkImageFileType()) {", "first_line_prediction": " (file.getContentType().startsWith(\"image\")) {", "match": 0}
{"groundtruth": "newFile.genThumbnailPath());", "prediction": "300, newFile);\n    }\n    return newFile;\n  }\n\n  /**\n    * Create or update a file meta in Firestore with the given fileId.\n    *\n    * @param tags list of tags label the file\n    * @param fileId unique ID of the file\n    * @param newFileId unique ID of the new file (for referencing Cloud Storage)\n    * @param name name of the file\n    * @param size size of the file\n    * @return file data\n    */\n  private BaseFile createOrUpdateFileMeta(\n      List<String> tags, String fileId, String newFileId", "first_line_groundtruth": "newFile.genThumbnailPath());", "first_line_prediction": "300, newFile);", "match": 0}
{"groundtruth": ".orderNo = System.currentTimeMillis() + \"-\" + LdsUtil.getPathId(path);", "prediction": ".size = size;\n  }\n\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public void setPath(String path) {\n    this.path = path;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public List<String> getTags() {\n    return tags;\n  }\n\n  public void setTags(List<String> tags) {\n   ", "first_line_groundtruth": ".orderNo = System.currentTimeMillis() + \"-\" + LdsUtil.getPathId(path);", "first_line_prediction": ".size = size;", "match": 0}
{"groundtruth": "storageService.batchDelete(bucketName);", "prediction": " storageService.deleteAll(bucketName);\n  }\n\n  /**\n    * Create a new file in Firestore and Cloud Storage.\n    *\n    * @param file the uploaded file\n    * @param tags list of tags label the file\n    * @param fileId unique id of the file\n    * @param newFileId unique id of the new file\n    * @param size size of the file\n    * @return the new file\n    */\n  private BaseFile createOrUpdateFile(\n      MultipartFile file, List<String> tags, String fileId, String newFileId, long size)\n      throws InterruptedException, ExecutionException, IOException", "first_line_groundtruth": "storageService.batchDelete(bucketName);", "first_line_prediction": " storageService.deleteAll(bucketName);", "match": 0}
{"groundtruth": "resourceBasePath = LdsUtil.getResourceBasePath(basePath);", "prediction": " orderNo = null;\n    if (!CollectionUtils.isEmpty(documents)) {\n      orderNo = documents.get(0).getString(ORDER_NO);\n    }\n    return documents.stream()\n        .map(doc -> new BaseFile(doc.getId(), doc.getString(FieldPath.documentId()),\n            doc.getString(FieldPath.documentId()), doc.getString(FieldPath.documentId()),\n            doc.getString(FieldPath.documentId()), doc.getLong(FieldPath.documentId()),\n            doc.getLong(FieldPath.documentId()), doc.getLong(FieldPath.documentId()),\n           ", "first_line_groundtruth": "resourceBasePath = LdsUtil.getResourceBasePath(basePath);", "first_line_prediction": " orderNo = null;", "match": 0}
{"groundtruth": "BaseFile oldFile = fileService.getFileById(fileId);", "prediction": " BaseFile newFile = fileService.updateFile(fileId, file, tags);\n       return ResponseEntity.ok().body(new FileResponse(newFile));\n     });\n   }", "first_line_groundtruth": "BaseFile oldFile = fileService.getFileById(fileId);", "first_line_prediction": " BaseFile newFile = fileService.updateFile(fileId, file, tags);", "match": 0}
{"groundtruth": "(contextValue.getType(), contextValue.getId());", "prediction": "(contextValue);\n    }\n\n    @Override\n    public boolean isCrossContext() {\n      return false;\n    }\n  }\n\n  private static final String CQL_LIBRARY_ID_KEY = \"cqlLibraryId\";\n  private static final String CQL_LIBRARY_VERSION_KEY = \"cqlLibraryVersion\";\n  private static final String CQL_LIBRARY_NAME_KEY = \"cqlLibraryName\";\n  private static final String CQL_LIBRARY_DESCRIPTION_KEY = \"cqlLibraryDescription\";\n  private static final String CQL_LIBRARY_EXPRESSION_KEY = \"cqlLibraryExpression\";\n  private static final String CQL_", "first_line_groundtruth": "(contextValue.getType(), contextValue.getId());", "first_line_prediction": "(contextValue);", "match": 0}
{"groundtruth": "enterContext(contextValue.getType());", "prediction": "setContextValue(contextValue.getType(), contextValue.getId());\n    }\n\n    @Override\n    public boolean isCrossContext() {\n      return false;\n    }\n  }\n\n  private static final String CQL_LIBRARY_ID_KEY = \"cqlLibraryId\";\n  private static final String CQL_LIBRARY_VERSION_KEY = \"cqlLibraryVersion\";\n  private static final String CQL_LIBRARY_NAME_KEY = \"cqlLibraryName\";\n  private static final String CQL_LIBRARY_DESCRIPTION_KEY = \"cqlLibraryDescription\";\n  private static final String CQL_LIBRARY_EXPRESSION_KEY = \"cqlLibrary", "first_line_groundtruth": "enterContext(contextValue.getType());", "first_line_prediction": "setContextValue(contextValue.getType(), contextValue.getId());", "match": 0}
{"groundtruth": "contextValue.getId());", "prediction": "0, contextValue.getId());\n    }\n\n    @Override\n    public boolean isCrossContext() {\n      return false;\n    }\n  }\n\n  private static final String CQL_LIBRARY_ID_KEY = \"cqlLibraryId\";\n  private static final String CQL_LIBRARY_VERSION_KEY = \"cqlLibraryVersion\";\n  private static final String CQL_LIBRARY_NAME_KEY = \"cqlLibraryName\";\n  private static final String CQL_LIBRARY_DESCRIPTION_KEY = \"cqlLibraryDescription\";\n  private static final String CQL_LIBRARY_EXPRESSION_KEY = \"cqlLibraryExpression\";\n  private static final String", "first_line_groundtruth": "contextValue.getId());", "first_line_prediction": "0, contextValue.getId());", "match": 0}
{"groundtruth": "diceResult.setAmeacas(0);", "prediction": " diceResult.setDesastres(0);\n        } else if (advantage - threat < 0) {\n            diceResult.setVantagens(0);\n            diceResult.setDesastres(threat - advantage);\n        } else {\n            diceResult.setVantagens(0);\n            diceResult.setDesastres(0);\n        }\n\n        if (triumph - despair > 0) {\n            diceResult.setTriunfos(triumph - despair);\n            diceResult.setDesastres(0);\n        } else if (triumph - despair", "first_line_groundtruth": "diceResult.setAmeacas(0);", "first_line_prediction": " diceResult.setDesastres(0);", "match": 0}
{"groundtruth": "(libraryIds.getVersion()),\n          new CqlTranslatorOptions(TRANSLATOR_OPTIONS),\n          errors);", "prediction": "(libraryIds.getVersion()),\n          errors);\n      if (!errors.isEmpty()) {\n        throw new RuntimeException(\n            \"Failed to resolve library \" + libraryIds.getName() + \" \" + libraryIds.getVersion()\n                + \": \" + errors.get(0).getMessage());\n      }\n    }\n\n    return libraryManager.getLibraries().stream()\n        .map(CompiledLibrary::getLibrary)\n        .collect(toImmutableList());\n  }\n\n  private static ImmutableList<Library> loadLibraries(\n      Path cqlFolder, Collection<CqlLibraryId> cqlLibraryIds, FhirVersionEnum fhirVersion) {\n    Library", "first_line_groundtruth": "(libraryIds.getVersion()),", "first_line_prediction": "(libraryIds.getVersion()),", "match": 1}
{"groundtruth": "diceResult.setFracassos(0);", "prediction": " diceResult.setDesastres(failure);\n        } else {\n            diceResult.setSucessos(success);\n            diceResult.setDesastres(0);\n        }\n        if (triumph - despair > 0) {\n            diceResult.setTriunfos(triumph - despair);\n            diceResult.setDesastres(despair);\n        } else {\n            diceResult.setTriunfos(triumph);\n            diceResult.setDesastres(0);\n        }\n        if (advantage - threat > 0) {\n            diceResult.set", "first_line_groundtruth": "diceResult.setFracassos(0);", "first_line_prediction": " diceResult.setDesastres(failure);", "match": 0}
{"groundtruth": "super.resolveType(value);", "prediction": " super.resolveType(value);\n        });\n  }", "first_line_groundtruth": "super.resolveType(value);", "first_line_prediction": " super.resolveType(value);", "match": 0}
{"groundtruth": "diceResult.setFracassos(failure - success);", "prediction": " diceResult.setFracassos(success - failure);\n        } else {\n            diceResult.setSucessos(success);\n            diceResult.setFracassos(0);\n        }\n\n        if (triumph - despair > 0) {\n            diceResult.setTriumphos(triumph - despair);\n            diceResult.setDespair(0);\n        } else if (triumph - despair < 0) {\n            diceResult.setTriumphos(0);\n            diceResult.setDespair(triumph - despair);\n        } else {\n            dice", "first_line_groundtruth": "diceResult.setFracassos(failure - success);", "first_line_prediction": " diceResult.setFracassos(success - failure);", "match": 0}
{"groundtruth": "withId(libraryIds.getName())\n              .withVersion(libraryIds.getVersion()),\n          new CqlTranslatorOptions(TRANSLATOR_OPTIONS),\n          errors);", "prediction": "withId(libraryIds.getName())\n               .withVersion(libraryIds.getVersion()),\n          errors);\n      if (!errors.isEmpty()) {\n        throw new RuntimeException(\n            String.format(\n                \"Failed to resolve library %s@%s: %s\",\n                libraryIds.getName(), libraryIds.getVersion(), errors));\n      }\n    }\n\n    return libraryManager.getLibraries().stream()\n        .map(CompiledLibrary::getLibrary)\n        .collect(toImmutableList());\n  }\n\n  private static ImmutableList<Library> loadLibraries(\n      Path cqlFolder, Collection<CqlLibraryId> cqlLibraryIds, F", "first_line_groundtruth": "withId(libraryIds.getName())", "first_line_prediction": "withId(libraryIds.getName())", "match": 1}
{"groundtruth": "diceResult.setSucessos(success - failure);", "prediction": " diceResult.setResultado(\"Voc\u00ea ganhou!\");\n        } else if (success - failure < 0) {\n             diceResult.setResultado(\"Voc\u00ea perdeu!\");\n        } else if (success - failure == 0) {\n             diceResult.setResultado(\"Empate!\");\n        }\n\n        if (success > 0) {\n            diceResult.setResultado(\"Voc\u00ea ganhou!\");\n        } else if (success < 0) {\n            diceResult.setResultado(\"Voc\u00ea perdeu!\");\n        } else if (success == 0) {\n            diceResult", "first_line_groundtruth": "diceResult.setSucessos(success - failure);", "first_line_prediction": " diceResult.setResultado(\"Voc\u00ea ganhou!\");", "match": 0}
{"groundtruth": "service.rollDisVantage(\"Advantage\", dice);", "prediction": "0;\n    }", "first_line_groundtruth": "service.rollDisVantage(\"Advantage\", dice);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "diceResult.setVantagens(advantage - threat);", "prediction": " diceResult.setVantagens(advantage - threat);\n             diceResult.setFracassos(0);\n        } else if (advantage - threat < 0) {\n            diceResult.setVantagens(0);\n            diceResult.setFracassos(threat - advantage);\n        } else {\n            diceResult.setVantagens(0);\n            diceResult.setFracassos(0);\n        }\n\n        if (triumph - despair > 0) {\n            diceResult.setTriumphos(triumph - despair);\n            diceResult.setFracassos", "first_line_groundtruth": "diceResult.setVantagens(advantage - threat);", "first_line_prediction": " diceResult.setVantagens(advantage - threat);", "match": 0}
{"groundtruth": "return openTelemetryService.spanScope(this.getClass().getName(), \"healthCheck\", () -> {", "prediction": " return new ResponseEntity<>(HttpStatus.OK);\n  }\n\n  /**\n   * The upload API.\n   *\n   * @param file the file to be uploaded\n   * @return the file response\n   */\n  @PostMapping(\"/upload\")\n  public ResponseEntity<?> uploadFile(@RequestParam(\"file\") MultipartFile file) throws Exception {\n    log.info(\"uploading file: {}\", file.getOriginalFilename());\n    FileResponse fileResponse = fileService.uploadFile(file);\n    return new ResponseEntity<>(fileResponse, HttpStatus.CREATED);\n  }\n\n  /**\n   * The list API.\n   *\n   * @param searchTerm the search term\n  ", "first_line_groundtruth": "return openTelemetryService.spanScope(this.getClass().getName(), \"healthCheck\", () -> {", "first_line_prediction": " return new ResponseEntity<>(HttpStatus.OK);", "match": 0}
{"groundtruth": "diceResult.setDesesperos(0);", "prediction": " diceResult.setDespairas(0);\n        } else if (triumph - despair < 0) {\n            diceResult.setTriunfos(0);\n            diceResult.setDespairas(despair - triumph);\n        } else {\n            diceResult.setTriunfos(0);\n            diceResult.setDespairas(0);\n        }\n\n        return diceResult;\n    }\n\n    public ResultadoSwForceDTO rollSwForceDice(DiceSwDTO dice) {\n        int success = 0;\n        int triumph = 0;\n        int advantage = ", "first_line_groundtruth": "diceResult.setDesesperos(0);", "first_line_prediction": " diceResult.setDespairas(0);", "match": 0}
{"groundtruth": "= HydraulicImpl.instance().mod(modId);", "prediction": " = HydraulicImpl.getInstance().getModInfo(modId);\n\n        // Get the item name from the identifier\n        String itemName = identifier.substring(identifier.indexOf(\":\") + 1);\n\n        // Get the item from the mod\n        Item item = mod.getItem(itemName);\n\n        // Get the item's NBT\n        CompoundTag itemNbt = item.getNbt();\n\n        // Add the item's NBT to the item's NBT\n        newNbt.put(itemNbt);\n\n        // Add the item's NBT to the item's NBT\n        newNbt.put(item", "first_line_groundtruth": "= HydraulicImpl.instance().mod(modId);", "first_line_prediction": " = HydraulicImpl.getInstance().getModInfo(modId);", "match": 0}
{"groundtruth": "return HydraulicImpl.instance().dataFolder(Constants.MOD_ID)\n                .resolve(\"storage\")\n                .resolve(mod.id());", "prediction": " return HydraulicImpl.getInstance().modStoragePath().resolve(mod.id());\n    }", "first_line_groundtruth": "return HydraulicImpl.instance().dataFolder(Constants.MOD_ID)", "first_line_prediction": " return HydraulicImpl.getInstance().modStoragePath().resolve(mod.id());", "match": 0}
{"groundtruth": "forceResult.setLuz(light);", "prediction": " forceResult.setForca(light);\n         forceResult.setDestreza(dark);\n         return forceResult;\n    }", "first_line_groundtruth": "forceResult.setLuz(light);", "first_line_prediction": " forceResult.setForca(light);", "match": 0}
{"groundtruth": "this.hydraulic.server().registryAccess().registryOrThrow(key);", "prediction": " this.mod.registry(key);\n        return registry.getValues();\n    }\n\n    /**\n     * Gets the values from the specified {@link Registry registry}\n     * that are relevant for the {@link ModInfo mod} this pack is\n     * part of.\n     *\n     * @param key the key of the registry to get the values from\n     * @param <V> the type of the registry\n     * @return the values from the specified registry that are relevant for this mod\n     */\n    @NotNull\n    public <V> Map<ResourceKey<V>, V> registryEntries(@NotNull ResourceKey<Registry<V>> key", "first_line_groundtruth": "this.hydraulic.server().registryAccess().registryOrThrow(key);", "first_line_prediction": " this.mod.registry(key);", "match": 0}
{"groundtruth": "forceResult.setNegro(dark);", "prediction": " forceResult.setEscuridao(dark);\n        return forceResult;\n    }", "first_line_groundtruth": "forceResult.setNegro(dark);", "first_line_prediction": " forceResult.setEscuridao(dark);", "match": 0}
{"groundtruth": ".packManager.initialize();", "prediction": ".platform.onServerStarting(server);\n        this.bootstrap.onServerStarting(server);\n        this.packManager.onServerStarting(server);\n    }\n\n    /**\n     * Called when the server is stopping.\n     *\n     * @param server the Minecraft server instance\n     */\n    public void onServerStopping(@NotNull MinecraftServer server) {\n        this.server = null;\n\n        this.platform.onServerStopping(server);\n        this.bootstrap.onServerStopping(server);\n        this.packManager.onServerStopping(server);\n    }\n\n    /**\n     * Loads the Hydraulic mod.\n     *", "first_line_groundtruth": ".packManager.initialize();", "first_line_prediction": ".platform.onServerStarting(server);", "match": 0}
{"groundtruth": "result = boostDice.roll();", "prediction": "roller = boostDice.roll();\n            if (roller == 1) {\n                success++;\n            } else if (roller == 2) {\n                triumph++;\n            } else if (roller == 3) {\n                advantage++;\n            } else if (roller == 4) {\n                failure++;\n            } else if (roller == 5) {\n                despair++;\n            } else if (roller == 6) {\n                threat++;\n            }\n        }\n        for (int i = 0; i < ability; i++) {\n            Dice abilityDice = new Dice(6);\n            int roller", "first_line_groundtruth": "result = boostDice.roll();", "first_line_prediction": "roller = boostDice.roll();", "match": 0}
{"groundtruth": "this.bootstrap.mods();", "prediction": " this.platform.mods();\n    }\n\n    /**\n     * Gets the mod with the specified name, or null if not found.\n     *\n     * @param name the name of the mod\n     * @return the mod with the specified name, or null if not found\n     */\n    @Nullable\n    public ModStorage getModStorage(String name) {\n        return this.modStorage.get(name);\n    }\n\n    /**\n     * Gets the mod with the specified name, or null if not found.\n     *\n     * @param name the name of the mod\n     * @return the mod with the specified name, or null if", "first_line_groundtruth": "this.bootstrap.mods();", "first_line_prediction": " this.platform.mods();", "match": 0}
{"groundtruth": "logger.Info(String.format(\"[%s] [%s] websocket is closed\", conversationSignature, question));", "prediction": " callback.onClosed(code, reason);\n    }\n\n    @Override\n    public void onClosing(@NotNull WebSocket webSocket, int code, @NotNull String reason) {\n        callback.onClosing(code, reason);\n    }\n\n    @Override\n    public void onFailure(@NotNull WebSocket webSocket, @NotNull Throwable t, @Nullable Response response) {\n        callback.onFailure(t, response);\n    }\n\n    @Override\n    public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) {\n        JsonObject json = JsonParser.parseString(text).getAsJsonObject();\n        if (json.has(\"type\")) {", "first_line_groundtruth": "logger.Info(String.format(\"[%s] [%s] websocket is closed\", conversationSignature, question));", "first_line_prediction": " callback.onClosed(code, reason);", "match": 0}
{"groundtruth": "logger.Debug(String.format(\"[%s] [%s] client send message [%s]\", conversationSignature, question, data));", "prediction": " ws.send(data);\n    }", "first_line_groundtruth": "logger.Debug(String.format(\"[%s] [%s] client send message [%s]\", conversationSignature, question, data));", "first_line_prediction": " ws.send(data);", "match": 0}
{"groundtruth": "logger.Debug(String.format(\"[%s] [%s] websocket is received new message [%s]\", conversationSignature, question, textSpited));", "prediction": " logger.Debug(String.format(\"[%s] [%s] websocket is received: [%s]\", conversationSignature, question, textSpited));\n            if (textSpited.startsWith(\"[\")) {\n                JsonObject json = JsonParser.parseString(textSpited).getAsJsonObject();\n                if (json.has(\"type\")) {\n                    if (json.get(\"type\").getAsString().equals(\"participant\")) {\n                        Participant participant = new GsonBuilder().create().fromJson(json, Participant.class);\n                        logger.Debug(String.format(\"[%s] [%s] websocket is received: [%s]\",", "first_line_groundtruth": "logger.Debug(String.format(\"[%s] [%s] websocket is received new message [%s]\", conversationSignature, question, textSpited));", "first_line_prediction": " logger.Debug(String.format(\"[%s] [%s] websocket is received: [%s]\", conversationSignature, question, textSpited));", "match": 0}
{"groundtruth": "(String.format(\"%s   %s\", country.getEmoji(), country.getName()));", "prediction": "(country.getEmoji() + \" \" + country.getName());\n    holder.callingCode.setText(country.getCallingCode());\n\n    // Set the background color of the list item\n    holder.itemView.setBackgroundColor(darkMode ? Color.parseColor(\"#222222\") : Color.WHITE);\n  }\n\n  @Override\n  public int getItemCount() {\n    return countries.size();\n  }\n\n  public void setDefaultCountry(int defaultCountry) {\n    this.defaultCountry = defaultCountry;\n  }", "first_line_groundtruth": "(String.format(\"%s   %s\", country.getEmoji(), country.getName()));", "first_line_prediction": "(country.getEmoji() + \" \" + country.getName());", "match": 0}
{"groundtruth": "setText(String.format(\"%s   %s\", country.getEmoji(), country.getName()));", "prediction": "setText(country.getEmoji() + \" \" + country.getName());\n    holder.callingCode.setText(country.getCallingCode());\n\n    // Set the background color of the list item\n    holder.itemView.setBackgroundColor(darkMode ? Color.BLACK : Color.WHITE);\n  }\n\n  @Override\n  public int getItemCount() {\n    return countries.size();\n  }\n\n  public void setDefaultCountry(int defaultCountry) {\n    this.defaultCountry = defaultCountry;\n  }", "first_line_groundtruth": "setText(String.format(\"%s   %s\", country.getEmoji(), country.getName()));", "first_line_prediction": "setText(country.getEmoji() + \" \" + country.getName());", "match": 0}
{"groundtruth": "(country.getCallingCode());", "prediction": "(country.getCallingCode());\n\n    // Set the background color of the list item\n    holder.itemView.setBackgroundColor(darkMode ? Color.BLACK : Color.WHITE);\n  }\n\n  @Override\n  public int getItemCount() {\n    return countries.size();\n  }\n\n  public void setDefaultCountry(int defaultCountry) {\n    this.defaultCountry = defaultCountry;\n  }", "first_line_groundtruth": "(country.getCallingCode());", "first_line_prediction": "(country.getCallingCode());", "match": 1}
{"groundtruth": "country.getCode();", "prediction": " country.getCode();\n      }\n    };\n  }", "first_line_groundtruth": "country.getCode();", "first_line_prediction": " country.getCode();", "match": 0}
{"groundtruth": ", String> available = TraceUtils.listCategories();", "prediction": ", String> map = new TreeMap<String, String>();\n                for (String s : set) {\n                    map.put(s, s);\n                }\n                mTags.setEntries(map.values().toArray(new String[map.size()]));\n                mTags.setEntryValues(map.keySet().toArray(new String[map.size()]));\n                return true;\n            }\n        });\n\n        mRefreshReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                refreshUi();\n            }\n        };\n\n        IntentFilter filter = new IntentFilter();\n        filter", "first_line_groundtruth": ", String> available = TraceUtils.listCategories();", "first_line_prediction": ", String> map = new TreeMap<String, String>();", "match": 0}
{"groundtruth": "Process perfetto = TraceUtils.exec(cmd, null, false);", "prediction": " Process process = TraceUtils.exec(cmd);\n             BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n             String line;\n             while ((line = reader.readLine()) != null) {\n                 if (line.startsWith(\"  category: \")) {\n                     String category = line.substring(12);\n                     result.put(category, category);\n                 }\n             }\n             return result;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "first_line_groundtruth": "Process perfetto = TraceUtils.exec(cmd, null, false);", "first_line_prediction": " Process process = TraceUtils.exec(cmd);", "match": 0}
{"groundtruth": "TraceUtils.traceStop();", "prediction": " // If the user thinks tracing is off and the trace processor agrees, we have no work to do.\n         // We must still start a foreground service, but let's log as an FYI.\n        if (!TraceUtils.isTracingOn()) {\n            Log.i(TAG, \"StopTraceService does not see a trace to stop.\");\n        }\n    }\n\n    public static void notifySessionStopped(Context context, String traceId) {\n        Intent intent = new Intent(INTENT_ACTION_NOTIFY_SESSION_STOPPED);\n        intent.putExtra(INTENT_EXTRA_TAGS, traceId);\n        context.", "first_line_groundtruth": "TraceUtils.traceStop();", "first_line_prediction": " // If the user thinks tracing is off and the trace processor agrees, we have no work to do.", "match": 0}
{"groundtruth": "false : TraceUtils.isTracingOn();", "prediction": " false :\n                prefs.getBoolean(context.getString(R.string.pref_key_trace_utils_tracing_on), false);\n\n        boolean tracingIsOn = prefsTracingOn || traceUtilsTracingOn;\n\n        if (tracingIsOn) {\n            Log.i(TAG, \"Tracing is on\");\n            TraceurService.startTracing(context);\n        } else {\n            Log.i(TAG, \"Tracing is off\");\n            TraceurService.stopTracing(context);\n        }\n    }\n\n    public static void updateDeveloperOptionsWatcher(Context context) {\n        if (mDeveloperOptionsObserver == null) {", "first_line_groundtruth": "false : TraceUtils.isTracingOn();", "first_line_prediction": " false :", "match": 0}
{"groundtruth": "(TraceUtils.traceStart(tags, bufferSizeKb, appTracing,\n                longTrace, attachToBugreport, maxLongTraceSizeMb, maxLongTraceDurationMinutes)) {", "prediction": " (attachToBugreport) {\n            TraceUtils.traceStart(tags, bufferSizeKb, appTracing, longTrace,\n                    maxLongTraceSizeMb, maxLongTraceDurationMinutes);\n        } else {\n            TraceUtils.traceStart(tags, bufferSizeKb, appTracing, longTrace,\n                    maxLongTraceSizeMb, maxLongTraceDurationMinutes, false);\n        }\n    }\n\n    private void stopTracingInternal(String outputFilename, boolean notifySessionStopped,\n            boolean notifySessionStolen) {\n        Context context = getApplicationContext();\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        boolean attachToBugreport", "first_line_groundtruth": "(TraceUtils.traceStart(tags, bufferSizeKb, appTracing,", "first_line_prediction": " (attachToBugreport) {", "match": 0}
{"groundtruth": "Process process = TraceUtils.exec(cmd);", "prediction": " Process process = TraceUtils.execWithTimeout(cmd, null, 1000);\n             if (process == null) {\n                 return false;\n             } else if (process.exitValue() != 0) {\n                 Log.e(TAG, \"perfetto is_detached failed with: \" + process.exitValue());\n                 return false;\n             }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return true;\n    }\n\n    public boolean isTraceDumped() {\n        return Files.exists(Paths.get(TEMP_TRACE_LOCATION));\n    }\n\n   ", "first_line_groundtruth": "Process process = TraceUtils.exec(cmd);", "first_line_prediction": " Process process = TraceUtils.execWithTimeout(cmd, null, 1000);", "match": 0}
{"groundtruth": "(TraceUtils.getOutputFilename(), false, false);", "prediction": "();\n        } else if (intent.getAction().equals(INTENT_ACTION_NOTIFY_SESSION_STOPPED)) {\n            notifySessionStopped(context);\n        } else if (intent.getAction().equals(INTENT_ACTION_NOTIFY_SESSION_STOLEN)) {\n            notifySessionStolen(context);\n        }\n    }\n\n    private void startTracingInternal(Collection<String> tags, int bufferSizeKb,\n            boolean apps, boolean longTrace, int maxLongTraceSizeMb,\n            int maxLongTraceDurationMinutes) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n        prefs.edit().put", "first_line_groundtruth": "(TraceUtils.getOutputFilename(), false, false);", "first_line_prediction": "();", "match": 0}
{"groundtruth": "= TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);", "prediction": " = Runtime.getRuntime().exec(cmd);\n            process.waitFor();\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to start perfetto trace.\", e);\n            return null;\n        }\n\n        Log.v(TAG, \"Finished perfetto trace.\");\n\n        // The trace file is now in the temp location.\n        File traceFile = new File(TEMP_TRACE_LOCATION);\n        if (!traceFile.exists()) {\n            Log.e(TAG, \"Failed to find trace file.\");\n            return null;\n        }\n\n        // The trace file is now in the temp location.", "first_line_groundtruth": "= TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);", "first_line_prediction": " = Runtime.getRuntime().exec(cmd);", "match": 0}
{"groundtruth": "ps = TraceUtils.exec(\"ps -AT\", null, false);", "prediction": "atemp = TraceUtils.execWithTimeout(\"atrace --async_dump\", null, 10000);\n            if (atemp.waitFor() != 0) {\n                Log.e(TAG, \"atraceDump failed with: \" + atemp.exitValue());\n                return false;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return true;\n    }\n\n    public boolean traceDump(Streamer streamer) {\n        String cmd = \"atrace --async_stop -z -c -o -\";\n\n        Log.v(TAG,", "first_line_groundtruth": "ps = TraceUtils.exec(\"ps -AT\", null, false);", "first_line_prediction": "atemp = TraceUtils.execWithTimeout(\"atrace --async_dump\", null, 10000);", "match": 0}
{"groundtruth": "prefsTracingOn && !TraceUtils.isTracingOn()) {", "prediction": "prefsTracingOn) {\n            Log.i(TAG, \"Tracing is off, not stopping trace.\");\n            return;\n        }\n        // If the user thinks tracing is on and the trace processor agrees, we have no work to do.\n        // We must still start a foreground service, but let's log as an FYI.\n        if (TraceUtils.isTracingOn()) {\n            Log.i(TAG, \"Tracing is on, not stopping trace.\");\n            return;\n        }\n        // If the user thinks tracing is on and the trace processor disagrees, we have to stop the\n        // trace.", "first_line_groundtruth": "prefsTracingOn && !TraceUtils.isTracingOn()) {", "first_line_prediction": "prefsTracingOn) {", "match": 0}
{"groundtruth": "TraceUtils.clearSavedTraces();", "prediction": " TraceUtils.clearSavedTraces(getContext());\n                                    }\n                                })\n                             .setNegativeButton(R.string.cancel, null)\n                             .show();\n                        return true;\n                    }\n                });\n\n        mRefreshReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                refreshUi();\n            }\n        };\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(ACTION_REFRESH_TAGS);\n        getContext().registerReceiver(mRefreshReceiver, filter);\n\n        mRefreshing = false;\n    }\n\n    @Override\n    public void onDestroy() {\n        super.", "first_line_groundtruth": "TraceUtils.clearSavedTraces();", "first_line_prediction": " TraceUtils.clearSavedTraces(getContext());", "match": 0}
{"groundtruth": "process = TraceUtils.execWithTimeout(cmd, null, STOP_TIMEOUT_MS);", "prediction": " process = TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);\n            if (process == null) {\n                Log.e(TAG, \"perfetto traceStop failed with: \" + process.exitValue());\n            } else if (process.exitValue() != 0) {\n                Log.e(TAG, \"perfetto traceStop failed with: \" + process.exitValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        Log.v(TAG, \"perfetto traceStop succeeded!\");\n    }\n\n    public", "first_line_groundtruth": "process = TraceUtils.execWithTimeout(cmd, null, STOP_TIMEOUT_MS);", "first_line_prediction": " process = TraceUtils.execWithTimeout(cmd, TEMP_DIR, STARTUP_TIMEOUT_MS);", "match": 0}
{"groundtruth": "), accessor.getAddition(), recipe.getOutput().getItem(),\n\t\t\t\tnull, null\n\t\t).toJson();", "prediction": "recipe),\n\t\t\t\taccessor.getAddition(recipe),\n\t\t\t\trecipe.getOutput().getItem(),\n\t\t\t\trecipe.getOutput().getCount(),\n\t\t\t\trecipe.getGroup(),\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t).toJson();", "first_line_groundtruth": "), accessor.getAddition(), recipe.getOutput().getItem(),", "first_line_prediction": "recipe),", "match": 0}
{"groundtruth": "innerMsg.free();", "prediction": " innerMsg.release();\n        }\n    }", "first_line_groundtruth": "innerMsg.free();", "first_line_prediction": " innerMsg.release();", "match": 0}
{"groundtruth": ").contains(ConfigManager.getFirstName(p.getProperty(\"nbt.display.Name\")))) {", "prediction": "ArrayList::new).contains(p.getProperty(\"nbt.display.Name\"))) {\n                        int AEsize = ae.length;\n                        String[] newConfig = new String[AEsize + 1];\n                        int h = 0;\n                        while (h < AEsize) {\n                            newConfig[h] = ae[h];\n                            h++;\n                        }\n                        newConfig[h] = p.getProperty(\"nbt.display.Name\");\n                        Gson gson = new Gson();\n                        try {\n                            FileWriter writer = new FileWriter(currentFile);\n                            gson.toJson(new Rename(newConfig), writer);\n                            writer.", "first_line_groundtruth": ").contains(ConfigManager.getFirstName(p.getProperty(\"nbt.display.Name\")))) {", "first_line_prediction": "ArrayList::new).contains(p.getProperty(\"nbt.display.Name\"))) {", "match": 0}
{"groundtruth": "System.out.println(\">>> \u8fde\u63a5\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u6210\u529f! \"+conf.getAddress()+\" <<<\");", "prediction": " // \u8fde\u63a5\u6210\u529f\u540e\uff0c\u5c06\u5ba2\u6237\u7aef\u6dfb\u52a0\u5230\u8fde\u63a5\u6c60\u4e2d\n            addClientToPool();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void onLoseConnect(Future<Void> future){\n        if(future.isSuccess()){\n            return;\n        }\n        // \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5ba2\u6237\u7aef\u4ece\u8fde\u63a5\u6c60\u4e2d\u79fb\u9664\n        removeClientFromPool();\n    }\n\n    private void addClientToPool(){\n        String groupName = getGroupName(conf.getAddress());\n        Set<NettyClient> nettyClientSet = groupPool.get(groupName);\n        if(null == net", "first_line_groundtruth": "System.out.println(\">>> \u8fde\u63a5\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u6210\u529f! \"+conf.getAddress()+\" <<<\");", "first_line_prediction": " // \u8fde\u63a5\u6210\u529f\u540e\uff0c\u5c06\u5ba2\u6237\u7aef\u6dfb\u52a0\u5230\u8fde\u63a5\u6c60\u4e2d", "match": 0}
{"groundtruth": "chIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());", "prediction": " clientIndex = loadBalancePolicy.getClientIndex(ncSet.size());\n            InetSocketAddress inetSocketAddress =\n                    linkedHashSetGetByIndex(ncSet, clientIndex);\n            ch = createClient(serviceName, inetSocketAddress);\n            return put(serviceName, ch);\n        }\n\n        // \u5982\u679c\u4e0a\u8ff0\u64cd\u4f5c ch == null \u6216\u8005 group\u76f8\u7b49 \u90a3\u5c31\u51c6\u5907 \u4ece\u73b0\u6709\u961f\u5217\u4e2d\u9009\u62e9\u4e00\u4f4d\u8fde\u63a5\n        int clientIndex = loadBalancePolicy.getClientIndex(addressSet.size());\n        InetSocketAddress inetSocketAddress =\n                linkedHashSetGetByIndex(addressSet, clientIndex);\n        ch = createClient(serviceName, inetSocketAddress);\n       ", "first_line_groundtruth": "chIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());", "first_line_prediction": " clientIndex = loadBalancePolicy.getClientIndex(ncSet.size());", "match": 0}
{"groundtruth": "(\"\u7cfb\u7edf\u901a\u77e5 - \u6ce8\u610f: \u670d\u52a1\u5668\u8fde\u63a5\u5173\u95ed! >>> \" + conf.getAddress());", "prediction": "(\">>> \u8fde\u63a5\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u5931\u8d25! <<<\");\n        ch = null;\n    }\n\n    /**\n     * \u5173\u95ed\u8fde\u63a5\n     */\n    public void close(){\n        if(ch != null){\n            ch.close();\n        }\n    }", "first_line_groundtruth": "(\"\u7cfb\u7edf\u901a\u77e5 - \u6ce8\u610f: \u670d\u52a1\u5668\u8fde\u63a5\u5173\u95ed! >>> \" + conf.getAddress());", "first_line_prediction": "(\">>> \u8fde\u63a5\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u5931\u8d25! <<<\");", "match": 0}
{"groundtruth": "() < lintConf.getClientMaxConnCount()){", "prediction": "() < lintConf.getMaxClientPerGroup()){\n                ch = createClient(serviceName, addressSet);\n                if(ch != null){\n                    return put(serviceName, ch);\n                }\n            }\n        }\n\n        // \u5982\u679c\u4e0a\u8ff0\u64cd\u4f5c ch == null \u6216\u8005 group\u76f8\u7b49 \u90a3\u5c31\u51c6\u5907 \u4ece\u73b0\u6709\u961f\u5217\u4e2d\u9009\u62e9\u4e00\u4f4d\u8fde\u63a5\n        groupIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());\n        groupName = linkedHashSetGetByIndex(groupNameSet, groupIndex);\n        ncSet = groupPool.get(groupName);\n        if(null != ncSet){\n            // \u5982\u679c\u5f53\u524d\u5f00", "first_line_groundtruth": "() < lintConf.getClientMaxConnCount()){", "first_line_prediction": "() < lintConf.getMaxClientPerGroup()){", "match": 0}
{"groundtruth": "if(null == conf.getAddress()){", "prediction": " Bootstrap bootstrap = new Bootstrap();\n         bootstrap.group(new NioEventLoopGroup())\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<NioSocketChannel>() {\n                     @Override\n                     protected void initChannel(NioSocketChannel ch) throws Exception {\n                         ChannelPipeline pipeline = ch.pipeline();\n                         pipeline.addLast(new NettyClientHandler(conf));\n                     }\n                 });\n         ChannelFuture f = bootstrap.connect(new InetSocketAddress(conf.getAddress(), conf.getPort()));\n         try {\n             f.sync();\n             ch = f.channel();\n         } catch (InterruptedException e) {\n             e.", "first_line_groundtruth": "if(null == conf.getAddress()){", "first_line_prediction": " Bootstrap bootstrap = new Bootstrap();", "match": 0}
{"groundtruth": ".writeBytes(innerMsg.getRequestHeader().toBytesArray());", "prediction": ".writeBytes(innerMsg.getRequestHeader().toBytesArray());\n            // \u5199\u51fabody\n            byteBuf.writeBytes(innerMsg.getRequestBody().toBytesArray());\n        }\n    }", "first_line_groundtruth": ".writeBytes(innerMsg.getRequestHeader().toBytesArray());", "first_line_prediction": ".writeBytes(innerMsg.getRequestHeader().toBytesArray());", "match": 1}
{"groundtruth": "requestBody.setRes(res);", "prediction": " // \u54cd\u5e94\u6d88\u606f\n            RequestBody responseBody = new RequestBody();\n            responseBody.setRes(res);\n            RequestHeader responseHeader = new RequestHeader();\n            responseHeader.setVersion(requestHeader.getVersion());\n            responseHeader.setRequestId(requestHeader.getRequestId());\n            RequestContent responseContent = new RequestContent();\n            responseContent.setRequestHeader(responseHeader);\n            responseContent.setRequestBody(responseBody);\n            // \u51fa\u53d1\u6d88\u606f\u8bfb\u53d6\u4e8b\u4ef6\n            ctx.fireChannelRead(responseContent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "first_line_groundtruth": "requestBody.setRes(res);", "first_line_prediction": " // \u54cd\u5e94\u6d88\u606f", "match": 0}
{"groundtruth": "NettyClient> closeCallback = conf.getCloseCallback();", "prediction": "NettyClient> closeCallback = conf.getCloseCallback();\n        if(Objects.nonNull(closeCallback)){\n            closeCallback.accept(this);\n        }\n    }", "first_line_groundtruth": "NettyClient> closeCallback = conf.getCloseCallback();", "first_line_prediction": "NettyClient> closeCallback = conf.getCloseCallback();", "match": 1}
{"groundtruth": "bs.connect(conf.getAddress()).sync();", "prediction": " bs.connect(conf.getAddress()).sync();\n            if(f.isSuccess()){\n                ch = (NioSocketChannel) f.channel();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workGroup.shutdownGracefully();\n        }\n    }\n\n    public void close(){\n        if(ch != null){\n            ch.close();\n        }\n    }", "first_line_groundtruth": "bs.connect(conf.getAddress()).sync();", "first_line_prediction": " bs.connect(conf.getAddress()).sync();", "match": 0}
{"groundtruth": ".setLength(requestBody.toBytesArray().length);", "prediction": ".setFlag(requestHeader.getFlag() | 0x01);\n        RequestContent responseContent = new RequestContent();\n        responseContent.setRequestHeader(requestHeader);\n        responseContent.setRequestBody(requestBody);\n        ctx.writeAndFlush(responseContent);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }", "first_line_groundtruth": ".setLength(requestBody.toBytesArray().length);", "first_line_prediction": ".setFlag(requestHeader.getFlag() | 0x01);", "match": 0}
{"groundtruth": "Objects.hash(conf.getAddress().getHostName(), conf.getAddress().getPort());", "prediction": "31 * Objects.hash(conf);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        NettyClient that = (NettyClient) obj;\n        return Objects.equals(conf, that.conf);\n    }", "first_line_groundtruth": "Objects.hash(conf.getAddress().getHostName(), conf.getAddress().getPort());", "first_line_prediction": "31 * Objects.hash(conf);", "match": 0}
{"groundtruth": "loadBalancePolicy.getClientIndex(addressSet.size());", "prediction": "0;\n                    groupNameSet = new LinkedHashSet<>();\n                    for(InetSocketAddress address : addressSet){\n                        NettyClient client = new NettyClient(\n                                new NettyConf(lintConf.getNettyConf()),\n                                new ClientFactory(address, loadBalancePolicy));\n                        client.start();\n                        groupNameSet.add(client.getGroupName());\n                        clientIndex++;\n                    }\n                    servicePool.put(serviceName, groupNameSet);\n                }\n            }finally {\n                rLock.unlock();\n            }\n        }\n\n        int clientIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());\n        NettyClient client =", "first_line_groundtruth": "loadBalancePolicy.getClientIndex(addressSet.size());", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "factory = ClientFactory.getInstance();", "prediction": " clientFactory = ClientFactory.getInstance();\n        NettyClient ch = clientFactory.createClient(conf);\n        return ch;\n    }\n\n    private String getGroupName(InetSocketAddress address){\n        return address.getHostName() + \":\" + address.getPort();\n    }\n\n    private InetSocketAddress linkedHashSetGetByIndex(\n            LinkedHashSet<InetSocketAddress> linkedHashSet, int index){\n        int i = 0;\n        for (InetSocketAddress inetSocketAddress : linkedHashSet) {\n            if(i == index){\n                return inetSocketAddress;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    private String linkedHashSetGetByIndex(", "first_line_groundtruth": "factory = ClientFactory.getInstance();", "first_line_prediction": " clientFactory = ClientFactory.getInstance();", "match": 0}
{"groundtruth": "groupIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());", "prediction": " clientIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());\n        InetSocketAddress inetSocketAddress =\n                linkedHashSetGetByIndex(addressSet, clientIndex);\n\n        ch = createClient(serviceName, inetSocketAddress);\n        return put(serviceName, ch);\n    }\n\n    private NettyClient createClient(String serviceName, InetSocketAddress inetSocketAddress){\n        NettyConf conf = new NettyConf();\n        conf.setHost(inetSocketAddress.getHostName());\n        conf.setPort(inetSocketAddress.getPort());\n        conf.setServiceName(serviceName);\n        conf.setClientFactory(ClientFactory.getInstance());\n        NettyClient", "first_line_groundtruth": "groupIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());", "first_line_prediction": " clientIndex = loadBalancePolicy.getClientIndex(groupNameSet.size());", "match": 0}
{"groundtruth": "msg.getMessage());", "prediction": "msg.getMessage());\n        this.code = msg.getCode();\n        this.errorMessage = msg.getMessage();\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n\n    public String getErrorMessage() {\n        return errorMessage;\n    }\n\n    public void setErrorMessage(String errorMessage) {\n        this.errorMessage = errorMessage;\n    }", "first_line_groundtruth": "msg.getMessage());", "first_line_prediction": "msg.getMessage());", "match": 1}
{"groundtruth": "requestHeader.getLength()){", "prediction": " requestHeader.getLength()){\n                return;\n            }\n\n            // \u8bfb\u53d6\u6d88\u606f\u4f53\n            byte[] bodyByteArray = new byte[requestHeader.getLength()];\n            buff.readBytes(bodyByteArray);\n\n            RequestBody requestBody = null;\n            try(ByteArrayInputStream in = new ByteArrayInputStream(bodyByteArray);\n                ObjectInputStream ois = new ObjectInputStream(in);\n                 ) {\n\n                requestBody = (RequestBody) ois.readObject();\n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n\n            // \u8bfb\u53d6\u5b8c\u6210 \u91ca\u653e\u8d44\u6e90\n            buff.resetReaderIndex();\n\n            // \u6784\u9020\u6d88\u606f\n            Request", "first_line_groundtruth": "requestHeader.getLength()){", "first_line_prediction": " requestHeader.getLength()){", "match": 0}
{"groundtruth": "()) && this.getBody().build()) {", "prediction": "())) {\n            CompletableFuture.runAsync(() -> {\n                try {\n                    HttpsURLConnection connection = (HttpsURLConnection) new URL(this.getUrl()).openConnection();\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                    connection.setRequestProperty(\"User-Agent\", \"libasynDiscordWebHook-API\");\n                    connection.setRequestProperty(\"Authorization\", \"Bot \" + Loader.getInstance().getBotToken());\n\n                    OutputStream outputStream = connection.getOutputStream();\n                    outputStream.write(this.getBody().toString().getBytes());\n                   ", "first_line_groundtruth": "()) && this.getBody().build()) {", "first_line_prediction": "())) {", "match": 0}
{"groundtruth": ".getRequestId(), lintConf.getRequestWaitTimeBySeconds());", "prediction": ".getRequestId(),\n                    lintConf.getRpcTimeout()\n            );\n\n            // \u89e3\u9501\u7ebf\u7a0b\n            CountDownLatchPool.countDown(requestHeader.getRequestId());\n\n            // \u53d6\u51fa\u7ed3\u679c\n            responseMsg = MsgPool.getInstance().get(requestHeader.getRequestId());\n        } catch (Exception e) {\n            throw new RpcException(RpcMsg.EXCEPTION_RPC_ERROR, e);\n        } finally {\n            // \u91ca\u653e\u8d44\u6e90\n            MsgPool.getInstance().release(requestHeader.getRequestId(), responseMsg);\n            nc.release();\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.", "first_line_groundtruth": ".getRequestId(), lintConf.getRequestWaitTimeBySeconds());", "first_line_prediction": ".getRequestId(),", "match": 0}
{"groundtruth": ".getBody().toJson().getBytes());", "prediction": ".getBody().toString().getBytes());\n                    stream.flush();\n                    stream.close();\n\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode != 204) {\n                        throw new Exception(\"Error response code: \" + responseCode);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }", "first_line_groundtruth": ".getBody().toJson().getBytes());", "first_line_prediction": ".getBody().toString().getBytes());", "match": 0}
{"groundtruth": "(embed.toArray().entrySet())));", "prediction": "(embed.toArray().entrySet())));\n        if (!embedList.isEmpty()) {\n            result.put(\"embeds\", embedList.toArray());\n        }\n\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Base(tts=\" + this.isTextToSpeech() + \",content=\" + this.getContent() + \",username=\" + this.getUsername() + \",avatar=\" + this.getAvatar() + \",embeds=\" + this.getEmbeds() + \")\";\n    }", "first_line_groundtruth": "(embed.toArray().entrySet())));", "first_line_prediction": "(embed.toArray().entrySet())));", "match": 1}
{"groundtruth": "NPCs.search().indexIs(index).first().flatMap(npc ->\n\t\t{", "prediction": " NPCs.search().indexIs(index).first().flatMap(npc ->\n\t\t\t{\n\t\t\t\tMousePackets.queueClickPacket();\n\t\t\t\tNPCPackets.queueNPCAction(npc, actions);\n\t\t\t\treturn Optional.of(true);\n\t\t\t}).orElse(false);", "first_line_groundtruth": "NPCs.search().indexIs(index).first().flatMap(npc ->", "first_line_prediction": " NPCs.search().indexIs(index).first().flatMap(npc ->", "match": 0}
{"groundtruth": "return Bank.search().indexIs(index).first().flatMap(item ->\n\t\t{", "prediction": "\treturn Bank.search().indexIs(index).first().flatMap(item ->\n\t\t\t{\n\t\t\tMousePackets.queueClickPacket();\n\t\t\tWidgetPackets.queueWidgetAction(item, actions);\n\t\t\treturn Optional.of(true);\n\t\t\t})\n\t\t\t.orElse(false);", "first_line_groundtruth": "return Bank.search().indexIs(index).first().flatMap(item ->", "first_line_prediction": "\treturn Bank.search().indexIs(index).first().flatMap(item ->", "match": 0}
{"groundtruth": "return repository.findByEmailSent(false);", "prediction": " List<ContactForm> forms = repository.findByEmailSent(false);\n             List<ContactForm> result = new ArrayList<>();\n             for (ContactForm form : forms){\n                 if(form.isEmailSent()){\n                     result.add(form);\n                 }\n             }\n             return result;\n         }\n    }", "first_line_groundtruth": "return repository.findByEmailSent(false);", "first_line_prediction": " List<ContactForm> forms = repository.findByEmailSent(false);", "match": 0}
{"groundtruth": "Players.search().filter(predicate).first().flatMap(Player ->\n\t\t{", "prediction": " Players.search().filter(predicate).first().flatMap(Player ->\n\t\t{\n\t\t\tMousePackets.queueClickPacket();\n\t\t\tPlayerPackets.queuePlayerAction(Player, actions);\n\t\t\treturn Optional.of(true);\n\t\t}).orElse(false);", "first_line_groundtruth": "Players.search().filter(predicate).first().flatMap(Player ->", "first_line_prediction": " Players.search().filter(predicate).first().flatMap(Player ->", "match": 0}
{"groundtruth": "= pluginLoader.getPluginFactories();", "prediction": " = pluginLoader.getPluginFactories();\n        PluginStore.instance.plugins = factories;\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        log.info(\"Shutting down application\");\n        //Stops all plugins\n        for (String key : PluginStore.instance.plugins.keySet()) {\n            PluginStore.instance.plugins.get(key).onShutdown();\n        }\n    }", "first_line_groundtruth": "= pluginLoader.getPluginFactories();", "first_line_prediction": " = pluginLoader.getPluginFactories();", "match": 0}
{"groundtruth": "BankInventory.search().indexIs(index).first().flatMap(item ->\n\t\t{", "prediction": " BankInventory.search().indexIs(index).first().flatMap(item ->\n\t\t\t{\n\t\t\t\tMousePackets.queueClickPacket();\n\t\t\t\tWidgetPackets.queueWidgetAction(item, actions);\n\t\t\t\treturn Optional.of(true);\n\t\t\t}).orElse(false);", "first_line_groundtruth": "BankInventory.search().indexIs(index).first().flatMap(item ->", "first_line_prediction": " BankInventory.search().indexIs(index).first().flatMap(item ->", "match": 0}
{"groundtruth": "handler.onCommand(command, arguments);", "prediction": " handler.onCommand(command, arguments);\n            if (result) {\n                log.info(\"Command {} executed\", command);\n            }\n        }\n    }", "first_line_groundtruth": "handler.onCommand(command, arguments);", "first_line_prediction": " handler.onCommand(command, arguments);", "match": 0}
{"groundtruth": "NPCs.search().filter(predicate).first().flatMap(npc ->\n\t\t{", "prediction": " NPCs.search().filter(predicate).first().flatMap(npc ->\n\t\t{\n\t\t\tMousePackets.queueClickPacket();\n\t\t\tNPCPackets.queueNPCAction(npc, actions);\n\t\t\treturn Optional.of(true);\n\t\t}).orElse(false);", "first_line_groundtruth": "NPCs.search().filter(predicate).first().flatMap(npc ->", "first_line_prediction": " NPCs.search().filter(predicate).first().flatMap(npc ->", "match": 0}
{"groundtruth": "EasyContactFormsApplication.loadPlugins(pluginsPath);", "prediction": " //Checks if plugin directory exists\n        if (new File(pluginsPath).exists()) {\n            new FirstStartupChecker().checkDirectories();\n            loadPlugins(pluginsPath);\n        }\n    }\n\n    /**\n     * Shuts down the server\n     * @param args command line arguments\n     */\n    private void shutdown(String[] args) {\n        if (args.length > 0) {\n            try {\n                TimeUnit.SECONDS.sleep(Integer.parseInt(args[0]));\n            } catch (InterruptedException e) {\n                log.error(\"Interrupted while waiting for shutdown\");\n            }\n        }\n        System.exit(0);\n   ", "first_line_groundtruth": "EasyContactFormsApplication.loadPlugins(pluginsPath);", "first_line_prediction": " //Checks if plugin directory exists", "match": 0}
{"groundtruth": "BufferMethods.du(buffer, (Integer) input);", "prediction": "\tBufferMethods.du(buffer, (int) input);\n\t\t\t\tbreak;\n\t\t\tcase \"du\":\n\t\t\t\t\tBufferMethods.du(buffer, (int) input);\n\t\t\t\tbreak;\n\t\t\tcase \"du\":\n\t\t\t\t\tBufferMethods.du(buffer, (int) input);\n\t\t\t\tbreak;\n\t\t\tcase \"du\":\n\t\t\t\t\tBufferMethods.du(buffer, (int) input);\n\t\t\t\tbreak;\n\t\t\tcase \"du\":\n\t\t\t\t\tBufferMethods.du(buffer, (int) input);\n\t\t\t\tbreak;\n\t\t\tcase \"du\":\n\t\t\t\t\tBufferMethods.du(buffer,", "first_line_groundtruth": "BufferMethods.du(buffer, (Integer) input);", "first_line_prediction": "\tBufferMethods.du(buffer, (int) input);", "match": 0}
{"groundtruth": "<ContactForm> forms = contactFormService.getContactForms(true);", "prediction": "<ContactForm> contactForms = contactFormService.getContactForms(true);\n            for(ContactForm contactForm : contactForms){\n                try {\n                    sendMail(contactForm);\n                } catch (MessagingException | UnsupportedEncodingException e) {\n                    log.error(\"Error sending mail to \" + contactForm.getEmail(), e);\n                }\n            }\n        } else {\n            List<ContactForm> contactForms = contactFormService.getContactForms(false);\n            for(ContactForm contactForm : contactForms){\n                try {\n                    sendMail(contactForm);\n                } catch (MessagingException | UnsupportedEncodingException e) {", "first_line_groundtruth": "<ContactForm> forms = contactFormService.getContactForms(true);", "first_line_prediction": "<ContactForm> contactForms = contactFormService.getContactForms(true);", "match": 0}
{"groundtruth": "lastRange.covers(previous)) {", "prediction": "previous.end() == lastRange.end()) {\n                    lastRange = lastRange.extend(previous);\n                } else {\n                    tokens.add(lastRange);\n                    lastRange = previous;\n                }\n            }\n        }\n        tokens.add(lastRange);\n    }\n    \n    /**\n     * Returns the list of TokenRanges that can be used to split a given string into parts.\n     * @param string The string to split.\n     * @return The list of TokenRanges that can be used to split a given string into parts.\n     */\n    public static List<TokenRange> tokenize(final String string) {\n        Completion", "first_line_groundtruth": "lastRange.covers(previous)) {", "first_line_prediction": "previous.end() == lastRange.end()) {", "match": 0}
{"groundtruth": "Widget bow = HypsApiPlugin.getItem(\"*bow*\");", "prediction": "\tMousePackets.queueClickPacket();\n\t\t\t\t\tWidgetPackets.queueWidgetActionPacket(1, 5046276, -1, 11); //quickPrayer magic\n\t\t\t}\n\t\t\telse if (HypsApiPlugin.getHeadIcon(hunllef) == HeadIcon.RANGE && (!name.contains(\"sword\") && !name.contains(\"mace\")))\n\t\t\t{\n\t\t\t\tMousePackets.queueClickPacket();\n\t\t\t\tWidgetPackets.queueWidgetActionPacket(1, 5046276, -1, 10); //quickPr", "first_line_groundtruth": "Widget bow = HypsApiPlugin.getItem(\"*bow*\");", "first_line_prediction": "\tMousePackets.queueClickPacket();", "match": 0}
{"groundtruth": "lastRange.addRange(previous);", "prediction": " lastRange = lastRange.union(previous);\n                } else {\n                    iterator.add(lastRange);\n                    lastRange = previous;\n                }\n            }\n        }\n        iterator.add(lastRange);\n    }\n    \n    /**\n     * Returns the list of TokenRanges that can be used to split a given string into parts.\n     * Mainly used to split strings for completion purposes.\n     */\n    public List<TokenRange> tokens() {\n        return tokens;\n    }\n    \n    @Override\n    public TokenRange visit(final LiteralExpression expr, final Object context) {\n        return TokenRange.of(expr.start(), expr.", "first_line_groundtruth": "lastRange.addRange(previous);", "first_line_prediction": " lastRange = lastRange.union(previous);", "match": 0}
{"groundtruth": "<Widget> ring_of_wealth = Inventory.search().nameContains(\"Ring of wealth (\").first();", "prediction": "<Widget> ring_of_health = Inventory.search().withId(RING_OF_WEALTH).first();\n\t\t\t\tif (royal_seed_pod.isPresent() && ring_of_health.isPresent())\n\t\t\t\t{\n\t\t\t\t\tWidgetPackets.queueWidgetAction(ring_of_health.get(), \"Eat\");\n\t\t\t\t\tWidgetPackets.queueWidgetAction(royal_seed_pod.get(), \"Eat\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (previousLevel != level)\n\t\t\t{\n\t\t\t\tpreviousLevel = level;\n\t\t\t\tOptional<Widget> royal_", "first_line_groundtruth": "<Widget> ring_of_wealth = Inventory.search().nameContains(\"Ring of wealth (\").first();", "first_line_prediction": "<Widget> ring_of_health = Inventory.search().withId(RING_OF_WEALTH).first();", "match": 0}
{"groundtruth": "tokens.add(range.recalculate());", "prediction": "lastRange = range;\n        return range;\n    }\n    \n    @Override\n    public void accept(final StringSearcher searcher) {\n        \n        searcher.accept(this);\n    }\n    \n    @Override\n    public void accept(final String s) {\n        \n        accept(new StringSearcher(s));\n    }", "first_line_groundtruth": "tokens.add(range.recalculate());", "first_line_prediction": "lastRange = range;", "match": 0}
{"groundtruth": "> royal_seed_pod = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();", "prediction": "> fish = Inventory.search().idInList(List.of(371, 13441)).first();\n\t\t\t\tif (fish.isPresent())\n\t\t\t\t{\n\t\t\t\t\tWidgetPackets.queueWidgetAction(fish.get(), \"Eat\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (previousLevel != level)\n\t\t\t{\n\t\t\t\tpreviousLevel = level;\n\t\t\t\tOptional<Widget> fish = Inventory.search().idInList(List.of(371, 13441)).first();\n\t\t\t\tif (fish.isPresent())\n\t\t\t\t{\n\t\t\t\t\t", "first_line_groundtruth": "> royal_seed_pod = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();", "first_line_prediction": "> fish = Inventory.search().idInList(List.of(371, 13441)).first();", "match": 0}
{"groundtruth": "StringSearcher.search(search, this);", "prediction": "", "first_line_groundtruth": "StringSearcher.search(search, this);", "first_line_prediction": "", "match": 0}
{"groundtruth": "> widget = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();", "prediction": "> royal_seed_pod = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();\n\t\t\t\tOptional<Widget> ring_of_wealth = Inventory.search().nameContains(\"Ring of wealth (\").first();\n\t\t\t\tif (royal_seed_pod.isPresent() || ring_of_wealth.isPresent() || (rowEquipment != null && RING_OF_WEALTH_ITEM_IDS.contains(rowEquipment.getId())))\n\t\t\t\t{\n\t\t\t\t\tteleported = true;\n\t\t\t\t}\n\t\t\t\tif (teleported)\n\t\t\t\t", "first_line_groundtruth": "> widget = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();", "first_line_prediction": "> royal_seed_pod = Inventory.search().withId(ItemID.ROYAL_SEED_POD).first();", "match": 0}
{"groundtruth": "basicParameter.getApiUrl() == null) {", "prediction": "basicParameter.isSslEnable()) {\n            builder.setSSLContext(basicParameter.getSslContext());\n        }\n    }", "first_line_groundtruth": "basicParameter.getApiUrl() == null) {", "first_line_prediction": "basicParameter.isSslEnable()) {", "match": 0}
{"groundtruth": "cliRunner.start();", "prediction": " return getConnection(cliRunner.getPort(), cliRunner.getSessionToken(), Optional.of(cliRunner));\n        } catch (Exception e) {\n            LOG.error(\"Failed to initialize connection with engine from automatic provisioning\", e);\n            throw e;\n        }\n    }\n\n    private static Connection getConnection(int port, String sessionToken, Optional<CLIRunner> daggerRunner) {\n        Vertx vertx = Vertx.vertx();\n        VertxDynamicGraphQLClientBuilder builder = VertxDynamicGraphQLClientBuilder.newBuilder()\n                .url(\"http://localhost:\" + port + \"/graphql\")\n                .vertx(vertx);\n       ", "first_line_groundtruth": "cliRunner.start();", "first_line_prediction": " return getConnection(cliRunner.getPort(), cliRunner.getSessionToken(), Optional.of(cliRunner));", "match": 0}
{"groundtruth": "Widget> row = Inventory.search().nameContains(\"Ring of wealth (\").first();", "prediction": "Widget> ring_of_wealth = Inventory.search().nameContains(\"Ring of wealth (\").first();\n\t\t\t\tif (ring_of_wealth.isPresent())\n\t\t\t\t\t{\n\t\t\t\t\tteleported = true;\n\t\t\t\t\tInventoryInteraction.useItem(ring_of_wealth.get(), \"Commune\");\n\t\t\t\t\t}\n\t\t\t\tif (teleported)\n\t\t\t\t\t{\n\t\t\t\t\tteleportedFromSkulledPlayer = true;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tOptional<Widget> ring_of_wealth_item = Inventory.search().withId(RING_OF", "first_line_groundtruth": "Widget> row = Inventory.search().nameContains(\"Ring of wealth (\").first();", "first_line_prediction": "Widget> ring_of_wealth = Inventory.search().nameContains(\"Ring of wealth (\").first();", "match": 0}
{"groundtruth": "connectParams = cliRunner.getConnectionParams();", "prediction": " params = cliRunner.getConnectionParams();\n            return getConnection(params.port, params.token, Optional.of(cliRunner));\n        } catch (Exception e) {\n            LOG.error(\"Failed to initialize connection with engine\", e);\n            throw e;\n        }\n    }\n\n    private static Connection getConnection(int port, String sessionToken, Optional<CLIRunner> daggerRunner) throws IOException {\n        Vertx vertx = Vertx.vertx();\n        VertxDynamicGraphQLClientBuilder builder = VertxDynamicGraphQLClientBuilder.newBuilder()\n                .url(\"http://localhost:\" + port + \"/graphql\")\n                .", "first_line_groundtruth": "connectParams = cliRunner.getConnectionParams();", "first_line_prediction": " params = cliRunner.getConnectionParams();", "match": 0}
{"groundtruth": "(BufferedInputStream in = new BufferedInputStream(fetcher.fetch(checksumMapURL))) {", "prediction": " (InputStream in = fetcher.fetch(checksumMapURL)) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    String[] parts = line.split(\" \");\n                    checksums.put(parts[0], parts[1]);\n                }\n            }\n        }\n        return checksums;\n    }\n\n    private String extractCLI(String archiveName, String version, Path tmpBin) throws IOException {\n        try (InputStream in = fetcher.fetch(archiveName)) {\n            try (", "first_line_groundtruth": "(BufferedInputStream in = new BufferedInputStream(fetcher.fetch(checksumMapURL))) {", "first_line_prediction": " (InputStream in = fetcher.fetch(checksumMapURL)) {", "match": 0}
{"groundtruth": "parameter.setInit_images(new String[]{", "prediction": "\tparameter.setInit_images(new String[]{base64String});\n\t\tSdResponses res = Img2Img.generate(parameter);\n\t\tfor (String image : res.getImages()) {\n\t\t\tBufferedImage bufferedImage = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(image)));\n\t\t\tFile output = new File(\"image.png\");\n\t\t\tImageIO.write(bufferedImage, \"png\", output);\n\t\t}", "first_line_groundtruth": "parameter.setInit_images(new String[]{", "first_line_prediction": "\tparameter.setInit_images(new String[]{base64String});", "match": 0}
{"groundtruth": "parameter.setDenoisingStrength(new BigDecimal(\"0.55\"));", "prediction": "\tparameter.setDenoisingStrength(new BigDecimal(\"0.5\"));\n\t\t\t//\u521d\u59cb\u5316\u56fe\u7247\n\t\t\tparameter.setInit_images(new String[]{\"https://i.loli.net/2020/03/23/5e76222622232.jpg\"});\n\t\t\t//\u5982\u9700\u8981\u4ee3\u7406\u5219\u89e3\u5f00\u4e0b\u5217\u4ee3\u7801\u6ce8\u91ca", "first_line_groundtruth": "parameter.setDenoisingStrength(new BigDecimal(\"0.55\"));", "first_line_prediction": "\tparameter.setDenoisingStrength(new BigDecimal(\"0.5\"));", "match": 0}
{"groundtruth": "cliRunner.shutdown();", "prediction": " LOG.error(\"Failed to connect to Dagger engine\", ioe);\n             throw ioe;\n        }\n    }\n\n    private static Connection getConnection(int port, String sessionToken, Optional<CLIRunner> daggerRunner) throws IOException {\n        Vertx vertx = Vertx.vertx();\n        VertxDynamicGraphQLClientBuilder builder = VertxDynamicGraphQLClientBuilder.newBuilder()\n                .url(\"http://localhost:\" + port + \"/graphql\")\n                .vertx(vertx);\n        DynamicGraphQLClient graphQLClient = builder.build();\n        graphQLClient.query(\"query { sessionToken }\", sessionToken);\n        return", "first_line_groundtruth": "cliRunner.shutdown();", "first_line_prediction": " LOG.error(\"Failed to connect to Dagger engine\", ioe);", "match": 0}
{"groundtruth": "new BufferedInputStream(new DigestInputStream(fetcher.fetch(cliArchiveURL), sha256))) {", "prediction": " fetcher.fetch(cliArchiveURL);\n             DigestInputStream digest = new DigestInputStream(in, sha256);\n             ArchiveInputStream archive = getArchive(digest)) {\n            ArchiveEntry entry;\n            while ((entry = archive.getNextEntry()) != null) {\n                if (entry.isDirectory()) {\n                    continue;\n                }\n                Path destPath = dest.resolve(entry.getName());\n                LOG.info(\"Extracting \" + entry.getName() + \" to \" + destPath);\n                try (OutputStream out = Files.newOutputStream(destPath)) {\n                    byte[] buffer = new byte[102", "first_line_groundtruth": "new BufferedInputStream(new DigestInputStream(fetcher.fetch(cliArchiveURL), sha256))) {", "first_line_prediction": " fetcher.fetch(cliArchiveURL);", "match": 0}
{"groundtruth": "(serviceConnection.isEmpty()) tokens.add(token);", "prediction": " (serviceConnection.isEmpty()) {\n                tokens.add(token);\n            }\n        }\n        for (String token : tokens) {\n            map.remove(token);\n            services.remove(token);\n            dhizuku.unbindUserService(token);\n        }\n    }", "first_line_groundtruth": "(serviceConnection.isEmpty()) tokens.add(token);", "first_line_prediction": " (serviceConnection.isEmpty()) {", "match": 0}
{"groundtruth": "args.build());", "prediction": "iDhizukuUserServiceConnection, args.build());\n    }\n\n    static void bind(@NonNull IDhizuku dhizuku, @NonNull DhizukuUserServiceArgs args, @NonNull ServiceConnection connection) throws RemoteException {\n        ComponentName name = args.getComponentName();\n        String token = name.flattenToString();\n        IBinder service = services.get(token);\n        if (service == null) {\n            dhizuku.bindUserService(iDhizukuUserServiceConnection, args.build());\n            return;\n        }\n        map.put(token, new DhizukuService", "first_line_groundtruth": "args.build());", "first_line_prediction": "iDhizukuUserServiceConnection, args.build());", "match": 0}
{"groundtruth": ".update(SharedDataModel.getReservation());", "prediction": ".updateReservation(SharedDataModel.getReservation());\n        Stage stage = (Stage) btnPay.getScene().getWindow();\n        stage.close();\n    }\n\n    @javafx.fxml.FXML\n    public void handleCancel(ActionEvent actionEvent) {\n        Stage stage = (Stage) btnCancel.getScene().getWindow();\n        stage.close();\n    }", "first_line_groundtruth": ".update(SharedDataModel.getReservation());", "first_line_prediction": ".updateReservation(SharedDataModel.getReservation());", "match": 0}
{"groundtruth": "== null) dhizuku.bindUserService(iDhizukuUserServiceConnection, args.build());", "prediction": " == null) {\n            service = dhizuku.bindUserService(args);\n            services.put(token, service);\n        }\n        map.put(token, new DhizukuServiceConnection(args));\n    }\n\n    static void bind(@NonNull IDhizuku dhizuku, @NonNull DhizukuUserServiceArgs args, @NonNull ServiceConnection connection) throws RemoteException {\n        ComponentName name = args.getComponentName();\n        String token = name.flattenToString();\n        IBinder service = services.get(token);\n        if (service == null) {\n            service = dhizuk", "first_line_groundtruth": "== null) dhizuku.bindUserService(iDhizukuUserServiceConnection, args.build());", "first_line_prediction": " == null) {", "match": 0}
{"groundtruth": "SharedDataModel.getReservation().state = \"paid\";", "prediction": " Reservation reservation = SharedDataModel.getReservation();\n         ReservationDAO.payReservation(reservation);\n         Stage stage = (Stage) btnPay.getScene().getWindow();\n         stage.close();\n    }\n\n    @javafx.fxml.FXML\n    public void handleCancel(ActionEvent actionEvent) {\n        Stage stage = (Stage) btnCancel.getScene().getWindow();\n        stage.close();\n    }", "first_line_groundtruth": "SharedDataModel.getReservation().state = \"paid\";", "first_line_prediction": " Reservation reservation = SharedDataModel.getReservation();", "match": 0}
{"groundtruth": "customer = CustomerDAO.getCustomerbyID(kundenID);", "prediction": "customer = new Customer(kundenID);\n    }\n\n    public Reservation(int id, int anzahlPl\u00e4tze, int anzahlEinheiten, float preis, Date datum, Time uhrzeit, int platz, int kundenID) {\n        this.id = id;\n        this.court_count = anzahlPl\u00e4tze;\n        this.sessions = anzahlEinheiten;\n        this.price = preis;\n        this.date = datum;\n        this.cusomerID = kundenID;\n        this.customer = new Customer(kundenID);\n    }", "first_line_groundtruth": "customer = CustomerDAO.getCustomerbyID(kundenID);", "first_line_prediction": "customer = new Customer(kundenID);", "match": 0}
{"groundtruth": "(), connectParams.getSessionToken(), Optional.of(cliRunner));", "prediction": "(), connectParams.getSessionToken(), Optional.of(cliRunner));\n        } catch (Exception e) {\n            LOG.error(\"Failed to connect to Dagger engine\", e);\n            throw e;\n        }\n    }\n\n    private static Connection getConnection(int port, String sessionToken, Optional<CLIRunner> daggerRunner) throws IOException {\n        Vertx vertx = Vertx.vertx();\n        DynamicGraphQLClient graphQLClient = new VertxDynamicGraphQLClientBuilder()\n                .vertx(vertx)\n                .url(\"http://localhost:\" + port + \"/graphql\")\n                .build();\n        return new Connection(graphQL", "first_line_groundtruth": "(), connectParams.getSessionToken(), Optional.of(cliRunner));", "first_line_prediction": "(), connectParams.getSessionToken(), Optional.of(cliRunner));", "match": 1}
{"groundtruth": "Schema.initialize(in);", "prediction": " SchemaVisitor.visit(in);\n            CodegenVisitor codegenVisitor = new CodegenVisitor(schema);\n            codegenVisitor.visit(dest);\n        } catch (IOException e) {\n            throw new MojoExecutionException(\"Error while reading schema\", e);\n        }\n    }\n\n    private InputStream daggerSchema() throws IOException {\n        if (online) {\n            return onlineSchema();\n        } else {\n            return localSchema();\n        }\n    }\n\n    private InputStream onlineSchema() throws IOException {\n        URL url = new URL(introspectionQuertyURL);\n        return url.openStream();\n    }\n\n    private InputStream localSchema() throws IOException {", "first_line_groundtruth": "Schema.initialize(in);", "first_line_prediction": " SchemaVisitor.visit(in);", "match": 0}
{"groundtruth": "().info(String.format(\"Generating scala %s\", type.getName()));", "prediction": "().info(\"Visiting scalar: \" + type.getName());\n                    codegen.visit(type);\n                }\n\n                @Override\n                public void visitInput(Type type) {\n                    getLog().info(\"Visiting input: \" + type.getName());\n                    codegen.visit(type);\n                }\n\n                @Override\n                public void visitEnum(Type type) {\n                    getLog().info(\"Visiting enum: \" + type.getName());\n                    codegen.visit(type);\n                }\n\n                @Override\n                public void visitObject(Type type) {\n                    getLog().info(\"Visiting object: \" + type.getName());\n                   ", "first_line_groundtruth": "().info(String.format(\"Generating scala %s\", type.getName()));", "first_line_prediction": "().info(\"Visiting scalar: \" + type.getName());", "match": 0}
{"groundtruth": "= \"```\" + (isForWebhook ? topList.getTopListAsString(true) : topList.getTopListAsString(false)) + \"```\";", "prediction": " = Pattern.compile(\"\\\\{toplist\\\\}\", Pattern.CASE_INSENSITIVE).matcher(description).replaceAll(topList.getTopListAsString(isForWebhook));\n\n        //{toplist_formatted} placeholder\n        String replacement2  = Pattern.compile(\"\\\\{toplist_formatted\\\\}\", Pattern.CASE_INSENSITIVE).matcher(description).replaceAll(topList.getTopListAsString(isForWebhook));\n\n        //{toplist_formatted_with_placeholders} placeholder\n        String replacement3  = Pattern.compile(\"\\\\{toplist_formatted_with_placeholders\\\\}\", Pattern.CASE_INSENS", "first_line_groundtruth": "= \"```\" + (isForWebhook ? topList.getTopListAsString(true) : topList.getTopListAsString(false)) + \"```\";", "first_line_prediction": " = Pattern.compile(\"\\\\{toplist\\\\}\", Pattern.CASE_INSENSITIVE).matcher(description).replaceAll(topList.getTopListAsString(isForWebhook));", "match": 0}
{"groundtruth": "maxNameLength + 3) + \"s %d%s\\n\", i++, name, intValue, leaderboardConfig.getMetric());", "prediction": "maxNameLength + 3) + \"s %d%s\\\\n\", i++, name, intValue, leaderboardConfig.getMetric());\n                }\n            } else {\n                if (isWebhookFormat) {\n                    formattedEntry = String.format(\"%d. %-\" + (maxNameLength + 3) + \"s %s%s\\\\u000A\", i++, name, format(score), leaderboardConfig.getMetric());\n                } else {\n                    formattedEntry = String.format(\"%d. %-\" + (maxNameLength + 3) + \"s %s%s\\\\", "first_line_groundtruth": "maxNameLength + 3) + \"s %d%s\\n\", i++, name, intValue, leaderboardConfig.getMetric());", "first_line_prediction": "maxNameLength + 3) + \"s %d%s\\\\n\", i++, name, intValue, leaderboardConfig.getMetric());", "match": 0}
{"groundtruth": "(isForWebhook ? topList.getTopListAsString(true) : topList.getTopListAsString(false)) + \"```\";", "prediction": " topList.getTopListAsString(isForWebhook) + \"```\";\n        description = description.replace(\"{toplist}\", replacement1);\n\n        //{toplist_formatted} placeholder\n        String replacement2 = \"```\" +  topList.getTopListAsString(isForWebhook) + \"```\";\n        description = description.replace(\"{toplist_formatted}\", replacement2);\n\n        //{toplist_formatted_with_placeholders} placeholder\n        String replacement3 = \"```\" +  topList.getTopListAsString(isForWebhook) + \"```\";\n        description = description.replace(\"{toplist_", "first_line_groundtruth": "(isForWebhook ? topList.getTopListAsString(true) : topList.getTopListAsString(false)) + \"```\";", "first_line_prediction": " topList.getTopListAsString(isForWebhook) + \"```\";", "match": 0}
{"groundtruth": ") + \"s %d%s\\\\u000A\", i++, name, intValue, leaderboardConfig.getMetric());", "prediction": ") + \"s %d\", i, name, intValue);\n                } else {\n                    formattedEntry = String.format(\"%d. %-\" + (maxNameLength + 3) + \"s %d\", i, name, intValue);\n                }\n            } else {\n                if (isWebhookFormat) {\n                    formattedEntry = String.format(\"%d. %-\" + (maxNameLength + 3) + \"s %s\", i, name, new DecimalFormat(\"#,###.##\").format(score));\n                } else {\n                    formattedEntry = String.format(\"%d. %-\" + (", "first_line_groundtruth": ") + \"s %d%s\\\\u000A\", i++, name, intValue, leaderboardConfig.getMetric());", "first_line_prediction": ") + \"s %d\", i, name, intValue);", "match": 0}
{"groundtruth": "if (leaderboard.getConfig().getFloatingpoints() > 0){", "prediction": " if (placeholderType.equals(\"name\")) {\n                     replacement = isForWebhook ? entry.getKey() : PlaceholderAPI.setPlaceholders(null, entry.getKey());\n                 } else {\n                     replacement = String.format(\"%d%s\", intValue, leaderboard.getConfig().getMetric());\n                 }\n                description = description.replace(placeholder, replacement);\n            }\n        }\n\n        //{top-1-name} {top-1-score} placeholders\n        pattern = Pattern.compile(\"\\\\{top-(\\\\d+)-(name|score|time)\\\\}\");\n        matcher = pattern.matcher(description);\n        while", "first_line_groundtruth": "if (leaderboard.getConfig().getFloatingpoints() > 0){", "first_line_prediction": " if (placeholderType.equals(\"name\")) {", "match": 0}
{"groundtruth": ", Double> playerScores = topList.getTopListAsMap();", "prediction": ", Double> toplistmap = topList.getTopListAsMap();\n        int maxNameLength = getmaxnamelenght(toplistmap);\n        String replacement2 = \"\";\n        for (Map.Entry<String, Double> entry : toplistmap.entrySet()) {\n            String name = entry.getKey();\n            double score = entry.getValue();\n            String scoreString = String.format(\"%.\" + numberOfFloatingPoints + \"f\", score);\n            String scoreStringWithDecimals = String.format(\"%.\" + numberOfFloatingPoints + \"f\", score);\n            String scoreStringWithDecimalsAndComma = String", "first_line_groundtruth": ", Double> playerScores = topList.getTopListAsMap();", "first_line_prediction": ", Double> toplistmap = topList.getTopListAsMap();", "match": 0}
{"groundtruth": "this.leaderboardversion = mainConfig.getPluginVersion();", "prediction": " this.leaderboardversion = mainConfig.getLeaderboardVersion();\n        customConfig = new CustomConfig(name);\n        config = customConfig.get();\n        load();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public FileConfiguration getConfig() {\n        return config;\n    }\n\n    public void setConfig(FileConfiguration config) {\n        this.config = config;\n    }\n\n    public String getPlaceholder() {\n        return placeholder;\n    }\n\n    public void setPlaceholder(String placeholder) {\n        this.placeholder =", "first_line_groundtruth": "this.leaderboardversion = mainConfig.getPluginVersion();", "first_line_prediction": " this.leaderboardversion = mainConfig.getLeaderboardVersion();", "match": 0}
{"groundtruth": "= customConfig.get();", "prediction": " = customConfig.getConfig();\n        placeholder = config.getString(\"placeholder\");\n        top = config.getInt(\"top\");\n        delay = config.getString(\"delay\");\n        refreshOnSent = config.getBoolean(\"refreshOnSent\");\n        metric = config.getString(\"metric\");\n        higherisbetter = config.getBoolean(\"higherisbetter\");\n        floatingpoints = config.getInt(\"floatingpoints\");\n        webhookurl = config.getString(\"webhookurl\");\n        webhookAvatarUrl = config.getString(\"webhookAvatarUrl\");\n        webhookUserName = config.getString(\"webhookUserName\");\n        embedTitle = config.getString(\"embedTitle\");\n        embed", "first_line_groundtruth": "= customConfig.get();", "first_line_prediction": " = customConfig.getConfig();", "match": 0}
{"groundtruth": "customConfig.setup();", "prediction": " config = customConfig.get();\n        config.set(\"placeholder\", placeholder);\n        config.set(\"top\", top);\n        config.set(\"delay\", delay);\n        config.set(\"refreshOnSent\", refreshOnSent);\n        config.set(\"metric\", metric);\n        config.set(\"higherisbetter\", higherisbetter);\n        config.set(\"floatingpoints\", floatingpoints);\n        config.set(\"webhookurl\", webhookurl);\n        config.set(\"webhookAvatarUrl\", webhookAvatarUrl);\n        config.set(\"webhookUserName\", webhookUserName);\n        config.set(\"embedTitle\", embedTitle);\n       ", "first_line_groundtruth": "customConfig.setup();", "first_line_prediction": " config = customConfig.get();", "match": 0}
{"groundtruth": "if (cache.isDiffernt()){", "prediction": " cache.setCache();\n                    break;\n                case \"hourly\":\n                    if (currentTime.after(lastsent)){\n                        Cache cache = new Cache(leaderboard);\n                        cache.setCache();\n                    }\n                    break;\n                case \"daily\":\n                    if (currentTime.after(lastsent)){\n                        Cache cache = new Cache(leaderboard);\n                        cache.setCache();\n                    }\n                    break;\n                case \"weekly\":\n                    if (currentTime.after(lastsent)){\n                        Cache cache = new Cache(leaderboard);\n                        cache.setCache();\n                    }\n                    break;\n                case \"monthly\":\n                    if (currentTime.after(", "first_line_groundtruth": "if (cache.isDiffernt()){", "first_line_prediction": " cache.setCache();", "match": 0}
{"groundtruth": "content = jsonData.getDataAttributes().get(\"content\");", "prediction": " prompt = jsonData.getPrompt();\n\n        return prompt;\n    }", "first_line_groundtruth": "content = jsonData.getDataAttributes().get(\"content\");", "first_line_prediction": " prompt = jsonData.getPrompt();", "match": 0}
{"groundtruth": "(descriptionGenerator.getDescription(false));", "prediction": "(descriptionGenerator.getDescription(true));\n        return discordsrvEmbed;\n    }", "first_line_groundtruth": "(descriptionGenerator.getDescription(false));", "first_line_prediction": "(descriptionGenerator.getDescription(true));", "match": 0}
{"groundtruth": "companyProductName = jsonData.getDataAttributes().get(\"companyProductName\");", "prediction": " productName = jsonData.getDataAttributes().get(\"productName\");\n        String productPrice = jsonData.getDataAttributes().get(\"productPrice\");\n        String productImage = jsonData.getDataAttributes().get(\"productImage\");\n        String productLink = jsonData.getDataAttributes().get(\"productLink\");\n        String productLink2 = jsonData.getDataAttributes().get(\"productLink2\");\n        String productLink3 = jsonData.getDataAttributes().get(\"productLink3\");\n        String productLink4 = jsonData.getDataAttributes().get(\"productLink4\");\n        String productLink5 = jsonData.getDataAttributes().", "first_line_groundtruth": "companyProductName = jsonData.getDataAttributes().get(\"companyProductName\");", "first_line_prediction": " productName = jsonData.getDataAttributes().get(\"productName\");", "match": 0}
{"groundtruth": "customConfig.reload();", "prediction": "\n\n    }\n\n    //load methode\n    public void load() {\n        placeholder = config.getString(\"placeholder\");\n        top = config.getInt(\"top\");\n        delay = config.getString(\"delay\");\n        refreshOnSent = config.getBoolean(\"refresh-database-onsent\");\n        metric = config.getString(\"metric\");\n        higherisbetter = config.getBoolean(\"higherisbetter\");\n        floatingpoints = config.getInt(\"floatingpoints\");\n        webhookurl = config.getString(\"webhook-url\");\n        webhookAvatarUrl = config.getString(\"webhook-avatar-url\");\n        webhookUserName = config.getString(\"webhook-user", "first_line_groundtruth": "customConfig.reload();", "first_line_prediction": "", "match": 0}
{"groundtruth": "info = jsonData.getDataAttributes().get(\"info\");", "prediction": "ect = jsonData.getDataAttributes().get(\"ect\");\n        String ect_type = jsonData.getDataAttributes().get(\"ect_type\");\n        String ect_value = jsonData.getDataAttributes().get(\"ect_value\");\n        String ect_unit = jsonData.getDataAttributes().get(\"ect_unit\");\n        String ect_currency = jsonData.getDataAttributes().get(\"ect_currency\");\n        String ect_amount = jsonData.getDataAttributes().get(\"ect_amount\");\n        String ect_date = jsonData.getDataAttributes().get(\"ect_date\");\n        String", "first_line_groundtruth": "info = jsonData.getDataAttributes().get(\"info\");", "first_line_prediction": "ect = jsonData.getDataAttributes().get(\"ect\");", "match": 0}
{"groundtruth": "discordsrvEmbed.setEmbedImage(image);", "prediction": "\n\n        if (image != null && !image.isEmpty()) {\n            discordsrvEmbed.setEmbedImage(image);\n        }\n        if (thumb != null && !thumb.isEmpty()) {\n            discordsrvEmbed.setEmbedThumbnail(thumb);\n        }\n\n        return discordsrvEmbed;\n    }\n\n    public TopList getTopList() {\n        return topList;\n    }\n\n    public void setTopList(TopList topList) {\n        this.topList = topList;\n    }\n\n    public DescriptionGenerator getDescriptionGenerator() {\n        return new DescriptionGenerator(leaderboard);\n    }", "first_line_groundtruth": "discordsrvEmbed.setEmbedImage(image);", "first_line_prediction": "", "match": 0}
{"groundtruth": "sentence = jsonData.getDataAttributes().get(\"sentence\");", "prediction": "ects = jsonData.getDataAttributes().get(\"ects\");\n        String customerName = jsonData.getDataAttributes().get(\"customerName\");\n        String customerEmail = jsonData.getDataAttributes().get(\"customerEmail\");\n        String customerPhone = jsonData.getDataAttributes().get(\"customerPhone\");\n        String customerAddress = jsonData.getDataAttributes().get(\"customerAddress\");\n        String customerCity = jsonData.getDataAttributes().get(\"customerCity\");\n        String customerState = jsonData.getDataAttributes().get(\"customerState\");\n        String customerZip = jsonData.getDataAttributes().get(\"customerZip\");\n        String", "first_line_groundtruth": "sentence = jsonData.getDataAttributes().get(\"sentence\");", "first_line_prediction": "ects = jsonData.getDataAttributes().get(\"ects\");", "match": 0}
{"groundtruth": "cache.setCache();", "prediction": "\n                    }\n                    break;\n                case \"hourly\":\n                    if (currentTime.getTime() - lastsent.getTime() >= SECSFORHOUR){\n                        leaderboard.send();\n                    }\n                    break;\n                case \"daily\":\n                    if (currentTime.getTime() - lastsent.getTime() >= SECSFORDAY){\n                        leaderboard.send();\n                    }\n                    break;\n                case \"weekly\":\n                    if (currentTime.getTime() - lastsent.getTime() >= SECSFORWEEK){\n                        leaderboard.send();\n                    }\n                    break;\n                case \"monthly\":\n                    if (currentTime.getTime() - lastsent.getTime", "first_line_groundtruth": "cache.setCache();", "first_line_prediction": "", "match": 0}
{"groundtruth": "adminPublish.close();", "prediction": " IOUtils.closeQuietly(adminPublish);\n        } catch (IOException e) {\n            LOG.error(\"Error closing admin publish client\", e);\n        }\n    }\n\n    @Test\n    public void testPublishPage() throws ClientException, IOException, URISyntaxException {\n        // get the page\n        SlingHttpResponse response = adminPublish.doGet(HOMEPAGE);\n        // check the status code\n        assertEquals(200, response.getStatusCode());\n        // check the content type\n        assertEquals(\"text/html\", response.getHeader(\"Content-Type\"));\n        // check the content length\n        assertEquals(1000, response.", "first_line_groundtruth": "adminPublish.close();", "first_line_prediction": " IOUtils.closeQuietly(adminPublish);", "match": 0}
{"groundtruth": "jsonData.getTemplateId()) {", "prediction": "language) {\n            case \"en\":\n                promptGuide = \"You are a copywriter AI that can write and edit existing content. You always respond in HTML format for consumption by a rich text editor. Your goal is to produce the content that is requested as instructed without ever identifying yourself or the changes you have made. It should only ever contain content that was requested:  PROMPT: \";\n                break;\n            case \"es\":\n                promptGuide = \"You are a copywriter AI that can write and edit existing content. You always respond in HTML format for consumption by a rich text editor. Your goal is to produce the content", "first_line_groundtruth": "jsonData.getTemplateId()) {", "first_line_prediction": "language) {", "match": 0}
{"groundtruth": "String topic = jsonData.getDataAttributes().get(\"topic\");", "prediction": "\n\n        String prompt = \"\";\n        if (StringUtils.isNotBlank(content)) {\n            prompt += content;\n        }\n        if (StringUtils.isNotBlank(tone)) {\n            prompt += tone;\n        }\n        if (StringUtils.isNotBlank(companyName)) {\n            prompt += companyName;\n        }\n        if (StringUtils.isNotBlank(product)) {\n            prompt += product;\n        }\n        if (StringUtils.isNotBlank(outline)) {\n            prompt += outline;\n        }\n        if (StringUtils.isNotBlank(cta)) {\n            prompt += cta;\n        }\n        if (StringUtils.isNotBlank(title)) {\n            prompt += title;\n        }\n       ", "first_line_groundtruth": "String topic = jsonData.getDataAttributes().get(\"topic\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "customerAvatar = jsonData.getDataAttributes().get(\"customerAvatar\");", "prediction": "ect = jsonData.getDataAttributes().get(\"ect\");\n        String ectDescription = jsonData.getDataAttributes().get(\"ectDescription\");\n        String ectTitle = jsonData.getDataAttributes().get(\"ectTitle\");\n        String ectDescription2 = jsonData.getDataAttributes().get(\"ectDescription2\");\n        String ectTitle2 = jsonData.getDataAttributes().get(\"ectTitle2\");\n        String ectDescription3 = jsonData.getDataAttributes().get(\"ectDescription3\");\n        String ectTitle3 = jsonData.getDataAttributes().get(\"ectTitle3\");\n        String ectDescription4", "first_line_groundtruth": "customerAvatar = jsonData.getDataAttributes().get(\"customerAvatar\");", "first_line_prediction": "ect = jsonData.getDataAttributes().get(\"ect\");", "match": 0}
{"groundtruth": ".addHeader(\"Authorization\", \"Bearer\" + \" \" + config.getOpenAIAPIKey());", "prediction": ".setHeader(\"Authorization\", \"Bearer \" + key);\n        request.setHeader(\"Content-Type\", \"application/json\");\n        request.setEntity(new StringEntity(requestBody));\n\n        HttpResponse response = client.execute(request);\n        String responseBody = EntityUtils.toString(response.getEntity());\n\n        ChatGptResponse chatGptResponse = MAPPER.readValue(responseBody, ChatGptResponse.class);\n        if (chatGptResponse.data != null) {\n            Data data = chatGptResponse.data.get(0);\n            return data.text;\n        } else {\n            return null", "first_line_groundtruth": ".addHeader(\"Authorization\", \"Bearer\" + \" \" + config.getOpenAIAPIKey());", "first_line_prediction": ".setHeader(\"Authorization\", \"Bearer \" + key);", "match": 0}
{"groundtruth": "customerProblem = jsonData.getDataAttributes().get(\"customerProblem\");", "prediction": "ect = jsonData.getDataAttributes().get(\"ect\");\n        String customerName = jsonData.getDataAttributes().get(\"customerName\");\n        String customerEmail = jsonData.getDataAttributes().get(\"customerEmail\");\n        String customerPhone = jsonData.getDataAttributes().get(\"customerPhone\");\n        String customerAddress = jsonData.getDataAttributes().get(\"customerAddress\");\n        String customerCity = jsonData.getDataAttributes().get(\"customerCity\");\n        String customerState = jsonData.getDataAttributes().get(\"customerState\");\n        String customerZip = jsonData.getDataAttributes().get(\"customerZip\");\n        String customerCountry", "first_line_groundtruth": "customerProblem = jsonData.getDataAttributes().get(\"customerProblem\");", "first_line_prediction": "ect = jsonData.getDataAttributes().get(\"ect\");", "match": 0}
{"groundtruth": "audience = jsonData.getDataAttributes().get(\"audience\");", "prediction": "ect = jsonData.getDataAttributes().get(\"ect\");\n        String description = jsonData.getDataAttributes().get(\"description\");\n        String productName = jsonData.getDataAttributes().get(\"productName\");\n        String productDescription = jsonData.getDataAttributes().get(\"productDescription\");\n        String productPrice = jsonData.getDataAttributes().get(\"productPrice\");\n        String productImage = jsonData.getDataAttributes().get(\"productImage\");\n        String productUrl = jsonData.getDataAttributes().get(\"productUrl\");\n        String productBrand = jsonData.getDataAttributes().get(\"productBrand\");\n        String productCategory = json", "first_line_groundtruth": "audience = jsonData.getDataAttributes().get(\"audience\");", "first_line_prediction": "ect = jsonData.getDataAttributes().get(\"ect\");", "match": 0}
{"groundtruth": "String tone = jsonData.getDataAttributes().get(\"tone\");", "prediction": "", "first_line_groundtruth": "String tone = jsonData.getDataAttributes().get(\"tone\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "String product = jsonData.getDataAttributes().get(\"product\");", "prediction": "\n\n        String prompt = \"\";\n        if (StringUtils.isNotBlank(content)) {\n            prompt += content;\n        }\n        if (StringUtils.isNotBlank(tone)) {\n            prompt += tone;\n        }\n        if (StringUtils.isNotBlank(companyName)) {\n            prompt += companyName;\n        }\n\n        return prompt;\n    }", "first_line_groundtruth": "String product = jsonData.getDataAttributes().get(\"product\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "client.getResourceRefs(path);", "prediction": " client.getCoreComponentImageRenditions(path);\n        LOG.info(\"Found {} references to core components\", references.size());\n        for (URI reference : references) {\n            LOG.info(\"Checking reference {}\", reference.toString());\n            SlingHttpResponse response = client.doGet(reference.toString());\n            assertEquals(\"Request to [\" + reference.toString() + \"] does not return expected returncode 200\",\n                    200, response.getStatusCode());\n            assertTrue(\"Request to [\" + reference.toString() + \"] does not return a zerobyte response\",\n                    ZEROBYTEFILES.", "first_line_groundtruth": "client.getResourceRefs(path);", "first_line_prediction": " client.getCoreComponentImageRenditions(path);", "match": 0}
{"groundtruth": "String gradeLevel = jsonData.getDataAttributes().get(\"gradeLevel\");", "prediction": "\n\n        String prompt = \"\";\n        if (StringUtils.isNotBlank(content)) {\n            prompt += content;\n        }\n        if (StringUtils.isNotBlank(tone)) {\n            prompt += \" \" + tone;\n        }\n        if (StringUtils.isNotBlank(companyName)) {\n            prompt += \" \" + companyName;\n        }\n        if (StringUtils.isNotBlank(product)) {\n            prompt += \" \" + product;\n        }\n        if (StringUtils.isNotBlank(outline)) {\n            prompt += \" \" + outline;\n        }\n        if (StringUtils.isNotBlank(cta)) {\n            prompt += \" \" + cta;\n        }\n        if (", "first_line_groundtruth": "String gradeLevel = jsonData.getDataAttributes().get(\"gradeLevel\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "SqlUtils.setScheduleLastSent(leaderboardname, currenttimestamp);", "prediction": " SqlUtils.setLastSent(leaderboardname, currenttimestamp);\n    }\n\n    public Timestamp getLastSent(){\n        String leaderboardname = leaderboard.getName();\n        Timestamp lastsent = SqlUtils.getLastSent(leaderboardname);\n        return lastsent;\n    }\n\n    public void deleteDataIfNeeded(){\n        String leaderboardname = leaderboard.getName();\n        SqlUtils.deleteDataIfNeeded(leaderboardname);\n    }\n\n    public boolean isAlredySent(){\n        String leaderboardname = leaderboard.getName();\n        boolean isalredysent = SqlUtils.isAlredySent(leaderboardname);", "first_line_groundtruth": "SqlUtils.setScheduleLastSent(leaderboardname, currenttimestamp);", "first_line_prediction": " SqlUtils.setLastSent(leaderboardname, currenttimestamp);", "match": 0}
{"groundtruth": "boolean isrefreshonsent = leaderboard.getConfig().isRefreshOnSent();", "prediction": " String leaderboardname = leaderboard.getName();\n         SqlUtils.deleteDataIfNeeded(leaderboardname);\n    }", "first_line_groundtruth": "boolean isrefreshonsent = leaderboard.getConfig().isRefreshOnSent();", "first_line_prediction": " String leaderboardname = leaderboard.getName();", "match": 0}
{"groundtruth": "SqlUtils.isScheduleAlredySent(leaderboardname);", "prediction": " SqlUtils.isScheduleLastSent(leaderboardname);\n        return isalredysent;\n    }\n\n    public void deleteDataIfNeeded(){\n        String leaderboardname = leaderboard.getName();\n        SqlUtils.deleteDataIfNeeded(leaderboardname);\n    }", "first_line_groundtruth": "SqlUtils.isScheduleAlredySent(leaderboardname);", "first_line_prediction": " SqlUtils.isScheduleLastSent(leaderboardname);", "match": 0}
{"groundtruth": "SqlUtils.deleteAllValues(tablename, ColumnName);", "prediction": " leaderboard.deleteData(tablename, ColumnName);\n        }\n    }", "first_line_groundtruth": "SqlUtils.deleteAllValues(tablename, ColumnName);", "first_line_prediction": " leaderboard.deleteData(tablename, ColumnName);", "match": 0}
{"groundtruth": "(TimeUtils.getTimestampDifference(currentTime, lastsent) >= SECSFORHOUR){", "prediction": " (currentTime.after(lastsent)){\n                        leaderboard.send();\n                        setLastSent();\n                    }\n                    break;\n                case \"daily\":\n                    if (currentTime.after(lastsent)){\n                        leaderboard.send();\n                        setLastSent();\n                    }\n                    break;\n                case \"weekly\":\n                    if (currentTime.after(lastsent)){\n                        leaderboard.send();\n                        setLastSent();\n                    }\n                    break;\n                case \"monthly\":\n                    if (currentTime.after(lastsent)){\n                        leaderboard.send();\n                        setLastSent();\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n   ", "first_line_groundtruth": "(TimeUtils.getTimestampDifference(currentTime, lastsent) >= SECSFORHOUR){", "first_line_prediction": " (currentTime.after(lastsent)){", "match": 0}
{"groundtruth": "webhook.execute();", "prediction": " webhook.send();\n        }catch (IOException e){\n            plugin.getLogger().warning(\"Error while sending leaderboard to discord webhook\");\n            e.printStackTrace();\n        }\n    }\n\n    private String getOrDefault(String value, String defaultValue){\n        if (value == null || value.equals(\"\") || value.equals(\"-\")) {\n            return defaultValue;\n        }\n        return value;\n    }", "first_line_groundtruth": "webhook.execute();", "first_line_prediction": " webhook.send();", "match": 0}
{"groundtruth": "= mainConfig.getDembedTitle();", "prediction": " = mainConfig.getDembedTitle();\n        String dembedColour = mainConfig.getDembedColour();\n        String dembedFooter = mainConfig.getDembedFooter();\n\n        //getting default values from custom config\n        CustomConfig customConfig = new CustomConfig(name);\n        String embedTitle  = customConfig.getEmbedTitle();\n        String embedColour = customConfig.getEmbedColour();\n        String embedFooter = customConfig.getEmbedFooter();\n\n        //getting default values from leaderboard config\n        LeaderboardConfig leaderboardConfig = new LeaderboardConfig(name);\n        String placeholder = leaderboardConfig.getPlaceholder", "first_line_groundtruth": "= mainConfig.getDembedTitle();", "first_line_prediction": " = mainConfig.getDembedTitle();", "match": 0}
{"groundtruth": "webhook.setAvatarUrl(webhookAvatarUrl);", "prediction": " webhook.setAvatarUrl(webhookAvatarUrl);\n        }\n        if (webhookUserName != null && !webhookUserName.equals(\"\") && !webhookUserName.equals(\"-\")){\n             webhook.setUserName(webhookUserName);\n        }\n        if (embedTitle != null && !embedTitle.equals(\"\") && !embedTitle.equals(\"-\")){\n             webhook.setEmbedTitle(embedTitle);\n        }\n        if (embedUrl != null && !embedUrl.equals(\"\") && !embedUrl.equals(\"-\")){\n             webhook.setEmbedUrl(embedUrl);\n        }\n        if (embedColour != null && !embedColour.equals(\"\") &&", "first_line_groundtruth": "webhook.setAvatarUrl(webhookAvatarUrl);", "first_line_prediction": " webhook.setAvatarUrl(webhookAvatarUrl);", "match": 0}
{"groundtruth": "dwebhookAvatarUrl = mainConfig.getDwebhookAvatarUrl();", "prediction": " dwebhookAvatarUrl = mainConfig.getDwebhookAvatarUrl();\n        String dwebhookUserName = mainConfig.getDwebhookUserName();\n        String dwebhookDelay = mainConfig.getDwebhookDelay();\n\n        //getting default values from custom config\n        CustomConfig customConfig = new CustomConfig(name);\n        String embedTitle = customConfig.get().getString(\"embedTitle\");\n        String embedColour = customConfig.get().getString(\"embedColour\");\n        String embedFooter = customConfig.get().getString(\"embedFooter\");\n        String webhookurl = customConfig.get().getString(\"webhookurl\");\n        String webhookAvatarUrl =", "first_line_groundtruth": "dwebhookAvatarUrl = mainConfig.getDwebhookAvatarUrl();", "first_line_prediction": " dwebhookAvatarUrl = mainConfig.getDwebhookAvatarUrl();", "match": 0}
{"groundtruth": "dembedImage = mainConfig.getDembedImage();", "prediction": " dembedImage = mainConfig.getDembedImage();\n\n        //getting default values from leaderboard config\n        String placeholder = leaderboardConfig.getPlaceholder();\n        int top = leaderboardConfig.getTop();\n        WebhookDelay delay = WebhookDelay.valueOf(leaderboardConfig.getWebhookDelay());\n\n        //creating embed\n        DiscordsrvEmbed embed = new DiscordsrvEmbed(dembedTitle, dembedUrl, dembedColour, dembedFooter, dembedImage);\n\n        //creating webhook\n        DiscordWebhook webhook = new DiscordWebhook(dwebhookurl, dwebhookAvatarUrl, dwebhookUserName);\n\n        //getting top", "first_line_groundtruth": "dembedImage = mainConfig.getDembedImage();", "first_line_prediction": " dembedImage = mainConfig.getDembedImage();", "match": 0}
{"groundtruth": "String description = descriptionGenerator.getDescription(true);", "prediction": " if (embedDescription != null && !embedDescription.equals(\"\") && !embedDescription.equals(\"-\")){\n            embed.setDescription(embedDescription);\n         }\n\n        if (placeholder != null && !placeholder.equals(\"\") && !placeholder.equals(\"-\")){\n            embed.setPlaceholder(placeholder);\n        }\n\n        if (top != 0){\n            embed.setTop(top);\n        }\n\n        if (delay != null && !delay.equals(\"\") && !delay.equals(\"-\")){\n            embed.setDelay(WebhookDelay.valueOf(delay));\n        }\n\n        webhook.addEmbed(embed);\n\n        try {\n            webhook.send();", "first_line_groundtruth": "String description = descriptionGenerator.getDescription(true);", "first_line_prediction": " if (embedDescription != null && !embedDescription.equals(\"\") && !embedDescription.equals(\"-\")){", "match": 0}
{"groundtruth": "String delay = leaderboardConfig.getDelay();", "prediction": "\n\n        //getting leaderboard's values from custom config\n        String customTitle = leaderboardConfig.getCustomTitle();\n        String customDescription = leaderboardConfig.getCustomDescription();\n        String customColour = leaderboardConfig.getCustomColour();\n        String customFooter = leaderboardConfig.getCustomFooter();\n        String customImage = leaderboardConfig.getCustomImage();\n        String customThumbnail = leaderboardConfig.getCustomThumbnail();\n\n        //getting leaderboard's values from toplist\n        String topListTitle = leaderboardConfig.getTopListTitle();\n        String topListDescription = leaderboardConfig.getTopListDescription();", "first_line_groundtruth": "String delay = leaderboardConfig.getDelay();", "first_line_prediction": "", "match": 0}
{"groundtruth": "String placeholder = leaderboardConfig.getPlaceholder();", "prediction": " return name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public LeaderboardConfig getConfig() {\n        return leaderboardConfig;\n    }\n\n    public TopList getTopList() {\n        return topList;\n    }\n\n    public void sendTopList(String webhookURL, String webhookName, String webhookAvatarURL, String webhookColor, String webhookFooter, String webhookText, String webhookThumbnailURL) {\n        if (webhookURL != null) {\n            try {\n                DiscordWebhook webhook = new DiscordWebhook(webhookURL, webhookName, webhookAvatarURL, webhookColor, webhookFooter, webhookText, webhook", "first_line_groundtruth": "String placeholder = leaderboardConfig.getPlaceholder();", "first_line_prediction": " return name;", "match": 0}
{"groundtruth": "String dembedFooter = mainConfig.getDembedFooter();", "prediction": "\n\n        //getting default values from custom config\n        CustomConfig c1 = new CustomConfig(name);\n        String dembedImage = c1.get().getString(\"dembedImage\");\n        String dembedFooter = c1.get().getString(\"dembedFooter\");\n\n        //creating embed\n        DiscordsrvEmbed embed = new DiscordsrvEmbed(dembedTitle, dembedUrl, dembedColour, dembedImage, dembedFooter);\n\n        //getting the top list\n        String topList = this.topList.getTopListAsString(false);\n\n        //adding the top list to the embed\n        embed.addField(topList", "first_line_groundtruth": "String dembedFooter = mainConfig.getDembedFooter();", "first_line_prediction": "", "match": 0}
{"groundtruth": "embedTitle = leaderboardConfig.getEmbedTitle();", "prediction": " webhookDelay = leaderboardConfig.getWebhookDelay();\n        String webhookEmbedTitle = leaderboardConfig.getWebhookEmbedTitle();\n        String webhookEmbedDescription = leaderboardConfig.getWebhookEmbedDescription();\n        String webhookEmbedUrl = leaderboardConfig.getWebhookEmbedUrl();\n        String webhookEmbedColour = leaderboardConfig.getWebhookEmbedColour();\n        String webhookEmbedFooter = leaderboardConfig.getWebhookEmbedFooter();\n        String webhookEmbedImage = leaderboardConfig.getWebhookEmbedImage();\n        String webhookEmbedThumbnail = leaderboardConfig.getWebhookEmbedThumbnail();\n\n        //getting leaderboard's values from custom config\n        Custom", "first_line_groundtruth": "embedTitle = leaderboardConfig.getEmbedTitle();", "first_line_prediction": " webhookDelay = leaderboardConfig.getWebhookDelay();", "match": 0}
{"groundtruth": "database.getConnection().prepareStatement(\n                        \"DELETE FROM \" + tableName + \" WHERE \" + columnName + \" IS NOT NULL\"\n                );", "prediction": " database.getConnection().prepareStatement(\"DELETE FROM \" + tableName + \" WHERE \" + columnName + \" IS NULL\");\n                preparedStatement.executeUpdate();\n                preparedStatement.close();\n            } else if (mainConfig.getStorageType().equalsIgnoreCase(\"mysql\")) {\n                preparedStatement =  database.getConnection().prepareStatement(\"DELETE FROM \" + tableName + \" WHERE \" + columnName + \" IS NULL\");\n                preparedStatement.executeUpdate();\n                preparedStatement.close();\n            }\n        } catch (SQLException ex) {\n            Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.", "first_line_groundtruth": "database.getConnection().prepareStatement(", "first_line_prediction": " database.getConnection().prepareStatement(\"DELETE FROM \" + tableName + \" WHERE \" + columnName + \" IS NULL\");", "match": 0}
{"groundtruth": "database.getConnection().prepareStatement(\n                        \"REPLACE INTO Schedule (Leaderboard, LastSent) VALUES (?, ?)\"\n                );", "prediction": " database.getConnection().prepareStatement(\"INSERT INTO Schedule (Leaderboard, LastSent) VALUES (?, ?) ON DUPLICATE KEY UPDATE LastSent = VALUES(LastSent)\");\n                preparedStatement.setString(1, leaderboard);\n                preparedStatement.setTimestamp(2, timestamp);\n                preparedStatement.executeUpdate();\n                preparedStatement.close();\n            } catch (SQLException ex) {\n                Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while reading data in database  [code : 13]\");\n            }\n        }\n   ", "first_line_groundtruth": "database.getConnection().prepareStatement(", "first_line_prediction": " database.getConnection().prepareStatement(\"INSERT INTO Schedule (Leaderboard, LastSent) VALUES (?, ?) ON DUPLICATE KEY UPDATE LastSent = VALUES(LastSent)\");", "match": 0}
{"groundtruth": "SqlUtils.addUserDataToDatabase(placeholderColumnName, uuid, username, value);", "prediction": " PreparedStatement preparedStatement;\n             if (mainConfig.getStorageType().equalsIgnoreCase(\"h2\")){\n                 try {\n                     preparedStatement = database.getConnection().prepareStatement(\"INSERT INTO UserData (uuid, username, \" + placeholderColumnName + \") VALUES (?, ?, ?);\");\n                     preparedStatement.setString(1, uuid);\n                     preparedStatement.setString(2, username);\n                     preparedStatement.setDouble(3, value);\n                     preparedStatement.execute();\n                 } catch (Exception e) {\n                     e.printStackTrace();\n                 }\n             }else if (mainConfig.getStorageType().equalsIgnoreCase(\"mysql\")){\n                 try {\n                     preparedStatement", "first_line_groundtruth": "SqlUtils.addUserDataToDatabase(placeholderColumnName, uuid, username, value);", "first_line_prediction": " PreparedStatement preparedStatement;", "match": 0}
{"groundtruth": "String embedColour = leaderboardConfig.getEmbedColour();", "prediction": " String embedColour = leaderboardConfig.getEmbedColour();\n        String embedFooter = leaderboardConfig.getEmbedFooter();\n        String embedImage = leaderboardConfig.getEmbedImage();\n        String embedThumbnail = leaderboardConfig.getEmbedThumbnail();\n        String embedDescription = leaderboardConfig.getEmbedDescription();\n        String metric = leaderboardConfig.getMetric();\n        boolean isHigherisbetter = leaderboardConfig.isHigherisbetter();\n        int numberOfFloatingPoints = leaderboardConfig.getFloatingpoints();\n\n        //getting webhook delay\n        WebhookDelay webhookDelay = WebhookDelay.None;\n        if (", "first_line_groundtruth": "String embedColour = leaderboardConfig.getEmbedColour();", "first_line_prediction": " String embedColour = leaderboardConfig.getEmbedColour();", "match": 0}
{"groundtruth": "String webhookAvatarUrl = leaderboardConfig.getWebhookAvatarUrl();", "prediction": "\n\n        //getting toplist from toplist object\n        Map<String, Double> toplistmap = topList.getTopListAsMap();\n\n        //getting max name length from toplist\n        int maxNameLength = getmaxnamelenght(toplistmap);\n\n        //creating StringBuilder object\n        StringBuilder sb = new StringBuilder();\n\n        //creating embed object\n        EmbedBuilder embed = new EmbedBuilder();\n\n        //creating embed description\n        embed.setDescription(dembedDescription);\n\n        //creating embed title\n        embed.setTitle(dembedTitle);\n\n        //creating embed colour\n        embed.setColor(Color.decode(dembedColour));\n\n        //", "first_line_groundtruth": "String webhookAvatarUrl = leaderboardConfig.getWebhookAvatarUrl();", "first_line_prediction": "", "match": 0}
{"groundtruth": "UnsupportedOperationException(\"Unsupported storage type: \" + mainConfig.getStorageType());", "prediction": " Exception(\"Storage Type not supported\");\n            }\n            int rowsUpdated = preparedStatement.executeUpdate();\n            preparedStatement.close();\n        } catch (SQLException ex) {\n            Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while deleting all values in database  [code : 16]\");\n        }\n    }\n\n    public static void deleteAllValues(String tableName) {\n        PreparedStatement preparedStatement;\n        MainConfig mainConfig = new MainConfig();\n        Database database = new Database();\n        try {\n            if (mainConfig.getStorage", "first_line_groundtruth": "UnsupportedOperationException(\"Unsupported storage type: \" + mainConfig.getStorageType());", "first_line_prediction": " Exception(\"Storage Type not supported\");", "match": 0}
{"groundtruth": "preparedStatement = database.getConnection().prepareStatement(\"SELECT COUNT(*) AS count FROM Schedule WHERE Leaderboard = ?\");", "prediction": " preparedStatement = database.getConnection().prepareStatement(\"SELECT * FROM Schedule WHERE Leaderboard = ?\");\n             preparedStatement.setString(1, leaderboard);\n             ResultSet rs = preparedStatement.executeQuery();\n             if (rs.next()){\n                 preparedStatement.close();\n                 return true;\n             }\n             preparedStatement.close();\n        } catch (SQLException ex) {\n            Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while reading data in database  [code : 13.2]\");\n        }\n        return false;\n    }\n\n   ", "first_line_groundtruth": "preparedStatement = database.getConnection().prepareStatement(\"SELECT COUNT(*) AS count FROM Schedule WHERE Leaderboard = ?\");", "first_line_prediction": " preparedStatement = database.getConnection().prepareStatement(\"SELECT * FROM Schedule WHERE Leaderboard = ?\");", "match": 0}
{"groundtruth": "preparedStatement = database.getConnection().prepareStatement(\n                        \"UPDATE \" + tableName + \" SET \" + columnName + \" = NULL\"\n                );", "prediction": " preparedStatement = database.getConnection().prepareStatement(\n                         \"DELETE FROM \" + tableName + \" WHERE \" + columnName + \" IS NOT NULL\"\n                 );\n            }\n            int rowsUpdated = preparedStatement.executeUpdate();\n            preparedStatement.close();\n        } catch (SQLException ex) {\n            Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while deleting all values in table \" + tableName + \" [code : 04]\");\n        }\n    }\n\n    public static void deleteAllValues(String tableName) {\n        PreparedStatement preparedStatement;\n       ", "first_line_groundtruth": "preparedStatement = database.getConnection().prepareStatement(", "first_line_prediction": " preparedStatement = database.getConnection().prepareStatement(", "match": 0}
{"groundtruth": "outputEGLSurface = outputEglCore.createOffsetScreenSurface(renderWidth, renderHeight);", "prediction": " outputEglCore.makeCurrent(outputEglCore.createWindowSurface(this));\n\n        // create egl surface\n        outputEGLSurface = outputEglCore.createPbufferSurface(renderWidth, renderHeight);\n        outputEglCore.makeCurrent(outputEGLSurface);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy\");\n\n        outputEglCore.destroy();\n    }", "first_line_groundtruth": "outputEGLSurface = outputEglCore.createOffsetScreenSurface(renderWidth, renderHeight);", "first_line_prediction": " outputEglCore.makeCurrent(outputEglCore.createWindowSurface(this));", "match": 0}
{"groundtruth": "database.getConnection().prepareStatement(\"SELECT \" + \"LastSent\" + \" FROM Schedule WHERE Leaderboard = ?\");", "prediction": " database.getConnection().prepareStatement(\"SELECT LastSent FROM Schedule WHERE Leaderboard = ?\");\n            preparedStatement.setString(1, leaderboard);\n            ResultSet rs = preparedStatement.executeQuery();\n            if (rs.next()) {\n                lastsent = rs.getTimestamp(\"LastSent\");\n            }\n            preparedStatement.close();\n        }catch (SQLException ex){\n            Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while reading data in database  [code : 15]\");\n        }\n        return lastsent;\n    }\n\n    public static", "first_line_groundtruth": "database.getConnection().prepareStatement(\"SELECT \" + \"LastSent\" + \" FROM Schedule WHERE Leaderboard = ?\");", "first_line_prediction": " database.getConnection().prepareStatement(\"SELECT LastSent FROM Schedule WHERE Leaderboard = ?\");", "match": 0}
{"groundtruth": "quadRenderer.drawTexture(texId, renderWidth, renderHeight);", "prediction": " sharedTexture.draw();\n                }\n            }\n        });\n    }\n\n    private void startOffscreenService() {\n        Intent intent = new Intent(this, OffscreenService.class);\n        startService(intent);\n        bindService(intent, aidlConnection, BIND_AUTO_CREATE);\n    }\n\n    private void stopOffscreenService() {\n        unbindService(aidlConnection);\n        stopService(new Intent(this, OffscreenService.class));\n    }\n\n    private void createRenderResources() {\n        // create render context\n        outputEglCore = new EGLCore(EGLCore.CONFIG_PLAIN);", "first_line_groundtruth": "quadRenderer.drawTexture(texId, renderWidth, renderHeight);", "first_line_prediction": " sharedTexture.draw();", "match": 0}
{"groundtruth": ", leaderboard.getConfig().getPlaceholder());", "prediction": ", leaderboard.getPlaceholder());\n            userData.addToDatabase();\n        }\n    }\n\n    //All Players All Placeholders\n    public void addUserDataToDBAllPlaceholders(){\n        MainConfig mainConfig = new MainConfig();\n        List<String> leaderboardnamelist = mainConfig.getLeaderboardsList();\n        for (String lbname : leaderboardnamelist){\n            Leaderboard leaderboard = new Leaderboard(lbname);\n            UserData userData = new UserData(lbname);\n            userData.addToDatabase();\n        }\n    }", "first_line_groundtruth": ", leaderboard.getConfig().getPlaceholder());", "first_line_prediction": ", leaderboard.getPlaceholder());", "match": 0}
{"groundtruth": "database.getConnection().prepareStatement(\"MERGE INTO Schedule s USING (VALUES (?, ?)) data (Leaderboard, LastSent) ON s.Leaderboard = data.Leaderboard WHEN MATCHED THEN UPDATE SET s.LastSent = data.LastSent WHEN NOT MATCHED THEN INSERT (Leaderboard, LastSent) VALUES (data.Leaderboard, data.LastSent);", "prediction": " database.getConnection().prepareStatement(\"UPDATE Leaderboard SET LastSent = ? WHERE Name = ?\");\n                preparedStatement.setTimestamp(1, timestamp);\n                preparedStatement.setString(2, leaderboard);\n                preparedStatement.executeUpdate();\n                preparedStatement.close();\n            } catch (SQLException ex) {\n                Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Issue while setting last sent timestamp for leaderboard \" + leaderboard + \" [code : 11]\");\n                ex.printStackTrace();\n            }\n        } else if (mainConfig", "first_line_groundtruth": "database.getConnection().prepareStatement(\"MERGE INTO Schedule s USING (VALUES (?, ?)) data (Leaderboard, LastSent) ON s.Leaderboard = data.Leaderboard WHEN MATCHED THEN UPDATE SET s.LastSent = data.LastSent WHEN NOT MATCHED THEN INSERT (Leaderboard, LastSent) VALUES (data.Leaderboard, data.LastSent);", "first_line_prediction": " database.getConnection().prepareStatement(\"UPDATE Leaderboard SET LastSent = ? WHERE Name = ?\");", "match": 0}
{"groundtruth": "ServerCountryFlags.updateAPILanguage(null);", "prediction": " cfg.locale = \"en_US\";\n        }\n\n        if (cfg.useKm) {\n            cfg.locale = \"en_US\";\n        }\n\n        if (cfg.showDistance) {\n            cfg.showDistance = true;\n        }\n\n        if (cfg.showDistrict) {\n            cfg.showDistrict = true;\n        }\n\n        if (cfg.showISP) {\n            cfg.showISP = true;\n        }\n\n        if (cfg.mapButton) {\n            cfg.mapButton = true;\n        }\n\n        if (cfg.mapButtonRight) {\n            cfg.mapButtonRight = true;\n       ", "first_line_groundtruth": "ServerCountryFlags.updateAPILanguage(null);", "first_line_prediction": " cfg.locale = \"en_US\";", "match": 0}
{"groundtruth": "String databaseName = mainConfig.getStorageType();", "prediction": " if (mainConfig.getStorageType().equalsIgnoreCase(\"h2\")){\n                preparedStatement = database.getConnection().prepareStatement(\"SELECT PlayerName, \" + placeholderColumnName + \" FROM UserData ORDER BY \" + placeholderColumnName + \" DESC LIMIT \" + top);\n                ResultSet resultSet = preparedStatement.executeQuery();\n                while (resultSet.next()) {\n                    String playerName = resultSet.getString(\"PlayerName\");\n                    double playerScore = resultSet.getDouble(placeholderColumnName);\n                    topPlayerScores.put(playerName, playerScore);\n                }\n                resultSet.close();\n                preparedStatement.close();\n             } else if (mainConfig.getStorage", "first_line_groundtruth": "String databaseName = mainConfig.getStorageType();", "first_line_prediction": " if (mainConfig.getStorageType().equalsIgnoreCase(\"h2\")){", "match": 0}
{"groundtruth": ".setRequestsLeft(requestsLeft - APITimeoutManager.getRequestsSent());", "prediction": ".setCooldown(requestsLeft, secondsLeft);\n\t\t\t}", "first_line_groundtruth": ".setRequestsLeft(requestsLeft - APITimeoutManager.getRequestsSent());", "first_line_prediction": ".setCooldown(requestsLeft, secondsLeft);", "match": 0}
{"groundtruth": "userData.addUserDataToDBAllPlayersThisPlaceholder();", "prediction": " PlayerUtils.syncOfflinePlayerData(plugin);\n                });\n            } catch (Exception e) {\n                p.sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"Invalid Placeholder Name [code : 01]\");\n            }\n        }\n        //Delete Command\n        if (args[0].equalsIgnoreCase(\"delete\")) {\n            if (!sender.hasPermission(\"dl.delete\") && !sender.hasPermission(\"dl.admin\")) {\n                sender.sendMessage(ChatColor.AQUA + \"[Dleaderboards] \" + ChatColor.RED + \"No Permission ! [dl", "first_line_groundtruth": "userData.addUserDataToDBAllPlayersThisPlaceholder();", "first_line_prediction": " PlayerUtils.syncOfflinePlayerData(plugin);", "match": 0}
{"groundtruth": "APITimeoutManager.setSecondsLeftUntilReset(secondsLeft);", "prediction": "\tAPITimeoutManager.setSecondsLeft(secondsLeft - APITimeoutManager.getSecondsSent());\n\t\t\t}", "first_line_groundtruth": "APITimeoutManager.setSecondsLeftUntilReset(secondsLeft);", "first_line_prediction": "\tAPITimeoutManager.setSecondsLeft(secondsLeft - APITimeoutManager.getSecondsSent());", "match": 0}
{"groundtruth": "(APITimeoutManager.isOnCooldown()) {", "prediction": " (ip.isEmpty()) {\n\t\t\treturn new APIResponse(localLocation);\n\t\t}", "first_line_groundtruth": "(APITimeoutManager.isOnCooldown()) {", "first_line_prediction": " (ip.isEmpty()) {", "match": 0}
{"groundtruth": "APITimeoutManager.decrementRequestsSent();", "prediction": "", "first_line_groundtruth": "APITimeoutManager.decrementRequestsSent();", "first_line_prediction": "", "match": 0}
{"groundtruth": "APITimeoutManager.incrementRequestsSent();", "prediction": "\tURL url = new URL(apiUrlStr);\n\t\t\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\t\t\t\tconnection.setConnectTimeout(1000);\n\t\t\t\tconnection.setReadTimeout(1000);\n\t\t\t\tconnection.setRequestMethod(\"GET\");\n\t\t\t\tconnection.setDoInput(true);\n\t\t\t\tconnection.setDoOutput(false);\n\t\t\t\tconnection.connect();", "first_line_groundtruth": "APITimeoutManager.incrementRequestsSent();", "first_line_prediction": "\tURL url = new URL(apiUrlStr);", "match": 0}
{"groundtruth": "request.setReturnCode(500);", "prediction": "\t//return error500;\n\t\t\t}\n\t\t\n\t\trequest.setReturnCode(404);\n\t\treturn error404;", "first_line_groundtruth": "request.setReturnCode(500);", "first_line_prediction": "\t//return error500;", "match": 0}
{"groundtruth": ">= server.getMaximumHeaderParameterCount())\n\t\t\t\t\treturn parameters;", "prediction": " > 0)\n\t\t\t\t\tparameters.put(key.toString(), value.toString());\n\t\t\t\tkeyFlag = true;\n\t\t\t\tvalue = new StringBuilder();\n\t\t\t}\n\t\t\telse\n\t\t\t\tvalue.append(c);\n\t\t}\n\t\treturn parameters;", "first_line_groundtruth": ">= server.getMaximumHeaderParameterCount())", "first_line_prediction": " > 0)", "match": 0}
{"groundtruth": "request.getContentType());", "prediction": " \"text/html; charset=UTF-8\");\n\t\t\n\t\t//default date\n\t\tif(!headers.containsKey(\"Date\"))\n\t\t\theaders.put(\"Date\", ZonedDateTime.now().format(DateTimeFormatter.RFC_1123_DATE_TIME));\n\t\t\n\t\t//default server\n\t\tif(!headers.containsKey(\"Server\"))\n\t\t\theaders.put(\"Server\", \"HTTPdLib\");\n\t\t\n\t\t//default connection\n\t\tif(!headers.containsKey(\"Connection\"))\n\t\t\theaders.put(\"Connection\", \"close\");\n\t\t\n\t\t//default cache-control\n\t\tif(!headers.containsKey(\"Cache-Control\"))", "first_line_groundtruth": "request.getContentType());", "first_line_prediction": " \"text/html; charset=UTF-8\");", "match": 0}
{"groundtruth": "if(cookies.size() >= server.getMaximumCookieCount())\n\t\t\t\t\t\tbreak;", "prediction": "\tif(cookies.size() >= server.getMaximumHeaderParameterSize())\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tvalue.append(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cookies;", "first_line_groundtruth": "if(cookies.size() >= server.getMaximumCookieCount())", "first_line_prediction": "\tif(cookies.size() >= server.getMaximumHeaderParameterSize())", "match": 0}
{"groundtruth": "size() >= server.getMaximumHeaderParameterSize())\n\t\t\t\t\t\tbreak;", "prediction": "size() >= server.getMaximumParameterCount())\n\t\t\t\t\t\treturn parameters;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t///end of value\n\t\t\t\telse if(c == '\\n' || c == '\\r')\n\t\t\t\t{\n\t\t\t\t\tif(key.length() > 0 && value.length() > 0)\n\t\t\t\t\t\tparameters.put(key.toString(), value.toString());\n\t\t\t\t\t\n\t\t\t\t\tkey = new StringBuilder();\n\t\t\t\t\tvalue = new StringBuilder();\n\t\t\t\t\tkeyFlag = true;\n\t\t\t\t\t\n\t\t\t\t\tif(parameters.size() >= server.getMaximumParameterCount())\n\t\t\t\t\t\treturn parameters;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t/", "first_line_groundtruth": "size() >= server.getMaximumHeaderParameterSize())", "first_line_prediction": "size() >= server.getMaximumParameterCount())", "match": 0}
{"groundtruth": "if(value.length() < server.getMaximumHeaderParameterSize())\n\t\t\t\tvalue.append(c);", "prediction": " if(c == ' ')\n\t\t\t\tkeyFlag = true;\n\t\t\telse\n\t\t\t\tvalue.append(c);\n\t\t}\n\t\t\n\t\treturn parameters;", "first_line_groundtruth": "if(value.length() < server.getMaximumHeaderParameterSize())", "first_line_prediction": " if(c == ' ')", "match": 0}
{"groundtruth": "buffer.writeBody(bytes);", "prediction": "\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclient.setState(100);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 100:\n\t\t\t\t\t\t///TODO\n\t\t\t\t\t\t// if the client is still connected, send the response to the client\n\t\t\t\t\t\t// if the client is not connected, close the connection\n\t\t\t\t\t\t// if the client is not connected, close the connection\n\t\t\t\t\t\t// if the client is not connected, close the connection\n\t\t\t\t\t\t// if the client is not connected, close the connection\n\t\t\t\t\t\t// if the client is not connected, close", "first_line_groundtruth": "buffer.writeBody(bytes);", "first_line_prediction": "", "match": 0}
{"groundtruth": "buffer.writeHeader(bytes);", "prediction": "\t///process the bytes\n\t\t\t\t\t\trequestBuilder.build(client, buffer);\n\t\t\t\t\t\t\n\t\t\t\t\t\t///signal that we want to start reading and to fill up the buffer\n\t\t\t\t\t\tclient.setInputRead(true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t///advance to stage 1\n\t\t\t\t\t\tclient.setState(1);\n\t\t\t\t\t}\n\t\t\t\t\tcatch(IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\t\n\t\t//when a client disconnects\n\t\tclient ->\n\t\t{\n\t\t\tClientBuffer buffer = connected.remove(client.getId());\n\t\t\t\n\t\t\tif(buffer != null", "first_line_groundtruth": "buffer.writeHeader(bytes);", "first_line_prediction": "\t///process the bytes", "match": 0}
{"groundtruth": "= decoder.decodeParameters(new String(buffer.bodyBuffer.toByteArray(), StandardCharsets.UTF_8));", "prediction": " = decoder.decodeParameters(path.substring(path.indexOf('=') + 1));\n\t\t\telse\n\t\t\t\tpost = new HashMap<>();\n\t\t\t\n\t\t\t// decode cookies\n\t\t\tcookies = decoder.decodeCookies(parameters.get(\"Cookie\"));\n\t\t\t\n\t\t\treturn new Request(client.getRemoteIP(), methodType, path, version, parameters, cookies, get, post);\n\t\t}\n\t\telse\n\t\t\treturn null;", "first_line_groundtruth": "= decoder.decodeParameters(new String(buffer.bodyBuffer.toByteArray(), StandardCharsets.UTF_8));", "first_line_prediction": " = decoder.decodeParameters(path.substring(path.indexOf('=') + 1));", "match": 0}
{"groundtruth": "client.setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request, requestListener.request(buffer.request)));", "prediction": "\t//TODO: handle other methods\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuffer.request.process(client, buffer);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 10:\n\t\t\t\t\t\t//TODO: handle post requests\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}, requestListener);", "first_line_groundtruth": "client.setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request, requestListener.request(buffer.request)));", "first_line_prediction": "\t//TODO: handle other methods", "match": 0}
{"groundtruth": "setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request,\n\t\t\t\t\t\t\t\t\trequestListener.request(buffer.request)));", "prediction": "setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request, requestListener.request(buffer.request)));\n\t\t\t\t\t\t\n\t\t\t\t\t\tclient.setState(100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 100:\n\t\t\t\t\tclient.close();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});", "first_line_groundtruth": "setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request,", "first_line_prediction": "setOutputBufferCache(requestBuilder.getEncoder().generateResponse(buffer.request, requestListener.request(buffer.request)));", "match": 0}
{"groundtruth": "cookies = decoder.decodeCookies(parameters.get(\"Cookie\"));", "prediction": "\tcookies = decoder.decodeCookies(parameters.get(\"Cookie\"));\n\t\t\telse\n\t\t\t\tcookies = new HashMap<>();\n\t\t\t\n\t\t\treturn new Request(client.getRemoteAddress(), methodType, path, version, parameters, cookies, get, post);\n\t\t}\n\t\t\n\t\treturn null;", "first_line_groundtruth": "cookies = decoder.decodeCookies(parameters.get(\"Cookie\"));", "first_line_prediction": "\tcookies = decoder.decodeCookies(parameters.get(\"Cookie\"));", "match": 0}
{"groundtruth": "List<String> exps = RegexHelper.find(text, \"\\\\$\\\\{", "prediction": " // \u89e3\u6790\u53d8\u91cf\n        text = RegexHelper.findFirst(text, \"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n        while (null != text) {\n            String key = text.substring(2, text.length() - 1);\n            Expression expression = elMap.get(key);\n            if (null == expression) {\n                text = RegexHelper.findFirst(text, \"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n                continue;\n            }\n            text = expression.parser(text, map);\n        }\n        return text;\n    }\n\n    /**\n     * \u89e3\u6790\u53d8\u91cf\n     *\n     * @param text ", "first_line_groundtruth": "List<String> exps = RegexHelper.find(text, \"\\\\$\\\\{", "first_line_prediction": " // \u89e3\u6790\u53d8\u91cf", "match": 0}
{"groundtruth": "webAgent.url(url).execute(map);", "prediction": " webAgent.webAgent(WebAgent.defaultAgent().referer(webAgent.getConfig().getUrl()).url(url)).execute(map);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }).thenApply(parserFunction);\n            cfList.add(cf);\n            cf.thenAccept(consumer);\n        }\n        CompletableFuture.allOf(cfList.toArray(new CompletableFuture[]{})).join();\n        return list;\n    }\n\n    public static void main(String[] args) {\n        EasyCrawl<String> easyCrawl = new EasyCrawl<>();\n        easy", "first_line_groundtruth": "webAgent.url(url).execute(map);", "first_line_prediction": " webAgent.webAgent(WebAgent.defaultAgent().referer(webAgent.getConfig().getUrl()).url(url)).execute(map);", "match": 0}
{"groundtruth": "data = webAgent.execute(map);", "prediction": " webAgent = this.webAgent;\n        Function<WebAgent, R> parserFunction = this.parserFunction;\n        int pageIndex = 1;\n        int total = 0;\n        while (true) {\n            map.put(pageIndexKey, pageIndex);\n            map.put(totalKey, total);\n            R result = execute(map);\n            if (result == null) {\n                break;\n            }\n            total = JsonHelper.getInt(result, totalKey);\n            list.add(result);\n            pageIndex++;\n        }\n        return list;\n    }\n\n    /**\n     * restApi json\u683c\u5f0f", "first_line_groundtruth": "data = webAgent.execute(map);", "first_line_prediction": " webAgent = this.webAgent;", "match": 0}
{"groundtruth": "!result.getStatusCode().equals(200)) {", "prediction": "result.getStatusCode() != 200) {\n            log.error(\"http\u72b6\u6001\u7801\u4e0d\u4e3a200\uff1a{}\", result.getStatusCode());\n            throw new RuntimeException(String.format(\"http\u72b6\u6001\u7801\u4e0d\u4e3a200\uff1a%s\", result.getStatusCode()));\n        }\n    }\n\n    public void contentType() {\n        log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getContentType());\n        if (!result.getContentType().startsWith(\"text/html\")) {\n            log.error(\"http\u54cd\u5e94\u7c7b\u578b\u4e0d\u4e3atext/html\uff1a{}\", result.getContentType());\n            throw new RuntimeException(String.format(\"http\u54cd\u5e94\u7c7b\u578b\u4e0d", "first_line_groundtruth": "!result.getStatusCode().equals(200)) {", "first_line_prediction": "result.getStatusCode() != 200) {", "match": 0}
{"groundtruth": "Assert.notNull(timeStamp, \"\u65f6\u95f4\u6233\u4e0d\u80fd\u4e3a\u7a7a\uff01\");", "prediction": " return new DateHelper(LocalDateTime.ofInstant(timeStamp, ZoneId.systemDefault()));\n    }\n\n    /**\n     * \u521d\u59cb\u5bf9\u8c61\n     *\n     * @param timeStamp \u65f6\u95f4", "first_line_groundtruth": "Assert.notNull(timeStamp, \"\u65f6\u95f4\u6233\u4e0d\u80fd\u4e3a\u7a7a\uff01\");", "first_line_prediction": " return new DateHelper(LocalDateTime.ofInstant(timeStamp, ZoneId.systemDefault()));", "match": 0}
{"groundtruth": "text = text.replace(el, elMap.get(tag).execute(argsMap));", "prediction": " text = text.replace(el, elMap.get(tag).parser(argsMap));\n                } else {\n                    text = text.replace(el, MapUtil.get(map, tag));\n                }\n            }\n        }\n        return text;\n    }", "first_line_groundtruth": "text = text.replace(el, elMap.get(tag).execute(argsMap));", "first_line_prediction": " text = text.replace(el, elMap.get(tag).parser(argsMap));", "match": 0}
{"groundtruth": "return parent.type();", "prediction": " return UnreflectType.CONSTRUCTOR;\n    }", "first_line_groundtruth": "return parent.type();", "first_line_prediction": " return UnreflectType.CONSTRUCTOR;", "match": 0}
{"groundtruth": "UnreflectType.of(source.getGenericReturnType());", "prediction": " UnreflectType.of(source.getGenericReturnType());\n    }", "first_line_groundtruth": "UnreflectType.of(source.getGenericReturnType());", "first_line_prediction": " UnreflectType.of(source.getGenericReturnType());", "match": 0}
{"groundtruth": "if (result.getStatusCode() == 400) {", "prediction": " {\n                log.warn(\"\u672a\u77e5\u9519\u8bef\uff01\");\n            }\n        }\n    }\n\n    public void contentType() {\n        log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getContentType());\n        if (!result.getContentType().startsWith(\"text/html\")) {\n            log.warn(\"\u54cd\u5e94\u7c7b\u578b\u975e\u6587\u672c\u7c7b\u578b\uff01\");\n        }\n    }", "first_line_groundtruth": "if (result.getStatusCode() == 400) {", "first_line_prediction": " {", "match": 0}
{"groundtruth": "(T) accessor.invoke(null, args);", "prediction": " accessor.invoke(object(), args);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n    private interface Overrides {\n        void unreflect();\n    }", "first_line_groundtruth": "(T) accessor.invoke(null, args);", "first_line_prediction": " accessor.invoke(object(), args);", "match": 0}
{"groundtruth": "UnreflectType.of(source);", "prediction": " UnreflectType.of(source);\n    }", "first_line_groundtruth": "UnreflectType.of(source);", "first_line_prediction": " UnreflectType.of(source);", "match": 0}
{"groundtruth": "return (T) JdkInternals.allocateInstance(toClass());", "prediction": " return JdkInternals.allocateInstance(toClass());\n    }\n\n    /**\n     * Returns the type of this type.\n     *\n     * @return the type of this type\n     */\n    public Type getType() {\n        return typeToken.getType();\n    }\n\n    /**\n     * Returns the type of this type as a {@link Class}.\n     *\n     * @return the type of this type as a {@link Class}\n     */\n    public Class<?> toClass() {\n        return typeToken.getRawType();\n    }\n\n    /**\n     * Returns the type of this type as a {@link ParameterizedType}.\n     *\n     * @", "first_line_groundtruth": "return (T) JdkInternals.allocateInstance(toClass());", "first_line_prediction": " return JdkInternals.allocateInstance(toClass());", "match": 0}
{"groundtruth": "return new BytecodeFieldAccess((ReflectionFieldAccess) delegate.bind(object), accessor);", "prediction": " return new BytecodeFieldAccess(delegate.bind(object), accessor);\n    }\n\n    @Override\n    public Object get() {\n        return accessor.get(object);\n    }\n\n    @Override\n    public void set(Object value) {\n        accessor.set(object, value);\n    }", "first_line_groundtruth": "return new BytecodeFieldAccess((ReflectionFieldAccess) delegate.bind(object), accessor);", "first_line_prediction": " return new BytecodeFieldAccess(delegate.bind(object), accessor);", "match": 0}
{"groundtruth": "return UnreflectType.of(source.getGenericType());", "prediction": " return UnreflectType.of(source.getGenericType());\n    }", "first_line_groundtruth": "return UnreflectType.of(source.getGenericType());", "first_line_prediction": " return UnreflectType.of(source.getGenericType());", "match": 0}
{"groundtruth": "webAgent.getConfig().getUrl()).set(pageIndexKey, String.valueOf(i)).getUrl();", "prediction": "data.getUrl()).set(pageIndexKey, i).getUrl();\n            cfList.add(CompletableFuture.supplyAsync(() -> webAgent.execute(url)).thenApply(parserFunction));\n            cfList.get(i).thenAccept(consumer);\n        }\n        CompletableFuture.allOf(cfList.toArray(new CompletableFuture[]{})).join();\n        return list;\n    }\n\n    public static void main(String[] args) {\n        EasyCrawl<String> easyCrawl = EasyCrawl.of(WebAgent.of(\"https://www.szse.cn/app/szse/#/stock/", "first_line_groundtruth": "webAgent.getConfig().getUrl()).set(pageIndexKey, String.valueOf(i)).getUrl();", "first_line_prediction": "data.getUrl()).set(pageIndexKey, i).getUrl();", "match": 0}
{"groundtruth": "().toClass().getSimpleName() + Parameters.toString(parameters().toList());", "prediction": "().toString() + \" \" + name() + Parameters.toString(parameters().toList());\n    }", "first_line_groundtruth": "().toClass().getSimpleName() + Parameters.toString(parameters().toList());", "first_line_prediction": "().toString() + \" \" + name() + Parameters.toString(parameters().toList());", "match": 0}
{"groundtruth": "int totalRows = json.get(totalKey, Integer.class);", "prediction": " int total = json.getInt(totalKey, 0);\n         int pageIndex = json.getInt(pageIndexKey, 1);\n         int pageCount = total / pageSize + (total % pageSize == 0 ? 0 : 1);\n         for (int i = 1; i <= pageCount; i++) {\n             Map<String, Object> params = new HashMap<>(map);\n             params.put(pageIndexKey, i);\n             params.put(totalKey, total);\n             params.put(pageSize, pageSize);\n             CompletableFuture<R> cf = CompletableFuture.supplyAsync(() -> {\n                ", "first_line_groundtruth": "int totalRows = json.get(totalKey, Integer.class);", "first_line_prediction": " int total = json.getInt(totalKey, 0);", "match": 0}
{"groundtruth": "(result.getStatusCode() == 401) {", "prediction": " (result.getStatusCode() == 403) {\n                log.warn(\"\u8bbf\u95ee\u88ab\u7981\u6b62\uff01\");\n            } else if (result.getStatusCode() == 401) {\n                log.warn(\"\u8bbf\u95ee\u88ab", "first_line_groundtruth": "(result.getStatusCode() == 401) {", "first_line_prediction": " (result.getStatusCode() == 403) {", "match": 0}
{"groundtruth": ".warn(\"\u672a\u652f\u6301\u7684\u72b6\u6001\u7801: {", "prediction": ".warn(\"\u672a\u77e5\u9519\u8bef\uff01\");\n            }\n        }\n    }\n\n    public void contentType() {\n        log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getHeaders().get(\"Content-Type\"));\n        if (!result.getHeaders().get(\"Content-Type\").startsWith(\"text/html\")) {\n            log.warn(\"\u54cd\u5e94\u7c7b\u578b\u975e\u6587\u672c\u7c7b\u578b\uff01\");\n        }\n    }", "first_line_groundtruth": ".warn(\"\u672a\u652f\u6301\u7684\u72b6\u6001\u7801: {", "first_line_prediction": ".warn(\"\u672a\u77e5\u9519\u8bef\uff01\");", "match": 0}
{"groundtruth": "Assert.isTrue(data.get(0) instanceof JSONArray, \"\u6570\u636e\u683c\u5f0f\u4e0d\u5339\u914d\uff01\");", "prediction": " String temp = \"insert into %s (%s) values %s;\";\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < data.size(); i++) {\n            JSONObject json = data.getJSONObject(i);\n            String values = Arrays.stream(columns).map(c -> {\n                String val = String.valueOf(json.get(c));\n                //\u79d1\u5b66\u8ba1\u6570\u8f6c\u6362\n                if (val.matches(RegexHelper.REGEX_SCIENTIFIC_NOTATION)) {\n                    return String.format(\"'%s'\", null == json.get(c) ? \"\"", "first_line_groundtruth": "Assert.isTrue(data.get(0) instanceof JSONArray, \"\u6570\u636e\u683c\u5f0f\u4e0d\u5339\u914d\uff01\");", "first_line_prediction": " String temp = \"insert into %s (%s) values %s;\";", "match": 0}
{"groundtruth": "String type = result.getContentType();", "prediction": " log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getContentType());\n         if (!result.getContentType().startsWith(\"text/html\")) {\n             log.warn(\"\u54cd\u5e94\u7c7b\u578b\u4e0d\u6b63\u786e\uff01\");\n         }\n    }", "first_line_groundtruth": "String type = result.getContentType();", "first_line_prediction": " log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getContentType());", "match": 0}
{"groundtruth": "return webAgent.execute(map);", "prediction": " result = parserFunction.apply(webAgent);\n            } catch (Exception e) {\n                log.error(\"\u89e3\u6790\u51fd\u6570\u6267\u884c\u5931\u8d25\uff01\", e);\n                throw new RuntimeException(e);\n            }\n            return result;\n        });\n        try {\n            result = cf.get();\n        } catch (Exception e) {\n            log.error(\"\u89e3\u6790\u51fd\u6570\u6267\u884c\u5931\u8d25\uff01\", e);\n            throw new RuntimeException(e);\n        }\n        return result;\n    }\n\n    public static <R> EasyCrawl<R> of(WebAgent webAgent, Function<WebAgent, R> parserFunction) {\n        return new EasyCrawl", "first_line_groundtruth": "return webAgent.execute(map);", "first_line_prediction": " result = parserFunction.apply(webAgent);", "match": 0}
{"groundtruth": "if (result.getStatusCode() >= 500) {", "prediction": " log.error(\"http\u72b6\u6001\u7801\u9519\u8bef\uff1a{}\", result.getStatusCode());\n             throw new RuntimeException(String.format(\"http\u72b6\u6001\u7801\u9519\u8bef\uff1a%s\", result.getStatusCode()));\n        }\n    }\n\n    public void contentType() {\n        log.debug(\"http\u54cd\u5e94\u7c7b\u578b\uff1a{}\", result.getContentType());\n        if (!result.getContentType().startsWith(\"text/html\")) {\n            log.error(\"http\u54cd\u5e94\u7c7b\u578b\u9519\u8bef\uff1a{}\", result.getContentType());\n            throw new RuntimeException(String.format(\"http\u54cd\u5e94\u7c7b\u578b\u9519\u8bef\uff1a%s\", result.getContentType()));\n        }\n    }", "first_line_groundtruth": "if (result.getStatusCode() >= 500) {", "first_line_prediction": " log.error(\"http\u72b6\u6001\u7801\u9519\u8bef\uff1a{}\", result.getStatusCode());", "match": 0}
{"groundtruth": "JsonHelper json = data.getJson();", "prediction": " int pageIndex = 1;\n        while (true) {\n            Map<String, Object> params = new MapUtil<String, Object>()\n                    .put(pageIndexKey, pageIndex)\n                    .put(\"pageSize\", pageSize)\n                    .getMap();\n            Map<String, String> cookies = getXQCookies();\n            String url = UrlHelper.buildUrl(data.getUrl(), params);\n            WebAgent page = webAgent.webAgent(data).url(url).cookie(cookies).execute();\n            R result = parserFunction.apply(page);\n            list.add(result);\n            if (result", "first_line_groundtruth": "JsonHelper json = data.getJson();", "first_line_prediction": " int pageIndex = 1;", "match": 0}
{"groundtruth": "isTrue(headHelper.fileContent(), \"\u975e\u6587\u4ef6\u6d41\u8bf7\u6c42\uff0c\u65e0\u6cd5\u8f93\u51fa\u6587\u4ef6\uff01\");", "prediction": "notNull(headHelper, \"\u8fd4\u56de\u5bf9\u8c61\u4e3a\u7a7a\uff01\u6216\u8005\u7a0b\u5e8f\u8fd8\u672a\u6267\u884cexecute\u65b9\u6cd5\uff01\");\n        String fileName = headHelper.getFileName();\n        Assert.notNull(fileName, \"\u8fd4\u56de\u5bf9\u8c61\u4e3a\u7a7a\uff01\u6216\u8005\u7a0b\u5e8f\u8fd8\u672a\u6267\u884cexecute\u65b9\u6cd5\uff01\");\n        String folder = this.config.getFolder();\n        Assert.notNull(folder, \"\u8fd4\u56de\u5bf9\u8c61\u4e3a\u7a7a\uff01\u6216\u8005\u7a0b\u5e8f\u8fd8\u672a\u6267\u884cexecute\u65b9\u6cd5\uff01\");\n        String filePath = folder + File.separator + fileName;\n        File file = new File(filePath);\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(getResult().getBody().getBytes());", "first_line_groundtruth": "isTrue(headHelper.fileContent(), \"\u975e\u6587\u4ef6\u6d41\u8bf7\u6c42\uff0c\u65e0\u6cd5\u8f93\u51fa\u6587\u4ef6\uff01\");", "first_line_prediction": "notNull(headHelper, \"\u8fd4\u56de\u5bf9\u8c61\u4e3a\u7a7a\uff01\u6216\u8005\u7a0b\u5e8f\u8fd8\u672a\u6267\u884cexecute\u65b9\u6cd5\uff01\");", "match": 0}
{"groundtruth": "setBody(transcoding(result.getBodyAsByes(), charset));", "prediction": "setCharset(charset);\n            }\n        }\n        return result;\n    }", "first_line_groundtruth": "setBody(transcoding(result.getBodyAsByes(), charset));", "first_line_prediction": "setCharset(charset);", "match": 0}
{"groundtruth": "wa = this.webAgent.execute(data);", "prediction": " webAgent = this.webAgent.execute(data);\n        this.result = webAgent.getResult();\n        return this;\n    }\n\n    @Override\n    public AgentResult getResult() {\n        return this.result;\n    }\n\n    @Override\n    public WebAgent execute() {\n        return this.execute(null);\n    }\n\n    @Override\n    public WebAgent execute(Map<String, Object> data) {\n        this.execute(data);\n        return this;\n    }\n\n    @Override\n    public WebAgent execute(String data) {\n        this.execute(JsonHelper.parse(data));\n        return this;\n   ", "first_line_groundtruth": "wa = this.webAgent.execute(data);", "first_line_prediction": " webAgent = this.webAgent.execute(data);", "match": 0}
{"groundtruth": "hct.getHue()) >= 90.0 && Math.round(hct.getHue()) <= 111.0;", "prediction": "hct.getHue()) < 15;\n    final boolean chromaPasses = hct.getChroma() > 10;\n    final boolean saturationPasses = hct.getSaturation() > 10;\n    final boolean luminancePasses = hct.getLuminance() > 10;\n    return huePasses && chromaPasses && saturationPasses && luminancePasses;\n  }", "first_line_groundtruth": "hct.getHue()) >= 90.0 && Math.round(hct.getHue()) <= 111.0;", "first_line_prediction": "hct.getHue()) < 15;", "match": 0}
{"groundtruth": "this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);", "prediction": " this.a2 = TonalPalette.fromHueAndChroma(hue, chroma);\n       this.a3 = TonalPalette.fromHueAndChroma(hue, chroma);\n       this.n1 = TonalPalette.fromHueAndChroma(hue, chroma);\n       this.n2 = TonalPalette.fromHueAndChroma(hue, chroma);\n       this.error = TonalPalette.fromHueAndChroma(hue, chroma);\n    } else {\n      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);", "first_line_groundtruth": "this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);", "first_line_prediction": " this.a2 = TonalPalette.fromHueAndChroma(hue, chroma);", "match": 0}
{"groundtruth": "ColorUtils.yFromLstar(tone);", "prediction": "100.0 - tone;\n    return ColorUtils.lstarFromY(darkY * ratio + tone);\n  }", "first_line_groundtruth": "ColorUtils.yFromLstar(tone);", "first_line_prediction": "100.0 - tone;", "match": 0}
{"groundtruth": "ratioOfYs(ColorUtils.yFromLstar(t1), ColorUtils.yFromLstar(t2));", "prediction": "1.0 + (t1 - t2) / (1.0 - t2);\n  }\n\n  /**\n   * Calculates the luminance of a color given its XYZ values.\n   *\n   * <p>The luminance is defined as Y in XYZ, relative luminance. However, relative luminance is\n   * linear to number of photons, not to perception of lightness. Perceptual luminance, L* in\n   * L*a*b*, T in HCT, is. Designers prefer color spaces with perceptual luminance since they're\n   * accurate to the eye", "first_line_groundtruth": "ratioOfYs(ColorUtils.yFromLstar(t1), ColorUtils.yFromLstar(t2));", "first_line_prediction": "1.0 + (t1 - t2) / (1.0 - t2);", "match": 0}
{"groundtruth": "Math.round(hct.getHue()) >= 90.0 && Math.round(hct.getHue()) <= 111.0;", "prediction": "0.0 <= hct.getHue() && hct.getHue() <= 15.0;\n    final boolean chromaPasses = hct.getChroma() >= 1.0;\n    return huePasses && chromaPasses;\n  }", "first_line_groundtruth": "Math.round(hct.getHue()) >= 90.0 && Math.round(hct.getHue()) <= 111.0;", "first_line_prediction": "0.0 <= hct.getHue() && hct.getHue() <= 15.0;", "match": 0}
{"groundtruth": ".from(hct.getHue(), hct.getChroma(), 70.0);", "prediction": ".fromInt(hct.toArgb() | 0x00000000ff000000);\n    }\n    return hct;\n  }", "first_line_groundtruth": ".from(hct.getHue(), hct.getChroma(), 70.0);", "first_line_prediction": ".fromInt(hct.toArgb() | 0x00000000ff000000);", "match": 0}
{"groundtruth": "round(hct.getChroma()) > 16.0;", "prediction": "round(hct.getChroma()) >= 16.0 && Math.round(hct.getChroma()) <= 20.0;\n    return huePasses && chromaPasses;\n  }", "first_line_groundtruth": "round(hct.getChroma()) > 16.0;", "first_line_prediction": "round(hct.getChroma()) >= 16.0 && Math.round(hct.getChroma()) <= 20.0;", "match": 0}
{"groundtruth": "hct.getChroma();", "prediction": "0.5;\n    double tone = 0.5;\n    if (isContent) {\n      chroma = 0.75;\n      tone = 0.25;\n    }\n    a1 = TonalPalette.fromHct(new Hct(HctSolver.solveToInt(hue, chroma, 0.0)));\n    a2 = TonalPalette.fromHct(new Hct(HctSolver.solveToInt(hue, chroma, 0.25)));\n    a3 = TonalPalette.fromHct(new Hct(HctSolver.", "first_line_groundtruth": "hct.getChroma();", "first_line_prediction": "0.5;", "match": 0}
{"groundtruth": "a1 = TonalPalette.fromHueAndChroma(hue, chroma);", "prediction": "a1 = TonalPalette.fromHue(hue, chroma, 0.0);\n      this.a2 = TonalPalette.fromHue(hue, chroma, 0.1);\n      this.a3 = TonalPalette.fromHue(hue, chroma, 0.2);\n      this.n1 = TonalPalette.fromHue(hue, chroma, 0.3);\n      this.n2 = TonalPalette.fromHue(hue, chroma, 0.4);\n      this.error = TonalPalette.fromHue(hue, chroma", "first_line_groundtruth": "a1 = TonalPalette.fromHueAndChroma(hue, chroma);", "first_line_prediction": "a1 = TonalPalette.fromHue(hue, chroma, 0.0);", "match": 0}
{"groundtruth": "hct.getTone()) < 65.0;", "prediction": "hct.getTone()) > 50.0;\n    return huePasses && chromaPasses && tonePasses;\n  }", "first_line_groundtruth": "hct.getTone()) < 65.0;", "first_line_prediction": "hct.getTone()) > 50.0;", "match": 0}
{"groundtruth": ".a3 = TonalPalette.fromHueAndChroma(hue + 60., chroma / 2.);", "prediction": ".a3 = TonalPalette.fromHueAndChroma(hue, chroma / 2.);\n      this.n1 = TonalPalette.fromHueAndChroma(hue, chroma / 2.);\n      this.n2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);\n      this.error = TonalPalette.fromHueAndChroma(hue, chroma / 2.);\n    } else {\n      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);\n      this.a2 = TonalPalette.", "first_line_groundtruth": ".a3 = TonalPalette.fromHueAndChroma(hue + 60., chroma / 2.);", "first_line_prediction": ".a3 = TonalPalette.fromHueAndChroma(hue, chroma / 2.);", "match": 0}
{"groundtruth": "ColorUtils.lstarFromY(lightY) + LUMINANCE_GAMUT_MAP_TOLERANCE;", "prediction": "100.0 - tone;\n    if (Math.abs(returnValue - tone) > CONTRAST_RATIO_EPSILON) {\n      return -1.0;\n    }\n    return returnValue;\n  }", "first_line_groundtruth": "ColorUtils.lstarFromY(lightY) + LUMINANCE_GAMUT_MAP_TOLERANCE;", "first_line_prediction": "100.0 - tone;", "match": 0}
{"groundtruth": "hue = hct.getHue();", "prediction": " hue = hct.getHue();\n    double  chroma = hct.getChroma();\n    double  tone = hct.getTone();\n    double  saturation = hct.getSaturation();\n    double  luminance = hct.getLuminance();\n    double  contrast = hct.getContrast();\n    double  brightness = hct.getBrightness();\n    double  contrastRatio = hct.getContrastRatio();\n    double  brightnessRatio = hct.getBrightnessRatio();\n    double  contrastLight = hct.getContrastLight();\n    double  contrastDark = hct.", "first_line_groundtruth": "hue = hct.getHue();", "first_line_prediction": " hue = hct.getHue();", "match": 0}
{"groundtruth": "= TonalPalette.fromHueAndChroma(hue, min(chroma / 12., 4.));", "prediction": " = TonalPalette.fromHueAndChroma(hue, chroma);\n      this.n2  = TonalPalette.fromHueAndChroma(hue, chroma / 3.);\n      this.error = TonalPalette.fromHueAndChroma(hue, chroma / 2.);\n    } else {\n      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);\n      this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);\n      this.a3 = TonalPalette.fromHueAndChroma", "first_line_groundtruth": "= TonalPalette.fromHueAndChroma(hue, min(chroma / 12., 4.));", "first_line_prediction": " = TonalPalette.fromHueAndChroma(hue, chroma);", "match": 0}
{"groundtruth": "a1 = TonalPalette.fromHueAndChroma(hue, max(48., chroma));", "prediction": "a1 = TonalPalette.fromHueAndChroma(hue, chroma);\n      this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);\n      this.a3 = TonalPalette.fromHueAndChroma(hue + 60., chroma / 2.);\n      this.n1 = TonalPalette.fromHueAndChroma(hue, chroma / 12.);\n      this.n2 = TonalPalette.fromHueAndChroma(hue, chroma / 6.);\n    }\n    this.error = Tonal", "first_line_groundtruth": "a1 = TonalPalette.fromHueAndChroma(hue, max(48., chroma));", "first_line_prediction": "a1 = TonalPalette.fromHueAndChroma(hue, chroma);", "match": 0}
{"groundtruth": "this.n2 = TonalPalette.fromHueAndChroma(hue, min(chroma / 6., 8.));", "prediction": " this.n2 = TonalPalette.fromHueAndChroma(hue, min(chroma / 12., 8.));\n      this.error = TonalPalette.fromHueAndChroma(hue, chroma / 2.);\n    } else {\n      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);\n      this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3.);\n      this.a3 = TonalPalette.fromHueAndChroma(hue + 60., chroma / ", "first_line_groundtruth": "this.n2 = TonalPalette.fromHueAndChroma(hue, min(chroma / 6., 8.));", "first_line_prediction": " this.n2 = TonalPalette.fromHueAndChroma(hue, min(chroma / 12., 8.));", "match": 0}
{"groundtruth": "= TonalPalette.fromHueAndChroma(hue, 16.);", "prediction": " = TonalPalette.fromHueAndChroma(hue, max(48., chroma / 3.));\n      this.a3 = TonalPalette.fromHueAndChroma(hue + 60., max(48., chroma / 2.));\n      this.n1 = TonalPalette.fromHueAndChroma(hue, max(48., chroma / 12.));\n      this.n2 = TonalPalette.fromHueAndChroma(hue, max(48., chroma / 6.));\n    }\n    this.error = T", "first_line_groundtruth": "= TonalPalette.fromHueAndChroma(hue, 16.);", "first_line_prediction": " = TonalPalette.fromHueAndChroma(hue, max(48., chroma / 3.));", "match": 0}
{"groundtruth": "ColorUtils.blueFromArgb(argb);", "prediction": "255 - red;\n    int green = ColorUtils.greenFromArgb(argb);\n    return String.format(\"#%02x%02x%02x\", red, green, blue);\n  }", "first_line_groundtruth": "ColorUtils.blueFromArgb(argb);", "first_line_prediction": "255 - red;", "match": 0}
{"groundtruth": "a3 = TonalPalette.fromHueAndChroma(hue + 60., 24.);", "prediction": "a3 = TonalPalette.fromHueAndChroma(hue, 24.);\n      this.n1 = TonalPalette.fromHueAndChroma(hue, 12.);\n      this.n2 = TonalPalette.fromHueAndChroma(hue, 16.);\n    }\n    this.error = TonalPalette.fromHueAndChroma(hue, 16.);\n  }", "first_line_groundtruth": "a3 = TonalPalette.fromHueAndChroma(hue + 60., 24.);", "first_line_prediction": "a3 = TonalPalette.fromHueAndChroma(hue, 24.);", "match": 0}
{"groundtruth": "MathUtils.clampInt(0, 255, (int) Math.round(delinearized * 255.0));", "prediction": "255 * (int) Math.round(delinearized);\n  }", "first_line_groundtruth": "MathUtils.clampInt(0, 255, (int) Math.round(delinearized * 255.0));", "first_line_prediction": "255 * (int) Math.round(delinearized);", "match": 0}
{"groundtruth": "return new TonalPalette(hct.getHue(), hct.getChroma(), hct);", "prediction": " return new TonalPalette(hct);\n  }\n\n  private TonalPalette(Hct hct) {\n    this.keyColor = hct;\n    this.hue = hct.getHue();\n    this.chroma = hct.getChroma();\n    this.cache = new HashMap<>();\n  }\n\n  /**\n    * Get the tones for a given tone.\n    *\n    * @param tone The tone to get.\n    * @return The ARGB representation of the tone.\n    */\n  public int get(double tone) {\n    if (cache.containsKey((int) tone)) {\n      return", "first_line_groundtruth": "return new TonalPalette(hct.getHue(), hct.getChroma(), hct);", "first_line_prediction": " return new TonalPalette(hct);", "match": 0}
{"groundtruth": ".n1 = TonalPalette.fromHueAndChroma(hue, 4.);", "prediction": ".n1 = TonalPalette.fromHueAndChroma(hue, 12.);\n      this.n2 = TonalPalette.fromHueAndChroma(hue, 16.);\n    }\n    this.error = TonalPalette.fromHueAndChroma(hue, 16.);\n  }", "first_line_groundtruth": ".n1 = TonalPalette.fromHueAndChroma(hue, 4.);", "first_line_prediction": ".n1 = TonalPalette.fromHueAndChroma(hue, 12.);", "match": 0}
{"groundtruth": "return MathUtils.matrixMultiply(new double[] {", "prediction": " double[][] matrix = SRGB_TO_XYZ;\n    double x = matrix[0][0] * r + matrix[0][1] * g + matrix[0][2] * b;\n    double y = matrix[1][0] * r + matrix[1][1] * g + matrix[1][2] * b;\n    double z = matrix[2][0] * r + matrix[2][1] * g + matrix[2][2] * b;\n    return new double[] {x, y, z};\n  }", "first_line_groundtruth": "return MathUtils.matrixMultiply(new double[] {", "first_line_prediction": " double[][] matrix = SRGB_TO_XYZ;", "match": 0}
{"groundtruth": "differenceDegrees(hct.getHue(), chosenHct.getHue()) < differenceDegrees) {", "prediction": "degreesBetween(hct.getHue(), chosenHct.getHue()) == differenceDegrees) {\n            hasDuplicateHue = true;\n            break;\n          }\n        }\n        if (!hasDuplicateHue) {\n          chosenColors.add(hct);\n        }\n      }\n      if (chosenColors.size() >= desired) {\n        break;\n      }\n    }\n\n    // If the desired number of colors is not available, return the fallback color.\n    if (chosenColors.size() < desired) {\n      chosenColors.add(Hct.fromInt(fallbackColorArgb));\n    }\n\n    // Return the colors in", "first_line_groundtruth": "differenceDegrees(hct.getHue(), chosenHct.getHue()) < differenceDegrees) {", "first_line_prediction": "degreesBetween(hct.getHue(), chosenHct.getHue()) == differenceDegrees) {", "match": 0}
{"groundtruth": ") Math.floor(hct.getHue());", "prediction": ") Math.floor(hct.getHue());\n      huePopulation[hue]++;\n      populationSum += entry.getValue();\n    }\n\n    // Sort the colors by hue, then by chroma.\n    Collections.sort(colorsHct, new Comparator<Hct>() {\n      @Override\n      public int compare(Hct o1, Hct o2) {\n        int hueComparison = (int) Math.floor(o1.getHue() - o2.getHue());\n        if (hueComparison != 0) {\n          return hueComparison;\n        }\n        return (int) Math.floor(o1", "first_line_groundtruth": ") Math.floor(hct.getHue());", "first_line_prediction": ") Math.floor(hct.getHue());", "match": 1}
{"groundtruth": "= Math.abs(smallestDeltaHct.getChroma() - chroma);", "prediction": " = smallestDeltaHct.getDelta();\n    double smallestDeltaHue = smallestDeltaHct.getHue();\n    double smallestDeltaChroma = smallestDeltaHct.getChroma();\n    for (double tone = startTone; tone <= 100.0; tone += 10.0) {\n      Hct hct = Hct.from(hue, chroma, tone);\n      double delta = hct.getDelta();\n      double deltaHue = hct.getHue();\n      double deltaChroma = hct.getChroma();\n      if (delta < smallestDelta) {\n       ", "first_line_groundtruth": "= Math.abs(smallestDeltaHct.getChroma() - chroma);", "first_line_prediction": " = smallestDeltaHct.getDelta();", "match": 0}
{"groundtruth": "= MathUtils.sanitizeDegreesInt(i);", "prediction": " = i % 360;\n        if (neighborHue != hue) {\n          proportion += huePopulation[neighborHue] / populationSum;\n        }\n      }\n      hueExcitedProportions[hue] = proportion;\n    }\n\n    // Get the HCT color for each Argb value, while finding the per hue count and\n    // total count.\n    List<Hct> colorsHctSorted = new ArrayList<>();\n    for (int hue = 0; hue < 360; hue++) {\n      colorsHctSorted.add(colorsHct.get(hue));\n    }\n    Collections.", "first_line_groundtruth": "= MathUtils.sanitizeDegreesInt(i);", "first_line_prediction": " = i % 360;", "match": 0}
{"groundtruth": "if (MathUtils.differenceDegrees(hct.getHue(), chosenHct.getHue()) < differenceDegrees) {", "prediction": " if (chosenHct.getHue() == hct.getHue()) {\n             hasDuplicateHue = true;\n             break;\n           }\n        }\n        if (!hasDuplicateHue) {\n          chosenColors.add(hct);\n        }\n      }\n      if (chosenColors.size() >= desired) {\n        break;\n      }\n    }\n\n    // If the desired number of colors is not available, return the fallback color.\n    if (chosenColors.size() < desired) {\n      chosenColors.add(Hct.fromInt(fallbackColorArgb));\n    }\n\n    // Return the colors in the order of their", "first_line_groundtruth": "if (MathUtils.differenceDegrees(hct.getHue(), chosenHct.getHue()) < differenceDegrees) {", "first_line_prediction": " if (chosenHct.getHue() == hct.getHue()) {", "match": 0}
{"groundtruth": "filter && (hct.getChroma() < CUTOFF_CHROMA || proportion <= CUTOFF_EXCITED_PROPORTION)) {", "prediction": "proportion < CUTOFF_EXCITED_PROPORTION) {\n        continue;\n      }\n      double chroma = hct.getChroma();\n      if (chroma < CUTOFF_CHROMA) {\n        if (chroma < TARGET_CHROMA) {\n          scoredHcts.add(new ScoredHCT(hct, WEIGHT_CHROMA_BELOW));\n        } else {\n          scoredHcts.add(new ScoredHCT(hct, WEIGHT_CHROMA_ABOVE));\n        }\n      } else {\n       ", "first_line_groundtruth": "filter && (hct.getChroma() < CUTOFF_CHROMA || proportion <= CUTOFF_EXCITED_PROPORTION)) {", "first_line_prediction": "proportion < CUTOFF_EXCITED_PROPORTION) {", "match": 0}
{"groundtruth": "MathUtils.sanitizeDegreesInt((int) Math.round(hct.getHue()));", "prediction": "0 - (int) Math.floor(hct.getHue());\n      double proportion = huePopulation[hue] / populationSum;\n      double chroma = hct.getChroma();\n      double chromaAbove = hct.getChromaAbove(CUTOFF_CHROMA);\n      double chromaBelow = hct.getChromaBelow(CUTOFF_CHROMA);\n      double excitedProportion = hueExcitedProportions[hue];\n      double totalProportion = proportion + excitedProportion;\n      double totalChroma = chroma + chromaAbove + chromaBelow;", "first_line_groundtruth": "MathUtils.sanitizeDegreesInt((int) Math.round(hct.getHue()));", "first_line_prediction": "0 - (int) Math.floor(hct.getHue());", "match": 0}
{"groundtruth": "smallestDeltaHct = Hct.from(hue, chroma, startTone);", "prediction": " hct = Hct.from(hue, chroma, startTone);\n    while (hct.getChroma() < chroma) {\n      startTone += 10.0;\n      hct = Hct.from(hue, chroma, startTone);\n    }\n    return hct;\n  }\n\n  /**\n    * Get the color for a given tone.\n    *\n    * @param tone Tone to get.\n    * @return ARGB representation of the color.\n    */\n  public int get(double tone) {\n    int key = (int) (tone * 100.", "first_line_groundtruth": "smallestDeltaHct = Hct.from(hue, chroma, startTone);", "first_line_prediction": " hct = Hct.from(hue, chroma, startTone);", "match": 0}
{"groundtruth": "= MathUtils.sanitizeDegreesInt((int) Math.round(hct.getHue()));", "prediction": " = (int) Math.floor(hct.getHue());\n      double proportion = huePopulation[hue] / populationSum;\n      double chroma = hct.getChroma();\n      double chromaAbove = hct.getChromaAbove(CUTOFF_CHROMA);\n      double chromaBelow = hct.getChromaBelow(CUTOFF_CHROMA);\n      double excitedProportion = hueExcitedProportions[hue];\n      double totalProportion = proportion + excitedProportion;\n      double totalChroma = chroma + chromaAbove + chromaBelow;\n     ", "first_line_groundtruth": "= MathUtils.sanitizeDegreesInt((int) Math.round(hct.getHue()));", "first_line_prediction": " = (int) Math.floor(hct.getHue());", "match": 0}
{"groundtruth": "= Hct.fromInt(entry.getKey());", "prediction": " = Hct.from(entry.getKey());\n      colorsHct.add(hct);\n      huePopulation[hct.getHue()] += entry.getValue();\n      populationSum += entry.getValue();\n    }\n\n    // Sort the colors by hue, then by chroma.\n    Collections.sort(colorsHct, new Comparator<Hct>() {\n      @Override\n      public int compare(Hct hct1, Hct hct2) {\n        if (hct1.getHue() == hct2.getHue()) {\n          return Double.compare(hct1.getChroma(),", "first_line_groundtruth": "= Hct.fromInt(entry.getKey());", "first_line_prediction": " = Hct.from(entry.getKey());", "match": 0}
{"groundtruth": "= TonalPalette.fromHueAndChroma(25, 84.);", "prediction": " = TonalPalette.fromHueAndChroma(hue, 16.);\n  }", "first_line_groundtruth": "= TonalPalette.fromHueAndChroma(25, 84.);", "first_line_prediction": " = TonalPalette.fromHueAndChroma(hue, 16.);", "match": 0}
{"groundtruth": "hct.getChroma() < TARGET_CHROMA ? WEIGHT_CHROMA_BELOW : WEIGHT_CHROMA_ABOVE;", "prediction": "1.0 - WEIGHT_PROPORTION * WEIGHT_CHROMA_ABOVE * (hct.getChroma() / TARGET_CHROMA);\n      double chromaScore = chromaWeight * WEIGHT_CHROMA_BELOW;\n      double score = proportionScore + chromaScore;\n      scoredHcts.add(new ScoredHCT(hct, score));\n    }\n\n    // Sort the colors by score, and return the top desired.\n    Collections.sort(scoredHcts, new Comparator<ScoredHCT>() {\n      @Override\n      public int", "first_line_groundtruth": "hct.getChroma() < TARGET_CHROMA ? WEIGHT_CHROMA_BELOW : WEIGHT_CHROMA_ABOVE;", "first_line_prediction": "1.0 - WEIGHT_PROPORTION * WEIGHT_CHROMA_ABOVE * (hct.getChroma() / TARGET_CHROMA);", "match": 0}
{"groundtruth": "(), hct.getChroma(), hct);", "prediction": "(), hct.getChroma());\n  }\n\n  /**\n   * Create tones using a HCT hue and chroma.\n   *\n   * @param hue Hue of the tones.\n   * @param chroma Chroma of the tones.\n   */\n  public TonalPalette(double hue, double chroma) {\n    this.hue = hue;\n    this.chroma = chroma;\n    this.cache = new HashMap<>();\n    this.keyColor = Hct.from(hue, chroma, 0.0);\n  }\n\n  /**\n   * Get the ARGB representation of a", "first_line_groundtruth": "(), hct.getChroma(), hct);", "first_line_prediction": "(), hct.getChroma());", "match": 0}
{"groundtruth": "ColorUtils.labFromArgb(color.toInt());", "prediction": " Lab.fromHct(color);\n    double[] lch = Lch.fromLab(lab);\n    double[] xyz = Xyz.fromLch(lch);\n    double[] lab2 = Xyz.toLab(xyz);\n    double[] lch2 = Lab.toLch(lab2);\n    double[] lab3 = Lch.fromLch(lch2);\n    double[] xyz3 = Xyz.fromLab(lab3);\n    double[] lab4 = Xyz.toLab(xyz3);\n    double[] lch4 = Lab.toLch(lab", "first_line_groundtruth": "ColorUtils.labFromArgb(color.toInt());", "first_line_prediction": " Lab.fromHct(color);", "match": 0}
{"groundtruth": "(hue, input.getChroma(), input.getTone());", "prediction": "Hsv(hue, 1., 1.);\n      hcts.add(colorAtHue);\n    }\n    precomputedHctsByHue = hcts;\n    return hcts;\n  }", "first_line_groundtruth": "(hue, input.getChroma(), input.getTone());", "first_line_prediction": "Hsv(hue, 1., 1.);", "match": 0}
{"groundtruth": "int red = ColorUtils.redFromArgb(argb);", "prediction": " return String.format(\"#%02x%02x%02x\", redFromArgb(argb), greenFromArgb(argb), blueFromArgb(argb));\n  }", "first_line_groundtruth": "int red = ColorUtils.redFromArgb(argb);", "first_line_prediction": " return String.format(\"#%02x%02x%02x\", redFromArgb(argb), greenFromArgb(argb), blueFromArgb(argb));", "match": 0}
{"groundtruth": "hctAdd = Hct.from(hue, chroma, startTone + delta);", "prediction": " deltaHct = Hct.from(hue, chroma, startTone + delta);\n      final double deltaChroma = Math.abs(deltaHct.getChroma() - chroma);\n      if (deltaChroma < smallestDelta) {\n        smallestDelta = deltaChroma;\n        smallestDeltaHct = deltaHct;\n      }\n    }\n    return smallestDeltaHct;\n  }\n\n  /**\n    * Returns the HCT hue of the key color.\n    */\n  public double getHue() {\n    return hue;\n  }\n\n  /**\n    * Returns the HCT chroma of the key color.", "first_line_groundtruth": "hctAdd = Hct.from(hue, chroma, startTone + delta);", "first_line_prediction": " deltaHct = Hct.from(hue, chroma, startTone + delta);", "match": 0}
{"groundtruth": "== Math.round(smallestDeltaHct.getChroma())) {", "prediction": " == Math.round(smallestDeltaHct.getChroma())) {\n        return smallestDeltaHct;\n      }\n      Hct deltaHct = Hct.from(hue, chroma, startTone + delta);\n      double deltaChroma = Math.abs(deltaHct.getChroma() - chroma);\n      if (deltaChroma < smallestDelta) {\n        smallestDelta = deltaChroma;\n        smallestDeltaHct = deltaHct;\n      }\n    }\n    return smallestDeltaHct;\n  }\n\n  /**\n    * Returns the HCT hue of the key color.\n    */\n ", "first_line_groundtruth": "== Math.round(smallestDeltaHct.getChroma())) {", "first_line_prediction": " == Math.round(smallestDeltaHct.getChroma())) {", "match": 0}
{"groundtruth": "input.getHue(), coldestHue, warmestHue);", "prediction": "coldestHue, warmestHue, startHue);\n\n    List<Hct> hctsByTemp = getHctsByTemp();\n    List<Hct> hctsByHue = getHctsByHue();\n\n    List<Hct> hctsByTempAndHue = new ArrayList<>();\n    for (int i = 0; i < hctsByTemp.size(); i++) {\n      Hct hct = hctsByTemp.get(i);\n      if (isBetween(hct.getHue(), coldestHue, warmestHue)) {\n        hctsByTempAndHue.", "first_line_groundtruth": "input.getHue(), coldestHue, warmestHue);", "first_line_prediction": "coldestHue, warmestHue, startHue);", "match": 0}
{"groundtruth": "coldestHue = getColdest().getHue();", "prediction": " temp = input.getTemp();\n    double  hue = input.getHue();\n    double  chroma = input.getChroma();\n    double  lightness = input.getLightness();\n    double  chromaLimit = input.getChromaLimit();\n    double  chromaLimit2 = input.getChromaLimit2();\n    double  chromaLimit3 = input.getChromaLimit3();\n    double  chromaLimit4 = input.getChromaLimit4();\n    double  chromaLimit5 = input.getChromaLimit5();\n    double  chromaLimit6 = input", "first_line_groundtruth": "coldestHue = getColdest().getHue();", "first_line_prediction": " temp = input.getTemp();", "match": 0}
{"groundtruth": "round(input.getHue()));", "prediction": "round(startHue));\n    for (int i = 0; i < 100; i++) {\n      double hue = answer.getHue() + directionOfRotation;\n      if (hue < 0.0) {\n        hue += 360.0;\n      }\n      if (hue > 360.0) {\n        hue -= 360.0;\n      }\n      double temp = getTempsByHct().get(getHctsByHue().get((int) Math.round(hue)));\n      double error = Math.abs(temp - coldestTemp);", "first_line_groundtruth": "round(input.getHue()));", "first_line_prediction": "round(startHue));", "match": 0}
{"groundtruth": "color = Hct.from(this.hue, this.chroma, tone).toInt();", "prediction": " color = keyColor.toInt();\n       for (int i = 0; i < tone; i++) {\n         color = blend(color, keyColor.toInt());\n       }\n       cache.put(tone, color);\n    }\n    return color;\n  }\n\n  private int blend(int from, int to) {\n    // Blend in CAM16-UCS space.\n    //\n    // @param from ARGB representation of color\n    // @param to ARGB representation of color\n    // @param amount how much blending to perform; 0.0 >= and <= 1.0\n    // @return from", "first_line_groundtruth": "color = Hct.from(this.hue, this.chroma, tone).toInt();", "first_line_prediction": " color = keyColor.toInt();", "match": 0}
{"groundtruth": ".getChroma(), ColorUtils.lstarFromY(viewedInVc[1]));", "prediction": ".getChroma(), recastInVc.getLStarInViewingConditions(vc));\n  }\n\n  /**\n    * Set the internal state of this color.\n    *\n    * @param argb ARGB representation of a color.\n    */\n  private void setInternalState(int argb) {\n    this.argb = argb;\n    this.hue = ColorUtils.getHue(argb);\n    this.chroma = ColorUtils.getChroma(argb);\n    this.tone = ColorUtils.getTone(argb);\n  }", "first_line_groundtruth": ".getChroma(), ColorUtils.lstarFromY(viewedInVc[1]));", "first_line_prediction": ".getChroma(), recastInVc.getLStarInViewingConditions(vc));", "match": 0}
{"groundtruth": "hue = MathUtils.sanitizeDegreesInt(startHue + i);", "prediction": "ithHue = (startHue + i) % 360;\n      Hct ithHct = getHctsByHue().get(ithHue);\n      double tempDelta = getRelativeTemperature(ithHct) - lastTemp;\n      absoluteTotalTempDelta += tempDelta;\n      lastTemp = getRelativeTemperature(ithHct);\n      if (absoluteTotalTempDelta >= 1.f) {\n        absoluteTotalTempDelta -= 1.f;\n        allColors.add(ithHct);\n        if (allColors.size() == count) {\n          break;\n        }\n      }\n    }", "first_line_groundtruth": "hue = MathUtils.sanitizeDegreesInt(startHue + i);", "first_line_prediction": "ithHue = (startHue + i) % 360;", "match": 0}
{"groundtruth": "Cam16.fromInt(toInt());", "prediction": " Cam16.fromInt(argb);\n    double[] xyz = cam16.inViewingConditions(vc);\n\n    // 2. Use XYZ coordinates to find L*a*b* of color in specified VC.\n    double[] lab = ColorUtils.xyzToLab(xyz);\n    double[] laba = ColorUtils.labToLaba(lab);\n\n    // 3. Use L*a*b* to find HCT of color in specified VC.\n    double[] hct = ColorUtils.labToHct(laba);\n\n    // 4. Use HCT to find", "first_line_groundtruth": "Cam16.fromInt(toInt());", "first_line_prediction": " Cam16.fromInt(argb);", "match": 0}
{"groundtruth": "recastInVc.getHue(), recastInVc.getChroma(), ColorUtils.lstarFromY(viewedInVc[1]));", "prediction": " recastInVc.hue(),\n         recastInVc.chroma(),\n         ColorUtils.yToLStar(viewedInVc[1]));\n  }\n\n  private void setInternalState(int argb) {\n    this.argb = argb;\n    hue = HctSolver.hueFromInt(argb);\n    chroma = HctSolver.chromaFromInt(argb);\n    tone = HctSolver.toneFromInt(argb);\n  }", "first_line_groundtruth": "recastInVc.getHue(), recastInVc.getChroma(), ColorUtils.lstarFromY(viewedInVc[1]));", "first_line_prediction": " recastInVc.hue(),", "match": 0}
{"groundtruth": "= MathUtils.sanitizeDegreesDouble(\n          startHue + directionOfRotation * hueAddend);", "prediction": " = startHue + hueAddend;\n      double temp = getTempsByHct().get(getHctsByHue().get((int) Math.round(hue)));\n      double error = Math.abs(temp - complementRelativeTemp);\n      if (error < smallestError) {\n        smallestError = error;\n        answer = getHctsByHue().get((int) Math.round(hue));\n      }\n    }\n\n    precomputedComplement = answer;\n    return answer;\n  }\n\n  /**\n    * A color that is the analogous color of the input color.\n    *\n    * <p>In art", "first_line_groundtruth": "= MathUtils.sanitizeDegreesDouble(", "first_line_prediction": " = startHue + hueAddend;", "match": 0}
{"groundtruth": "fromCam = Cam16.fromInt(from);", "prediction": "icsCam = Cam16.fromInt(to);\n    double fromHue = ucsCam.getHue();\n    double toHue = icsCam.getHue();\n    double differenceDegrees = MathUtils.differenceDegrees(fromHue, toHue);\n    double rotationDegrees = Math.min(differenceDegrees * 0.5, 15.0);\n    double outputHue =\n        MathUtils.sanitizeDegreesDouble(\n            fromHue\n                + rotationDegrees * MathUtils.rotationDirection(fromHue, toHue));\n    return Cam16.from(outputHue, ucsCam.getChroma(),", "first_line_groundtruth": "fromCam = Cam16.fromInt(from);", "first_line_prediction": "icsCam = Cam16.fromInt(to);", "match": 0}
{"groundtruth": "= Cam16.fromInt(ucs);", "prediction": " = Cam16.fromInt(ucs);\n    return ucsCam.toInt();\n  }\n\n  /**\n    * Blends chroma from one color into another. The hue and tone of the original color are\n    * maintained.\n    *\n    * @param from ARGB representation of color\n    * @param to ARGB representation of color\n    * @param amount how much blending to perform; 0.0 >= and <= 1.0\n    * @return from, with a chroma blended towards to. Hue and tone are constant.\n    */\n  public static int hctChroma(int from", "first_line_groundtruth": "= Cam16.fromInt(ucs);", "first_line_prediction": " = Cam16.fromInt(ucs);", "match": 0}
{"groundtruth": ".toRadians(MathUtils.sanitizeDegreesDouble(hue - 50.)));", "prediction": ".toRadians(hue))\n             * Math.cos(Math.toRadians(hue));\n  }\n\n  /**\n    * Returns the temperature of the warmest color in the color wheel.\n    */\n  public Hct getWarmest() {\n    return getHctsByHue().get(0);\n  }\n\n  /**\n    * Returns the temperature of the coldest color in the color wheel.\n    */\n  public Hct getColdest() {\n    return getHctsByHue().get(360);\n  }\n\n  /**\n    * Returns the temperature of the color with the given hue.\n    */\n  public", "first_line_groundtruth": ".toRadians(MathUtils.sanitizeDegreesDouble(hue - 50.)));", "first_line_prediction": ".toRadians(hue))", "match": 0}
{"groundtruth": "tone = ColorUtils.lstarFromArgb(argb);", "prediction": "tone = cam.getTone();\n  }", "first_line_groundtruth": "tone = ColorUtils.lstarFromArgb(argb);", "first_line_prediction": "tone = cam.getTone();", "match": 0}
{"groundtruth": "hue = MathUtils.sanitizeDegreesDouble(Math.toDegrees(Math.atan2(lab[2], lab[1])));", "prediction": " l = lab[0];\n    double a = lab[1];\n    double b = lab[2];\n    double c = Math.sqrt(a * a + b * b);\n    double h = Math.atan2(b, a);\n    double hPrime = h / (2 * Math.PI);\n    double hPrimeSquared = hPrime * hPrime;\n    double hPrimeCubed = hPrimeSquared * hPrime;\n    double hPrimeCubedSquared = hPrimeCubed * hPrimeCubed;\n    double hPrimeCubedSquaredPlusOne = hPrimeCubedSquared + 1;", "first_line_groundtruth": "hue = MathUtils.sanitizeDegreesDouble(Math.toDegrees(Math.atan2(lab[2], lab[1])));", "first_line_prediction": " l = lab[0];", "match": 0}
{"groundtruth": "fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "prediction": "0.0, 0.0);\n    return blended.toInt();\n  }", "first_line_groundtruth": "fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "first_line_prediction": "0.0, 0.0);", "match": 0}
{"groundtruth": "ucsCam.getHue(), fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "prediction": "ucsCam.getHue(), fromCam.getChroma(), fromCam.getTone());\n    return blended.toInt();\n  }", "first_line_groundtruth": "ucsCam.getHue(), fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "first_line_prediction": "ucsCam.getHue(), fromCam.getChroma(), fromCam.getTone());", "match": 0}
{"groundtruth": "HctSolver.solveToInt(hue, chroma, tone);", "prediction": "0;\n    if (hue < 0) {\n      hue += 360;\n    }\n    if (hue > 360) {\n      hue -= 360;\n    }\n    if (chroma < 0) {\n      chroma = 0;\n    }\n    if (chroma > 130) {\n      chroma = 130;\n    }\n    if (tone < 0) {\n      tone = 0;\n    }\n    if (tone > 100) {\n      tone = 100;\n    }\n    if (hue == ", "first_line_groundtruth": "HctSolver.solveToInt(hue, chroma, tone);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "toCam.getAstar();", "prediction": "0.0;\n    double toB = 0.0;\n    double fromJPrime = fromJ + (toJ - fromJ) * amount;\n    double fromAPrime = fromA + (toA - fromA) * amount;\n    double fromBPrime = fromB + (toB - fromB) * amount;\n    double toJPrime = toJ + (fromJ - toJ) * amount;\n    double toAPrime = toA + (fromA - toA) * amount;\n    double toBPrime = toB + (fromB - toB) * amount;", "first_line_groundtruth": "toCam.getAstar();", "first_line_prediction": "0.0;", "match": 0}
{"groundtruth": "hue = cam.getHue();", "prediction": " hue = cam.getHue();\n     chroma = cam.getChroma();\n     tone = ColorUtils.toneFromLstar(cam.getLstar());\n  }", "first_line_groundtruth": "hue = cam.getHue();", "first_line_prediction": " hue = cam.getHue();", "match": 0}
{"groundtruth": "fromCam.getBstar();", "prediction": "0.0;\n    double toJ = toCam.getJstar();\n    double toA = toCam.getAstar();\n    double toB = 0.0;\n    double fromJPrime = fromJ + (toJ - fromJ) * amount;\n    double fromAPrime = fromA + (toA - fromA) * amount;\n    double fromBPrime = fromB + (toB - fromB) * amount;\n    double toJPrime = toJ + (fromJ - toJ) * amount;\n    double toAPrime = toA + (fromA - to", "first_line_groundtruth": "fromCam.getBstar();", "first_line_prediction": "0.0;", "match": 0}
{"groundtruth": "return Cam16.fromUcs(jstar, astar, bstar).toInt();", "prediction": " return Cam16.from(fromCam.getHue(), fromCam.getChroma(), fromCam.getTone(), jstar, astar, bstar).toInt();\n  }", "first_line_groundtruth": "return Cam16.fromUcs(jstar, astar, bstar).toInt();", "first_line_prediction": " return Cam16.from(fromCam.getHue(), fromCam.getChroma(), fromCam.getTone(), jstar, astar, bstar).toInt();", "match": 0}
{"groundtruth": "double fromJ = fromCam.getJstar();", "prediction": " double fromHue = fromCam.getHue();\n    double toHue = toCam.getHue();\n    double fromChroma = fromCam.getChroma();\n    double toChroma = toCam.getChroma();\n    double fromLstar = ColorUtils.lstarFromArgb(from);\n    double toLstar = ColorUtils.lstarFromArgb(to);\n    double fromUcs = fromLstar * fromChroma;\n    double toUcs = toLstar * toChroma;\n    double fromUcsDelta = toUcs - fromUcs;\n    double fromUcsDeltaDegrees =", "first_line_groundtruth": "double fromJ = fromCam.getJstar();", "first_line_prediction": " double fromHue = fromCam.getHue();", "match": 0}
{"groundtruth": "toB = toCam.getBstar();", "prediction": " toB = toCam.getBstar();\n    double fromJPrime = fromJ + (toJ - fromJ) * amount;\n    double fromAPrime = fromA + (toA - fromA) * amount;\n    double fromBPrime = fromB + (toB - fromB) * amount;\n    double toJPrime = toJ + (fromJ - toJ) * amount;\n    double toAPrime = toA + (fromA - toA) * amount;\n    double toBPrime = toB + (fromB - toB) * amount;\n    Cam16 b", "first_line_groundtruth": "toB = toCam.getBstar();", "first_line_prediction": " toB = toCam.getBstar();", "match": 0}
{"groundtruth": "Hct.fromInt(designColor);", "prediction": " Hct.fromInt(designColor);\n    Hct toHct = Hct.fromInt(sourceColor);\n    double hue = fromHct.getHue();\n    double chroma = fromHct.getChroma();\n    double tone = fromHct.getTone();\n    double toHue = toHct.getHue();\n    double toChroma = toHct.getChroma();\n    double toTone = toHct.getTone();\n    double deltaHue = toHue - hue;\n    double deltaChroma = toChroma - chroma;\n    double deltaTone = toTone", "first_line_groundtruth": "Hct.fromInt(designColor);", "first_line_prediction": " Hct.fromInt(designColor);", "match": 0}
{"groundtruth": "differenceDegrees = MathUtils.differenceDegrees(fromHct.getHue(), toHct.getHue());", "prediction": " fromHue = fromHct.getHue();\n    double  toHue = toHct.getHue();\n    double  deltaHue = toHue - fromHue;\n    double  deltaHueNormalized = deltaHue / 360.0;\n    double  deltaHueNormalizedClamped = MathUtils.clamp(deltaHueNormalized, -1.0, 1.0);\n    double  deltaHueNormalizedClampedSquared = deltaHueNormalizedClamped * deltaHueNormalizedClamped;\n    double  deltaHueNormalizedClampedCubed = deltaHueNormalizedClampedSquared * deltaHueNormalizedClamped;\n    double", "first_line_groundtruth": "differenceDegrees = MathUtils.differenceDegrees(fromHct.getHue(), toHct.getHue());", "first_line_prediction": " fromHue = fromHct.getHue();", "match": 0}
{"groundtruth": "(), fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "prediction": "(), fromCam.getChroma(), fromCam.getTone());\n    return blended.toInt();\n  }", "first_line_groundtruth": "(), fromCam.getChroma(), ColorUtils.lstarFromArgb(from));", "first_line_prediction": "(), fromCam.getChroma(), fromCam.getTone());", "match": 0}
{"groundtruth": "* viewingConditions.getNbb();", "prediction": " / (1.0 + u);\n\n    // chroma\n    double c = Math.sqrt(ac * ac + 1.0);\n\n    // lightness\n    double j = 0.5 * (1.0 + ac);\n\n    // brightness\n    double q = 0.5 * (1.0 - ac);\n\n    // colorfulness\n    double m = 0.5 * (1.0 + 0.5 * (ac - 1.0));\n\n    // saturation\n    double s = 0.5 * (1.0 + 0.5 * (ac + 1", "first_line_groundtruth": "* viewingConditions.getNbb();", "first_line_prediction": " / (1.0 + u);", "match": 0}
{"groundtruth": "= MathUtils.differenceDegrees(fromHct.getHue(), toHct.getHue());", "prediction": " = toHct.getHue() - fromHct.getHue();\n    double differenceDegreesAbs = Math.abs(differenceDegrees);\n    double differenceDegreesSign = Math.signum(differenceDegrees);\n    double differenceDegreesClamped =\n        MathUtils.clamp(differenceDegreesAbs, -180, 180);\n    double differenceDegreesClampedNormalized =\n        differenceDegreesClamped / 180;\n    double differenceDegreesClampedNormalizedSquared =\n        differenceDegreesClampedNormalized * differenceDegreesClampedNormalized;\n    double differenceDegreesClampedNormalizedCubed =\n        differenceDegreesClampedNormalizedSquared", "first_line_groundtruth": "= MathUtils.differenceDegrees(fromHct.getHue(), toHct.getHue());", "first_line_prediction": " = toHct.getHue() - fromHct.getHue();", "match": 0}
{"groundtruth": "fromHct.getHue()\n                + rotationDegrees * MathUtils.rotationDirection(fromHct.getHue(), toHct.getHue()));", "prediction": "180.0 - (fromHct.getHue() + rotationDegrees), 12.0);\n    return Hct.fromHueAndChroma(outputHue, fromHct.getChroma()).toInt();\n  }\n\n  /**\n    * Blend the design color's HCT hue towards the key color's HCT hue, in a way that leaves the\n    * original color recognizable and recognizably shifted towards the key color.\n    *\n    * @param designColor ARGB representation of an arbitrary color.\n    * @param sourceColor ARGB representation of the main theme color.\n    * @return", "first_line_groundtruth": "fromHct.getHue()", "first_line_prediction": "180.0 - (fromHct.getHue() + rotationDegrees), 12.0);", "match": 0}
{"groundtruth": "viewingConditions.getAw() + 4.0)\n            * viewingConditions.getFlRoot();", "prediction": "1.0 + viewingConditions.getAw() / viewingConditions.getC());\n\n    // CAM16 chroma\n    double m =\n        viewingConditions.getC()\n             * viewingConditions.getZ()\n             * Math.pow(\n                viewingConditions.getAw() / viewingConditions.getC(),\n                viewingConditions.getC() * viewingConditions.getZ());\n    double s =\n        viewingConditions.getC()\n             * viewingConditions.getZ()\n             * Math.pow(\n                viewingConditions.getAw() / viewingConditions.getC(),\n                viewingConditions.getC() * viewingConditions.getZ());\n\n    // CAM16 J coordinate\n    double", "first_line_groundtruth": "viewingConditions.getAw() + 4.0)", "first_line_prediction": "1.0 + viewingConditions.getAw() / viewingConditions.getC());", "match": 0}
{"groundtruth": "ColorUtils.argbFromXyz(xyz[0], xyz[1], xyz[2]);", "prediction": "0xff000000 | (int) (255.999 * xyz[0]) << 16 | (int) (255.999 * xyz[1]) << 8 | (int) (255.999 * xyz[2]);\n  }\n\n  /**\n    * @return ARGB representation of the color, in defined viewing conditions.\n    * @param viewingConditions Information about the environment where the color will be viewed.\n    * @param out Array to write the color to.\n    */\n  double[] xyzInViewingConditions(Viewing", "first_line_groundtruth": "ColorUtils.argbFromXyz(xyz[0], xyz[1], xyz[2]);", "first_line_prediction": "0xff000000 | (int) (255.999 * xyz[0]) << 16 | (int) (255.999 * xyz[1]) << 8 | (int) (255.999 * xyz[2]);", "match": 0}
{"groundtruth": "viewingConditions.getC() * viewingConditions.getZ());", "prediction": "1.0 / viewingConditions.getA());\n    double q =\n        viewingConditions.getAw() * viewingConditions.getAw() * viewingConditions.getAw() * j;\n\n    // CAM16 chroma\n    double m =\n        viewingConditions.getAw() * viewingConditions.getAw() * viewingConditions.getAw() * j;\n    double s =\n        viewingConditions.getAw() * viewingConditions.getAw() * viewingConditions.getAw() * j;\n\n    // CAM16 J, a, and b\n    double jstar =\n        viewingConditions.getAw() * viewingConditions.", "first_line_groundtruth": "viewingConditions.getC() * viewingConditions.getZ());", "first_line_prediction": "1.0 / viewingConditions.getA());", "match": 0}
{"groundtruth": "outputHue, fromHct.getChroma(), fromHct.getTone()).toInt();", "prediction": "outputHue, fromHct.getChroma(), fromHct.getLuma()).toInt();\n  }\n\n  /**\n    * Blend the design color's HCT hue towards the key color's HCT hue, in a way that leaves the\n    * original color recognizable and recognizably shifted towards the key color.\n    *\n    * @param designColor ARGB representation of an arbitrary color.\n    * @param sourceColor ARGB representation of the main theme color.\n    * @return The design color with a hue shifted towards the system's color, a slightly\n    *     warmer/cooler variant of the design", "first_line_groundtruth": "outputHue, fromHct.getChroma(), fromHct.getTone()).toInt();", "first_line_prediction": "outputHue, fromHct.getChroma(), fromHct.getLuma()).toInt();", "match": 0}
{"groundtruth": "from(outputHue, fromHct.getChroma(), fromHct.getTone()).toInt();", "prediction": "fromHueAndChroma(outputHue, fromHct.getChroma()).toInt();\n  }\n\n  /**\n    * Blend the design color's HCT hue towards the key color's HCT hue, in a way that leaves the\n    * original color recognizable and recognizably shifted towards the key color.\n    *\n    * @param designColor ARGB representation of an arbitrary color.\n    * @param sourceColor ARGB representation of the main theme color.\n    * @return The design color with a hue shifted towards the system's color, a slightly\n    *     warmer/cooler variant of the design color's", "first_line_groundtruth": "from(outputHue, fromHct.getChroma(), fromHct.getTone()).toInt();", "first_line_prediction": "fromHueAndChroma(outputHue, fromHct.getChroma()).toInt();", "match": 0}
{"groundtruth": "viewingConditions.getRgbD()[0] * rT;", "prediction": "0.950456 * rT + 1.000000 * gT + 1.088835 * bT;\n    double gD = 0.105731 * rT + 0.105731 * gT + 0.894269 * bT;\n    double bD = 0.100417 * rT + 0.089933 * gT + 0.108737 * bT;\n\n    //", "first_line_groundtruth": "viewingConditions.getRgbD()[0] * rT;", "first_line_prediction": "0.950456 * rT + 1.000000 * gT + 1.088835 * bT;", "match": 0}
{"groundtruth": "Math.pow(viewingConditions.getFl() * Math.abs(bD) / 100.0, 0.42);", "prediction": "1.0 - rAF - gAF;\n\n    // Convert to CAM16\n    double[] xyz = new double[] {rAF, gAF, bAF};\n    double[] cam16 = XYZ_TO_CAM16.apply(xyz);\n\n    // Convert to CAM16-UCS\n    double[] cam16Ucs = CAM16_TO_CAM16UCS.apply(cam16);\n\n    // Convert to CAM16-UCS\n    double[] cam16Ucs2 = CAM16_TO_CAM16UCS.apply(cam1", "first_line_groundtruth": "Math.pow(viewingConditions.getFl() * Math.abs(bD) / 100.0, 0.42);", "first_line_prediction": "1.0 - rAF - gAF;", "match": 0}
{"groundtruth": "* viewingConditions.getZ());", "prediction": " // 1.0 / 2.2\n            );\n    double q =\n        viewingConditions.getAw() * viewingConditions.getAw() * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewingConditions.getAw()\n            * viewing", "first_line_groundtruth": "* viewingConditions.getZ());", "first_line_prediction": " // 1.0 / 2.2", "match": 0}
{"groundtruth": "double blueL = ColorUtils.linearized(blue);", "prediction": " double blueL = ColorUtils.linearized(blue);\n    double[] xyz = CAM16RGB_TO_XYZ[0][0] * redL + CAM16RGB_TO_XYZ[0][1] * greenL + CAM16RGB_TO_XYZ[0][2] * blueL;\n    double[] xyz2 = CAM16RGB_TO_XYZ[1][0] * redL + CAM16RGB_TO_XYZ[1][1] * greenL + CAM16RGB_TO_XYZ[1][2] * blueL;\n    double[]", "first_line_groundtruth": "double blueL = ColorUtils.linearized(blue);", "first_line_prediction": " double blueL = ColorUtils.linearized(blue);", "match": 0}
{"groundtruth": "eHue * viewingConditions.getNc() * viewingConditions.getNcb();", "prediction": "1.0 / viewingConditions.getC() * Math.pow(eHue, 0.25);\n    double m = 1.0 + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "first_line_groundtruth": "eHue * viewingConditions.getNc() * viewingConditions.getNcb();", "first_line_prediction": "1.0 / viewingConditions.getC() * Math.pow(eHue, 0.25);", "match": 0}
{"groundtruth": "* viewingConditions.getFlRoot();", "prediction": " * viewingConditions.getZ();\n\n    // CAM16 colorfulness\n    double m =\n        viewingConditions.getC()\n             * viewingConditions.getZ()\n             * Math.pow(\n                 viewingConditions.getAw() / viewingConditions.getAw0(),\n                 viewingConditions.getC() * viewingConditions.getZ());\n    double s =\n        viewingConditions.getC()\n             * viewingConditions.getZ()\n             * Math.pow(\n                 viewingConditions.getAw() / viewingConditions.getAw0(),\n                 viewingConditions.getC() * viewingConditions.getZ());\n\n    // CAM16 J, a, and b\n    double j", "first_line_groundtruth": "* viewingConditions.getFlRoot();", "first_line_prediction": " * viewingConditions.getZ();", "match": 0}
{"groundtruth": "rAF = Math.pow(viewingConditions.getFl() * Math.abs(rD) / 100.0, 0.42);", "prediction": "rix = rD * viewingConditions.getRgbX()[0] + gD * viewingConditions.getRgbX()[1] + bD * viewingConditions.getRgbX()[2];\n    double gix = rD * viewingConditions.getRgbX()[3] + gD * viewingConditions.getRgbX()[4] + bD * viewingConditions.getRgbX()[5];\n    double bix = rD * viewingConditions.getRgbX()[6] + gD * viewingConditions.getRgbX()[7] + bD * viewingConditions.getRgbX()[8];\n\n    //", "first_line_groundtruth": "rAF = Math.pow(viewingConditions.getFl() * Math.abs(rD) / 100.0, 0.42);", "first_line_prediction": "rix = rD * viewingConditions.getRgbX()[0] + gD * viewingConditions.getRgbX()[1] + bD * viewingConditions.getRgbX()[2];", "match": 0}
{"groundtruth": "* Math.sqrt((alpha * viewingConditions.getC()) / (viewingConditions.getAw() + 4.0));", "prediction": " // 50% saturation\n            * Math.pow(\n                viewingConditions.getAw() / viewingConditions.getAwMax(),\n                viewingConditions.getC() * viewingConditions.getZ());\n\n    // CAM16 color\n    double r = (rA + 100.0 * q) / 100.0;\n    double g = (gA + 100.0 * q) / 100.0;\n    double b = (bA + 100.0 * q) / 100.0;\n\n    // CAM16 color\n   ", "first_line_groundtruth": "* Math.sqrt((alpha * viewingConditions.getC()) / (viewingConditions.getAw() + 4.0));", "first_line_prediction": " // 50% saturation", "match": 0}
{"groundtruth": "double redL = ColorUtils.linearized(red);", "prediction": " // Convert to XYZ\n    double[] xyz = new double[3];\n    xyz[0] = (red * 0.4124564 + green * 0.3575761 + blue * 0.1804375) / 0.95047;\n    xyz[1] = (red * 0.2126729 + green * 0.7151522 + blue * 0.0721750) / 1.00000;\n   ", "first_line_groundtruth": "double redL = ColorUtils.linearized(red);", "first_line_prediction": " // Convert to XYZ", "match": 0}
{"groundtruth": "m = c * viewingConditions.getFlRoot();", "prediction": "ql = 1.0 - q;\n    double qb = 1.0 - q;\n    double qc = 1.0 - q;\n    double qd = 1.0 - q;\n    double qe = 1.0 - q;\n    double qf = 1.0 - q;\n    double qg = 1.0 - q;\n    double qh = 1.0 - q;\n    double qi = 1.0 - q;\n    double qj = 1.0 - q;\n    double qk = 1.0 - q", "first_line_groundtruth": "m = c * viewingConditions.getFlRoot();", "first_line_prediction": "ql = 1.0 - q;", "match": 0}
{"groundtruth": "viewingConditions.getAw(),\n                viewingConditions.getC() * viewingConditions.getZ());", "prediction": "100.0,\n                viewingConditions.getJab()\n                    ? viewingConditions.getJabPower()\n                    : viewingConditions.getJabPower() + 1.0)\n            / viewingConditions.getJabPower();\n    double q =\n        viewingConditions.getJab()\n            ? viewingConditions.getJabPower() * viewingConditions.getJabPower()\n            : viewingConditions.getJabPower() + 1.0;\n\n    // CAM16 chroma\n    double m =\n        viewingConditions.getJab()\n            ? viewingConditions.getJabPower() * viewing", "first_line_groundtruth": "viewingConditions.getAw(),", "first_line_prediction": "100.0,", "match": 0}
{"groundtruth": "pow(0.29, viewingConditions.getN()), 0.73) * Math.pow(t, 0.9);", "prediction": "pow(t, 0.25), 0.42)\n            * viewingConditions.getFl()\n            * viewingConditions.getFl()\n            * viewingConditions.getFl();\n    double jstar = 100.0 * Math.pow(alpha / viewingConditions.getAw(), 0.42);\n    double astar = 100.0 * Math.pow(alpha / viewingConditions.getAw(), 0.42);\n    double bstar = 100.0 * Math.pow(alpha / viewingConditions.getAw(), 0.4", "first_line_groundtruth": "pow(0.29, viewingConditions.getN()), 0.73) * Math.pow(t, 0.9);", "first_line_prediction": "pow(t, 0.25), 0.42)", "match": 0}
{"groundtruth": "alpha * viewingConditions.getC()) / (viewingConditions.getAw() + 4.0));", "prediction": "1.0 - Math.pow(m, 2.0)) / (1.0 + Math.pow(m, 2.0))) * viewingConditions.getFlRoot();\n\n    // CAM16 color\n    double r = (rA + rAF) / 2.0;\n    double g = (gA + gAF) / 2.0;\n    double b = (bA + bAF) / 2.0;\n\n    // CAM16 color\n    double[] rgb = {r, g, b};\n\n    // CAM16 color\n    return new Cam16(", "first_line_groundtruth": "alpha * viewingConditions.getC()) / (viewingConditions.getAw() + 4.0));", "first_line_prediction": "1.0 - Math.pow(m, 2.0)) / (1.0 + Math.pow(m, 2.0))) * viewingConditions.getFlRoot();", "match": 0}
{"groundtruth": "viewingConditions.getFlRoot();", "prediction": "0.0228;\n    double m = c * 0.0228;\n    double s =\n        50.0 * Math.sqrt((c * viewingConditions.getC()) / (viewingConditions.getAw() + 4.0));\n    double jstar = (1.0 + 100.0 * 0.007) * j / (1.0 + 0.007 * j);\n    double astar = m * Math.cos(Math.toRadians(h));\n    double bstar = m * Math.sin(Math", "first_line_groundtruth": "viewingConditions.getFlRoot();", "first_line_prediction": "0.0228;", "match": 0}
{"groundtruth": "Math.pow(getJ() / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());", "prediction": "0.007\n             * Math.pow(t, 0.9)\n             * Math.pow(1.0 + 0.007 * getJ(), 0.9);\n    double a = ac * Math.cos(eHue);\n    double b = ac * Math.sin(eHue);\n\n    double[] xyz =\n        ColorUtils.xyzFromLch(\n            getJ(), getChroma(), getHue(), viewingConditions, returnArray);\n    xyz[0] = xyz[0] * a + xyz[1] * b + xyz[2];\n    return xyz;", "first_line_groundtruth": "Math.pow(getJ() / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());", "first_line_prediction": "0.007", "match": 0}
{"groundtruth": ") / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());", "prediction": "viewingConditions) / 100.0, viewingConditions.getN())\n             * Math.pow(t, 0.9);\n    double a = ac * Math.cos(eHue);\n    double b = ac * Math.sin(eHue);\n\n    double[] xyz =\n        ColorUtils.xyzFromLch(\n            getJ(viewingConditions), getChroma(), getHue(), viewingConditions, returnArray);\n    xyz[0] = xyz[0] * a + xyz[1] * b + xyz[2];\n    return xyz;\n  }\n\n  /**\n    * @return AR", "first_line_groundtruth": ") / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());", "first_line_prediction": "viewingConditions) / 100.0, viewingConditions.getN())", "match": 0}
{"groundtruth": "(100.0 / viewingConditions.getFl()) * Math.pow(gCBase, 1.0 / 0.42);", "prediction": "100.0 * Math.pow(gCBase, 1.0 / 0.42);\n    double bCBase = max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));\n    double bC =\n        Math.signum(bA) * 100.0 * Math.pow(bCBase, 1.0 / 0.42);\n\n    double r = rC * rA;\n    double g = gC * gA;\n    double b", "first_line_groundtruth": "(100.0 / viewingConditions.getFl()) * Math.pow(gCBase, 1.0 / 0.42);", "first_line_prediction": "100.0 * Math.pow(gCBase, 1.0 / 0.42);", "match": 0}
{"groundtruth": "double c = m2 / viewingConditions.getFlRoot();", "prediction": " // CAM16-UCS components\n    double j = (1.0 + 100.0 * 0.007) * jstar / (1.0 + 0.007 * jstar);\n    double q =\n        4.0\n             / viewingConditions.getC()\n             * Math.sqrt(j / 100.0)\n             * (viewingConditions.getAw() + 4.0)\n             * viewingConditions.getFlRoot();\n    double c = m2 * viewingConditions.getFlRoot();\n    double s =\n        50", "first_line_groundtruth": "double c = m2 / viewingConditions.getFlRoot();", "first_line_prediction": " // CAM16-UCS components", "match": 0}
{"groundtruth": "ac / viewingConditions.getNbb());", "prediction": "1.0 - eHue) * (50000.0 / 13.0) * viewingConditions.getNc() * viewingConditions.getNcb();\n    double p3 =\n        viewingConditions.getAw()\n            * Math.pow(getJ() / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());\n    double p4 =\n        viewingConditions.getAw()\n            * Math.pow(getJ() / 100.0, 1.0 / viewingConditions.getC() / viewingConditions.getZ());\n   ", "first_line_groundtruth": "ac / viewingConditions.getNbb());", "first_line_prediction": "1.0 - eHue) * (50000.0 / 13.0) * viewingConditions.getNc() * viewingConditions.getNcb();", "match": 0}
{"groundtruth": "return QuantizerWsmeans.quantize(pixels, wuClusters, maxColors);", "prediction": " // TODO: Implement the rest of the algorithm.\n    return null;\n  }", "first_line_groundtruth": "return QuantizerWsmeans.quantize(pixels, wuClusters, maxColors);", "first_line_prediction": " // TODO: Implement the rest of the algorithm.", "match": 0}
{"groundtruth": "/ viewingConditions.getRgbD()[0];", "prediction": " * (1.0 + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "first_line_groundtruth": "/ viewingConditions.getRgbD()[0];", "first_line_prediction": " * (1.0 + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "match": 0}
{"groundtruth": "- Math.pow(0.29, viewingConditions.getN()), 0.73), 1.0 / 0.9);", "prediction": " - Math.pow(0.29, viewingConditions.getN()), 0.73), 0.9)\n            * Math.pow(getJ() / 100.0, 0.9);\n    double u = 1.0 + 0.305 * t;\n    double a = getAstar() * u;\n    double b = getBstar() * u;\n    double x = a * viewingConditions.getC() / (u + 0.305);\n    double y = b * viewingConditions.getC() / (u + 0.", "first_line_groundtruth": "- Math.pow(0.29, viewingConditions.getN()), 0.73), 1.0 / 0.9);", "first_line_prediction": " - Math.pow(0.29, viewingConditions.getN()), 0.73), 0.9)", "match": 0}
{"groundtruth": "lab = ColorUtils.labFromArgb(argb);", "prediction": "ary = new double[3];\n    ary[0] = ColorUtils.lstarFromArgb(argb);\n    ary[1] = ColorUtils.aFromArgb(argb);\n    ary[2] = ColorUtils.bFromArgb(argb);\n    return ary;\n  }\n\n  /**\n   * Convert a 3-element array of L*a*b* coordinates to a color represented in ARGB.\n   */\n  @Override\n  public int toInt(double[] ary) {\n    return ColorUtils.argbFromLstar(ary[0], ary[", "first_line_groundtruth": "lab = ColorUtils.labFromArgb(argb);", "first_line_prediction": "ary = new double[3];", "match": 0}
{"groundtruth": "errorPalette = TonalPalette.fromHueAndChroma(25.0, 84.0);", "prediction": "errorPalette = TonalPalette.fromHueAndChroma(25, 84.);\n  }\n\n  public DynamicScheme(\n      int sourceColorArgb,\n      Variant variant,\n      boolean isDark,\n      double contrastLevel,\n      TonalPalette primaryPalette,\n      TonalPalette secondaryPalette,\n      TonalPalette tertiaryPalette,\n      TonalPalette neutralPalette,\n      TonalPalette neutralVariantPalette) {\n    this.sourceColorArgb = sourceColorArgb;\n    this.sourceColorHct = Hct.fromArgb(sourceColorArgb);\n    this.variant = variant;\n    this.isDark", "first_line_groundtruth": "errorPalette = TonalPalette.fromHueAndChroma(25.0, 84.0);", "first_line_prediction": "errorPalette = TonalPalette.fromHueAndChroma(25, 84.);", "match": 0}
{"groundtruth": "ColorUtils.whitePointD65(),\n        (200.0 / Math.PI * ColorUtils.yFromLstar(50.0) / 100.f),\n        lstar,\n        2.0,\n        false);", "prediction": "1.0, 11.72, lstar, 2.0, false);\n  }\n\n  /**\n    * Create sRGB-like viewing conditions with a custom background lstar.\n    *\n    * <p>Default viewing conditions have a lstar of 50, midgray.\n    */\n  public static ViewingConditions defaultWithBackgroundLstar() {\n    return ViewingConditions.defaultWithBackgroundLstar(50.0);\n  }\n\n  /**\n    * Create sRGB-like viewing conditions with a custom background lstar.\n    *\n    * <p>Default viewing conditions have a l", "first_line_groundtruth": "ColorUtils.whitePointD65(),", "first_line_prediction": "1.0, 11.72, lstar, 2.0, false);", "match": 0}
{"groundtruth": "MathUtils.sanitizeDegreesDouble(sourceHue + rotations[0]);", "prediction": "0.0;\n    }\n    double min = Double.MAX_VALUE;\n    double max = Double.MIN_VALUE;\n    for (int i = 0; i < hues.length; i++) {\n      double hue = hues[i];\n      double rotation = rotations[i];\n      double rotatedHue = MathUtils.sanitizeDegreesDouble(hue + rotation);\n      if (rotatedHue < min) {\n        min = rotatedHue;\n      }\n      if (rotatedHue > max) {\n        max = rotatedHue;\n      }\n    }\n    double difference = max - min;\n    double rotation", "first_line_groundtruth": "MathUtils.sanitizeDegreesDouble(sourceHue + rotations[0]);", "first_line_prediction": "0.0;", "match": 0}
{"groundtruth": "gC / viewingConditions.getRgbD()[1];", "prediction": "0.0;\n    double bF = 0.0;\n    if (rF > 0.0031308) {\n      rF = 1.055 * Math.pow(rF, 1.0 / 2.4) - 0.055;\n    }\n    if (gF > 0.0031308) {\n      gF = 1.055 * Math.pow(gF, 1.0 / 2.4) - 0.055;\n    }\n    if", "first_line_groundtruth": "gC / viewingConditions.getRgbD()[1];", "first_line_prediction": "0.0;", "match": 0}
{"groundtruth": "ColorUtils.argbFromLab(lab[0], lab[1], lab[2]);", "prediction": "0xff000000 | ColorUtils.argbFromLab(lab[0], lab[1], lab[2]);\n  }", "first_line_groundtruth": "ColorUtils.argbFromLab(lab[0], lab[1], lab[2]);", "first_line_prediction": "0xff000000 | ColorUtils.argbFromLab(lab[0], lab[1], lab[2]);", "match": 0}
{"groundtruth": "n = (ColorUtils.yFromLstar(backgroundLstar) / whitePoint[1]);", "prediction": "ql = 1.0 + (0.015 * k4F * k4F * k4F * k4F);\n    double flRoot = Math.sqrt(fl);\n    double n = 1.0 / (ql * ql * ql);\n    double nbb = 1.0 / (ql * ql);\n    double ncb = 1.0 / ql;\n    double z = 1.0 / (1.0 + (0.045 * k4F * k4F * k4F * k4F));\n    return new", "first_line_groundtruth": "n = (ColorUtils.yFromLstar(backgroundLstar) / whitePoint[1]);", "first_line_prediction": "ql = 1.0 + (0.015 * k4F * k4F * k4F * k4F);", "match": 0}
{"groundtruth": "100.0 / viewingConditions.getFl()) * Math.pow(rCBase, 1.0 / 0.42);", "prediction": "rCBase + 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "first_line_groundtruth": "100.0 / viewingConditions.getFl()) * Math.pow(rCBase, 1.0 / 0.42);", "first_line_prediction": "rCBase + 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "match": 0}
{"groundtruth": "d = MathUtils.clampDouble(0.0, 1.0, d);", "prediction": " // Calculate the viewing conditions\n    double aw = 1.0 / (1.0 + d);\n    double nbb = 1.0 / (1.0 + (c * d));\n    double ncb = 1.0 / (1.0 + (c * (1.0 - d)));\n    double nc = 1.0 / (1.0 + (c * (1.0 - d)));\n    double n = 1.0 / (1.0 + (c * (1.0 - d)));\n    double[] rgbD = new double[3];\n    rgbD", "first_line_groundtruth": "d = MathUtils.clampDouble(0.0, 1.0, d);", "first_line_prediction": " // Calculate the viewing conditions", "match": 0}
{"groundtruth": "sourceColorArgb = sourceColorHct.toInt();", "prediction": "sourceColorHct = sourceColorHct;\n    this.variant = variant;\n    this.isDark = isDark;\n    this.contrastLevel = contrastLevel;\n    this.primaryPalette = primaryPalette;\n    this.secondaryPalette = secondaryPalette;\n    this.tertiaryPalette = tertiaryPalette;\n    this.neutralPalette = neutralPalette;\n    this.neutralVariantPalette = neutralVariantPalette;\n    this.errorPalette = TonalPalette.fromHueAndChroma(sourceColorHct.getHue(), 0.0);\n    this.sourceColorArgb = sourceColorHct.", "first_line_groundtruth": "sourceColorArgb = sourceColorHct.toInt();", "first_line_prediction": "sourceColorHct = sourceColorHct;", "match": 0}
{"groundtruth": ": MathUtils.lerp(0.525, 0.59, ((f - 0.8) * 10.0));", "prediction": " : MathUtils.lerp(0.59, 0.31, ((f - 0.9) * 10.0));\n    double nc = 1.0 - c;\n    double n = 1.0 / Math.sqrt(rW * rW + gW * gW + bW * bW);\n    double[] rgbD = new double[3];\n    rgbD[0] = rW * n;\n    rgbD[1] = gW * n;\n    rgbD[2] = bW * n;\n    // Calculate the viewing conditions\n   ", "first_line_groundtruth": ": MathUtils.lerp(0.525, 0.59, ((f - 0.8) * 10.0));", "first_line_prediction": " : MathUtils.lerp(0.59, 0.31, ((f - 0.9) * 10.0));", "match": 0}
{"groundtruth": "final double sourceHue = sourceColorHct.getHue();", "prediction": " double sourceHue = sourceColorHct.getHue();\n     double sourceHueIndex = MathUtils.indexOf(hues, sourceHue);\n     double rotatedHue = hues[MathUtils.mod(sourceHueIndex + rotations[sourceHueIndex], hues.length)];\n     return rotatedHue;\n  }\n\n  /**\n   * Given a set of hues and set of hue rotations, locate which hues the source color's hue is\n   * between, apply the rotation at the same index as the first hue in the range, and return the\n   * rotated hue.\n   *\n   * @param sourceColorH", "first_line_groundtruth": "final double sourceHue = sourceColorHct.getHue();", "first_line_prediction": " double sourceHue = sourceColorHct.getHue();", "match": 0}
{"groundtruth": "MathUtils.lerp(this.low, this.normal, (contrastLevel - -1) / 1);", "prediction": "1.0 + (contrastLevel * (this.normal - 1.0));\n    } else if (contrastLevel < 0.5) {\n      return this.normal;\n    } else if (contrastLevel < 1.0) {\n      return 1.0 + (contrastLevel * (this.medium - this.normal));\n    } else {\n      return this.medium;\n    }\n  }\n\n  /**\n    * Returns the contrast ratio at a given contrast level.\n    *\n    * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0 is the", "first_line_groundtruth": "MathUtils.lerp(this.low, this.normal, (contrastLevel - -1) / 1);", "first_line_prediction": "1.0 + (contrastLevel * (this.normal - 1.0));", "match": 0}
{"groundtruth": "(CorePalette.of(argb));", "prediction": "(CorePalette.contentOf(argb));\n  }\n\n  /** Creates a light theme Scheme from a source color in HCT, i.e. a color in the HCT color space. */\n  public static Scheme light(double[] hct) {\n    return lightFromCorePalette(CorePalette.contentOf(hct));\n  }\n\n  /** Creates a light theme Scheme from a source color in HCT, i.e. a color in the HCT color space. */\n  public static Scheme light(Hct hct) {\n    return lightFromCorePalette(CorePalette.contentOf(hct));", "first_line_groundtruth": "(CorePalette.of(argb));", "first_line_prediction": "(CorePalette.contentOf(argb));", "match": 0}
{"groundtruth": "MathUtils.lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5);", "prediction": "1.0;\n    } else if (contrastLevel < 1.0) {\n      return MathUtils.lerp(this.normal, this.medium, (contrastLevel - 0.5) / 0.5);\n    } else {\n      return this.medium;\n    }\n  }", "first_line_groundtruth": "MathUtils.lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5);", "first_line_prediction": "1.0;", "match": 0}
{"groundtruth": "MathUtils.lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);", "prediction": "1.0;\n    } else {\n      return MathUtils.lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);\n    }\n  }", "first_line_groundtruth": "MathUtils.lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);", "first_line_prediction": "1.0;", "match": 0}
{"groundtruth": "lightFromCorePalette(CorePalette.contentOf(argb));", "prediction": " lightFromCorePalette(CorePalette.ofContent(argb));\n  }", "first_line_groundtruth": "lightFromCorePalette(CorePalette.contentOf(argb));", "first_line_prediction": " lightFromCorePalette(CorePalette.ofContent(argb));", "match": 0}
{"groundtruth": "ColorUtils.yFromLstar(50.0) / 100.f),\n        lstar,\n        2.0,\n        false);", "prediction": "100.0),\n        lstar,\n        2.0,\n        false);\n  }\n\n  /**\n    * Create sRGB-like viewing conditions with a custom background lstar.\n    *\n    * <p>Default viewing conditions have a lstar of 50, midgray.\n    */\n  public static ViewingConditions defaultWithBackgroundLstar() {\n    return ViewingConditions.defaultWithBackgroundLstar(50.0);\n  }\n\n  /**\n    * Create sRGB-like viewing conditions with a custom background lstar.\n    *\n    * <p>Default viewing conditions have a lstar of ", "first_line_groundtruth": "ColorUtils.yFromLstar(50.0) / 100.f),", "first_line_prediction": "100.0),", "match": 0}
{"groundtruth": "pointProvider.toInt(clusters[i]);", "prediction": "0;\n      while (argbToPopulation.containsKey(possibleNewCluster)) {\n        possibleNewCluster++;\n      }\n      argbToPopulation.put(possibleNewCluster, count);\n    }\n\n    Map<Integer, Integer> argbToColor = new LinkedHashMap<>();\n    for (int i = 0; i < clusterCount; i++) {\n      int count = pixelCountSums[i];\n      if (count == 0) {\n        continue;\n      }\n\n      int possibleNewCluster = 0;\n      while (argbToColor.containsKey(possibleNewCluster)) {\n        possibleNewCluster++;\n      }", "first_line_groundtruth": "pointProvider.toInt(clusters[i]);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "distance = pointProvider.distance(clusters[i], clusters[j]);", "prediction": "rix = 0;\n          double riy = 0;\n          double riz = 0;\n          double rwx = 0;\n          double rwy = 0;\n          double rwz = 0;\n          double rxx = 0;\n          double rxy = 0;\n          double rxz = 0;\n          double ryy = 0;\n          double ryz = 0;\n          double rzz = 0;\n          for (int k = 0; k < pointCount; k++) {\n            int clusterIndex = clusterIndices[k];\n            if (clusterIndex == i ||", "first_line_groundtruth": "distance = pointProvider.distance(clusters[i], clusters[j]);", "first_line_prediction": "rix = 0;", "match": 0}
{"groundtruth": "pointProvider.fromInt(inputPixel);", "prediction": " new double[] {pointProvider.getRed(inputPixel), pointProvider.getGreen(inputPixel), pointProvider.getBlue(inputPixel)};\n        pixels[pointCount] = inputPixel;\n        pixelToCount.put(inputPixel, 1);\n        pointCount++;\n      } else {\n        pixelToCount.put(inputPixel, pixelCount + 1);\n      }\n    }\n\n    int[] clusters = startingClusters;\n    if (clusters == null) {\n      clusters = new int[pointCount];\n      for (int i = 0; i < pointCount; i++) {\n        clusters[i", "first_line_groundtruth": "pointProvider.fromInt(inputPixel);", "first_line_prediction": " new double[] {pointProvider.getRed(inputPixel), pointProvider.getGreen(inputPixel), pointProvider.getBlue(inputPixel)};", "match": 0}
{"groundtruth": "(Contrast.ratioOfTones(49, bgTone) >= desiredRatio) {", "prediction": " (answer < 50) {\n          answer = 50;\n        } else {\n          answer = 60;\n        }\n      }\n\n      return answer;\n    }\n  }\n\n  /** Returns the contrast curve of the color. */\n  @NonNull\n  public ContrastCurve getContrastCurve() {\n    return contrastCurve;\n  }\n\n  /** Returns the background color of the color. */\n  @Nullable\n  public DynamicColor getBackground() {\n    return background;\n  }\n\n  /** Returns the name of the color. */\n  @NonNull\n  public String getName() {\n    return name;\n  }\n\n  /** Returns the palette of", "first_line_groundtruth": "(Contrast.ratioOfTones(49, bgTone) >= desiredRatio) {", "first_line_prediction": " (answer < 50) {", "match": 0}
{"groundtruth": "if (Contrast.ratioOfTones(upper, answer) >= desiredRatio\n            && Contrast.ratioOfTones(lower, answer) >= desiredRatio) {", "prediction": " // If the background is darker, use the lower tone.\n        if (scheme.isDark) {\n          answer = lower;\n        } else {\n          answer = upper;\n        }\n      }\n\n      return answer;\n    }\n  }\n\n  /** Returns the contrast curve for the given scheme. */\n  public ContrastCurve getContrastCurve(@NonNull DynamicScheme scheme) {\n    return contrastCurve.apply(scheme);\n  }\n\n  /** Returns the contrast curve for the given scheme. */\n  public ContrastCurve getContrastCurve() {\n    return contrastCurve;\n  }\n\n  /** Returns the background color for the given scheme. */\n ", "first_line_groundtruth": "if (Contrast.ratioOfTones(upper, answer) >= desiredRatio", "first_line_prediction": " // If the background is darker, use the lower tone.", "match": 0}
{"groundtruth": "= Contrast.lighter(upper, desiredRatio);", "prediction": " = Contrast.ratioOfTones(upper, desiredRatio);\n        double darkOption = Contrast.ratioOfTones(lower, desiredRatio);\n\n        if (lightOption >= 0 && darkOption >= 0) {\n          answer = MathUtils.clampDouble(0, 100, (lightOption + darkOption) / 2);\n        } else if (lightOption >= 0) {\n          answer = MathUtils.clampDouble(0, 100, lightOption);\n        } else if (darkOption >= 0) {\n          answer = MathUtils.clampDouble(0", "first_line_groundtruth": "= Contrast.lighter(upper, desiredRatio);", "first_line_prediction": " = Contrast.ratioOfTones(upper, desiredRatio);", "match": 0}
{"groundtruth": "().quantize(pixels, colorCount);", "prediction": "().quantize(pixels, colorCount);\n    int[] colors = mapResult.colorToCount.keySet().toArray(new Integer[0]);\n    int[] counts = mapResult.colorToCount.values().toArray(new Integer[0]);\n    int[] histogram = new int[TOTAL_SIZE];\n    for (int i = 0; i < colors.length; i++) {\n      int index = colors[i] >> INDEX_BITS;\n      int count = counts[i];\n      histogram[index * INDEX_COUNT * INDEX_COUNT + count]++;\n    }\n    int[] histogramCopy = new int[", "first_line_groundtruth": "().quantize(pixels, colorCount);", "first_line_prediction": "().quantize(pixels, colorCount);", "match": 1}
{"groundtruth": "pointProvider.distance(point, clusters[j]);", "prediction": "0;\n          for (int k = 0; k < 3; k++) {\n            distance += Math.pow(point[k] - previousCluster[k], 2);\n          }\n          distance = Math.sqrt(distance);\n          if (distance < minimumDistance) {\n            minimumDistance = distance;\n            newClusterIndex = j;\n          }\n        }\n\n        if (newClusterIndex == -1) {\n          continue;\n        }\n\n        int newClusterCount = counts[i];\n        int previousClusterCount = counts[previousClusterIndex];\n        counts[i] = previousClusterCount + newClusterCount;", "first_line_groundtruth": "pointProvider.distance(point, clusters[j]);", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "red = ColorUtils.redFromArgb(pixel);", "prediction": " r = ColorUtils.red(pixel);\n      int  g = ColorUtils.green(pixel);\n      int  b = ColorUtils.blue(pixel);\n      int index = getIndex(r, g, b);\n      weights[index] += count;\n      momentsR[index] += count * r;\n      momentsG[index] += count * g;\n      momentsB[index] += count * b;\n      moments[index] += count;\n    }\n  }\n\n  void createMoments() {\n    for (int i = 0; i < TOTAL_SIZE; i++)", "first_line_groundtruth": "red = ColorUtils.redFromArgb(pixel);", "first_line_prediction": " r = ColorUtils.red(pixel);", "match": 0}
{"groundtruth": "previousDistance = pointProvider.distance(point, previousCluster);", "prediction": " previousClusterDistance = pointProvider.distance(point, previousCluster);\n        int newClusterIndex = indexMatrix[previousClusterIndex][0];\n        double[] newCluster = clusters[newClusterIndex];\n        double newClusterDistance = pointProvider.distance(point, newCluster);\n        if (newClusterDistance < previousClusterDistance) {\n          clusterIndices[i] = newClusterIndex;\n          pointsMoved++;\n        }\n      }\n\n      if (pointsMoved == 0) {\n        break;\n      }\n    }\n\n    int[] colors = new int[pointCount];\n    for (int i = 0; i < point", "first_line_groundtruth": "previousDistance = pointProvider.distance(point, previousCluster);", "first_line_prediction": " previousClusterDistance = pointProvider.distance(point, previousCluster);", "match": 0}
{"groundtruth": ") -> palette, (s) -> hct.getTone());", "prediction": ") -> palette, (s) -> hct.chroma());\n  }\n\n  /**\n    * Create a DynamicColor from a hex code.\n    *\n    * <p>Result has no background; thus no support for increasing/decreasing contrast for a11y.\n    *\n    * @param name The name of the dynamic color.\n    * @param argb The source color from which to extract the hue and chroma.\n    * @param isBackground Whether this dynamic color is a background, with some other color as the\n    *     foreground.\n    */\n  @NonNull\n  public static DynamicColor fromArgb(\n     ", "first_line_groundtruth": ") -> palette, (s) -> hct.getTone());", "first_line_prediction": ") -> palette, (s) -> hct.chroma());", "match": 0}
{"groundtruth": "WebhookVerifier(WebhookSigner.hmacSha1(secret), Encoder.HEX);", "prediction": " WebhookVerifier(WebhookSigner.hmacSha1(secret), BASE64);", "first_line_groundtruth": "WebhookVerifier(WebhookSigner.hmacSha1(secret), Encoder.HEX);", "first_line_prediction": " WebhookVerifier(WebhookSigner.hmacSha1(secret), BASE64);", "match": 0}
{"groundtruth": "return MathUtils.signum(component) * 400.0 * af / (af + 27.13);", "prediction": " return (af <= 0.008856) ? (component / 903.3) : (Math.pow(af, 1.0 / 3.0) * 116.0 - 16.0);\n  }\n\n  static double trueLinearized(double component) {\n    double linearized = 0.0;\n    if (component <= 0.04045) {\n      linearized = component / 12.92;\n    } else {\n      linearized = Math.pow((component + 0.055", "first_line_groundtruth": "return MathUtils.signum(component) * 400.0 * af / (af + 27.13);", "first_line_prediction": " return (af <= 0.008856) ? (component / 903.3) : (Math.pow(af, 1.0 / 3.0) * 116.0 - 16.0);", "match": 0}
{"groundtruth": "Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast\n              ? fInitialTone\n              : DynamicColor.foregroundTone(bgTone, fContrast);", "prediction": " Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast\n               ? fInitialTone\n               : DynamicColor.foregroundTone(bgTone, fContrast);\n\n      // 2nd round: solve to max, each\n      double nMaxContrast = nearer.contrastCurve.getContrast(scheme.contrastLevel);\n      double fMaxContrast = farther.contrastCurve.getContrast(scheme.contrastLevel);\n      double nMaxTone = nearer.tone.apply(scheme);\n      double fMaxTone = farther.tone.apply(scheme);\n      double nMinContrast = farther.", "first_line_groundtruth": "Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast", "first_line_prediction": " Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast", "match": 0}
{"groundtruth": "ResponseUtil.errorNotFound();", "prediction": " new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED);\n        }\n    }\n\n    @GetMapping(value = \"/{transactionId}\")\n    public ResponseEntity<Map<String,Object>> getTransactionById(@RequestHeader(\"Authorization\") String authHeader,\n                                                                 @PathVariable(\"transactionId\") String transactionId) {\n\n        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Get transaction by id\n            Transaction transaction = transactionService.getTransactionById(decodedToken.get", "first_line_groundtruth": "ResponseUtil.errorNotFound();", "first_line_prediction": " new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED);", "match": 0}
{"groundtruth": "Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast\n              ? nInitialTone\n              : DynamicColor.foregroundTone(bgTone, nContrast);", "prediction": "0.5 * (nInitialTone + (nContrast - nInitialTone) * (1 - delta) * expansionDir);\n      // Initial and adjusted tones for `farther`\n      double fInitialTone = farther.tone.apply(scheme);\n      @Var\n      double fTone =\n          0.5 * (fInitialTone + (fContrast - fInitialTone) * (1 + delta) * expansionDir);\n\n      // 2nd round: solve to max, each\n      double nContrast2 = nearer.contrastCurve.getContrast(scheme.contrastLevel);\n      double fContrast2 =", "first_line_groundtruth": "Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast", "first_line_prediction": "0.5 * (nInitialTone + (nContrast - nInitialTone) * (1 - delta) * expansionDir);", "match": 0}
{"groundtruth": "ResponseUtil.handleDashboardInfo(dashboardInfo);", "prediction": " ResponseUtil.successGet(dashboardInfo);\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorNotFound();\n        }\n    }", "first_line_groundtruth": "ResponseUtil.handleDashboardInfo(dashboardInfo);", "first_line_prediction": " ResponseUtil.successGet(dashboardInfo);", "match": 0}
{"groundtruth": "if(TransactionUtil.isValidYear(creationYear)){", "prediction": " if(TransactionUtil.isValidYear(creationYear)){\n            query = query.whereEqualTo(\"creationYear\",Integer.parseInt(creationYear));\n        }\n        else {\n            throw new NullPointerException(\"A valid date/month/year must be passed\");\n        }\n\n        //? Get the total amount spent by the user\n        AtomicDouble totalAmountSpent = new AtomicDouble(0.0);\n        List<Transaction> transactions = query.get().get().getDocuments().stream()\n                .map(doc -> doc.toObject(Transaction.class))\n                .collect(Collectors.toList());\n        for(Transaction transaction : transactions){\n           ", "first_line_groundtruth": "if(TransactionUtil.isValidYear(creationYear)){", "first_line_prediction": " if(TransactionUtil.isValidYear(creationYear)){", "match": 0}
{"groundtruth": "ColorUtils.blueFromArgb(pixel);", "prediction": " ColorUtils.blueFromArgb(pixel);\n      int index = getIndex(red, green, blue);\n      weights[index] += count;\n      momentsR[index] += count * red;\n      momentsG[index] += count * green;\n      momentsB[index] += count * blue;\n      moments[index] += count;\n    }\n  }\n\n  void createMoments() {\n    for (int i = 0; i < TOTAL_SIZE; i++) {\n      momentsR[i] /= weights[i];\n      momentsG[i] /= weights[i];", "first_line_groundtruth": "ColorUtils.blueFromArgb(pixel);", "first_line_prediction": " ColorUtils.blueFromArgb(pixel);", "match": 0}
{"groundtruth": "Contrast.ratioOfTones(bgTone, answer) >= desiredRatio) {", "prediction": "decreasingContrast) {\n        answer = DynamicColor.foregroundTone(bgTone, desiredRatio);\n      } else {\n        answer = DynamicColor.backgroundTone(bgTone, desiredRatio);\n      }\n\n      return answer;\n    }\n  }\n\n  /** Returns the contrast curve for the color. */\n  @NonNull\n  public ContrastCurve getContrastCurve() {\n    return contrastCurve;\n  }\n\n  /** Returns the background color. */\n  @Nullable\n  public DynamicColor getBackground() {\n    return background;\n  }\n\n  /** Returns the foreground color. */\n  @Nullable\n  public DynamicColor getForeground() {\n    return foreground;", "first_line_groundtruth": "Contrast.ratioOfTones(bgTone, answer) >= desiredRatio) {", "first_line_prediction": "decreasingContrast) {", "match": 0}
{"groundtruth": "= DateUtil.getUnixTimeFromDate(startDate);", "prediction": " = DateUtil.convertDateToUnixTimeStamp(startDate);\n        String endUnixTimeStamp = DateUtil.convertDateToUnixTimeStamp(endDate);\n\n        //? Query By ProfileId\n        Query query = transactionCollectionRef.whereEqualTo(\"profileId\", profileId);\n\n        //? Check if start date was passed\n        if(DateUtil.isValidDate(startDate)){\n            query = query.whereGreaterThanOrEqualTo(\"creationDate\",startUnixTimeStamp);\n        }\n        //? Check if end date was passed\n        else if(DateUtil.isValidDate(endDate)){\n            query = query.whereLessThanOrEqualTo(\"creationDate\",endUnixTimeStamp);", "first_line_groundtruth": "= DateUtil.getUnixTimeFromDate(startDate);", "first_line_prediction": " = DateUtil.convertDateToUnixTimeStamp(startDate);", "match": 0}
{"groundtruth": "MathUtils.matrixMultiply(linrgb, SCALED_DISCOUNT_FROM_LINRGB);", "prediction": " {\n        linrgb[0] / 100.0,\n        linrgb[1] / 100.0,\n        linrgb[2] / 100.0,\n    };\n    double[] discount = new double[3];\n    for (int i = 0; i < 3; i++) {\n      discount[i] = scaledDiscount[i] * 0.950456;\n    }\n    double[] transformed = new double[3];\n    for (int i = 0; i < 3; i++) {\n      transformed[i]", "first_line_groundtruth": "MathUtils.matrixMultiply(linrgb, SCALED_DISCOUNT_FROM_LINRGB);", "first_line_prediction": " {", "match": 0}
{"groundtruth": "DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)) {", "prediction": "DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)){\n            System.out.println(\"Inside date range\");\n            query = query.whereGreaterThanOrEqualTo(\"creationDate\",startDate).whereLessThanOrEqualTo(\"creationDate\",endDate);\n        }\n        //? Check if creationDate is passed and valid\n        else if(DateUtil.isValidDate(creationDate)){\n            System.out.println(\"Inside creation date\");\n            query = query.whereEqualTo(\"creationDate\",creationDate);\n        }\n        //? Check if creationMonth and creationYear is passed and valid\n        else if(TransactionUtil.isValidMonth(", "first_line_groundtruth": "DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)) {", "first_line_prediction": "DateUtil.isValidDate(startDate) && DateUtil.isValidDate(endDate)){", "match": 0}
{"groundtruth": "alpha = MathUtils.clampInt(0, 255, (int) Math.round(percentage * 255));", "prediction": "ialpha = (int) (255 * percentage);\n    return Color.argb(ialpha, Color.red(argb), Color.green(argb), Color.blue(argb));\n  }\n\n  /**\n    * Returns a HCT object.\n    *\n    * @param scheme Defines the conditions of the user interface, for example, whether or not it is\n    *     dark mode or light mode, and what the desired contrast level is.\n    */\n  @NonNull\n  public Hct getHct(@NonNull DynamicScheme scheme) {\n    TonalPalette palette = this.palette.apply(scheme", "first_line_groundtruth": "alpha = MathUtils.clampInt(0, 255, (int) Math.round(percentage * 255));", "first_line_prediction": "ialpha = (int) (255 * percentage);", "match": 0}
{"groundtruth": "(TransactionUtil.idValidAmount(amount)) {", "prediction": "(TransactionUtil.isValidAmount(amount)) {\n            timeQuery = timeQuery.whereEqualTo(\"transactionAmount\",amount);\n        }\n        //? Check if type is passed and valid\n        else if(TransactionUtil.isValidTransactionType(type)) {\n            timeQuery = timeQuery.whereEqualTo(\"transactionType\",type);\n        }\n        //? Check if tag is passed and valid\n        else if(TransactionUtil.isValidTransactionTag(tag)) {\n            timeQuery = timeQuery.whereEqualTo(\"transactionTag\",tag);\n        }\n        //? Check if remarks is passed and valid\n        else if(TransactionUtil.isValid", "first_line_groundtruth": "(TransactionUtil.idValidAmount(amount)) {", "first_line_prediction": "(TransactionUtil.isValidAmount(amount)) {", "match": 0}
{"groundtruth": "fTone = MathUtils.clampDouble(0, 100, nTone + delta * expansionDir);", "prediction": " // If a color is good enough, it is not adjusted.\n         // Initial and adjusted tones for `farther`\n        double fInitialTone = farther.tone.apply(scheme);\n        @Var\n        double fTone =\n            Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast\n                 ? fInitialTone\n                 : DynamicColor.foregroundTone(bgTone, fContrast);\n        if ((fTone - nTone) * expansionDir < delta) {\n          // 3rd round: expand farther to match delta.\n          // If a color is good enough, it is not", "first_line_groundtruth": "fTone = MathUtils.clampDouble(0, 100, nTone + delta * expansionDir);", "first_line_prediction": " // If a color is good enough, it is not adjusted.", "match": 0}
{"groundtruth": ".isValidDate(startDate) && DateUtil.isValidDate(endDate)) {", "prediction": ".isValidDate(startDate) && DateUtil.isValidDate(endDate)){\n            System.out.println(\"Inside date range\");\n            query = query.whereGreaterThanOrEqualTo(\"creationDate\",startDate).whereLessThanOrEqualTo(\"creationDate\",endDate);\n        }\n        //? Check if creationDate is passed and valid\n        else if(DateUtil.isValidDate(creationDate)){\n            System.out.println(\"Inside creation date\");\n            query = query.whereEqualTo(\"creationDate\",creationDate);\n        }\n        //? Check if creationMonth and creationYear is passed and valid\n        else if(TransactionUtil.isValidMonth(creationMonth", "first_line_groundtruth": ".isValidDate(startDate) && DateUtil.isValidDate(endDate)) {", "first_line_prediction": ".isValidDate(startDate) && DateUtil.isValidDate(endDate)){", "match": 0}
{"groundtruth": "MathUtils.clampDouble(0, 100, fTone - delta * expansionDir);", "prediction": " MathUtils.clampDouble(0, 100, fTone - delta * expansionDir);\n        }\n      }\n\n      // If constraint is not satisfied, try another round.\n      if ((fTone - nTone) * expansionDir < delta) {\n        // 4th round: expand farther to match delta.\n        fTone = MathUtils.clampDouble(0, 100, nTone + delta * expansionDir);\n        // If constraint is not satisfied, try another round.\n        if ((fTone - nTone) * expansionDir < delta) {\n          // 5th round: contract", "first_line_groundtruth": "MathUtils.clampDouble(0, 100, fTone - delta * expansionDir);", "first_line_prediction": " MathUtils.clampDouble(0, 100, fTone - delta * expansionDir);", "match": 0}
{"groundtruth": "(!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)){", "prediction": " (!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Get Dashboard By Date Range for a profile\n            Map<String,Object> dashboardInfo = dashboardService.getDashboardByDateRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate\n            );\n\n            //? Return response\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"", "first_line_groundtruth": "(!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)){", "first_line_prediction": " (!DateUtil.isValidDate(startDate) || !DateUtil.isValidDate(endDate)) {", "match": 0}
{"groundtruth": "TonalPalette.fromInt(argb);", "prediction": " TonalPalette.fromHct(hct);\n    return new DynamicColor(\n        name,\n        palette,\n        hct.chroma,\n        /* isBackground= */ false,\n        /* background= */ null,\n        /* secondBackground= */ null,\n        /* contrastCurve= */ null,\n        /* toneDeltaPair= */ null);\n  }\n\n  /**\n    * Create a DynamicColor from a hex code.\n    *\n    * <p>Result has no background; thus no support for increasing/decreasing contrast for a11y.\n    *\n    * @param name The name of the dynamic color.\n    *", "first_line_groundtruth": "TonalPalette.fromInt(argb);", "first_line_prediction": " TonalPalette.fromHct(hct);", "match": 0}
{"groundtruth": "whereGreaterThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(startDate))\n                    .whereLessThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(endDate));", "prediction": "whereGreaterThanOrEqualTo(\"creationDate\", startDate).whereLessThanOrEqualTo(\"creationDate\", endDate);\n        }\n        //? Check if creationDate is passed and valid\n        else if(DateUtil.isValidDate(creationDate)) {\n            query = query.whereEqualTo(\"creationDate\", creationDate);\n        }\n        //? Check if creationMonth and creationYear is passed and valid\n        else if(TransactionUtil.isValidMonth(creationMonth) && TransactionUtil.isValidYear(creationYear)) {\n            query = query\n                     .whereEqualTo(\"creationMonth\", creationMonth)\n                     .whereEqualTo(\"creationYear\", Integer.parseInt(creationYear", "first_line_groundtruth": "whereGreaterThan(\"creationTimeStamp\", DateUtil.getUnixTimeFromDate(startDate))", "first_line_prediction": "whereGreaterThanOrEqualTo(\"creationDate\", startDate).whereLessThanOrEqualTo(\"creationDate\", endDate);", "match": 0}
{"groundtruth": "&& TransactionUtil.isValidYear(creationYear)) {", "prediction": " && TransactionUtil.isValidYear(creationYear)) {\n            query = query\n                    .whereEqualTo(\"creationMonth\",creationMonth)\n                    .whereEqualTo(\"creationYear\",Integer.parseInt(creationYear));\n        }\n        //? Check if year passed\n        else if(TransactionUtil.isValidYear(creationYear)){\n            query = query.whereEqualTo(\"creationYear\",Integer.parseInt(creationYear));\n        }\n        else {\n            throw new NullPointerException(\"A valid date/month/year must be passed\");\n        }\n\n        //? Get the transactions\n        QuerySnapshot querySnapshot = query.get().get();\n        List<Transaction> transactions", "first_line_groundtruth": "&& TransactionUtil.isValidYear(creationYear)) {", "first_line_prediction": " && TransactionUtil.isValidYear(creationYear)) {", "match": 0}
{"groundtruth": "ResponseUtil.errorLimitExceeded();", "prediction": " ResponseUtil.handleLimitExceed(exceedLimit);\n\n        //? Extract the token\n        String token = authHeader.substring(7);\n\n        //? Get the profileId from the token\n        FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n        String profileId = decodedToken.getUid();\n\n        //? Get all transactions\n        List<Transaction> transactions;\n        try {\n            transactions = transactionService.getAllTransactions(profileId, limit);\n        } catch (ExecutionException | InterruptedException e) {\n            return ResponseUtil.handleTransactionError(e.getMessage());\n        }\n\n        //? Return the transactions\n        return", "first_line_groundtruth": "ResponseUtil.errorLimitExceeded();", "first_line_prediction": " ResponseUtil.handleLimitExceed(exceedLimit);", "match": 0}
{"groundtruth": "(TransactionUtil.idValidAmount(transactionAmount)) {", "prediction": " (TransactionUtil.idValidAmount(startAmount)) {\n            query = query.whereGreaterThan(\"transactionAmount\", Double.parseDouble(startAmount));\n        }\n\n        else if  (TransactionUtil.idValidAmount(endAmount)) {\n            query = query.whereLessThan(\"transactionAmount\", Double.parseDouble(endAmount));\n        }\n\n        else {\n            throw new NullPointerException(\"A valid start/end amount must be passed\");\n        }\n        System.out.println(\"End of build query by amount range\");\n        return query;\n    }\n\n    public static Query buildQueryByTransactionRange(Query query,\n                                                     String startAmount,\n                                                    ", "first_line_groundtruth": "(TransactionUtil.idValidAmount(transactionAmount)) {", "first_line_prediction": " (TransactionUtil.idValidAmount(startAmount)) {", "match": 0}
{"groundtruth": "DateUtil.isValidDate(endDate)){", "prediction": "DateUtil.isValidDate(endDate)) {\n                return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Get Dashboard By Date Range for a profile\n            Map<String,Object> dashboardInfo = dashboardService.getDashboardByDateRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate\n            );\n\n            //? Return response\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"Error: \"+e);\n            return new ResponseEntity<>(\"", "first_line_groundtruth": "DateUtil.isValidDate(endDate)){", "first_line_prediction": "DateUtil.isValidDate(endDate)) {", "match": 0}
{"groundtruth": "ResponseUtil.errorParsingEntity(\"Required Date must be passed in query and should be in dd-MM-yyyy format\");", "prediction": " ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n            }\n\n            //? Get Dashboard By Date Range for a profile\n            Map<String,Object> dashboardInfo = dashboardService.getDashboardByDateRange(\n                    decodedToken.getUid(),\n                    startDate,\n                    endDate\n            );\n\n            //? Return response\n            return ResponseUtil.handleDashboardInfo(dashboardInfo);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            System.out.println(\"Error: \"+e);\n            return new ResponseEntity<>(\"Unauthenticated!! Invalid token\", HttpStatus.UNAUTHORIZED", "first_line_groundtruth": "ResponseUtil.errorParsingEntity(\"Required Date must be passed in query and should be in dd-MM-yyyy format\");", "first_line_prediction": " ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");", "match": 0}
{"groundtruth": "return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");", "prediction": " return ResponseUtil.errorBadRequest();\n            }\n\n            //? Create transaction\n            Transaction createdTransaction = transactionService.createTransaction(decodedToken.getUid(), transaction);\n\n            //? Return response\n            return ResponseUtil.successPostOne(createdTransaction);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException e) {\n            return ResponseUtil.errorNotFound();\n        }\n    }", "first_line_groundtruth": "return ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");", "first_line_prediction": " return ResponseUtil.errorBadRequest();", "match": 0}
{"groundtruth": "(this.isNumber() && other.isNumber()) {", "prediction": " (this.equals(other)) {\n            result = Value.TRUE;\n        }\n        return result;\n    }", "first_line_groundtruth": "(this.isNumber() && other.isNumber()) {", "first_line_prediction": " (this.equals(other)) {", "match": 0}
{"groundtruth": "other.assertNumber();", "prediction": " this.assertNumber(other);\n        return Value.of(action.apply(this.asInteger(), other.asInteger()));\n    }", "first_line_groundtruth": "other.assertNumber();", "first_line_prediction": " this.assertNumber(other);", "match": 0}
{"groundtruth": "ResponseUtil.errorUnauthorized();", "prediction": " ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");\n        }\n    }\n\n    @PutMapping(value = \"/update\")\n    public ResponseEntity<Map<String,Object>> updateTransaction(@RequestHeader(\"Authorization\") String authHeader,\n                                                @RequestBody Transaction transaction) {\n        try {\n            //? Extract the token\n            String token = authHeader.substring(7);\n\n            //? Verify the JWT\n            FirebaseToken decodedToken = firebaseAuthService.verifyToken(token);\n\n            //? Check if valid date format\n            if (!DateUtil.isValidDate(transaction.getCreationDate())) {", "first_line_groundtruth": "ResponseUtil.errorUnauthorized();", "first_line_prediction": " ResponseUtil.errorParsingEntity(\"Error! Date format must be in dd-MM-yyyy\");", "match": 0}
{"groundtruth": "userDetail.getAuthorities());", "prediction": " AuthorityUtils.commaSeparatedStringToAuthorityList(userDetail.getAuthorities()));\n        return Jwts.builder()\n                .setClaims(claims)\n                .signWith(SignatureAlgorithm.HS512, SECRET)\n                .compact();\n    }\n\n    /**\n     * \u89e3\u6790\u4ee4\u724c\n     *\n     * @param token \u4ee4\u724c\n     * @return \u89e3\u6790\u540e\u7684\u7528\u6237\u4fe1\u606f\n     */\n    public static SecurityUser parseToken(String token) {\n        Claims claims = Jwts.parser()\n                .setSigningKey(SECRET)\n                .parseClaimsJws(token)\n                .getBody();", "first_line_groundtruth": "userDetail.getAuthorities());", "first_line_prediction": " AuthorityUtils.commaSeparatedStringToAuthorityList(userDetail.getAuthorities()));", "match": 0}
{"groundtruth": "getSourceIndex(), body.getDestinationIndex());", "prediction": "getSourceIndex(), body.getDestinationIndex());", "first_line_groundtruth": "getSourceIndex(), body.getDestinationIndex());", "first_line_prediction": "getSourceIndex(), body.getDestinationIndex());", "match": 1}
{"groundtruth": "return ResponseUtil.successAddOne();", "prediction": " return ResponseUtil.successPostOne(transaction);\n\n        } catch (FirebaseAuthException | ExecutionException | InterruptedException | ParseException e) {\n            return ResponseUtil.errorNotFound();\n        }\n    }", "first_line_groundtruth": "return ResponseUtil.successAddOne();", "first_line_prediction": " return ResponseUtil.successPostOne(transaction);", "match": 0}
{"groundtruth": "body.getSourceIndex(), body.getDestinationIndex());", "prediction": " body.getSourceIndex(), body.getDestinationIndex());", "first_line_groundtruth": "body.getSourceIndex(), body.getDestinationIndex());", "first_line_prediction": " body.getSourceIndex(), body.getDestinationIndex());", "match": 0}
{"groundtruth": "DeluxeMenuCommand> command = parser.parse(commandArgs);", "prediction": "DeluxeMenuCommand> command = parser.parse(commandArgs);\n        if (!command.isPresent()) {\n            logger.warn(\"Could not parse command '\" + commandType + \"' with args '\" + commandArgs + \"' in input '\" + input + \"'\");\n            return Optional.empty();\n        }\n\n        if (decorators != null) {\n            var decoratorParser = decoratorParsers.get(decorators);\n            if (decoratorParser == null) {\n                logger.warn(\"No decorator parser registered for type '\" + decorators + \"' in input '\" + input + \"'\");\n                return Optional.empty();\n            }\n\n            command = decoratorParser.parse", "first_line_groundtruth": "DeluxeMenuCommand> command = parser.parse(commandArgs);", "first_line_prediction": "DeluxeMenuCommand> command = parser.parse(commandArgs);", "match": 1}
{"groundtruth": "= helixWrapper.fetchChatters(channelId, accessToken);", "prediction": " = helixWrapper.fetchChatters(channelId, accessToken);\n    return mapToUsers(vips);\n  }\n\n  public Set<UserDto> getModerators(String channelId, String accessToken) {\n    Set<Moderator> moderators = helixWrapper.fetchModerators(channelId, accessToken);\n    return mapToUsers(moderators);\n  }\n\n  public Set<UserDto> getVips(String channelId, String accessToken) {\n    Set<ChannelVip> vips = helixWrapper.fetchVips(channelId, accessToken);\n    return mapToUsers(vipsToChatters(", "first_line_groundtruth": "= helixWrapper.fetchChatters(channelId, accessToken);", "first_line_prediction": " = helixWrapper.fetchChatters(channelId, accessToken);", "match": 0}
{"groundtruth": "channel.isAccessTokenExpired()) {", "prediction": "channel.isAccessTokenExpired()) {\n      LOGGER.info(\"access token for channel {} is expired\", channelId);\n      throw new InvalidTokenRequestException(\"access token for channel is expired\");\n    }\n\n    return channel.getAccessToken();\n  }\n\n  public Set<String> getScopes(String channelId)\n      throws InvalidTokenRequestException, ChannelNotFoundException {\n    Optional<Channel> optionalChannel = channelRepository.findById(channelId);\n    if (optionalChannel.isEmpty()) {\n      throw new ChannelNotFoundException(\"channel is not yet registered\");\n    }\n\n    Channel channel = optionalChannel.get();\n    if (channel.isAccessTokenExpired()) {\n     ", "first_line_groundtruth": "channel.isAccessTokenExpired()) {", "first_line_prediction": "channel.isAccessTokenExpired()) {", "match": 1}
{"groundtruth": "Moderator> vips = helixWrapper.fetchModerators(channelId, accessToken);", "prediction": "Moderator> moderators = helixWrapper.fetchModerators(channelId, accessToken);\n    return mapToUsers(moderators);\n  }\n\n  public Set<UserDto> getVips(String channelId, String accessToken) {\n    Set<ChannelVip> vips = helixWrapper.fetchVips(channelId, accessToken);\n    return mapToUsers(vips);\n  }", "first_line_groundtruth": "Moderator> vips = helixWrapper.fetchModerators(channelId, accessToken);", "first_line_prediction": "Moderator> moderators = helixWrapper.fetchModerators(channelId, accessToken);", "match": 0}
{"groundtruth": "channel.getScopeNames());", "prediction": "0);\n\n    Optional<OAuth2Credential> optionalFullCredential =\n        identityProvider.getAdditionalCredentialInformation(channelCredential);\n    if (optionalFullCredential.isEmpty()) {\n      throw new InvalidTokenRequestException(\"could not request credential details\");\n    }\n\n    OAuth2Credential fullCredential = optionalFullCredential.get();\n    if (!isScopeListValid(fullCredential)) {\n      throw new InvalidScopesException(\"missing scopes from autorization\");\n    }\n\n    channel.setAccessToken(fullCredential.getToken());\n    channel.setRefreshToken(fullCredential.getRefreshToken());\n    channel.setExpiresAt(fullCredential.getExpiresAt());\n    channel", "first_line_groundtruth": "channel.getScopeNames());", "first_line_prediction": "0);", "match": 0}
{"groundtruth": "sum += x.getSubTotal();", "prediction": "\tsum += x.getSubTotal();\n\t\t}\n\t\treturn sum;", "first_line_groundtruth": "sum += x.getSubTotal();", "first_line_prediction": "\tsum += x.getSubTotal();", "match": 0}
{"groundtruth": "setDescription(game.getDescription());", "prediction": "setCost(game.getCost());\n                updateToGame.setDescription(game.getDescription());\n                updateToGame.setCountOwner(game.getCountOwner());\n                System.out.println(\"Game updated\");\n            }\n        }\n    }\n\n    @Override\n    public List<Game> getGames() {\n        return games;\n    }", "first_line_groundtruth": "setDescription(game.getDescription());", "first_line_prediction": "setCost(game.getCost());", "match": 0}
{"groundtruth": "setId(game.getId());", "prediction": "setCost(game.getCost());\n                updateToGame.setDescription(game.getDescription());\n                updateToGame.setCountOwner(game.getCountOwner());\n                System.out.println(\"Game updated\");\n            }\n        }\n    }\n\n    @Override\n    public Game getGameById(int id) {\n        Game game = null;\n        for(Game game1: games){\n            if(game1.getId()==id){\n                game = game1;\n            }\n        }\n        return game;\n    }\n\n    @Override\n    public List<Game> getAllGames() {\n        return games;\n    }", "first_line_groundtruth": "setId(game.getId());", "first_line_prediction": "setCost(game.getCost());", "match": 0}
{"groundtruth": "(game.getId() == id){", "prediction": "(game.getId() == id){\n                games.remove(game);\n                System.out.println(\"Game deleted\");\n            }\n        }\n    }\n\n    @Override\n    public void updateGame(int id, Game game) {\n        Game gameToUpdate = null;\n        for (Game game2 : games) {\n            if (game2.getId() == id) {\n                gameToUpdate = game2;\n                break;\n            }\n        }\n        if(gameToUpdate != null){\n            gameToUpdate.setName(game.getName());\n            gameToUpdate.setCost(game.getCost());\n            gameToUpdate.setDiscountAmount(", "first_line_groundtruth": "(game.getId() == id){", "first_line_prediction": "(game.getId() == id){", "match": 1}
{"groundtruth": "game.setCountOwner(game.getCountOwner() + 1);", "prediction": " System.out.println(\"Game \" + game.getName() + \" not sold to \" + customer.getName());\n        }\n    }", "first_line_groundtruth": "game.setCountOwner(game.getCountOwner() + 1);", "first_line_prediction": " System.out.println(\"Game \" + game.getName() + \" not sold to \" + customer.getName());", "match": 0}
{"groundtruth": "(!(customer.getGames().contains(game))){", "prediction": "(game.getCountOwner() == 0){\n            campaignService.deleteCampaignById(game.getCampaign().getId());\n            game.getCampaign().getGames().remove(game);\n            game.setCountOwner(0);\n            game.setCost(0);\n            userService.deleteUserById(game.getCampaign().getUser().getId());\n            System.out.println(\"Campaign deleted\");\n        }\n    }", "first_line_groundtruth": "(!(customer.getGames().contains(game))){", "first_line_prediction": "(game.getCountOwner() == 0){", "match": 0}
{"groundtruth": ".equals(customer.getSurName()) &&\n                    customer2.getBirthYear() == customer.getBirthYear()) {", "prediction": " == customer.getSurName() &&\n                    customer2.getBirthYear() == customer.getBirthYear()) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": ".equals(customer.getSurName()) &&", "first_line_prediction": " == customer.getSurName() &&", "match": 0}
{"groundtruth": "(game1.getId()==id){", "prediction": "(game1.getId() == id){\n                updateToGame = game1;\n                updateToGame.setName(game.getName());\n                updateToGame.setPrice(game.getPrice());\n                updateToGame.setGenre(game.getGenre());\n                updateToGame.setPlatform(game.getPlatform());\n                updateToGame.setReleaseDate(game.getReleaseDate());\n                updateToGame.setSummary(game.getSummary());\n                updateToGame.setDeveloper(game.getDeveloper());\n                updateToGame.setPublisher(game.getPublisher());\n                updateToGame.setRating", "first_line_groundtruth": "(game1.getId()==id){", "first_line_prediction": "(game1.getId() == id){", "match": 0}
{"groundtruth": "customer2.getSurName().equals(customer.getSurName()) &&\n                    customer2.getBirthYear() == customer.getBirthYear()) {", "prediction": " customer2.getSurName().equals(customer.getSurName())) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": "customer2.getSurName().equals(customer.getSurName()) &&", "first_line_prediction": " customer2.getSurName().equals(customer.getSurName())) {", "match": 0}
{"groundtruth": ") == customer.getBirthYear()) {", "prediction": "customer.getBirthYear()) &&\n                    customer2.getEmail().equals(customer.getEmail()) &&\n                    customer2.getPassword().equals(customer.getPassword())) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": ") == customer.getBirthYear()) {", "first_line_prediction": "customer.getBirthYear()) &&", "match": 0}
{"groundtruth": "customer2.getBirthYear() == customer.getBirthYear()) {", "prediction": " customer2.getBirthYear().equals(customer.getBirthYear())) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": "customer2.getBirthYear() == customer.getBirthYear()) {", "first_line_prediction": " customer2.getBirthYear().equals(customer.getBirthYear())) {", "match": 0}
{"groundtruth": ".getName() + \" sold to \" + customer.getName()+\" cost: \"+game.getCost());", "prediction": ".getName() + \" sold to \" + customer.getName());\n        }\n    }", "first_line_groundtruth": ".getName() + \" sold to \" + customer.getName()+\" cost: \"+game.getCost());", "first_line_prediction": ".getName() + \" sold to \" + customer.getName());", "match": 0}
{"groundtruth": "p1.getCategories().add(cat2);", "prediction": "\n\t\tUser u1 = new User(null, \"admin\", \"admin\", \"<EMAIL>\", \"123456\", \"admin\", \"admin\", Instant.now());\n\t\tUser u2 = new User(null, \"user\", \"user\", \"<EMAIL>\", \"123456\", \"user\", \"user\", Instant.now());\n\t\tUser u3 = new User(null, \"user2\", \"user2\", \"<EMAIL>\", \"123456\", \"user2\", \"user2\", Instant.now());\n\t\tUser u4 = new User(null", "first_line_groundtruth": "p1.getCategories().add(cat2);", "first_line_prediction": "", "match": 0}
{"groundtruth": "setDiscountAmount(campaign.getDiscountAmount());", "prediction": "setDiscountAmount(campaign.getDiscountAmount());\n                updateToCampaign.setStartDate(campaign.getStartDate());\n                updateToCampaign.setEndDate(campaign.getEndDate());\n                System.out.println(\"Campaign updated\");\n            }\n        }\n    }\n\n    @Override\n    public List<Campaign> getCampaigns() {\n        return campaigns;\n    }", "first_line_groundtruth": "setDiscountAmount(campaign.getDiscountAmount());", "first_line_prediction": "setDiscountAmount(campaign.getDiscountAmount());", "match": 1}
{"groundtruth": "()+\" cost: \"+game.getCost());", "prediction": "());\n        }\n    }", "first_line_groundtruth": "()+\" cost: \"+game.getCost());", "first_line_prediction": "());", "match": 0}
{"groundtruth": "(campaign1.getId()==id){", "prediction": "(campaign1.getId() == id){\n                updateToCampaign = campaign1;\n            }\n        }\n        if(updateToCampaign != null){\n            updateToCampaign.setDiscountAmount(campaign.getDiscountAmount());\n            updateToCampaign.setDiscountType(campaign.getDiscountType());\n            updateToCampaign.setGame(campaign.getGame());\n            updateToCampaign.setPrice(campaign.getPrice());\n            updateToCampaign.setStartDate(campaign.getStartDate());\n            updateToCampaign.setEndDate(campaign.getEndDate());\n            System.out.println(\"Campaign updated\");\n        }else{\n            System", "first_line_groundtruth": "(campaign1.getId()==id){", "first_line_prediction": "(campaign1.getId() == id){", "match": 0}
{"groundtruth": "(campaign.getGames().get(id));", "prediction": "(campaign.getGame());\n                updateToCampaign.setDiscountAmount(campaign.getDiscountAmount());\n                updateToCampaign.setStartDate(campaign.getStartDate());\n                updateToCampaign.setEndDate(campaign.getEndDate());\n                System.out.println(\"Campaign updated\");\n            }\n        }\n    }\n\n    @Override\n    public List<Campaign> getCampaigns() {\n        return campaigns;\n    }", "first_line_groundtruth": "(campaign.getGames().get(id));", "first_line_prediction": "(campaign.getGame());", "match": 0}
{"groundtruth": "p2.getCategories().add(cat3);", "prediction": "", "first_line_groundtruth": "p2.getCategories().add(cat3);", "first_line_prediction": "", "match": 0}
{"groundtruth": "System.out.println(user2.getName() +\" is updated to \" + customer.getName());", "prediction": " userToUpdate = user2;\n            }\n        }\n        if (userToUpdate != null) {\n            userToUpdate.setName(customer.getName());\n            userToUpdate.setEmail(customer.getEmail());\n            userToUpdate.setPassword(customer.getPassword());\n            System.out.println(\"User: \" + userToUpdate.getId() + \" is updated.\");\n        } else {\n            System.out.println(\"User is not in database.\");\n        }\n    }", "first_line_groundtruth": "System.out.println(user2.getName() +\" is updated to \" + customer.getName());", "first_line_prediction": " userToUpdate = user2;", "match": 0}
{"groundtruth": ".out.println(user2.getName() +\" is updated to \" + customer.getName());", "prediction": ".out.println(\"User: \" + user2.getId() + \" is updated.\");\n                userToUpdate = user2;\n                break;\n            }\n        }\n        if (userToUpdate == null) {\n            System.out.println(\"User: \" + id + \" is not in database.\");\n        } else {\n            userToUpdate.setName(customer.getName());\n            userToUpdate.setEmail(customer.getEmail());\n            userToUpdate.setPassword(customer.getPassword());\n        }\n    }", "first_line_groundtruth": ".out.println(user2.getName() +\" is updated to \" + customer.getName());", "first_line_prediction": ".out.println(\"User: \" + user2.getId() + \" is updated.\");", "match": 0}
{"groundtruth": "p3.getCategories().add(cat3);", "prediction": "", "first_line_groundtruth": "p3.getCategories().add(cat3);", "first_line_prediction": "", "match": 0}
{"groundtruth": "p4.getCategories().add(cat3);", "prediction": "", "first_line_groundtruth": "p4.getCategories().add(cat3);", "first_line_prediction": "", "match": 0}
{"groundtruth": ", p1.getPrice());", "prediction": ");\n\t\tOrderItem oi2 = new OrderItem(o1, p2, 1);\n\t\tOrderItem oi3 = new OrderItem(o1, p3, 1);\n\t\tOrderItem oi4 = new OrderItem(o1, p4, 1);\n\t\tOrderItem oi5 = new OrderItem(o1, p5, 1);", "first_line_groundtruth": ", p1.getPrice());", "first_line_prediction": ");", "match": 0}
{"groundtruth": "setSurName(customer.getSurName());", "prediction": "setSurName(customer.getSurName());\n                userToUpdate.setTc(customer.getTc());\n                userToUpdate.setAddress(customer.getAddress());\n                userToUpdate.setPhone(customer.getPhone());\n                userToUpdate.setBirthDate(customer.getBirthDate());\n                userToUpdate.setGender(customer.getGender());\n                userToUpdate.setGames(customer.getGames());\n                break;\n            }\n        }\n        if (userToUpdate == null) {\n            System.out.println(\"User is not in database.\");\n        }\n    }", "first_line_groundtruth": "setSurName(customer.getSurName());", "first_line_prediction": "setSurName(customer.getSurName());", "match": 1}
{"groundtruth": "2, p5.getPrice());", "prediction": "1, p5.getPrice());", "first_line_groundtruth": "2, p5.getPrice());", "first_line_prediction": "1, p5.getPrice());", "match": 0}
{"groundtruth": "userToUpdate.setBirthYear(customer.getBirthYear());", "prediction": " userToUpdate.setTc(customer.getTc());\n                break;\n            }\n        }\n        if (userToUpdate == null) {\n            System.out.println(\"User is not in database.\");\n        }\n    }", "first_line_groundtruth": "userToUpdate.setBirthYear(customer.getBirthYear());", "first_line_prediction": " userToUpdate.setTc(customer.getTc());", "match": 0}
{"groundtruth": "setTc(customer.getTc());", "prediction": "setTc(customer.getTc());\n                userToUpdate.setAddress(customer.getAddress());\n                userToUpdate.setPhone(customer.getPhone());\n                userToUpdate.setGender(customer.getGender());\n                userToUpdate.setGames(customer.getGames());\n                break;\n            }\n        }\n        if (userToUpdate == null) {\n            System.out.println(\"User is not in database.\");\n        }\n    }", "first_line_groundtruth": "setTc(customer.getTc());", "first_line_prediction": "setTc(customer.getTc());", "match": 1}
{"groundtruth": ", p3, 2, p3.getPrice());", "prediction": ", p2, 1, p2.getPrice());\n\t\tOrderItem oi4 = new OrderItem(o2, p4, 1, p4.getPrice());\n\t\tOrderItem oi5 = new OrderItem(o3, p5, 1, p5.getPrice());\n\t\t\n\t\torderItemRepository.saveAll(Arrays.asList(oi1, oi2, oi3, oi4, oi5));", "first_line_groundtruth": ", p3, 2, p3.getPrice());", "first_line_prediction": ", p2, 1, p2.getPrice());", "match": 0}
{"groundtruth": "p5.getCategories().add(cat2);", "prediction": "", "first_line_groundtruth": "p5.getCategories().add(cat2);", "first_line_prediction": "", "match": 0}
{"groundtruth": "(ClientCommandInternals.executeCommand(command)) {", "prediction": " (ClientCommandInternals.activeDispatcher != null) {\n            ClientCommandInternals.activeDispatcher.execute(command);\n            cir.setReturnValue(true);\n        }\n    }", "first_line_groundtruth": "(ClientCommandInternals.executeCommand(command)) {", "first_line_prediction": " (ClientCommandInternals.activeDispatcher != null) {", "match": 0}
{"groundtruth": "ClientCommandInternals.finalizeInit();", "prediction": "", "first_line_groundtruth": "ClientCommandInternals.finalizeInit();", "first_line_prediction": "", "match": 0}
{"groundtruth": "ClientCommandInternals.getActiveDispatcher();", "prediction": " ClientCommandInternals.getActiveDispatcher();\n    }\n\n    /**\n     * Registers a literal command.\n     *\n     * <p>The literal command is executed when the command is entered without any arguments.\n     *\n     * <p>The literal command is executed on the client game thread by default.\n     * Avoid doing any heavy calculations here as that can freeze the game's rendering.\n     * For example, you can move heavy code to another thread.\n     *\n     * <p>The literal command is executed on the client game thread by default.\n     * Avoid doing any heavy calculations here as that can freeze the game's rendering.\n    ", "first_line_groundtruth": "ClientCommandInternals.getActiveDispatcher();", "first_line_prediction": " ClientCommandInternals.getActiveDispatcher();", "match": 0}
{"groundtruth": "activeDispatcher.register(ClientCommandManager.literal(API_COMMAND_NAME).then(help));", "prediction": " activeDispatcher.getRoot();\n            mainNode.addChild(help.build());\n\n            activeDispatcher.findAmbiguities(AmbiguityConsumer.ignore());\n        }\n    }\n\n    private static int executeRootHelp(CommandContext<FabricClientCommandSource> context) {\n        List<String> children = Iterables.transform(activeDispatcher.getRoot().getChildren(), CommandNode::getName);\n        context.getSource().sendFeedback(Text.join(children, \"\\n\"), false);\n        return 1;\n    }\n\n    private static int executeArgumentHelp(CommandContext<FabricClientCommandSource> context) {\n        String command = context.", "first_line_groundtruth": "activeDispatcher.register(ClientCommandManager.literal(API_COMMAND_NAME).then(help));", "first_line_prediction": " activeDispatcher.getRoot();", "match": 0}
{"groundtruth": "register(ClientCommandManager.literal(SHORT_API_COMMAND_NAME).redirect(mainNode));", "prediction": "findAmbiguities(mainNode, (AmbiguityConsumer<FabricClientCommandSource>) (context, builder) -> {\n                List<ParsedCommandNode<FabricClientCommandSource>> nodes = builder.build();\n                if (nodes.size() > 1) {\n                    context.getSource().sendError(Text.translatable(\"command.dispatcher.ambiguity\", Iterables.getLast(nodes).getCommand()));\n                }\n            });\n        }\n    }\n\n    private static int executeRootHelp(CommandContext<FabricClientCommandSource> context) {\n        context.getSource().sendFeedback(Text.translatable(\"command.help", "first_line_groundtruth": "register(ClientCommandManager.literal(SHORT_API_COMMAND_NAME).redirect(mainNode));", "first_line_prediction": "findAmbiguities(mainNode, (AmbiguityConsumer<FabricClientCommandSource>) (context, builder) -> {", "match": 0}
{"groundtruth": "LiteralArgumentBuilder<FabricClientCommandSource> help = ClientCommandManager.literal(\"help\");", "prediction": " activeDispatcher.register(API_COMMAND_NAME, ClientCommandInternals::registerApiCommand);\n        }\n\n        activeDispatcher.findAmbiguities(AmbiguityConsumer.NO_OP);\n    }\n\n    private static void registerApiCommand(CommandDispatcher<FabricClientCommandSource> dispatcher) {\n        LiteralArgumentBuilder<FabricClientCommandSource> helpCommand = LiteralArgumentBuilder.<FabricClientCommandSource>literal(\"help\")\n                .requires(source -> source.hasPermissionLevel(2))\n                .then(LiteralArgumentBuilder.<FabricClientCommandSource>literal(\"commands\")\n                        .executes(ClientCommandInternals::executeHelpCommands", "first_line_groundtruth": "LiteralArgumentBuilder<FabricClientCommandSource> help = ClientCommandManager.literal(\"help\");", "first_line_prediction": " activeDispatcher.register(API_COMMAND_NAME, ClientCommandInternals::registerApiCommand);", "match": 0}
{"groundtruth": ") + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"intelligence\");", "prediction": " + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"intelligence\"));\n\t\t}\n\t\treturn stats.getModifier(stats.getIntelligence());", "first_line_groundtruth": ") + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"intelligence\");", "first_line_prediction": " + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"intelligence\"));", "match": 0}
{"groundtruth": "HelpCommandAccessor.getFailedException().create();", "prediction": " CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand();\n        }\n\n        ParsedCommandNode<FabricClientCommandSource> node = nodes.get(0);\n        return executeHelp(node, context);\n    }\n\n    private static int executeHelp(CommandNode<FabricClientCommandSource> node, CommandContext<FabricClientCommandSource> context) {\n        HelpCommandAccessor helpAccessor = (HelpCommandAccessor) node;\n        List<Text> text = helpAccessor.getHelpText(context.getSource());\n\n        if (text.isEmpty()) {\n            context.getSource().sendError(Texts.toText(\"", "first_line_groundtruth": "HelpCommandAccessor.getFailedException().create();", "first_line_prediction": " CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand();", "match": 0}
{"groundtruth": "type.getSubRace();", "prediction": " type.getSubRace();", "first_line_groundtruth": "type.getSubRace();", "first_line_prediction": " type.getSubRace();", "match": 0}
{"groundtruth": "type.getSubRace()).containsKey(\"strength\")){", "prediction": "type.getSubRace()).get(\"strength\") != null){\n\t\t\t\t\treturn type.getAbilityScoreIncrease(type.getSubRace()).get(\"strength\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase \"dexterity\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).get(\"dexterity\") != null){\n\t\t\t\t\treturn type.getAbilityScoreIncrease(type.getSubRace()).get(\"dexterity\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase \"constitution\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).get(\"", "first_line_groundtruth": "type.getSubRace()).containsKey(\"strength\")){", "first_line_prediction": "type.getSubRace()).get(\"strength\") != null){", "match": 0}
{"groundtruth": "getModifier(stats.getStrength()) + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"strength\");", "prediction": "getAbilityScoreIncrease(type.getSubRace()).get(\"strength\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase \"dexterity\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).containsKey(\"dexterity\")){\n\t\t\t\t\treturn stats.getAbilityScoreIncrease(type.getSubRace()).get(\"dexterity\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase \"constitution\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).containsKey(\"constitution\")){\n\t\t\t\t\treturn stats.getAbilityScoreIncrease(type.getSubRace()).get(\"", "first_line_groundtruth": "getModifier(stats.getStrength()) + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"strength\");", "first_line_prediction": "getAbilityScoreIncrease(type.getSubRace()).get(\"strength\");", "match": 0}
{"groundtruth": "type.getSpeed();", "prediction": "10 + stats.getModifier(stats.getDexterity());", "first_line_groundtruth": "type.getSpeed();", "first_line_prediction": "10 + stats.getModifier(stats.getDexterity());", "match": 0}
{"groundtruth": "stats.getModifier(stats.getCharisma());", "prediction": "0;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}", "first_line_groundtruth": "stats.getModifier(stats.getCharisma());", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "stats.getModifier(stats.getStrength());", "prediction": "0;\n\t\t\tcase \"dexterity\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).containsKey(\"dexterity\")){\n\t\t\t\t\treturn stats.getModifier(stats.getDexterity()) + (int) type.getAbilityScoreIncrease(type.getSubRace()).get(\"dexterity\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase \"constitution\":\n\t\t\t\tif (type.getAbilityScoreIncrease(type.getSubRace()).containsKey(\"constitution\")){\n\t\t\t\t\treturn stats.getModifier(stats.getConstitution()) + (int) type.getAbility", "first_line_groundtruth": "stats.getModifier(stats.getStrength());", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "return stats.getSavingThrow(stats.getStrength(), true);", "prediction": "\treturn stats.getModifier(stats.getStrength()) + 10;\n\t\t\tcase \"dexterity\":\n\t\t\t\t\treturn stats.getModifier(stats.getDexterity()) + 10;\n\t\t\tcase \"constitution\":\n\t\t\t\t\treturn stats.getModifier(stats.getConstitution()) + 10;\n\t\t\tcase \"intelligence\":\n\t\t\t\t\treturn stats.getModifier(stats.getIntelligence()) + 10;\n\t\t\tcase \"wisdom\":\n\t\t\t\t\treturn stats.getModifier(stats.getWisdom()) + 10;\n\t\t\tcase \"char", "first_line_groundtruth": "return stats.getSavingThrow(stats.getStrength(), true);", "first_line_prediction": "\treturn stats.getModifier(stats.getStrength()) + 10;", "match": 0}
{"groundtruth": "stats.getCharisma(), false);", "prediction": "stats.getCharisma(), true);\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}", "first_line_groundtruth": "stats.getCharisma(), false);", "first_line_prediction": "stats.getCharisma(), true);", "match": 0}
{"groundtruth": "return stats.getSavingThrow(stats.getDexterity(), false);", "prediction": "\treturn stats.getSavingThrow(stats.getDexterity(), true);\n\t\t\tcase \"constitution\":\n\t\t\t\treturn stats.getSavingThrow(stats.getConstitution(), true);\n\t\t\tcase \"intelligence\":\n\t\t\t\treturn stats.getSavingThrow(stats.getIntelligence(), true);\n\t\t\tcase \"wisdom\":\n\t\t\t\treturn stats.getSavingThrow(stats.getWisdom(), true);\n\t\t\tcase \"charisma\":\n\t\t\t\treturn stats.getSavingThrow(stats.getCharisma(), true);\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}", "first_line_groundtruth": "return stats.getSavingThrow(stats.getDexterity(), false);", "first_line_prediction": "\treturn stats.getSavingThrow(stats.getDexterity(), true);", "match": 0}
{"groundtruth": "(stats.getIntelligence(), true);", "prediction": "(stats.getIntelligence(), false);\n\t\t\tcase \"wisdom\":\n\t\t\t\treturn stats.getSavingThrow(stats.getWisdom(), false);\n\t\t\tcase \"charisma\":\n\t\t\t\treturn stats.getSavingThrow(stats.getCharisma(), false);\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}", "first_line_groundtruth": "(stats.getIntelligence(), true);", "first_line_prediction": "(stats.getIntelligence(), false);", "match": 0}
{"groundtruth": "readResult, \"selectApdu with AID: \" + Utils.bytesToHex(command));", "prediction": "readResult, \"Select response: \" + Utils.bytesToHex(responseSelect));\n\n                // now we run the read command\n                command = readApdu();\n                byte[] responseRead = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"Read response: \" + Utils.bytesToHex(responseRead));\n\n                // now we run the write command\n                command = writeApdu();\n                byte[] responseWrite = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"Write response: \" + Utils.bytesToHex(responseWrite));\n\n                // now we run the", "first_line_groundtruth": "readResult, \"selectApdu with AID: \" + Utils.bytesToHex(command));", "first_line_prediction": "readResult, \"Select response: \" + Utils.bytesToHex(responseSelect));", "match": 0}
{"groundtruth": "writeToUiAppend(readResult, \"select CC: \" + Utils.bytesToHex(command));", "prediction": " writeToUiAppend(readResult, \"selectApdu with selectCapabilityContainer: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"selectApdu response: \" + Utils.bytesToHex(responseSelectCc));\n\n                if (responseSelectCc == null) {\n                    writeToUiAppend(readResult, \"selectApdu with selectCapabilityContainer fails (null)\");\n                } else {\n                    writeToUiAppend(readResult, \"responseSelectCc length: \" + responseSelectCc.length + \" data: \" + Utils.bytesToHex(responseSelectCc));\n                    System.out.", "first_line_groundtruth": "writeToUiAppend(readResult, \"select CC: \" + Utils.bytesToHex(command));", "first_line_prediction": " writeToUiAppend(readResult, \"selectApdu with selectCapabilityContainer: \" + Utils.bytesToHex(command));", "match": 0}
{"groundtruth": "readResult, \"selectApdu response: \" + Utils.bytesToHex(responseSelect));", "prediction": "readResult, \"selectApdu with AID: \" + Utils.bytesToHex(responseSelect));\n\n                // now we run the read command\n                command = readApdu();\n                responseSelect = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"readApdu: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"readApdu: \" + Utils.bytesToHex(responseSelect));\n\n                // now we run the write command\n                command = writeApdu();\n                responseSelect = isoDep.transceive(command);\n                writeToUiAppend(", "first_line_groundtruth": "readResult, \"selectApdu response: \" + Utils.bytesToHex(responseSelect));", "first_line_prediction": "readResult, \"selectApdu with AID: \" + Utils.bytesToHex(responseSelect));", "match": 0}
{"groundtruth": "(\"sendBinaryFromCc response: \" + Utils.bytesToHex(responseSendBinaryFromCc));", "prediction": "(\"responseSendBinaryFromCc: \" + Utils.bytesToHex(responseSendBinaryFromCc));\n\n                if (!Utils.isSucceed(responseSendBinaryFromCc)) {\n                    writeToUiAppend(readResult, \"responseSendBinaryFromCc is not 90 00 - aborted\");\n                    System.out.println(\"responseSendBinaryFromCc is not 90 00 - aborted \");\n                    return;\n                }\n\n                // Sending ReadBinary from CC...\n                String sendBinareFromCc2 = \"00b000000f\";\n                command = Utils.hexStringToByteArray(", "first_line_groundtruth": "(\"sendBinaryFromCc response: \" + Utils.bytesToHex(responseSendBinaryFromCc));", "first_line_prediction": "(\"responseSendBinaryFromCc: \" + Utils.bytesToHex(responseSendBinaryFromCc));", "match": 0}
{"groundtruth": "System.out.println(\"capabilityContainerHeader: \" + Utils.bytesToHex(capabilityContainerHeader));", "prediction": " // Capability Container data:\n                byte[] capabilityContainerData = Arrays.copyOfRange(responseSendBinaryFromCc, responseSendBinaryFromCc.length - 2, responseSendBinaryFromCc.length);\n                writeToUiAppend(readResult, \"capabilityContainerData length: \" + capabilityContainerData.length + \" data: \" + Utils.bytesToHex(capabilityContainerData));\n\n                // Capability Container data:\n                byte[] capabilityContainerData2 = Arrays.copyOfRange(responseSendBinaryFromCc, responseSendBinaryFromCc.length - 2, responseSendBinaryFromCc.length);\n                writeToUi", "first_line_groundtruth": "System.out.println(\"capabilityContainerHeader: \" + Utils.bytesToHex(capabilityContainerHeader));", "first_line_prediction": " // Capability Container data:", "match": 0}
{"groundtruth": "(\"responseSelect: \" + Utils.bytesToHex(responseSelect));", "prediction": "(\"responseSelect length: \" + responseSelect.length + \" data: \" + Utils.bytesToHex(responseSelect));\n                    if (responseSelect.length == 2 && responseSelect[0] == 0x90 && responseSelect[1] == 0x00) {\n                        // success\n                        // now we run the read command\n                        byte[] commandRead = readApdu();\n                        byte[] responseRead = isoDep.transceive(commandRead);\n                        writeToUiAppend(readResult, \"readApdu: \" + Utils.bytesToHex(commandRead));\n                        writeToUiAppend(read", "first_line_groundtruth": "(\"responseSelect: \" + Utils.bytesToHex(responseSelect));", "first_line_prediction": "(\"responseSelect length: \" + responseSelect.length + \" data: \" + Utils.bytesToHex(responseSelect));", "match": 0}
{"groundtruth": ",\"ndefLen: \" + Utils.bytesToHex(ndefLen) + \" len (dec): \" + ndefLenInt);", "prediction": ", \"ndefLen: \" + Utils.bytesToHex(ndefLen));\n                writeToUiAppend(readResult, \"cmdLen: \" + Utils.bytesToHex(cmdLen));\n                writeToUiAppend(readResult, \"ndefLenInt: \" + ndefLenInt);\n                System.out.println(\"ndefLen: \" + Utils.bytesToHex(ndefLen));\n                System.out.println(\"cmdLen: \" + Utils.bytesToHex(cmdLen));\n                System.out.println(\"ndefLenInt: \" + ndefLenInt);\n\n                if (ndefLenInt > 0", "first_line_groundtruth": ",\"ndefLen: \" + Utils.bytesToHex(ndefLen) + \" len (dec): \" + ndefLenInt);", "first_line_prediction": ", \"ndefLen: \" + Utils.bytesToHex(ndefLen));", "match": 0}
{"groundtruth": "writeToUiAppend(readResult, \"responseSelect length: \" + responseSelectCc.length + \" data: \" + Utils.bytesToHex(responseSelectCc));", "prediction": " if (responseSelectCc == null) {\n                    writeToUiAppend(readResult, \"select CC fails (null)\");\n                } else {\n                    writeToUiAppend(readResult, \"responseSelectCc length: \" + responseSelectCc.length + \" data: \" + Utils.bytesToHex(responseSelectCc));\n                    System.out.println(\"responseSelectCc: \" + Utils.bytesToHex(responseSelectCc));\n                }\n\n                if (!Utils.isSucceed(responseSelectCc)) {\n                    writeToUiAppend(readResult, \"responseSelectCc is not 90 00 - aborted\");\n                   ", "first_line_groundtruth": "writeToUiAppend(readResult, \"responseSelect length: \" + responseSelectCc.length + \" data: \" + Utils.bytesToHex(responseSelectCc));", "first_line_prediction": " if (responseSelectCc == null) {", "match": 0}
{"groundtruth": "= \"00b000\" + Utils.bytesToHex(cmdLenNew);", "prediction": " = \"00b00000\" + ndefLenIntRequest;\n                command = Utils.hexStringToByteArray(sendReadBinaryNdefData);\n                byte[] responseSendBinaryNdefData = isoDep.transceive(command);\n                writeToUiAppend(readResult, \"sendBinaryNdefData: \" + Utils.bytesToHex(command));\n                writeToUiAppend(readResult, \"sendBinaryNdefData response: \" + Utils.bytesToHex(responseSendBinaryNdefData));\n                writeToUiAppend(readResult, \"sendBinaryNdefData response length: \" + response", "first_line_groundtruth": "= \"00b000\" + Utils.bytesToHex(cmdLenNew);", "first_line_prediction": " = \"00b00000\" + ndefLenIntRequest;", "match": 0}
{"groundtruth": "] cmdLenNew = Utils.convertIntToByteArray(ndefLenIntRequest, 2);", "prediction": " ] cmdLenNew = Utils.intToByteArray(ndefLenIntRequest);\n                byte[] cmdLenNew2 = Arrays.copyOfRange(cmdLenNew, 0, 2);\n                byte[] cmdLenNew3 = Arrays.copyOfRange(cmdLenNew, 2, cmdLenNew.length);\n                byte[] cmdLenNew4 = Arrays.copyOfRange(cmdLenNew, 4, cmdLenNew.length);\n                byte[] cmdLenNew5 = Arrays.copyOfRange(cmdLenNew, 6, cmdLenNew.length);\n                byte[] cmdLenNew6 = Arrays.copyOf", "first_line_groundtruth": "] cmdLenNew = Utils.convertIntToByteArray(ndefLenIntRequest, 2);", "first_line_prediction": " ] cmdLenNew = Utils.intToByteArray(ndefLenIntRequest);", "match": 0}
{"groundtruth": "writeToUiAppend(readResult,\"ndefLen new (dec): \" + ndefLenIntRequest + \" data: \" + Utils.bytesToHex(cmdLenNew) );", "prediction": " //byte[] cmdLenNew = Utils.hexStringToByteArray(sendReadBinaryNlen);\n                byte[] cmdLenNew = Arrays.copyOfRange(cmdLen, 0, 2);\n                cmdLenNew[0] = cmdLenNew[0] & 0x00;\n                cmdLenNew[1] = cmdLenNew[1] & 0x00;\n                cmdLenNew[1] = cmdLenNew[1] | 0x02;\n                cmdLenNew[0] = cmdLenNew[0] | 0x02;\n                cmdLenNew", "first_line_groundtruth": "writeToUiAppend(readResult,\"ndefLen new (dec): \" + ndefLenIntRequest + \" data: \" + Utils.bytesToHex(cmdLenNew) );", "first_line_prediction": " //byte[] cmdLenNew = Utils.hexStringToByteArray(sendReadBinaryNlen);", "match": 0}
{"groundtruth": "if (!Utils.isSucceed(responseSelect)) {", "prediction": " // now we run the read command\n                byte[] commandRead = readApdu();\n                byte[] responseRead = isoDep.transceive(commandRead);\n                writeToUiAppend(readResult, \"readApdu: \" + Utils.bytesToHex(commandRead));\n                writeToUiAppend(readResult, \"readApdu response: \" + Utils.bytesToHex(responseRead));\n\n                if (responseRead == null) {\n                    writeToUiAppend(readResult, \"readApdu fails (null)\");\n                } else {\n                    writeToUiAppend(readResult, \"responseRead length: \" + responseRead.", "first_line_groundtruth": "if (!Utils.isSucceed(responseSelect)) {", "first_line_prediction": " // now we run the read command", "match": 0}
{"groundtruth": "Utils.getTimestamp();", "prediction": " Utils.getDateAndTime(Calendar.getInstance().getTime());\n                    dataToSend.setText(messageWithTimestamp);\n                } else if (rbUrl.isChecked()) {\n                    String urlWithTimestamp = dataToSendString + \" on \" +\n                             Utils.getDateAndTime(Calendar.getInstance().getTime());\n                    dataToSend.setText(urlWithTimestamp);\n                } else if (rbTimestamp.isChecked()) {\n                    String messageWithTimestamp = dataToSendString + \" on \" +\n                             Utils.getDateAndTime(Calendar.getInstance().getTime());\n                    dataToSend.setText(messageWithTimestamp);\n                }\n            }\n        });\n\n        rbTimestamp.", "first_line_groundtruth": "Utils.getTimestamp();", "first_line_prediction": " Utils.getDateAndTime(Calendar.getInstance().getTime());", "match": 0}
{"groundtruth": "(\"messageType\", identifierBroadcastMessageEntry.getValue().getMessageType().getID().toString());", "prediction": "(\"id\", identifierBroadcastMessageEntry.getKey().toString());\n            arrayOfMessagePresets.add(object);\n        }\n        config.add(\"message_presets\", arrayOfMessagePresets);\n\n        try {\n            Files.writeString(getConfigurationFile().toPath(), gson.toJson(config));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void loadConfig() {\n        Gson gson = new GsonBuilder().setPrettyPrinting().serializeNulls().disableHtmlEscaping().create();\n        try {\n            JsonObject config = gson.fromJson(new FileReader(getConfigurationFile()), JsonObject.class);", "first_line_groundtruth": "(\"messageType\", identifierBroadcastMessageEntry.getValue().getMessageType().getID().toString());", "first_line_prediction": "(\"id\", identifierBroadcastMessageEntry.getKey().toString());", "match": 0}
{"groundtruth": "] cmdLen = Utils.hexStringToByteArray(sendReadBinaryNlen);", "prediction": " ] ndefData = Arrays.copyOfRange(responseSendBinaryNlen, 2, responseSendBinaryNlen.length);\n                writeToUiAppend(readResult, \"ndefLen length: \" + ndefLen.length + \" data: \" + Utils.bytesToHex(ndefLen));\n                writeToUiAppend(readResult, \"ndefData length: \" + ndefData.length + \" data: \" + Utils.bytesToHex(ndefData));\n                System.out.println(\"ndefLen: \" + Utils.bytesToHex(ndefLen));\n                System.out.println(\"ndefData:", "first_line_groundtruth": "] cmdLen = Utils.hexStringToByteArray(sendReadBinaryNlen);", "first_line_prediction": " ] ndefData = Arrays.copyOfRange(responseSendBinaryNlen, 2, responseSendBinaryNlen.length);", "match": 0}
{"groundtruth": "resource.canBeOpened() ) {", "prediction": " resource.exists() ) {\n            loadProperties( resource );\n        } else if ( !quiet ) {\n            getLog().warn( String.format( \"File '%s' does not exist\", resource.getFilename() ) );\n        }\n    }\n\n    private void loadProperties( Resource resource ) throws MojoExecutionException {\n        try (InputStream is = resource.getInputStream()) {\n            Properties properties = new Properties();\n            properties.load( is );\n            for ( String key : properties.stringPropertyNames() ) {\n                String value = properties.getProperty( key );\n                if ( keyPrefix != null ) {\n                    key = keyPrefix", "first_line_groundtruth": "resource.canBeOpened() ) {", "first_line_prediction": " resource.exists() ) {", "match": 0}
{"groundtruth": "<Path> pathStream = pathParser.streamFilesMatchingAntPath(antPattern)) {", "prediction": "<Path> paths = pathParser.findFilesByPattern(project.getBasedir().toPath(), antPattern)) {\n                paths.forEach(path -> load(new FileResource(path.toFile())));\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Failed to load properties from files by pattern\", e);\n            }\n        }\n    }\n\n    private void loadUrls() throws MojoExecutionException {\n        for ( String url : urls ) {\n            load( new UrlResource( url ) );\n        }\n    }\n\n    private void load( Resource resource ) throws MojoExecutionException {\n        try (InputStream is =", "first_line_groundtruth": "<Path> pathStream = pathParser.streamFilesMatchingAntPath(antPattern)) {", "first_line_prediction": "<Path> paths = pathParser.findFilesByPattern(project.getBasedir().toPath(), antPattern)) {", "match": 0}
{"groundtruth": "circularDefinitionPreventer.throwCircularDefinitionException();", "prediction": " throw new IllegalArgumentException(\"Circular property definition detected: \" + key);\n        }\n\n        String value = mavenProjectProperties.getProperty(key);\n        if (value == null) {\n            value = environment.getProperty(key);\n        }\n        if (value == null) {\n            return key;\n        }\n\n        if (value.startsWith(\"${\")) {\n            String resolvedValue = getPropertyValue(value.substring(2, value.length() - 1), mavenProjectProperties, environment, circularDefinitionPreventer);\n            return StringUtils.replace(value, \"${\" + key + \"}\", resolvedValue);\n        }\n\n        return value;\n    }", "first_line_groundtruth": "circularDefinitionPreventer.throwCircularDefinitionException();", "first_line_prediction": " throw new IllegalArgumentException(\"Circular property definition detected: \" + key);", "match": 0}
{"groundtruth": "( InputStream stream = resource.getInputStream() ) {", "prediction": " (InputStream is = resource.openStream()) {\n                Properties properties = new Properties();\n                properties.load( is );\n                for ( String key : properties.stringPropertyNames() ) {\n                    String value = properties.getProperty( key );\n                    if ( keyPrefix != null ) {\n                        key = keyPrefix + \".\" + key;\n                    }\n                    resolver.setProperty( key, value );\n                }\n            }\n        } catch ( IOException e ) {\n            missing( resource );\n        }\n    }\n\n    private void missing( Resource resource ) throws MojoExecutionException {\n        if ( quiet ) {\n            getLog().debug( \"Skipping loading properties", "first_line_groundtruth": "( InputStream stream = resource.getInputStream() ) {", "first_line_prediction": " (InputStream is = resource.openStream()) {", "match": 0}
{"groundtruth": "newValue = getPropertyValue(newKey, mavenProjectProperties, environment, circularDefinitionPreventer.cloneWithAdditionalKey(key));", "prediction": " newValue = getPropertyValue(newKey, mavenProjectProperties, environment, circularDefinitionPreventer);\n            if (newValue == null) {\n                return null;\n            }\n            buffer.replaceWith(newValue);\n        }\n\n        return buffer.toString();\n    }\n\n    private String fromPropertiesThenSystemThenEnvironment(String key, Properties mavenProjectProperties, Properties environment) {\n        String value = mavenProjectProperties.getProperty(key);\n        if (value != null) {\n            return value;\n        }\n        value = System.getProperty(key);\n        if (value != null) {\n            return value;\n        }\n        value = environment.getProperty", "first_line_groundtruth": "newValue = getPropertyValue(newKey, mavenProjectProperties, environment, circularDefinitionPreventer.cloneWithAdditionalKey(key));", "first_line_prediction": " newValue = getPropertyValue(newKey, mavenProjectProperties, environment, circularDefinitionPreventer);", "match": 0}
{"groundtruth": "circularDefinitionPreventer.isPropertyAlreadyVisited(key)) {", "prediction": "circularDefinitionPreventer.isPropertyAlreadyVisited(key)) {\n            return key;\n        }\n\n        String value = mavenProjectProperties.getProperty(key);\n        if (value == null) {\n            value = environment.getProperty(key);\n        }\n\n        if (value == null) {\n            return key;\n        }\n\n        if (value.startsWith(\"${\")) {\n            String resolvedValue = resolveProperty(value, mavenProjectProperties, environment, circularDefinitionPreventer);\n            if (resolvedValue != null) {\n                return resolvedValue;\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Resolves a property value", "first_line_groundtruth": "circularDefinitionPreventer.isPropertyAlreadyVisited(key)) {", "first_line_prediction": "circularDefinitionPreventer.isPropertyAlreadyVisited(key)) {", "match": 1}
{"groundtruth": "size = queryResult.getValueListSize();", "prediction": " count = 0;\n          while (queryResult.next()) {\n            count++;\n            if (count % batch_size == 0) {\n              Instant statementStartTime = Instant.now();\n              connection.execute(\n                  StringUtils.replaceParameters(statement, values).getStatement());\n              writeStatementEvent(\n                  statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n            }\n          }\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing file: \" + file.getId());\n        writeFileEvent(fileStartTime, file.getId(), Status.FAILURE);\n        throw e", "first_line_groundtruth": "size = queryResult.getValueListSize();", "first_line_prediction": " count = 0;", "match": 0}
{"groundtruth": "(file.getStatements().size() != 1) {", "prediction": " (queryResult != null) {\n        queryResult.close();\n      }\n\n      for (StatementExec statement : file.getStatements()) {\n        Instant statementStartTime = Instant.now();\n\n        if (queryResult == null) {\n          queryResult = connection.executeQuery(statement.getSql());\n        }\n\n        while (queryResult.next()) {\n          if (batch_size > 1) {\n            for (int i = 0; i < batch_size; i++) {\n              if (queryResult.next()) {\n                // do nothing\n              } else {\n                break;\n              }\n            }\n          } else {\n           ", "first_line_groundtruth": "(file.getStatements().size() != 1) {", "first_line_prediction": " (queryResult != null) {", "match": 0}
{"groundtruth": ".putAll(queryResult.getStringMappings(j, localMax));", "prediction": ".put(RESULT, queryResult.getValueList(j, localMax));\n            Instant statementStartTime = Instant.now();\n            connection.executeQuery(\n                StringUtils.replaceParameters(statement, localValues).getStatement());\n            writeStatementEvent(\n                statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n          }\n        }\n      } catch (Exception e) {\n        writeStatementEvent(\n            statement.getStartTime(), statement.getId(), Status.FAILURE, e.getMessage());\n        throw new ClientException(e);\n      } finally {\n        if (queryResult != null) {\n          queryResult.close", "first_line_groundtruth": ".putAll(queryResult.getStringMappings(j, localMax));", "first_line_prediction": ".put(RESULT, queryResult.getValueList(j, localMax));", "match": 0}
{"groundtruth": "statement.getId(),\n                Status.FAILURE,\n                e.getMessage() + \";", "prediction": " statement.getId(),\n                 Status.FAILURE,\n                 new ObjectMapper().writeValueAsString(task.getMetadata()));\n            throw e;\n          }\n          writeStatementEvent(\n              statementStartTime,\n              statement.getId(),\n              Status.SUCCESS,\n              new ObjectMapper().writeValueAsString(task.getMetadata()));\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing file: \" + file.getId());\n        writeStatementEvent(\n            fileStartTime,\n            file.getId(),\n            Status.FAILURE,\n            new ObjectMapper().writeValueAsString(task.getMetadata()));\n        throw e;\n      }\n      writeStatementEvent(\n          fileStartTime,\n          file", "first_line_groundtruth": "statement.getId(),", "first_line_prediction": " statement.getId(),", "match": 0}
{"groundtruth": "statement.getId(), StringUtils.format(statement.getStatement(), parameterValues));", "prediction": " statement.getId(),\n         statement.getStatement(),\n         statement.getStatementType(),\n         statement.getStatementStartTime(),\n         statement.getStatementEndTime(),\n         statement.getStatementStatus(),\n         statement.getStatementPayload(),\n         statement.getStatementDuration(),\n         statement.getStatementResult(),\n         statement.getStatementResultType(),\n         statement.getStatementResultPayload(),\n         statement.getStatementResultDuration(),\n         statement.getStatementResultSize(),\n         statement.getStatementResultRowCount(),\n         statement.getStatementResultColumns(),\n         statement.getStatementResultColumnTypes(),\n         statement.getStatementResultColumnNames(),\n         statement.", "first_line_groundtruth": "statement.getId(), StringUtils.format(statement.getStatement(), parameterValues));", "first_line_prediction": " statement.getId(),", "match": 0}
{"groundtruth": "(prompt.getOption()) {", "prediction": "(prompt.getOption(), prompt.getIndex()) {\n                @Override\n                public String addStatement(String code) {\n                    return prompt.getSnippet().replace(\"{query}\", code);\n                }\n            };\n            actionManager.registerAction(idPrefix + prompt.getIndex(), oldAction);\n            actionGroup.add(oldAction);\n        }\n        popupMenu.add(actionGroup);\n    }\n\n    private void clear(DefaultActionGroup popupMenu, DefaultActionGroup actionGroup) {\n        for (AnAction action : popupMenu.getChildren(null)) {\n            popupMenu.remove(action);\n        }\n        for (AnAction action", "first_line_groundtruth": "(prompt.getOption()) {", "first_line_prediction": "(prompt.getOption(), prompt.getIndex()) {", "match": 0}
{"groundtruth": "if (queryResult == null || queryResult.containsEmptyResultColumnOnly()) {", "prediction": " // Execute second query that uses the iterable input from the first query.\n          for (int i = 0; i < batch_size; i++) {\n            Instant statementStartTime = Instant.now();\n            queryResult =\n                connection.executeQuery(\n                    StringUtils.replaceParameters(statement, values).getStatement());\n            writeStatementEvent(\n                statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n          }\n        } else {\n          // Execute second query that uses the iterable input from the first query.\n          Instant statementStartTime = Instant.now();\n          queryResult =\n              connection.executeQuery(\n                  StringUtils.", "first_line_groundtruth": "if (queryResult == null || queryResult.containsEmptyResultColumnOnly()) {", "first_line_prediction": " // Execute second query that uses the iterable input from the first query.", "match": 0}
{"groundtruth": "().anyMatch(prompt -> prompt.getOption().equals(o.getOption()))) {", "prediction": "().anyMatch(prompt -> prompt.getOption().equals(o.getOption()) || Objects.equals(prompt.getIndex(),o.getIndex()))) {\n            return false;\n        }\n        return prompts.add(o);\n    }\n\n    public void remove(Prompt o) {\n        prompts.remove(o);\n    }\n\n    public void remove(int index) {\n        prompts.remove(index);\n    }\n\n    public void remove(String option) {\n        prompts.removeIf(next -> next.getOption().equals(option));\n    }\n\n    public void remove(String option, int index) {\n        prompts", "first_line_groundtruth": "().anyMatch(prompt -> prompt.getOption().equals(o.getOption()))) {", "first_line_prediction": "().anyMatch(prompt -> prompt.getOption().equals(o.getOption()) || Objects.equals(prompt.getIndex(),o.getIndex()))) {", "match": 0}
{"groundtruth": "+ statement.getId());", "prediction": " + statement.getId());\n            writeStatementEvent(\n                statementStartTime, statement.getId(), Status.FAILURE, /* payload= */ null);\n            throw e;\n          }\n          writeStatementEvent(\n              statementStartTime, statement.getId(), Status.SUCCESS, /* payload= */ null);\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing file: \" + file.getId());\n        writeFileEvent(fileStartTime, file.getId(), Status.FAILURE);\n        throw e;\n      }\n      writeFileEvent(fileStartTime, file.getId(), Status.SUCCESS);\n    }\n  }\n\n  protected void write", "first_line_groundtruth": "+ statement.getId());", "first_line_prediction": " + statement.getId());", "match": 0}
{"groundtruth": "(rowIndex).setSnippet(str);", "prediction": "(rowIndex).setSnippet(str);\n                }\n            } else {\n                //\u5220\u9664prompts\u4e2d\u7684\u503c\n                prompts.remove(rowIndex);\n            }\n            promptTableModel.fireTableDataChanged();\n        }\n\n        @Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (columnIndex == NAME_COLUMN) {\n                return prompts.get(rowIndex).getOption();\n            } else if (columnIndex == VALUE_COLUMN) {\n                return prompts.get(rowIndex).getSnippet();\n            }\n            return null;\n        }\n\n        @Override\n        public String getColumnName(int column) {\n            if", "first_line_groundtruth": "(rowIndex).setSnippet(str);", "first_line_prediction": "(rowIndex).setSnippet(str);", "match": 1}
{"groundtruth": "file.getId(),\n            Status.FAILURE,\n            /* payload= */ e.getMessage() + \";", "prediction": "0,\n            Status.FAILURE,\n            new ObjectMapper().writeValueAsString(queryResult));\n        throw e;\n      } finally {\n        telemetryRegistry.flush();\n      }\n    }\n  }", "first_line_groundtruth": "file.getId(),", "first_line_prediction": "0,", "match": 0}
{"groundtruth": "stringStringHashMap.put(prompt.getOption(), prompt.getSnippet());", "prediction": " stringStringHashMap.put(prompt.getOption(), prompt.getSnippet());\n        }\n        return stringStringHashMap;\n    }\n\n    public void clear() {\n        prompts.clear();\n    }\n\n    public void remove(Prompt o) {\n        prompts.remove(o);\n    }\n\n    public void remove(int index) {\n        prompts.remove(index);\n    }\n\n    public void remove(String option) {\n        prompts.removeIf(prompt -> prompt.getOption().equals(option));\n    }\n\n    public void removeAll(List<Prompt> prompts) {\n        prompts.forEach(this::remove", "first_line_groundtruth": "stringStringHashMap.put(prompt.getOption(), prompt.getSnippet());", "first_line_prediction": " stringStringHashMap.put(prompt.getOption(), prompt.getSnippet());", "match": 0}
{"groundtruth": "readValue(StringUtils.replaceEnvVars(new File(filePath)), objectType);", "prediction": "readValue(replaceEnvVars(new File(filePath)), objectType);\n  }", "first_line_groundtruth": "readValue(StringUtils.replaceEnvVars(new File(filePath)), objectType);", "first_line_prediction": "readValue(replaceEnvVars(new File(filePath)), objectType);", "match": 0}
{"groundtruth": ".put(prompt.getOption(), prompt.getSnippet());", "prediction": ".put(prompt.getOption(), prompt.getSnippet());\n        }\n        return stringStringHashMap;\n    }\n\n    public void clear() {\n        prompts.clear();\n    }\n\n    public void remove(Prompt o) {\n        prompts.remove(o);\n    }\n\n    public void remove(int index) {\n        prompts.remove(index);\n    }\n\n    public void remove(String option) {\n        prompts.removeIf(prompt -> prompt.getOption().equals(option));\n    }\n\n    public void removeAll(List<Prompt> prompts) {\n        prompts.forEach(this::remove);\n    }", "first_line_groundtruth": ".put(prompt.getOption(), prompt.getSnippet());", "first_line_prediction": ".put(prompt.getOption(), prompt.getSnippet());", "match": 1}
{"groundtruth": "getId(), StringUtils.format(statement.getStatement(), parameterValues));", "prediction": "getId(),\n        statement.getStatement(),\n        statement.getStatementType(),\n        statement.getStatementStartTime(),\n        statement.getStatementEndTime(),\n        statement.getStatementStatus(),\n        statement.getStatementPayload(),\n        statement.getStatementDuration(),\n        statement.getStatementResult(),\n        statement.getStatementResultType(),\n        statement.getStatementResultPayload(),\n        statement.getStatementResultDuration(),\n        statement.getStatementResultSize(),\n        statement.getStatementResultRowCount(),\n        statement.getStatementResultColumns(),\n        statement.getStatementResultColumnTypes(),\n        statement.getStatementResultColumnNames(),\n        statement.getStatement", "first_line_groundtruth": "getId(), StringUtils.format(statement.getStatement(), parameterValues));", "first_line_prediction": "getId(),", "match": 0}
{"groundtruth": "stream().anyMatch(prompt -> prompt.getOption().equals(o.getOption()))) {", "prediction": "stream().anyMatch(prompt -> prompt.getOption().equals(o.getOption()) || Objects.equals(prompt.getIndex(),o.getIndex()))) {\n            return false;\n        }\n        return prompts.add(o);\n    }\n\n    public void remove(Prompt o) {\n        prompts.remove(o);\n    }\n\n    public void remove(int index) {\n        prompts.remove(index);\n    }\n\n    public void remove(String option) {\n        prompts.removeIf(next -> next.getOption().equals(option));\n    }\n\n    public void remove(String option, int index) {\n        promp", "first_line_groundtruth": "stream().anyMatch(prompt -> prompt.getOption().equals(o.getOption()))) {", "first_line_prediction": "stream().anyMatch(prompt -> prompt.getOption().equals(o.getOption()) || Objects.equals(prompt.getIndex(),o.getIndex()))) {", "match": 0}
{"groundtruth": "prompts.get(rowIndex).setOption(str);", "prediction": " prompts.get(rowIndex).setOption(str);\n                } else {\n                    prompts.get(rowIndex).setSnippet(str);\n                }\n                promptTableModel.fireTableDataChanged();\n            }\n        }\n\n        @Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (columnIndex == NAME_COLUMN) {\n                return prompts.get(rowIndex).getOption();\n            } else {\n                return prompts.get(rowIndex).getSnippet();\n            }\n        }\n\n        @Override\n        public String getColumnName(int columnIndex) {\n            if (columnIndex == NAME_COLUMN) {\n                return \"", "first_line_groundtruth": "prompts.get(rowIndex).setOption(str);", "first_line_prediction": " prompts.get(rowIndex).setOption(str);", "match": 0}
{"groundtruth": "actionManager.unregisterAction(idPrefix + prompt.getOption());", "prediction": " actionManager.unregisterAction(idPrefix + prompt.getOption());\n            }\n            BasePilotPluginAction newAction = new BasePilotPluginAction(prompt.getOption(), prompt.getIndex()) {\n                @Override\n                public String addStatement(String code) {\n                    return prompt.getSnippet().replace(\"{query}\", code);\n                }\n            };\n            actionManager.registerAction(idPrefix + prompt.getIndex(), newAction);\n            actionGroup.add(newAction);\n        }\n        popupMenu.add(actionGroup);\n    }\n\n    private void clear(DefaultActionGroup popupMenu, DefaultActionGroup actionGroup) {\n        for (", "first_line_groundtruth": "actionManager.unregisterAction(idPrefix + prompt.getOption());", "first_line_prediction": " actionManager.unregisterAction(idPrefix + prompt.getOption());", "match": 0}
{"groundtruth": "appSettingsStorage.unregisterActions();", "prediction": " appSettingsStorage.loadState(state);\n    }\n\n    @Override\n    public void reset() {\n        appSettingsStorage.loadState(state);\n        form.reset(state);\n    }\n\n    @Override\n    public void disposeUIResources() {\n        form = null;\n    }", "first_line_groundtruth": "appSettingsStorage.unregisterActions();", "first_line_prediction": " appSettingsStorage.loadState(state);", "match": 0}
{"groundtruth": "(idPrefix + prompt.getOption());", "prediction": "(idPrefix + prompt.getIndex());\n            if (oldAction != null) {\n                popupMenu.remove(oldAction);\n            }\n            BasePilotPluginAction newAction = new BasePilotPluginAction(prompt.getOption(), prompt.getIndex()) {\n                @Override\n                public String addStatement(String code) {\n                    return prompt.getSnippet().replace(\"{query}\", code);\n                }\n            };\n            actionManager.registerAction(idPrefix + prompt.getIndex(), newAction);\n            popupMenu.add(newAction);\n        }\n    }\n\n    private void clear(DefaultActionGroup popupMenu, DefaultActionGroup actionGroup)", "first_line_groundtruth": "(idPrefix + prompt.getOption());", "first_line_prediction": "(idPrefix + prompt.getIndex());", "match": 0}
{"groundtruth": "ddlFileStatements = SQLParser.getStatements(ddlFile).getStatements();", "prediction": " ddlStatements = SQLParser.getStatements(ddlFile).getStatements();\n      for (StatementExec statement : ddlStatements) {\n        statement.setParameters(parameterValues);\n        connection.execute(statement);\n      }\n    }\n  }\n\n  public void writeFileEvent(Instant startTime, String fileId, Status status) {\n    eventsStream.add(new EventInfo(startTime, fileId, status));\n  }\n\n  public void writeStatementEvent(Instant startTime, String statementId, Status status) {\n    eventsStream.add(new EventInfo(startTime, statementId, status));\n  }\n\n  public void write", "first_line_groundtruth": "ddlFileStatements = SQLParser.getStatements(ddlFile).getStatements();", "first_line_prediction": " ddlStatements = SQLParser.getStatements(ddlFile).getStatements();", "match": 0}
{"groundtruth": "form.getSettings().clone();", "prediction": " form.getState();\n        appSettingsStorage.loadState(state);\n        appSettingsStorage.registerActions();\n    }\n\n    @Override\n    public void reset() {\n        form.importForm(state);\n    }\n\n    @Override\n    public void disposeUIResources() {\n        form = null;\n    }", "first_line_groundtruth": "form.getSettings().clone();", "first_line_prediction": " form.getState();", "match": 0}
{"groundtruth": "connection.execute(currentQuery);", "prediction": " connection.execute(currentQuery);\n      }\n    }\n  }\n\n  public void writeEvent(EventInfo event) {\n    eventsStream.add(event);\n  }\n\n  public void flush() throws ClientException {\n    try (Connection connection = connectionManager.createConnection()) {\n      for (StatementExec statement : insertFileStatements) {\n        connection.execute(statement.getStatement());\n      }\n      for (EventInfo event : eventsStream) {\n        connection.execute(event.getInsertStatement());\n      }\n    }\n    eventsStream.clear();\n  }\n\n  public void close() throws ClientException {\n    flush();\n  }", "first_line_groundtruth": "connection.execute(currentQuery);", "first_line_prediction": " connection.execute(currentQuery);", "match": 0}
{"groundtruth": "task.getTimeTravelPhaseId() != null) {", "prediction": "task.getRuntimeParameters() != null) {\n      for (Map.Entry<String, Object> entry : task.getRuntimeParameters().entrySet()) {\n        values.put(entry.getKey(), entry.getValue());\n      }\n    }\n    return values;\n  }\n\n  private TaskExecutor getTaskExecutor(TaskExec task) {\n    CustomTaskExecutorArguments arguments = task.getArguments();\n    if (arguments == null) {\n      return new TaskExecutor(connectionManager, telemetryRegistry, task);\n    }\n    String executorClassName = arguments.getExecutorClassName();\n    if (StringUtils.isNullOrEmpty(executorClassName)) {\n     ", "first_line_groundtruth": "task.getTimeTravelPhaseId() != null) {", "first_line_prediction": "task.getRuntimeParameters() != null) {", "match": 0}
{"groundtruth": ".forName(task.getCustomTaskExecutor())\n                .getDeclaredConstructor(\n                    SQLTelemetryRegistry.class, String.class, CustomTaskExecutorArguments.class);", "prediction": ".forName(task.getCustomTaskExecutor()).getConstructor(SQLTelemetryRegistry.class, String.class);\n        return (TaskExecutor) constructor.newInstance(this.telemetryRegistry, this.experimentStartTime);\n      } catch (Exception e) {\n        throw new RuntimeException(\"Unable to instantiate custom task executor: \" + task.getCustomTaskExecutor(), e);\n      }\n    }\n  }\n\n  private void writeTaskEvent(Instant startTime, String taskId, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.builder()\n            .eventType(EventType.TASK)\n            .status(status)\n            .startTime(", "first_line_groundtruth": ".forName(task.getCustomTaskExecutor())", "first_line_prediction": ".forName(task.getCustomTaskExecutor()).getConstructor(SQLTelemetryRegistry.class, String.class);", "match": 0}
{"groundtruth": "+ task.getId());", "prediction": " + task.getId());\n          writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE, e.getMessage() + \"; \" + e.getStackTrace());\n          throw e;\n        }\n        Instant taskEndTime = Instant.now();\n        writeTaskEvent(taskStartTime, task.getId(), Status.SUCCESS);\n        writeTaskEvent(taskStartTime, task.getId(), Status.SUCCESS, taskEndTime.until(taskStartTime, ChronoUnit.MILLIS));\n        writeTaskEvent(taskStartTime, task.getId(), Status.SUCCESS, taskEndTime.until(taskStartTime, ChronoUnit.SECONDS));\n       ", "first_line_groundtruth": "+ task.getId());", "first_line_prediction": " + task.getId());", "match": 0}
{"groundtruth": "\"Unable to load custom task class: \" + task.getCustomTaskExecutor(), e);", "prediction": " \"Invalid custom task executor: \" + task.getCustomTaskExecutor(), e);\n      }\n    }\n  }\n\n  private void writeTaskEvent(Instant startTime, String taskId, Status status) {\n    EventInfo eventInfo =\n        ImmutableEventInfo.builder()\n            .withEventType(EventType.TASK)\n            .withStartTime(startTime)\n            .withEndTime(Instant.now())\n            .withStatus(status)\n            .withTaskId(taskId)\n            .build();\n    this.telemetryRegistry.writeEvent(eventInfo);\n  }\n\n  private void writeSessionEvent(Instant startTime, String sessionId, Status status) {\n   ", "first_line_groundtruth": "\"Unable to load custom task class: \" + task.getCustomTaskExecutor(), e);", "first_line_prediction": " \"Invalid custom task executor: \" + task.getCustomTaskExecutor(), e);", "match": 0}
{"groundtruth": "return instance.getState();", "prediction": " return instance.getState();\n    }\n\n    public static void addDefaultPrompts(Prompts prompts) {\n        prompts.addPrompt(\"print\", 0);\n        prompts.addPrompt(\"print\", 1);\n        prompts.addPrompt(\"print\", 2);\n        prompts.addPrompt(\"print\", 3);\n        prompts.addPrompt(\"print\", 4);\n        prompts.addPrompt(\"print\", 5);\n        prompts.addPrompt(\"print\", 6);\n        prompts.addPrompt(\"print\", 7);\n        prompts.addPrompt(\"print", "first_line_groundtruth": "return instance.getState();", "first_line_prediction": " return instance.getState();", "match": 0}
{"groundtruth": ", eventInfo.getEndTime()));", "prediction": ", Instant.now()));\n          eventInfo = writePhaseEvent(phaseStartTime, phase.getId(), Status.SUCCESS);\n          phaseIdToEndTime.put(phase.getId(), Instant.now());\n        }\n        // Write experiment end event\n        writeExperimentEvent(repetitionStartTime, experimentMetadata, Status.SUCCESS);\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing experiment: \" + config.getId());\n        writeExperimentEvent(repetitionStartTime, experimentMetadata, Status.FAILURE);\n        throw e;\n      } finally {\n        if (executor != null) {\n          executor.shutdown();\n          try {\n           ", "first_line_groundtruth": ", eventInfo.getEndTime()));", "first_line_prediction": ", Instant.now()));", "match": 0}
{"groundtruth": "if (phase.getSessions().size() > maxConcurrentSessions) {", "prediction": " maxConcurrentSessions = Math.max(maxConcurrentSessions, phase.getSessions().size());\n    }\n    ExecutorService executorService = Executors.newFixedThreadPool(maxConcurrentSessions);\n    List<Future<SessionExec>> futures = new ArrayList<>();\n    for (PhaseExec phase : workload.getPhases()) {\n      for (SessionExec session : phase.getSessions()) {\n        futures.add(\n            executorService.submit(\n                () -> {\n                  try {\n                    return session.execute();\n                  } catch (Exception e) {\n                    throw new RuntimeException(e);\n                  }\n                }));\n      }\n    }\n    for (Future<", "first_line_groundtruth": "if (phase.getSessions().size() > maxConcurrentSessions) {", "first_line_prediction": " maxConcurrentSessions = Math.max(maxConcurrentSessions, phase.getSessions().size());", "match": 0}
{"groundtruth": "writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE);", "prediction": " writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE, e.getMessage() + \"; \" + e.getStackTrace());\n          throw e;\n        }\n        writeTaskEvent(taskStartTime, task.getId(), Status.SUCCESS, /* payload= */ null);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"Exception executing session: \" + session.getId());\n      writeSessionEvent(sessionStartTime, Status.FAILURE, e.getMessage() + \"; \" + e.getStackTrace());\n      throw e;\n    }\n    writeSessionEvent(sessionStartTime, Status.SUCCESS, /* payload= */", "first_line_groundtruth": "writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE);", "first_line_prediction": " writeTaskEvent(taskStartTime, task.getId(), Status.FAILURE, e.getMessage() + \"; \" + e.getStackTrace());", "match": 0}
{"groundtruth": ".info(\"Running \" + phase.getId() + \" phase...\");", "prediction": ".info(\"Starting phase: {}\", phase.getId());\n          final Instant phaseStartTime = Instant.now();\n          final List<Future<Boolean>> futures = new ArrayList<>();\n          for (SessionExec session : phase.getSessions()) {\n            futures.add(\n                executor.submit(\n                    new SessionExecutor(\n                        connectionManagers,\n                        config,\n                        telemetryRegistry,\n                        session,\n                        runtimeParameterValues,\n                        phaseIdToEndTime)));\n          }\n          for (Future<Boolean> future : futures) {\n            try {\n              future.get(config.getTimeout(), TimeUnit.SECONDS);\n            } catch (InterruptedException | ExecutionException e)", "first_line_groundtruth": ".info(\"Running \" + phase.getId() + \" phase...\");", "first_line_prediction": ".info(\"Starting phase: {}\", phase.getId());", "match": 0}
{"groundtruth": "settings = AppSettingsStorage.getInstance().getState();", "prediction": " appSettings = AppSettingsStorage.getInstance(project).getAppSettings();\n        GPTClient gptClient = new GPTClient(appSettings.getGptApiKey());\n        List<CompletionChoice> choices = gptClient.complete(statement);\n        if (choices.isEmpty()) {\n            NotifyUtils.notifyMessage(project,\"no result\", NotificationType.INFORMATION);\n            return;\n        }\n        String snippet = choices.get(0).getSnippet();\n        ApplicationManager.getApplication().invokeLater(() -> {\n            CommandProcessor.getInstance().executeCommand(project, () -> {\n                Document document = editor.getDocument();\n               ", "first_line_groundtruth": "settings = AppSettingsStorage.getInstance().getState();", "first_line_prediction": " appSettings = AppSettingsStorage.getInstance(project).getAppSettings();", "match": 0}
{"groundtruth": "String reportFileName = contributionFilesService.getFileName(start, finish);", "prediction": " // @TODO handle empty list\n        return contributionFilesService.processFiles(contributionFiles, start, finish, contributionFilesService.getFileName(start, finish));\n    }", "first_line_groundtruth": "String reportFileName = contributionFilesService.getFileName(start, finish);", "first_line_prediction": " // @TODO handle empty list", "match": 0}
{"groundtruth": "phase.getId(),\n              ChronoUnit.SECONDS.between(phaseStartTime, eventInfo.getEndTime()));", "prediction": " phase.getId(),\n               ChronoUnit.SECONDS.between(phaseStartTime, Instant.now()));\n          eventInfo = writePhaseEvent(phaseStartTime, phase.getId(), Status.SUCCESS);\n          phaseIdToEndTime.put(phase.getId(), Instant.now());\n        }\n        // Write experiment end event\n        writeExperimentEvent(repetitionStartTime, experimentMetadata, Status.SUCCESS);\n      } catch (Exception e) {\n        LOGGER.error(\"Exception executing experiment: \" + config.getId());\n        writeExperimentEvent(repetitionStartTime, experimentMetadata, Status.FAILURE);\n        throw e;\n      } finally {\n        if", "first_line_groundtruth": "phase.getId(),", "first_line_prediction": " phase.getId(),", "match": 0}
{"groundtruth": "(next.getOption()));", "prediction": "(next.getOption()));\n        _prompts.addAll(prompts.getPrompts());\n    }\n\n    public static Prompts addDefaultPrompts(Prompts prompts) {\n        prompts.add(\"yes\", \"yes\");\n        prompts.add(\"no\", \"no\");\n        prompts.add(\"y\", \"yes\");\n        prompts.add(\"n\", \"no\");\n        prompts.add(\"y/n\", \"yes/no\");\n        prompts.add(\"y/n/a\", \"yes/no/abort\");\n        prompts.add(\"y", "first_line_groundtruth": "(next.getOption()));", "first_line_prediction": "(next.getOption()));", "match": 1}
{"groundtruth": ", session.getId(), Status.FAILURE);", "prediction": ", session.getId(), Status.FAILURE);\n      throw e;\n    } finally {\n      telemetryRegistry.flush();\n    }\n    return true;\n  }\n\n  private TaskExecutor getTaskExecutor(TaskExec task) {\n    String taskExecutorClassName = task.getTaskExecutorClassName();\n    try {\n      Class<?> taskExecutorClass = Class.forName(taskExecutorClassName);\n      Constructor<?> taskExecutorConstructor = taskExecutorClass.getConstructor(TaskExec.class);\n      return (TaskExecutor) taskExecutorConstructor.newInstance(task);\n    } catch (Exception e) {\n      throw new RuntimeException(\n          \"Failed to instantiate task executor", "first_line_groundtruth": ", session.getId(), Status.FAILURE);", "first_line_prediction": ", session.getId(), Status.FAILURE);", "match": 1}
{"groundtruth": "fdcFileMapper.processRequest(files.toArray(new String[0]), getFileName(start, finish));", "prediction": " fdcFileMapper.processRequest(files.toArray(new String[0]), start, finish);\n    }\n\n    public String getFileName(LocalDate start, LocalDate finish) {\n        return String.format(FILE_NAME_TEMPLATE, start, finish);\n    }", "first_line_groundtruth": "fdcFileMapper.processRequest(files.toArray(new String[0]), getFileName(start, finish));", "first_line_prediction": " fdcFileMapper.processRequest(files.toArray(new String[0]), start, finish);", "match": 0}
{"groundtruth": "experiment.execute();", "prediction": " experiment.run();\n  }\n\n  /** Create command line options. */\n  private static Options createOptions() {\n    final Options options = new Options();\n    options.addOption(\n        Option.builder(OPT_INPUT_TASK_LIBRARY_FILE)\n            .longOpt(OPT_INPUT_TASK_LIBRARY_FILE)\n            .hasArg()\n            .desc(\"Task library file\")\n            .build());\n    options.addOption(\n        Option.builder(OPT_INPUT_WORKLOAD_FILE)\n            .longOpt(OPT_INPUT_WORKLOAD_FILE)\n            .hasArg()\n            .desc(\"Workload file", "first_line_groundtruth": "experiment.execute();", "first_line_prediction": " experiment.run();", "match": 0}
{"groundtruth": "<String> contributionFiles = contributionFilesService.getFiles(start, finish);", "prediction": "<String> contributionFiles = contributionFilesService.getFiles(start, finish);\n        // @TODO handle empty list\n        return contributionFilesService.processFiles(contributionFiles, start, finish);\n    }", "first_line_groundtruth": "<String> contributionFiles = contributionFilesService.getFiles(start, finish);", "first_line_prediction": "<String> contributionFiles = contributionFilesService.getFiles(start, finish);", "match": 1}
{"groundtruth": "(Prompt.of(\"\u6b65\u9aa4\u6ce8\u91ca\", \"\u5e2e\u6211\u7ed9\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\u7684\u5173\u952e\u6b65\u9aa4\u6dfb\u52a0\u6ce8\u91ca\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u9664\u4e86\u4f18\u5316\u540e\u7684\u4ee3\u7801\uff0c\u4e0d\u8981\u6dfb\u52a0\u4efb\u4f55\u5176\u4ed6\u4fe1\u606f\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{", "prediction": "(Prompt.of(\"Explain\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"Explain\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"Explain\", \"help me add comments to the key steps of the following code", "first_line_groundtruth": "(Prompt.of(\"\u6b65\u9aa4\u6ce8\u91ca\", \"\u5e2e\u6211\u7ed9\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\u7684\u5173\u952e\u6b65\u9aa4\u6dfb\u52a0\u6ce8\u91ca\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u9664\u4e86\u4f18\u5316\u540e\u7684\u4ee3\u7801\uff0c\u4e0d\u8981\u6dfb\u52a0\u4efb\u4f55\u5176\u4ed6\u4fe1\u606f\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{", "first_line_prediction": "(Prompt.of(\"Explain\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));", "match": 0}
{"groundtruth": "contributionFilesService.processFiles(contributionFiles, start, finish, reportFileName);", "prediction": " contributionFilesService.processFiles(contributionFiles, start, finish, reportFileName);\n    }", "first_line_groundtruth": "contributionFilesService.processFiles(contributionFiles, start, finish, reportFileName);", "first_line_prediction": " contributionFilesService.processFiles(contributionFiles, start, finish, reportFileName);", "match": 0}
{"groundtruth": ", phase.getId(), Status.SUCCESS);", "prediction": ", phase.getId(), Status.SUCCESS);\n          } catch (Exception e) {\n            eventInfo = writePhaseEvent(phaseStartTime, phase.getId(), Status.FAILURE);\n            throw e;\n          }\n          phaseIdToEndTime.put(phase.getId(), Instant.now());\n          experimentMetadata.put(phase.getId(), eventInfo);\n        }\n        // Write experiment metadata\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.writeValue(config.getExperimentMetadataFile(), experimentMetadata);\n        // Write experiment summary\n        mapper.writeValue(config.getExperimentSummaryFile(), experimentMetadata);\n        // Write experiment summary\n        mapper.", "first_line_groundtruth": ", phase.getId(), Status.SUCCESS);", "first_line_prediction": ", phase.getId(), Status.SUCCESS);", "match": 1}
{"groundtruth": "( getFdcValue(DateUtils.convertXmlGregorianToString(o),true));", "prediction": " String.format(FDC_FORMAT, (Objects.nonNull(o)?DateUtils.convertXmlGregorianToString(o):EMPTY_CHARACTER));\n    }\n\n    private String getFdcValue(String o){\n        return  String.format(FDC_FORMAT, (Objects.nonNull(o)?o:EMPTY_CHARACTER));\n    }\n\n    private File createCsvFile(String fileName) throws IOException {\n        File file = new File(fileName);\n        if (file.exists()) {\n            file.delete();\n        }\n        file.createNewFile();\n        return file;\n    }\n\n    private void setFilePermissions", "first_line_groundtruth": "( getFdcValue(DateUtils.convertXmlGregorianToString(o),true));", "first_line_prediction": " String.format(FDC_FORMAT, (Objects.nonNull(o)?DateUtils.convertXmlGregorianToString(o):EMPTY_CHARACTER));", "match": 0}
{"groundtruth": "Prompt.of(\"emptyForYou\", \"balabala{", "prediction": "Prompt.of(\"\u4f18\u5316\", \"\u5e2e\u6211\u4f18\u5316\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{query}\"));\n        prompts.add(Prompt.of(\"\u4f18\u5316\u4ee3\u7801\", \"\u5e2e\u6211\u4f18\u5316\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{query}\"));\n        prompts.add(Prompt.of(\"\u4f18\u5316\u4ee3\u7801\u7247\u6bb5\", \"\u5e2e\u6211\u4f18\u5316\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{query}\"));\n        prompts.add(Prompt.of(\"\u4f18\u5316\u4ee3\u7801\u7247\u6bb5\", \"\u5e2e\u6211\u4f18\u5316\u4e0b\u9762\u4e00\u6bb5", "first_line_groundtruth": "Prompt.of(\"emptyForYou\", \"balabala{", "first_line_prediction": "Prompt.of(\"\u4f18\u5316\", \"\u5e2e\u6211\u4f18\u5316\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\uff0c\u8fd4\u56de\u4f18\u5316\u540e\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{query}\"));", "match": 0}
{"groundtruth": "(task.getCustomTaskExecutor() == null) {", "prediction": " (task.getCustomTaskExecutorClass() != null) {\n      try {\n        Class<?> clazz = Class.forName(task.getCustomTaskExecutorClass());\n        Constructor<?> constructor = clazz.getConstructor(CustomTaskExecutorArguments.class);\n        return (TaskExecutor) constructor.newInstance(task.getCustomTaskExecutorArguments());\n      } catch (Exception e) {\n        throw new RuntimeException(\n            \"Failed to instantiate custom task executor class: \"\n                + task.getCustomTaskExecutorClass(),\n            e);\n      }\n    } else {\n      return new TaskExecutor();\n    }\n  }\n\n  private void writeSessionEvent(", "first_line_groundtruth": "(task.getCustomTaskExecutor() == null) {", "first_line_prediction": " (task.getCustomTaskExecutorClass() != null) {", "match": 0}
{"groundtruth": "return fdcFilesService.processFiles(contributionFiles, start, end);", "prediction": " return fdcFilesService.processFiles(\n                contributionFiles,\n                start,\n                end,\n                fdcFilesService.getFileName(start, end)\n         );\n    }", "first_line_groundtruth": "return fdcFilesService.processFiles(contributionFiles, start, end);", "first_line_prediction": " return fdcFilesService.processFiles(", "match": 0}
{"groundtruth": "form.getGptKey();", "prediction": " form.getGptKey();\n    }", "first_line_groundtruth": "form.getGptKey();", "first_line_prediction": " form.getGptKey();", "match": 0}
{"groundtruth": "add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet:{", "prediction": "addPrompt(Prompt.of(\"test\", \"test\"));\n        prompts.addPrompt(Prompt.of(\"test2\", \"test2\"));\n        prompts.addPrompt(Prompt.of(\"test3\", \"test3\"));\n        prompts.addPrompt(Prompt.of(\"test4\", \"test4\"));\n        prompts.addPrompt(Prompt.of(\"test5\", \"test5\"));\n        prompts.addPrompt(Prompt.of(\"test6\", \"test6\"));\n        prompts.addPrompt(Prompt.of(\"test7\", \"test7\"));\n        prompts.addPrompt(Prompt", "first_line_groundtruth": "add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet:{", "first_line_prediction": "addPrompt(Prompt.of(\"test\", \"test\"));", "match": 0}
{"groundtruth": ".add(Prompt.of(\"List Steps\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. without adding any additional information except for the optimized code. Here is the code snippet:{", "prediction": ".add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet", "first_line_groundtruth": ".add(Prompt.of(\"List Steps\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. without adding any additional information except for the optimized code. Here is the code snippet:{", "first_line_prediction": ".add(Prompt.of(\"Readable\", \"help me enhance the readability of the following code snippet, without adding any additional information except for the optimized code. Here is the code snippet:{query}\"));", "match": 0}
{"groundtruth": ".add(Prompt.of(\"Explain\", \"\u5e2e\u6211\u589e\u5f3a\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\u5427\uff0c\u9664\u4e86\u4f18\u5316\u540e\u7684\u4ee3\u7801\uff0c\u4e0d\u8981\u6dfb\u52a0\u4efb\u4f55\u5176\u4ed6\u4fe1\u606f\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{", "prediction": ".add(Prompt.of(\"List Steps with Comments\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"List Steps with Comments and Comments\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. Here is the code snippet:{query}\"));\n        prompts.add(Prompt.of(\"List Steps with Comments and Comments and Comments\", \"help me add comments to the key steps of the following code snippet and return the optimized", "first_line_groundtruth": ".add(Prompt.of(\"Explain\", \"\u5e2e\u6211\u589e\u5f3a\u4e0b\u9762\u4e00\u6bb5\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\u5427\uff0c\u9664\u4e86\u4f18\u5316\u540e\u7684\u4ee3\u7801\uff0c\u4e0d\u8981\u6dfb\u52a0\u4efb\u4f55\u5176\u4ed6\u4fe1\u606f\uff0c\u8fd9\u662f\u4ee3\u7801\u7247\u6bb5\uff1a{", "first_line_prediction": ".add(Prompt.of(\"List Steps with Comments\", \"help me add comments to the key steps of the following code snippet and return the optimized code with comments. Here is the code snippet:{query}\"));", "match": 0}
{"groundtruth": "(AppSettings.getProject(), \"Test connection failed!\", NotificationType.ERROR);", "prediction": "(AppSettings.getProject(), \"Test connection failed!ChatGPT answer:\" + GPTClient.toString(choices), NotificationType.ERROR);\n            }\n        });\n    }\n\n    private boolean checkSettings() {\n        if (StringUtils.isBlank(gptKey.getText())) {\n            NotifyUtils.notifyMessage(AppSettings.getProject(), \"Please input your OpenAI API key\", NotificationType.ERROR);\n            return true;\n        }\n        if (StringUtils.isBlank(gptModel.getText())) {\n            NotifyUtils.notifyMessage(AppSettings.getProject(), \"Please input your OpenAI model\", NotificationType.ERROR);\n            return true", "first_line_groundtruth": "(AppSettings.getProject(), \"Test connection failed!\", NotificationType.ERROR);", "first_line_prediction": "(AppSettings.getProject(), \"Test connection failed!ChatGPT answer:\" + GPTClient.toString(choices), NotificationType.ERROR);", "match": 0}
{"groundtruth": "String, String> stringStringMap = prompts.asMap();", "prediction": "String, String> map = prompts.asMap();\n        for (Prompt prompt : _prompts) {\n            prompt.setOption(map.get(prompt.getOption()));\n            prompt.setSnippet(map.get(prompt.getSnippet()));\n        }\n    }\n\n    public static Prompts addDefaultPrompts(Prompts prompts) {\n        Map<String, String> map = prompts.asMap();\n        map.put(\"query\", \"query\");\n        map.put(\"query_id\", \"query_id\");\n        map.put(\"query_name\", \"query_name", "first_line_groundtruth": "String, String> stringStringMap = prompts.asMap();", "first_line_prediction": "String, String> map = prompts.asMap();", "match": 0}
{"groundtruth": "gptKeyLink = ActionLinkUtils.newActionLink(\"https://platform.openai.com/account/api-keys\");", "prediction": "", "first_line_groundtruth": "gptKeyLink = ActionLinkUtils.newActionLink(\"https://platform.openai.com/account/api-keys\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "notifyMessage(AppSettings.getProject(), \"Test connection successfully!ChatGPT answer:\" + GPTClient.toString(choices), NotificationType.INFORMATION);", "prediction": "notifySuccess(\"GPT\u6d4b\u8bd5\u6210\u529f\", \"GPT\u6d4b\u8bd5\u6210\u529f\");\n            } else {\n                NotifyUtils.notifyError(\"GPT\u6d4b\u8bd5\u5931\u8d25\", \"GPT\u6d4b\u8bd5\u5931\u8d25\");\n            }\n        });\n    }\n\n    private boolean checkSettings() {\n        if (StringUtils.isBlank(gptKey.getText())) {\n            NotifyUtils.notifyError(\"GPT API Key\u4e0d\u80fd\u4e3a\u7a7a\", \"GPT API Key\u4e0d\u80fd\u4e3a\u7a7a\");\n            return true;\n        }\n        if (StringUtils.isBlank(gptModel.getText())) {\n            NotifyUtils.notifyError(\"GPT Model\u4e0d\u80fd\u4e3a\u7a7a\", \"GPT Model\u4e0d\u80fd\u4e3a\u7a7a\");\n            return true;\n        }\n       ", "first_line_groundtruth": "notifyMessage(AppSettings.getProject(), \"Test connection successfully!ChatGPT answer:\" + GPTClient.toString(choices), NotificationType.INFORMATION);", "first_line_prediction": "notifySuccess(\"GPT\u6d4b\u8bd5\u6210\u529f\", \"GPT\u6d4b\u8bd5\u6210\u529f\");", "match": 0}
{"groundtruth": "= original.clone();", "prediction": " = original;\n        this.promptsTable = new PromptsTable();\n        this.promptsTable.prompts.addAll(original.prompts.getPrompts());\n        this.promptsTable.settings = original;\n        this.promptsTable.setColumnWidths();\n        this.promptsPane.add(promptsTable.rootPane, BorderLayout.CENTER);\n        this.promptsPane.revalidate();\n        this.promptsPane.repaint();\n        this.promptsTable.addDoubleClickListener(new DoubleClickListener() {\n           ", "first_line_groundtruth": "= original.clone();", "first_line_prediction": " = original;", "match": 0}
{"groundtruth": "campaign.getGames().get(id));", "prediction": "campaign.getGame());\n                updateToCampaign.setDiscountAmount(campaign.getDiscountAmount());\n                updateToCampaign.setDayTime(campaign.getDayTime());\n                System.out.println(\"Campaign updated\");\n            }\n        }\n    }\n\n    @Override\n    public List<Campaign> getCampaigns() {\n        return campaigns;\n    }", "first_line_groundtruth": "campaign.getGames().get(id));", "first_line_prediction": "campaign.getGame());", "match": 0}
{"groundtruth": "setBirthYear(customer.getBirthYear());", "prediction": "setTc(customer.getTc());\n                userToUpdate.setBirthYear(customer.getBirthYear());\n                userToUpdate.setAddress(customer.getAddress());\n                userToUpdate.setPhone(customer.getPhone());\n                userToUpdate.setGender(customer.getGender());\n                userToUpdate.setRole(customer.getRole());\n                userToUpdate.setGames(customer.getGames());\n                break;\n            }\n        }\n    }", "first_line_groundtruth": "setBirthYear(customer.getBirthYear());", "first_line_prediction": "setTc(customer.getTc());", "match": 0}
{"groundtruth": "append(\"\\n    <string name=\\\"\" + singleStrings.getId() + \"\\\">\" + singleStrings.getValue() + \"</string>\");", "prediction": "append(\"\\n<string name=\\\"\" + singleStrings.getId() + \"\\\">\" + singleStrings.getValue() + \"</string>\");\n                    FileUtils.replaceContentToFile(file.getPath(), oldContent.toString());\n                }\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            } finally {\n                FileUtils.closeQuietly(is);\n            }\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n\n        showHint(sb.toString());\n    }\n\n    private void showHint(String message) {\n        Notifications.Bus.notify(new Notification(\"\u63d0\u793a\", \"\u63d0\u793a\", message,", "first_line_groundtruth": "append(\"\\n    <string name=\\\"\" + singleStrings.getId() + \"\\\">\" + singleStrings.getValue() + \"</string>\");", "first_line_prediction": "append(\"\\n<string name=\\\"\" + singleStrings.getId() + \"\\\">\" + singleStrings.getValue() + \"</string>\");", "match": 0}
{"groundtruth": "println(user2.getName() +\" is updated to \" + customer.getName());", "prediction": "println(\"User: \" + user2.getId() + \" is updated.\");\n                userToUpdate = user2;\n                break;\n            }\n        }\n        if (userToUpdate == null) {\n            System.out.println(\"User is not in database.\");\n        } else {\n            userToUpdate.setName(customer.getName());\n            userToUpdate.setSurName(customer.getSurName());\n            userToUpdate.setBirthYear(customer.getBirthYear());\n            userToUpdate.setTc(customer.getTc());\n        }\n    }", "first_line_groundtruth": "println(user2.getName() +\" is updated to \" + customer.getName());", "first_line_prediction": "println(\"User: \" + user2.getId() + \" is updated.\");", "match": 0}
{"groundtruth": "if(campaign1.getId()==id){", "prediction": " if(campaign1.getId() == id){\n                 updateToCampaign = campaign1;\n             }\n        }\n        if(updateToCampaign != null){\n            updateToCampaign.setPrice(campaign.getPrice());\n            updateToCampaign.setDuration(campaign.getDuration());\n            updateToCampaign.setGame(campaign.getGame());\n            System.out.println(\"Campaign updated\");\n        }else{\n            System.out.println(\"Campaign not found\");\n        }\n    }\n\n    @Override\n    public List<Campaign> getCampaigns() {\n        return campaigns;\n    }", "first_line_groundtruth": "if(campaign1.getId()==id){", "first_line_prediction": " if(campaign1.getId() == id){", "match": 0}
{"groundtruth": "(campaign.getId() == id){", "prediction": "(campaign.getId() == id){\n                campaigns.remove(campaign);\n                System.out.println(\"Campaign deleted\");\n            }\n        }\n    }\n\n    @Override\n    public void updateCampaign(int id, Campaign campaign) {\n        for (Campaign campaign2 : campaigns) {\n            if(campaign2.getId() == id){\n                campaigns.remove(campaign2);\n                campaigns.add(campaign);\n                System.out.println(\"Campaign updated\");\n            }\n        }\n    }\n\n    @Override\n    public List<Campaign> getCampaigns() {\n        return campaigns;\n    }", "first_line_groundtruth": "(campaign.getId() == id){", "first_line_prediction": "(campaign.getId() == id){", "match": 1}
{"groundtruth": "\"\\\"=\\\"\" + string.getValue() + \"\\\";", "prediction": " \"\\\" = \\\"\"+string.getValue()+\"\\\";\");\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        if (is != null) {\n                            is.close();\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \u626b\u63cf.m\u6587\u4ef6\n     * @param is\n     * @param fileName\n     * @param oldContent\n     * @return\n     */\n    private List<StringEntity> extraClassEntity(InputStream is, String fileName, StringBuilder oldContent,Map<String,", "first_line_groundtruth": "\"\\\"=\\\"\" + string.getValue() + \"\\\";", "first_line_prediction": " \"\\\" = \\\"\"+string.getValue()+\"\\\";\");", "match": 0}
{"groundtruth": "!(customer.getGames().contains(game))){", "prediction": "game.getCountOwner()==campaignService.getCampaigns().size()){\n            game.setCountOwner(0);\n            campaignService.getCampaigns().remove(campaignService.getCampaigns().stream().findFirst().get());\n            System.out.println(\"Campaign deleted\");\n        }\n    }", "first_line_groundtruth": "!(customer.getGames().contains(game))){", "first_line_prediction": "game.getCountOwner()==campaignService.getCampaigns().size()){", "match": 0}
{"groundtruth": "while (iterator.temProximo()) {", "prediction": "\n\t\twhile (iterator.temProximo()) {\n\t\t\tSystem.out.println(iterator.proximo());\n\t\t\titerator.proximo();\n\t\t}", "first_line_groundtruth": "while (iterator.temProximo()) {", "first_line_prediction": "", "match": 0}
{"groundtruth": ".println(playlist1.execute());", "prediction": ".println(\"Musica original: \" + musicaComNotaLetraOriginal.getNome());\n\t\tSystem.out.println(\"Musica traduzida: \" + musicaComNotaLetraOriginalTraduzida.getNome());\n\t\tSystem.out.println(\"Musica somente com nota: \" + musicaSomenteComNota.getNome());\n\t\tSystem.out.println(\"Musica com nota traduzida: \" + musicaComNotaLetraOriginalTraduzida.getNome());", "first_line_groundtruth": ".println(playlist1.execute());", "first_line_prediction": ".println(\"Musica original: \" + musicaComNotaLetraOriginal.getNome());", "match": 0}
{"groundtruth": "listener.onChangeMode();", "prediction": "\tlistener.onChangeMode();\n\t\t}", "first_line_groundtruth": "listener.onChangeMode();", "first_line_prediction": "\tlistener.onChangeMode();", "match": 0}
{"groundtruth": "= playlistItem.execute();", "prediction": " = playlistItem.execute();", "first_line_groundtruth": "= playlistItem.execute();", "first_line_prediction": " = playlistItem.execute();", "match": 0}
{"groundtruth": "playlist1.insert(playlist2);", "prediction": "\n\t\tPlaylist playlist3 = new Playlist(\"Minha playlist 3\");\n\t\tplaylist3.insert(musicaComNotaLetraOriginalTraduzida);\n\t\tplaylist3.insert(musicaComNotaLetraOriginal);", "first_line_groundtruth": "playlist1.insert(playlist2);", "first_line_prediction": "", "match": 0}
{"groundtruth": "iterator = player.createIterator();", "prediction": "\tSystem.out.println(\"Modo repetido\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tplayer.setMode(PlayerMode.PlayerAll);\n\t\t\t\t\tSystem.out.println(\"Modo player\");\n\t\t\t}\n\t\t}", "first_line_groundtruth": "iterator = player.createIterator();", "first_line_prediction": "\tSystem.out.println(\"Modo repetido\");", "match": 0}
{"groundtruth": "playlistItem = iterator.proximo();", "prediction": " item = iterator.proximo();\n\t\t\tSystem.out.println(item.toString());", "first_line_groundtruth": "playlistItem = iterator.proximo();", "first_line_prediction": " item = iterator.proximo();", "match": 0}
{"groundtruth": "(\"\\n::::::::::::\\nModo: %s, est\u00e1 ativado!\\n\", player.getMode());", "prediction": "(\"Modem alterada para %s\\n\", player.getMode());", "first_line_groundtruth": "(\"\\n::::::::::::\\nModo: %s, est\u00e1 ativado!\\n\", player.getMode());", "first_line_prediction": "(\"Modem alterada para %s\\n\", player.getMode());", "match": 0}
{"groundtruth": "player.createIterator();", "prediction": " player.createIterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next().getNome());\n\t\t}", "first_line_groundtruth": "player.createIterator();", "first_line_prediction": " player.createIterator();", "match": 0}
{"groundtruth": "MessageUtils.showNotify(\"\u8bf7\u9009\u62e9\u5e03\u5c40\u6587\u4ef6\");", "prediction": " return;\n            }\n            List<StringEntity> strings;\n            StringBuilder oldContent = new StringBuilder();\n            try {\n                oldContent.append(new String(file.contentsToByteArray(), \"utf-8\"));\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            InputStream is = null;\n            try {\n                is = file.getInputStream();\n                strings = extraLayoutEntity(is, file.getNameWithoutExtension().toLowerCase(), oldContent, valueKeyMap);\n                if (strings != null) {\n                    for (StringEntity string : strings) {\n                        sb.append(\"\\n    <string name", "first_line_groundtruth": "MessageUtils.showNotify(\"\u8bf7\u9009\u62e9\u5e03\u5c40\u6587\u4ef6\");", "first_line_prediction": " return;", "match": 0}
{"groundtruth": "tokens.addAll(Lexer.tokenize(s));", "prediction": " tokens.addAll(Lexer.tokenize(s));\n\n            reader.close();\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n        }\n\n        return tokens;\n    }\n\n    // Returns a file path to a file to be used as input\n    private static String selectFile() {\n        String[] files = {\"src/core/test.vm\", \"src/core/test.vm.txt\"};\n        String file = null;\n\n        for (String f : files) {\n            if (new File(f).exists()) {\n                file", "first_line_groundtruth": "tokens.addAll(Lexer.tokenize(s));", "first_line_prediction": " tokens.addAll(Lexer.tokenize(s));", "match": 0}
{"groundtruth": "+ \": \"+ selectedEngineer.getFullNameWithDiscipline() + \": \" + comment + \"#@\";", "prediction": " + \" \" + comment;\n            else currComment = currComment + \"#@\" + formattedDate + \" \" + comment;\n            collision.setComment(currComment);\n            collisionsRepository.save(collision);\n        }\n    }\n\n    public Page<Collision> findAll(Pageable pageable) {\n        return collisionsRepository.findAll(pageable);\n    }\n\n    public Page<Collision> findAllByProject(Project project, Pageable pageable) {\n        return collisionsRepository.findAllByProjectBase(project, pageable);\n    }\n\n    public Page<Collision> findAllByProjectAndEngineer(Project project, Engineer engineer, Page", "first_line_groundtruth": "+ \": \"+ selectedEngineer.getFullNameWithDiscipline() + \": \" + comment + \"#@\";", "first_line_prediction": " + \" \" + comment;", "match": 0}
{"groundtruth": "originalEngineer = engineersService.findOne(id);", "prediction": " originalEngineer = engineersService.findOne(id);\n        engineersService.update(id, updatedEngineer, originalEngineer);\n\n        return \"redirect:/engineers/\" + id;\n    }", "first_line_groundtruth": "originalEngineer = engineersService.findOne(id);", "first_line_prediction": " originalEngineer = engineersService.findOne(id);", "match": 0}
{"groundtruth": "> foundCollision = collisionsRepository.findByIdFetchEngineer(id);", "prediction": "> foundCollision = collisionsRepository.findById(id);\n\n        return foundCollision.orElse(null);\n    }\n\n    public Collision findOneAndProject(int id) {\n        Optional<Collision> foundCollision = collisionsRepository.findById(id);\n\n        return foundCollision.orElse(null);\n    }\n\n    public Collision findOneAndProjectBase(int id) {\n        Optional<Collision> foundCollision = collisionsRepository.findById(id);\n\n        return foundCollision.orElse(null);\n    }\n\n    public Collision findOneAndProjectBaseAndEngineer(int id) {\n        Optional<Collision> foundCollision = collisionsRepository.findById(", "first_line_groundtruth": "> foundCollision = collisionsRepository.findByIdFetchEngineer(id);", "first_line_prediction": "> foundCollision = collisionsRepository.findById(id);", "match": 0}
{"groundtruth": ".findByIdFetchCollisions(engineerDetails.getEngineer().getId());", "prediction": " .findOne(engineerDetails.getEngineer().getId());\n\n        model.addAttribute(\"engineer\", engineer);\n\n        return \"account\";\n    }\n\n    @GetMapping(\"/projects\")\n    public String showProjects(Model model) {\n        List<Project> projects = projectService.findAll();\n        model.addAttribute(\"projects\", projects);\n        return \"projects/index\";\n    }\n\n    @GetMapping(\"/projects/{id}\")\n    public String showProject(Model model, @PathVariable(\"id\") int id) {\n        Project project = projectService.findOne(id);\n        model.addAttribute(\"project\", project);\n        return \"projects/show", "first_line_groundtruth": ".findByIdFetchCollisions(engineerDetails.getEngineer().getId());", "first_line_prediction": " .findOne(engineerDetails.getEngineer().getId());", "match": 0}
{"groundtruth": "\"engineers\", engineersService.findAll());", "prediction": "project);\n        List<Engineer> engineers = engineersService.findAll();\n        model.addAttribute(\"engineers\", engineers);\n        return \"projects/new\";\n    }\n\n    @PostMapping(\"/new\")\n    public String createProject(@Valid @ModelAttribute(\"project\") Project project,\n                                BindingResult bindingResult,\n                                Model model) {\n        if (bindingResult.hasErrors()) {\n            List<Engineer> engineers = engineersService.findAll();\n            model.addAttribute(\"engineers\", engineers);\n            return \"projects/new\";\n        }\n        projectService.save(project);\n        return \"redirect:/", "first_line_groundtruth": "\"engineers\", engineersService.findAll());", "first_line_prediction": "project);", "match": 0}
{"groundtruth": "Optional<Collision> optionalCollision = collisionsRepository.findByIdFetchEngineer(id);", "prediction": " collisionsRepository.findByIdFetchEngineer(id).ifPresent(\n                collision -> {\n                    collision.setEngineer(selectedEngineer);\n                    collision.setComment(comment);\n                }\n         );\n    }\n\n    public Page<Collision> findAll(Pageable pageable) {\n        return collisionsRepository.findAll(pageable);\n    }\n\n    public Page<Collision> findAllByProject(Project project, Pageable pageable) {\n        return collisionsRepository.findAllByProject(project, pageable);\n    }\n\n    public Page<Collision> findAllByProjectBase(Project project, Pageable pageable) {\n        return collisionsRepository.", "first_line_groundtruth": "Optional<Collision> optionalCollision = collisionsRepository.findByIdFetchEngineer(id);", "first_line_prediction": " collisionsRepository.findByIdFetchEngineer(id).ifPresent(", "match": 0}
{"groundtruth": "= engineersService.findByIdFetchCollisions(id);", "prediction": " = engineersService.findOne(id);\n        model.addAttribute(\"engineer\", engineer);\n        return \"engineers/show\";\n    }\n\n    @GetMapping(\"/new\")\n    public String newEngineer(Model model) {\n        model.addAttribute(\"engineer\", new Engineer());\n        return \"engineers/new\";\n    }\n\n    @PostMapping(\"/new\")\n    public String createEngineer(@Valid @ModelAttribute(\"engineer\") Engineer engineer, BindingResult result, Model model) {\n        if (result.hasErrors()) {\n            return \"engineers/new\";\n        }\n\n        engineersService.save(engineer);", "first_line_groundtruth": "= engineersService.findByIdFetchCollisions(id);", "first_line_prediction": " = engineersService.findOne(id);", "match": 0}
{"groundtruth": "\"engineer\", engineersService.findOne(id));", "prediction": "engineersService.findById(id));\n        model.addAttribute(\"engineers\", engineersService.findAll());\n        return \"engineers/edit\";\n    }\n\n    @PatchMapping(\"/{id}\")\n    public String update(@ModelAttribute(\"engineer\") @Valid Engineer engineer, BindingResult bindingResult, Model model) {\n        if (bindingResult.hasErrors()) {\n            model.addAttribute(\"engineers\", engineersService.findAll());\n            return \"engineers/edit\";\n        }\n\n        engineersService.save(engineer);\n        return \"redirect:/engineers\";\n    }\n\n    @GetMapping(\"/upload\")\n    public String", "first_line_groundtruth": "\"engineer\", engineersService.findOne(id));", "first_line_prediction": "engineersService.findById(id));", "match": 0}
{"groundtruth": "collisionsRepository.findByIdFetchEngineer(id).ifPresent(\n                collision -> {", "prediction": " collisionsRepository.release(id);\n    }\n\n    public Page<Collision> findAll(Pageable pageable) {\n        return collisionsRepository.findAll(pageable);\n    }\n\n    public Page<Collision> findAllByProject(Pageable pageable, Project project) {\n        return collisionsRepository.findAllByProjectBase(pageable, project);\n    }\n\n    public Page<Collision> findAllByEngineer(Pageable pageable, Engineer engineer) {\n        return collisionsRepository.findAllByEngineer(pageable, engineer);\n    }\n\n    public Page<Collision> findAllByProjectAndEngineer(Pageable pageable, Project project", "first_line_groundtruth": "collisionsRepository.findByIdFetchEngineer(id).ifPresent(", "first_line_prediction": " collisionsRepository.release(id);", "match": 0}
{"groundtruth": "(engineerDAO.index());", "prediction": "((List<Engineer>) engineersRepository.findAll());\n        Collections.sort(engineers, new Comparator<Engineer>() {\n            @Override\n            public int compare(Engineer o1, Engineer o2) {\n                return o2.getCollisions().size() - o1.getCollisions().size();\n            }\n        });\n        return engineers;\n    }\n\n    public List<Engineer> findAllSortedByCollisionsSize(int project_id) {\n        List<Engineer> engineers = new ArrayList<>((List<Engineer>) engineersRepository.findAllOnProject(project_id));\n       ", "first_line_groundtruth": "(engineerDAO.index());", "first_line_prediction": "((List<Engineer>) engineersRepository.findAll());", "match": 0}
{"groundtruth": "model.addAttribute(\"comments\", collision.getComments());", "prediction": " model.addAttribute(\"engineer\", collisionOwner);\n        model.addAttribute(\"collisions\", collisionOwner.getCollisions());\n        model.addAttribute(\"reports\", service.findAllByCollision(collision));\n        model.addAttribute(\"role\", authority);\n        return \"collisions/show\";\n    }\n\n    @GetMapping(\"/new\")\n    public String newCollision(Model model,\n                                @PathVariable(\"project_id\") int project_id,\n                                @ModelAttribute(\"engineer\") Engineer engineer) {\n        model.addAttribute(\"engineer\", engineer);\n        model.addAttribute(\"project\", projectService.findOne(project_id));\n        return \"", "first_line_groundtruth": "model.addAttribute(\"comments\", collision.getComments());", "first_line_prediction": " model.addAttribute(\"engineer\", collisionOwner);", "match": 0}
{"groundtruth": "= collisionsService.findOneAndEngineer(id);", "prediction": " = collisionsService.findById(id);\n        model.addAttribute(\"collision\", collision);\n        model.addAttribute(\"engineer\", engineer);\n        model.addAttribute(\"collisions\", collision.getEngineers());\n        model.addAttribute(\"role\", authority);\n        return \"collisions/show\";\n    }\n\n    @GetMapping(\"/new\")\n    public String newCollision(Model model,\n                                @PathVariable(\"project_id\") int project_id,\n                                @ModelAttribute(\"engineer\") Engineer engineer) {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        String authority = authentication.getAuthorities().stream().findFirst().orElse", "first_line_groundtruth": "= collisionsService.findOneAndEngineer(id);", "first_line_prediction": " = collisionsService.findById(id);", "match": 0}
{"groundtruth": "(id, engineerDetails.getEngineer(), comment);", "prediction": "(id, comment, engineerDetails.getEngineer());\n        return \"redirect:/projects/\" + project_id + \"/collisions/\" + id;\n    }", "first_line_groundtruth": "(id, engineerDetails.getEngineer(), comment);", "first_line_prediction": "(id, comment, engineerDetails.getEngineer());", "match": 0}
{"groundtruth": "Engineer> foundEngineer = engineersRepository.findByIdFetchCollisions(id);", "prediction": "Engineer> foundEngineer = engineersRepository.findByIdFetchCollisions(id);\n\n        return foundEngineer.orElse(null);\n    }\n\n    public void save(Engineer engineer) {\n        if (engineer.getPassword() != null) {\n            engineer.setPassword(passwordEncoder.encode(engineer.getPassword()));\n        }\n        engineersRepository.save(engineer);\n    }\n\n    public void delete(Engineer engineer) {\n        engineersRepository.delete(engineer);\n    }\n\n    public void delete(int id) {\n        engineersRepository.deleteById(id);\n    }\n\n    public void", "first_line_groundtruth": "Engineer> foundEngineer = engineersRepository.findByIdFetchCollisions(id);", "first_line_prediction": "Engineer> foundEngineer = engineersRepository.findByIdFetchCollisions(id);", "match": 1}
{"groundtruth": "handle = getHandle(mapper.getLayout(target.getClass()));", "prediction": " handle = getHandle(mapper.getLayout(field));\n            }\n            handle.set(target, segment);\n        } else if(fieldType.equals(MemorySegment.class)){\n            var offset = mapper.getOffset(field);\n            if(offset != null){\n                field.set(target, segment.asSlice(offset, segment.byteSize()));\n            }\n        } else if(fieldType.equals(Array.class)){\n            var array = (Array) field.get(target);\n            if(array != null){\n                array.bind(segment);\n            }\n        } else {\n            var nestedStruct = (", "first_line_groundtruth": "handle = getHandle(mapper.getLayout(target.getClass()));", "first_line_prediction": " handle = getHandle(mapper.getLayout(field));", "match": 0}
{"groundtruth": "mapper.getLayout(target.getClass()).byteOffset(MemoryLayout.PathElement.groupElement(model.name()));", "prediction": "0L;\n        if(model.isPointer()){\n            offset = Pointer.getAddress(segment);\n        }\n        return segment.asSlice(offset, mapper.sizeOf(model.type()));\n    }\n\n    @Override\n    public T handle(NativeMapper mapper, MemorySegment segment, T target) throws IllegalAccessException {\n        fill(mapper, segment, target);\n        return target;\n    }\n\n    @Override\n    public MemoryLayout getLayout(Class<T> type){\n        return ValueLayout.of(type);\n    }", "first_line_groundtruth": "mapper.getLayout(target.getClass()).byteOffset(MemoryLayout.PathElement.groupElement(model.name()));", "first_line_prediction": "0L;", "match": 0}
{"groundtruth": "var structDef = mapper.getOrDefineStruct(fieldType);", "prediction": " // If it's an object, we determine if it's a nested struct or a pointer to a struct,\n             // and we populate it with the offset of the field (nested) *or* the memory address\n             // contained in the field (pointer) as the object's self-pointer segment\n            if(model.isPointer()){\n                field.set(target, segmentForField(mapper, target, segment));\n            }else{\n                field.set(target, segmentForField(mapper, target, segment));\n            }\n        }\n    }\n\n    protected MemorySegment segmentForField(NativeMapper mapper, T target, Memory", "first_line_groundtruth": "var structDef = mapper.getOrDefineStruct(fieldType);", "first_line_prediction": " // If it's an object, we determine if it's a nested struct or a pointer to a struct,", "match": 0}
{"groundtruth": "instance.getCore().debug(\"Plugin is not setup / ProxyProtocol is off / Player is on DirectConnectWhitelist (return)\");", "prediction": " channel.close();\n                     instance.getCore().debug(\"Close connection (return)\");\n                     return;\n                }\n\n                instance.getCore().debug(\"Adding handler...\");\n                if (instance.getCore().isSetup() && Config.isProxyProtocol()) {\n                    addProxyProtocolHandler(channel, null);\n                }\n\n                instance.getCore().debug(\"Adding KeepAlivePacketHandler\");\n                addKeepAlivePacketHandler(channel, null, instance);\n            }\n        };\n\n        // Handle incoming channels\n        beginInitProtocol = new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel channel) {\n                try {\n                   ", "first_line_groundtruth": "instance.getCore().debug(\"Plugin is not setup / ProxyProtocol is off / Player is on DirectConnectWhitelist (return)\");", "first_line_prediction": " channel.close();", "match": 0}
{"groundtruth": "instance.getCore().debug(\"Adding Handler...\");", "prediction": " // Get the server connection\n                    Object serverConnection = getServerConnection.get(getMinecraftServer.get(Bukkit.getServer()));\n\n                    // Get the network managers\n                    if (networkManagersFieldAccessor != null) {\n                        networkManagers = (List<Object>) networkManagersFieldAccessor.get(serverConnection);\n                    } else {\n                        networkManagers = (List<Object>) getNetworkMarkers.invoke(serverConnection);\n                    }\n\n                    // Get the network manager\n                    Object networkManager = networkManagers.stream().filter(n -> socketAddressFieldAccessor.get(n).equals(channel.remoteAddress())).findFirst().orElse(null", "first_line_groundtruth": "instance.getCore().debug(\"Adding Handler...\");", "first_line_prediction": " // Get the server connection", "match": 0}
{"groundtruth": ".getEventManager(), neoProtectVelocity.getLogger()));", "prediction": "\n                                                                                                  .getConfiguration()\n                                                                                                  .isOnlineMode()));\n    }\n\n    private void removePlayer(Player player) {\n        ConnectedPlayer p = (ConnectedPlayer) player;\n        p.getConnection()\n                 .getChannel()\n                 .pipeline()\n                 .remove(\"packetevents\");\n    }", "first_line_groundtruth": ".getEventManager(), neoProtectVelocity.getLogger()));", "first_line_prediction": "", "match": 0}
{"groundtruth": "core.severe(exception.getMessage(), exception);", "prediction": " core.severe(request + \" failed cause (\" + exception + \")\");\n        }\n        return null;\n    }\n\n    protected Request.Builder defaultBuilder() {\n        return new Request.Builder();\n    }\n\n    protected String getSubDirectory(RequestType type, Object... value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(type.toString().substring(3));\n        for (Object object : value) {\n            builder.append(\"/\").append(object);\n        }\n        return builder.toString();\n    }\n\n    protected boolean isAPIInvalid(String apiKey) {\n        return apiKey == null || apiKey.isEmpty();\n    }", "first_line_groundtruth": "core.severe(exception.getMessage(), exception);", "first_line_prediction": " core.severe(request + \" failed cause (\" + exception + \")\");", "match": 0}
{"groundtruth": "instance.getCore().debug(\"Player connected over IP (\" + channel.remoteAddress() + \") doesn't match to Neo-IPs (warning)\");", "prediction": " instance.getCore().debug(\"Player is not on a NeoProtect server (return)\");\n                    return;\n                }\n\n                instance.getCore().debug(\"Adding proxy protocol handler...\");\n                addProxyProtocolHandler(channel, (InetSocketAddress) channel.remoteAddress());\n\n                AtomicReference<InetSocketAddress> playerAddress = new AtomicReference<>();\n                String sourceAddress = ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress();\n                if (channel.localAddress().toString().startsWith(\"local:\") || sourceAddress.equals(Config.getGeyserServerIP())) {\n                    instance.getCore().debug(\"Detected bedrock player", "first_line_groundtruth": "instance.getCore().debug(\"Player connected over IP (\" + channel.remoteAddress() + \") doesn't match to Neo-IPs (warning)\");", "first_line_prediction": " instance.getCore().debug(\"Player is not on a NeoProtect server (return)\");", "match": 0}
{"groundtruth": "core.severe(\"Failed to load API-Key. Key is null or not valid\");", "prediction": " core.severe(\"APIKey is not valid! Please run /neoprotect setup to set the API Key\");\n             setup = false;\n             return;\n        } else if (gameShieldID.length() != 32) {\n            core.severe(\"Gameshield is not valid! Please run /neoprotect setgameshield to set the gameshield\");\n            setup = false;\n            return;\n        } else if (backendID.length() != 32) {\n            core.severe(\"Backend is not valid! Please run /neoprotect setbackend to set the backend\");\n            setup = false;\n            return", "first_line_groundtruth": "core.severe(\"Failed to load API-Key. Key is null or not valid\");", "first_line_prediction": " core.severe(\"APIKey is not valid! Please run /neoprotect setup to set the API Key\");", "match": 0}
{"groundtruth": "instance.getCore().severe(\"Cannot inject incoming channel \" + channel, ex);", "prediction": " instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);\n                }\n            }\n        };\n\n        // Handle incoming channels\n        beginInitProtocol = new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel channel) {\n                if (!Config.isProxyProtocol() | !instance.getCore().isSetup() | instance.getCore().getDirectConnectWhitelist().contains(((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress())) {\n                    instance.getCore().debug(\"Plugin is not setup / ProxyProtocol is off / Player is on DirectConnectWhitelist (return", "first_line_groundtruth": "instance.getCore().severe(\"Cannot inject incoming channel \" + channel, ex);", "first_line_prediction": " instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);", "match": 0}
{"groundtruth": "core.severe(\"Failed to load GameshieldID. ID is null\");", "prediction": " core.severe(\"Failed to load Gameshield-ID. ID is null or not valid\");\n             return;\n        }\n        if (backendID.isEmpty()) {\n            core.severe(\"Failed to load Backend-ID. ID is null or not valid\");\n            return;\n        }\n        if (geyserBackendID.isEmpty()) {\n            core.severe(\"Failed to load Geyser-Backend-ID. ID is null or not valid\");\n            return;\n        }\n        if (updateIP) {\n            if (updateSetting == null) {\n                core.severe(\"Failed to load Update-Setting", "first_line_groundtruth": "core.severe(\"Failed to load GameshieldID. ID is null\");", "first_line_prediction": " core.severe(\"Failed to load Gameshield-ID. ID is null or not valid\");", "match": 0}
{"groundtruth": "core.info(\"BackendID loaded successful '\" + backendID + \"'\");", "prediction": "\n\n        if (updateIP) {\n            core.info(\"Auto-Update IP is enabled\");\n        } else {\n            core.info(\"Auto-Update IP is disabled\");\n        }\n\n        if (debugMode) {\n            core.info(\"DebugMode is enabled\");\n        } else {\n            core.info(\"DebugMode is disabled\");\n        }\n\n        if (geyserServerIP.isEmpty()) {\n            core.severe(\"Failed to load GeyserServerIP. IP is null\");\n            return;\n        }\n\n        core.info(\"GeyserServerIP loaded successful '\" + geyserServerIP + \"'\");\n\n       ", "first_line_groundtruth": "core.info(\"BackendID loaded successful '\" + backendID + \"'\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "core.info(\"API-Key loaded successful '\" + \"******************************\" + APIKey.substring(32) + \"'\");", "prediction": "\n\n        if (updateIP) {\n            updateSetting = config.getString(\"gameshield.updateSetting\", \"1\");\n        } else {\n            updateSetting = config.getString(\"gameshield.updateSetting\", \"0\");\n        }\n\n        if (updateSetting.equals(\"1\")) {\n            updateSetting = \"1\";\n        } else {\n            updateSetting = \"0\";\n        }\n\n        if (geyserServerIP.isEmpty()) {\n            core.severe(\"Failed to load GeyserServerIP. IP is null\");\n            return;\n        }\n\n        if (debugMode) {\n            core.info(\"DebugMode", "first_line_groundtruth": "core.info(\"API-Key loaded successful '\" + \"******************************\" + APIKey.substring(32) + \"'\");", "first_line_prediction": "", "match": 0}
{"groundtruth": "core.info(\"GameshieldID loaded successful '\" + gameShieldID + \"'\");", "prediction": "\n\n        language = language.toLowerCase(Locale.ROOT);\n        if (language.equals(\"de\")) {\n            language = \"de_DE\";\n        } else if (language.equals(\"en\")) {\n            language = \"en_US\";\n        } else if (language.equals(\"es\")) {\n            language = \"es_ES\";\n        } else if (language.equals(\"fr\")) {\n            language = \"fr_FR\";\n        } else if (language.equals(\"it\")) {\n            language = \"it_IT\";\n        } else if (language.equals(\"ja\")) {\n            language = \"ja_JP", "first_line_groundtruth": "core.info(\"GameshieldID loaded successful '\" + gameShieldID + \"'\");", "first_line_prediction": "", "match": 0}
{"groundtruth": ".equals(core.getRestAPI().getStatsServer())) {", "prediction": "\n                    .startsWith(baseURL + getSubDirectory(RequestType.GET_NEO_SERVER_IPS))\n                    && !request.url().toString()\n                    .startsWith(baseURL + getSubDirectory(RequestType.GET_GAMESHIELD_INFO))\n                    && !request.url().toString()\n                    .startsWith(baseURL + getSubDirectory(RequestType.GET_GAMESHIELD_BACKENDS))\n                    && !request.url().toString()\n                    .startsWith(baseURL + getSubDirectory(RequestType.GET_GAMESHIELD_BACKEND_INFO))\n                    && !request.url().toString()\n                   ", "first_line_groundtruth": ".equals(core.getRestAPI().getStatsServer())) {", "first_line_prediction": "", "match": 0}
{"groundtruth": "(Config.getAPIKey());", "prediction": "(null);\n    }\n\n    protected Request.Builder defaultBuilder(RequestBody requestBody) {\n        return new Request.Builder().addHeader(\"Authorization\", \"Bearer \" + Config.getAPIKey()).addHeader(\"Content-Type\", \"application/json\");\n    }\n\n    protected String getSubDirectory(RequestType type, Object... value) {\n        Formatter formatter = new Formatter();\n        formatter.format(\"%s/%s\", type.getSubDirectory(), value[0]);\n        return formatter.toString();\n    }\n\n    protected boolean isAPIInvalid(String apiKey) {\n        return apiKey == null || apiKey.isEmpty();\n    }\n\n    protected boolean", "first_line_groundtruth": "(Config.getAPIKey());", "first_line_prediction": "(null);", "match": 0}
{"groundtruth": "instance.getCore().severe(\"Error: The server was unable to set the IP address from the 'HAProxyMessage'. Therefore we closed the channel.\", exception);", "prediction": " exception.printStackTrace();\n            }\n\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    private boolean isIPInRange(String ipRange, String ip) {\n        String[] ipRangeParts = ipRange.split(\"\\\\.\");\n        String[] ipParts = ip.split(\"\\\\.\");\n\n        for (int i = 0; i < 4; i++) {\n            int ipRangePart = Integer.parseInt(ipRangeParts[i]);\n            int ipPart = Integer.parseInt(ipParts[i]);\n\n            if (ipRangePart > ipPart)\n                return false;\n\n            if (ipRangePart < ip", "first_line_groundtruth": "instance.getCore().severe(\"Error: The server was unable to set the IP address from the 'HAProxyMessage'. Therefore we closed the channel.\", exception);", "first_line_prediction": " exception.printStackTrace();", "match": 0}
{"groundtruth": "instance.getCore().info(\"Proceeding with the server channel injection...\");", "prediction": " // Get the server channel initializer\n            serverChannelHandler = new ServerChannelInitializer(instance);\n            serverChannelHandler.setProxyProtocol(true);\n            serverChannelHandler.setProxyProtocolVersion(Config.PROXY_PROTOCOL_VERSION);\n            serverChannelHandler.setProxyProtocolAddress(Config.PROXY_PROTOCOL_ADDRESS);\n            serverChannelHandler.setProxyProtocolPort(Config.PROXY_PROTOCOL_PORT);\n\n            // Get the channel initializer for the server channel\n            beginInitProtocol = Reflection.getField(serverChannelHandler.getClass(), ChannelInitializer.class, 0);\n            endInitProtocol = Reflection.getField(serverChannelHandler", "first_line_groundtruth": "instance.getCore().info(\"Proceeding with the server channel injection...\");", "first_line_prediction": " // Get the server channel initializer", "match": 0}
{"groundtruth": "Reflection.getField(serverConnection.getClass(), List.class, i).get(serverConnection);", "prediction": " networkManagers.get(i);\n            if (list == null) {\n                continue;\n            }\n            if (list.stream().anyMatch(networkManager -> networkManager.getClass().equals(networkManager))) {\n                looking = false;\n            }\n        }\n\n        // Add the channel handler to the pipeline\n        serverChannelHandler.setNetworkManagers(networkManagers);\n        serverChannelHandler.setBeginInitProtocol(beginInitProtocol);\n        serverChannelHandler.setEndInitProtocol(endInitProtocol);\n        serverChannelHandler.setSocketAddressFieldAccessor(socketAddressFieldAccessor);\n        serverChannelHandler.setNetworkManager(networkManager", "first_line_groundtruth": "Reflection.getField(serverConnection.getClass(), List.class, i).get(serverConnection);", "first_line_prediction": " networkManagers.get(i);", "match": 0}
{"groundtruth": "instance.getCore().info(\"Late bind injection successful.\");", "prediction": " instance.getCore().info(\"Server channel injection delayed.\");\n                }\n            }.runTaskLater(instance, 1L);\n        }\n    }\n\n    /**\n     * Register the channel handler.\n     * <p>\n     * This is done in a separate thread to avoid a deadlock.\n     */\n    private void registerChannelHandler() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                try {\n                    serverChannelHandler = new ServerChannelInitializer(instance);\n                    serverChannelHandler.initChannel(Bukkit.getServer().getWorldContainer().createChannel());\n                    instance.getCore().info(\"", "first_line_groundtruth": "instance.getCore().info(\"Late bind injection successful.\");", "first_line_prediction": " instance.getCore().info(\"Server channel injection delayed.\");", "match": 0}
{"groundtruth": "instance.getCore().info(\"Delaying server channel injection due to late bind.\");", "prediction": " instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);\n        }\n    }\n\n    /**\n     * Register the channel handler.\n     *\n     * @throws IllegalArgumentException - if the channel handler is already registered.\n     */\n    private void registerChannelHandler() throws IllegalArgumentException {\n        if (serverChannelHandler != null) {\n            throw new IllegalArgumentException(\"The channel handler is already registered!\");\n        }\n\n        serverChannelHandler = new ServerChannelInitializer();\n        instance.getProxy().getPluginManager().registerChannel(instance, serverChannelHandler);\n    }\n\n    /**\n     * The channel initializer for the server channel.", "first_line_groundtruth": "instance.getCore().info(\"Delaying server channel injection due to late bind.\");", "first_line_prediction": " instance.getLogger().log(Level.SEVERE, \"Cannot inject incoming channel \" + channel, ex);", "match": 0}
{"groundtruth": "this.instance.getCore().info(\"Found the server channel and added the handler. Injection successfully!\");", "prediction": " // We need to synchronize against this list\n                networkManagers = Reflection.isNewerPackage() || Reflection.VERSION.contains(\"16\") ? networkManagersFieldAccessor.get(serverConnection) : (List<Object>) getNetworkMarkers.invoke(null, serverConnection);\n            }\n        }\n    }\n\n    private boolean isIPInRange(String ipRange, String ip) {\n        String[] split = ipRange.split(\"/\");\n        String[] split2 = split[0].split(\"\\\\.\");\n        String[] split3 = split[1].split(\"\\\\.\");\n\n        int[] ip1 = new int[4];\n        int[] ip", "first_line_groundtruth": "this.instance.getCore().info(\"Found the server channel and added the handler. Injection successfully!\");", "first_line_prediction": " // We need to synchronize against this list", "match": 0}
{"groundtruth": "if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode())) {", "prediction": " if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode())) {\n            Stats stats = instance.getStats();\n            String infos =\n                    \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                            \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                            \"\u00a7bServerVersion\u00a77: \" + instance.getServer().getVersion() + \" \\n\" +\n                            \"\u00a7bServerType\u00a77: \" + instance.getServer().getType", "first_line_groundtruth": "if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode())) {", "first_line_prediction": " if (instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getServer().getOnlineMode())) {", "match": 0}
{"groundtruth": "instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "prediction": "instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {\n                    Stats stats = instance.getStats();\n                    String infos =\n                            \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                                    \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                                    \"\u00a7bPluginVersion\u00a77: \" + stats.getPluginVersion() + \" \\n\" +\n                                    \"\u00a7bVersionStatus\u00a77: \" + instance.getCore", "first_line_groundtruth": "instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "first_line_prediction": "instance.getCore().isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "match": 1}
{"groundtruth": ".forLanguageTag(Config.getLanguage()), new File(\"plugins/NeoProtect/languages/\"));", "prediction": ".ENGLISH.toLanguageTag(), languageEN, languageDE, languageRU, languageUA);\n        this.restAPIRequests = new RestAPIRequests(this);\n\n        plugin.getServer().getPluginManager().registerEvents(new PlayerListener(this), plugin);\n        plugin.getServer().getPluginManager().registerEvents(new BlockListener(this), plugin);\n        plugin.getServer().getPluginManager().registerEvents(new EntityListener(this), plugin);\n        plugin.getServer().getPluginManager().registerEvents(new WorldListener(this), plugin);\n        plugin.getServer().getPluginManager().registerEvents(new PlayerInteractListener(this", "first_line_groundtruth": ".forLanguageTag(Config.getLanguage()), new File(\"plugins/NeoProtect/languages/\"));", "first_line_prediction": ".ENGLISH.toLanguageTag(), languageEN, languageDE, languageRU, languageUA);", "match": 0}
{"groundtruth": ").isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "prediction": "player).isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {\n                    Stats stats = instance.getStats();\n                    String infos =\n                            \"\u00a7bOsName\u00a77: \" + System.getProperty(\"os.name\") + \" \\n\" +\n                                    \"\u00a7bJavaVersion\u00a77: \" + System.getProperty(\"java.version\") + \" \\n\" +\n                                    \"\u00a7bPluginVersion\u00a77: \" + stats.getPluginVersion() + \" \\n\" +\n                                    \"\u00a7bVersionStatus\u00a77: \" + instance.getCore().getVersionResult", "first_line_groundtruth": ").isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "first_line_prediction": "player).isPlayerMaintainer(player.getUniqueId(), instance.getProxy().getConfiguration().isOnlineMode())) {", "match": 0}
{"groundtruth": "\"NeoProtect\", \"NeoPlugin\", \"v\" + plugin.getPluginVersion(), VersionUtils.UpdateSetting.DISABLED).message();", "prediction": "plugin.getName(), plugin.getPluginName(), plugin.getPluginVersion(), plugin.getAutoUpdaterSettings());\n        this.restAPIRequests = new RestAPIRequests(this);\n        this.localization = new Localization(plugin.getDataFolder().toPath().resolve(\"lang\"), plugin.getPluginName());\n\n        plugin.saveDefaultConfig();\n        plugin.saveConfig();\n\n        plugin.getProxy().getPluginManager().registerListener(plugin, new LoginListener(this));\n        plugin.getProxy().getPluginManager().registerListener(plugin, new PlayerListener(this));\n        plugin.getProxy().getPluginManager().registerListener(", "first_line_groundtruth": "\"NeoProtect\", \"NeoPlugin\", \"v\" + plugin.getPluginVersion(), VersionUtils.UpdateSetting.DISABLED).message();", "first_line_prediction": "plugin.getName(), plugin.getPluginName(), plugin.getPluginVersion(), plugin.getAutoUpdaterSettings());", "match": 0}
{"groundtruth": "return restAPIRequests.isSetup();", "prediction": " return restAPIRequests.isSetup();\n    }\n\n    public boolean isMaintainerOnline() {\n        return restAPIRequests.isMaintainerOnline();\n    }\n\n    public boolean isMaintainerOffline() {\n        return restAPIRequests.isMaintainerOffline();\n    }\n\n    public boolean isMaintainerOnline(UUID uuid) {\n        return restAPIRequests.isMaintainerOnline(uuid);\n    }\n\n    public boolean isMaintainerOffline(UUID uuid) {\n        return restAPIRequests.isMaintainerOffline(uuid);\n    }\n\n    public boolean isMaintainerOnline(String uuid) {\n        return restAPIRequests.isMaint", "first_line_groundtruth": "return restAPIRequests.isSetup();", "first_line_prediction": " return restAPIRequests.isSetup();", "match": 0}
{"groundtruth": "(Config.isDebugMode()) ((Logger) LogManager.getLogger().logger).log(Level.SEVERE, output);", "prediction": " (isDebugRunning) {\n            plugin.getLogger().info(output);\n        }\n    }\n\n    public void debug(String output, Level level) {\n        if  (isDebugRunning) {\n            plugin.getLogger().log(level, output);\n        }\n    }\n\n    public void debug(String output, Level level, Throwable throwable) {\n        if  (isDebugRunning) {\n            plugin.getLogger().log(level, output, throwable);\n        }\n    }\n\n    public void debug(String output, Throwable throwable) {\n        if  (isDebugRunning) {\n            plugin.getLogger().log(Level.SEVERE, output, throwable);", "first_line_groundtruth": "(Config.isDebugMode()) ((Logger) LogManager.getLogger().logger).log(Level.SEVERE, output);", "first_line_prediction": " (isDebugRunning) {", "match": 0}
{"groundtruth": "instance.getCore().getDebugPingResponses().put(player.getName(), new ArrayList<>());", "prediction": " map.put(player.getName(), new ArrayList<>());\n                        }\n\n                        map.get(player.getName()).add(new DebugPingResponse(keepAliveResponseKey.getAddress().getAddress().getHostAddress(), keepAliveResponseKey.getAddress().getPort(), neoRTT, backendRTT, ping));\n                    }\n\n                    pingMap.remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n\n    public boolean isIPInRange(String ipRange, String ip) {\n        String[] ipRangeParts = ipRange.split(\"\\\\.\");\n        String[] ipParts = ip.split(\"\\\\.\");\n\n        for (int i =", "first_line_groundtruth": "instance.getCore().getDebugPingResponses().put(player.getName(), new ArrayList<>());", "first_line_prediction": " map.put(player.getName(), new ArrayList<>());", "match": 0}
{"groundtruth": "instance.getCore().getPingMap().remove(keepAliveResponseKey);", "prediction": "\n\n                    pingMap.remove(keepAliveResponseKey);\n                    break;\n                }\n            }\n        });\n    }\n\n    public boolean isIPInRange(String ipRange, String ip) {\n        String[] ipRangeParts = ipRange.split(\"\\\\.\");\n        String[] ipParts = ip.split(\"\\\\.\");\n\n        for (int i = 0; i < 4; i++) {\n            int ipRangePart = Integer.parseInt(ipRangeParts[i]);\n            int ipPart = Integer.parseInt(ipParts[i]);\n\n            if (ipRangePart > ipPart) {\n                return false;\n            }\n\n            if (", "first_line_groundtruth": "instance.getCore().getPingMap().remove(keepAliveResponseKey);", "first_line_prediction": "", "match": 0}
{"groundtruth": ".request(RequestType.GET_GAMESHIELD_BANDWIDTH, null, Config.getGameShieldID()).getResponseBodyObject();", "prediction": ".request(RequestType.GET_GAMESHIELD_TRAFFIC, null, Config.getGameShieldID()).getResponseBodyObject();\n    }\n\n    public JSONObject getBackend() {\n        return rest.request(RequestType.GET_GAMESHIELD_BACKEND, null, Config.getGameShieldID()).getResponseBodyObject();\n    }\n\n    public JSONObject getBackend(String backendID) {\n        return rest.request(RequestType.GET_GAMESHIELD_BACKEND, null, Config.getGameShieldID(), backendID).getResponseBodyObject();\n    }\n\n    public JSONObject getBackend(String backendID, String game", "first_line_groundtruth": ".request(RequestType.GET_GAMESHIELD_BANDWIDTH, null, Config.getGameShieldID()).getResponseBodyObject();", "first_line_prediction": ".request(RequestType.GET_GAMESHIELD_TRAFFIC, null, Config.getGameShieldID()).getResponseBodyObject();", "match": 0}
{"groundtruth": "POST_GAMESHIELD_BACKEND_UPDATE, requestBody, Config.getGameShieldID(),backendID).checkCode(200);", "prediction": "UPDATE_BACKEND, requestBody, backendID).checkCode(200);\n    }\n\n    private boolean updateGameshield(RequestBody requestBody, String gameshieldID) {\n        return rest.request(RequestType.UPDATE_GAMESHIELD, requestBody, gameshieldID).checkCode(200);\n    }\n\n    private boolean updateFirewall(RequestBody requestBody, String gameshieldID) {\n        return rest.request(RequestType.UPDATE_FIREWALL, requestBody, gameshieldID).checkCode(200);\n    }\n\n    private boolean updateAttack(RequestBody requestBody, String gameshieldID) {", "first_line_groundtruth": "POST_GAMESHIELD_BACKEND_UPDATE, requestBody, Config.getGameShieldID(),backendID).checkCode(200);", "first_line_prediction": "UPDATE_BACKEND, requestBody, backendID).checkCode(200);", "match": 0}
{"groundtruth": "(isAPIInvalid(Config.getAPIKey())) {", "prediction": " (Config.getAPIKey() == null || Config.getAPIKey().isEmpty()) {\n            core.severe(\"No API key set. Please set one in the config.yml file.\");\n            return;\n        }\n\n        if (Config.getGameShieldID() == null || Config.getGameShieldID().isEmpty()) {\n            core.severe(\"No Gameshield ID set. Please set one in the config.yml file.\");\n            return;\n        }\n\n        if (Config.getBackendID() == null || Config.getBackendID().isEmpty()) {\n            core.severe(\"No Backend ID set. Please", "first_line_groundtruth": "(isAPIInvalid(Config.getAPIKey())) {", "first_line_prediction": " (Config.getAPIKey() == null || Config.getAPIKey().isEmpty()) {", "match": 0}
{"groundtruth": ".request(RequestType.GET_GAMESHIELD_ISUNDERATTACK, null, Config.getGameShieldID()).getResponseBody().equals(\"true\");", "prediction": ".getAttacks().size() > 0;\n    }\n\n    public boolean isSetup() {\n        return setup;\n    }\n\n    public void setup() {\n        setup = true;\n        core.getLogger().info(\"Setup complete!\");\n    }\n\n    public void testCredentials() {\n        if (Config.isTestCredentials()) {\n            if (Config.isTestCredentials()) {\n                if (Config.isTestCredentials()) {\n                    if (Config.isTestCredentials()) {\n                        if (Config.isTestCredentials()) {\n                            if (Config.isTestCredentials()) {\n                                if (Config.isTestCredentials()) {\n                                    if", "first_line_groundtruth": ".request(RequestType.GET_GAMESHIELD_ISUNDERATTACK, null, Config.getGameShieldID()).getResponseBody().equals(\"true\");", "first_line_prediction": ".getAttacks().size() > 0;", "match": 0}
{"groundtruth": "Config.getGameShieldID());", "prediction": " Config.getGameShieldID());\n    }\n\n    public void setUpdateIP(boolean setting) {\n        rest.request(RequestType.POST_GAMESHIELD_UPDATE, RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"updateIP\", String.valueOf(setting)).build().toString()),  Config.getGameShieldID());\n    }\n\n    public void setDebugMode(boolean setting) {\n        rest.request(RequestType.POST_GAMESHIELD_UPDATE, RequestBody.create(MediaType.parse(\"application/json\"), new JsonBuilder().appendField(\"debugMode", "first_line_groundtruth": "Config.getGameShieldID());", "first_line_prediction": " Config.getGameShieldID());", "match": 0}
{"groundtruth": "if (Config.isUpdateIP()) {", "prediction": "\n\n    }\n\n    private void testCredentials() {\n        if (Config.getBackend() == Backend.NEO) {\n            if (Config.getNeoServerIP() == null || Config.getNeoServerIP().isEmpty()) {\n                core.getLogger().info(\"No NeoServer IP found in config.yml. Please add one.\");\n            } else {\n                core.getLogger().info(\"NeoServer IP found in config.yml. Checking if it is reachable...\");\n                if (rest.getCore().getProxy().getServers().get(Config.getNeoServerIP()) == null) {\n                    core.getLogger().info(\"", "first_line_groundtruth": "if (Config.isUpdateIP()) {", "first_line_prediction": "", "match": 0}
{"groundtruth": "setProxyProtocol(Config.isProxyProtocol());", "prediction": " core.info(\"API-Key is valid\");\n         core.info(\"GameshieldID is valid\");\n         core.info(\"BackendID is valid\");\n    }\n\n    public void attackCheckSchedule() {\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                if (isAttack()) {\n                    core.severe(\"Gameshield is under attack!\");\n                }\n            }\n        }, 0, 1000 * 60 * 10);\n    }\n\n    public void statsUpdateSchedule() {\n        Timer timer = new Timer();\n        timer", "first_line_groundtruth": "setProxyProtocol(Config.isProxyProtocol());", "first_line_prediction": " core.info(\"API-Key is valid\");", "match": 0}
{"groundtruth": "Config.addAutoUpdater(getPlan().equalsIgnoreCase(\"Basic\"));", "prediction": " core.info(\"API is valid! /neoprotect setup is done\");\n    }\n\n    public void attackCheckSchedule() {\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                if (isAttack()) {\n                    core.severe(\"Gameshield is under attack! Please run /neoprotect attack to stop the attack\");\n                }\n            }\n        }, 0, 1000 * 60 * 10);\n    }\n\n    public void statsUpdateSchedule() {\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {", "first_line_groundtruth": "Config.addAutoUpdater(getPlan().equalsIgnoreCase(\"Basic\"));", "first_line_prediction": " core.info(\"API is valid! /neoprotect setup is done\");", "match": 0}
{"groundtruth": "Config.getGameShieldID()).getCode();", "prediction": " Config.getGameShieldID()).getResponseBodyCode();\n            return code;\n        } else {\n            int code = rest.request(RequestType.POST_GAMESHIELD_UPDATE,\n                    RequestBody.create(MediaType.parse(\"application/json\"), settings.put(mode, true).toString()),\n                     Config.getGameShieldID()).getResponseBodyCode();\n            return code;\n        }\n    }\n\n    public boolean isSetup() {\n        return setup;\n    }\n\n    public boolean isAttack() {\n        return isAttack();\n    }\n\n    public boolean isUnderAttack() {\n        return rest.request(RequestType.GET_G", "first_line_groundtruth": "Config.getGameShieldID()).getCode();", "first_line_prediction": " Config.getGameShieldID()).getResponseBodyCode();", "match": 0}
{"groundtruth": "core.severe(\"Gameshield is not valid! Please run /neoprotect setgameshield to set the gameshield\");", "prediction": " core.severe(\"Gameshield is not valid! Please run /neoprotect setup to set the Gameshield ID\");\n             setup = false;\n             return;\n        } else {\n            setup = true;\n        }\n\n        if (isBackendInvalid(Config.getBackendID())) {\n            core.severe(\"Backend is not valid! Please run /neoprotect setup to set the Backend ID\");\n            setup = false;\n            return;\n        }\n\n        if (isAttack()) {\n            core.severe(\"You are under attack! Please wait until the attack is over\");\n            setup = false;\n            return;\n        }\n\n        if", "first_line_groundtruth": "core.severe(\"Gameshield is not valid! Please run /neoprotect setgameshield to set the gameshield\");", "first_line_prediction": " core.severe(\"Gameshield is not valid! Please run /neoprotect setup to set the Gameshield ID\");", "match": 0}
{"groundtruth": "core.severe(\"API is not valid! Please run /neoprotect setup to set the API Key\");", "prediction": " core.severe(\"API Key invalid!\");\n        }\n\n        if (isGameshieldInvalid(Config.getGameShieldID())) {\n            core.severe(\"Gameshield ID invalid!\");\n        }\n\n        if (isBackendInvalid(Config.getBackendID())) {\n            core.severe(\"Backend ID invalid!\");\n        }\n    }\n\n    public void attackCheckSchedule() {\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                if (isAttack()) {\n                    core.severe(\"Gameshield is under attack!\");\n                }\n            }\n        }, ", "first_line_groundtruth": "core.severe(\"API is not valid! Please run /neoprotect setup to set the API Key\");", "first_line_prediction": " core.severe(\"API Key invalid!\");", "match": 0}
{"groundtruth": "null, Config.getGameShieldID()).getResponseBodyArray();", "prediction": " null, Config.getGameShieldID()).getResponseBodyArray();\n\n        for (Object object : backends) {\n            JSONObject jsonObject = (JSONObject) object;\n            list.add(new Backend(jsonObject.getString(\"id\"), jsonObject.getString(\"name\")));\n        }\n\n        return list;\n    }\n\n    public boolean isSetup() {\n        return setup;\n    }\n\n    public boolean isAttacking() {\n        return isAttack();\n    }\n\n    public boolean isPanicMode() {\n        return rest.request(RequestType.GET_GAMESHIELD_INFO, null, Config.getGameShieldID()).getResponseBodyObject().getJSONObject(\"game", "first_line_groundtruth": "null, Config.getGameShieldID()).getResponseBodyArray();", "first_line_prediction": " null, Config.getGameShieldID()).getResponseBodyArray();", "match": 0}
{"groundtruth": "Config.setGeyserBackendID(args[1]);", "prediction": " Config.setGeyserBackendID(args[1]);\n\n        instance.sendMessage(sender, localization.get(locale, \"set.backend\", \"geyser\", args[1]));\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().", "first_line_groundtruth": "Config.setGeyserBackendID(args[1]);", "first_line_prediction": " Config.setGeyserBackendID(args[1]);", "match": 0}
{"groundtruth": "Config.setBackendID(args[1]);", "prediction": " Config.setJavaBackendID(args[1]);\n         instance.sendMessage(sender, localization.get(locale, \"set.backend\", \"java\", args[1]));", "first_line_groundtruth": "Config.setBackendID(args[1]);", "first_line_prediction": " Config.setJavaBackendID(args[1]);", "match": 0}
{"groundtruth": "int response = instance.getCore().getRestAPI().toggle(args[1]);", "prediction": " instance.getCore().getRestAPI().toggle(args[1]);\n             instance.sendMessage(sender, localization.get(locale, \"command.toggle\", args[1], instance.getCore().getRestAPI().isToggled(args[1]) ? \"utils.activated\" : \"utils.deactivated\"));\n        }\n    }\n\n    private void analytics() {\n        instance.getCore().getAnalytics().sendAnalytics(sender);\n    }\n\n    private void firewall(String[] args) {\n        if (args.length != 2) {\n            instance.sendMessage(sender, localization.get(locale, \"", "first_line_groundtruth": "int response = instance.getCore().getRestAPI().toggle(args[1]);", "first_line_prediction": " instance.getCore().getRestAPI().toggle(args[1]);", "match": 0}
{"groundtruth": "getBackends().stream().noneMatch(e -> e.compareById(backendID));", "prediction": " !new ResponseManager(rest.callRequest(rest.defaultBuilder().url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_BACKEND_INFO, backendID)).build())).checkCode(200);\n    }\n\n    public boolean isFirewallInvalid(String firewallID) {\n        return  !new ResponseManager(rest.callRequest(rest.defaultBuilder().url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_FIREWALL_INFO, firewallID)).build())).checkCode(200);\n    }\n\n    public boolean isIPValid(String ip) {\n       ", "first_line_groundtruth": "getBackends().stream().noneMatch(e -> e.compareById(backendID));", "first_line_prediction": " !new ResponseManager(rest.callRequest(rest.defaultBuilder().url(rest.getBaseURL() + rest.getSubDirectory(RequestType.GET_BACKEND_INFO, backendID)).build())).checkCode(200);", "match": 0}
{"groundtruth": "= instance.getCore().getRestAPI().getTraffic();", "prediction": " = analytics.getJSONObject(ak);\n                instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7bTraffic \u00a77\u00a7l---------\");\n                traffic.keySet().forEach(ak2 -> {\n                    instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7b\" + ak2 + \" \u00a77\u00a7l---------\");\n                    traffic.getJSONArray(ak2).forEach(ak3 -> {\n                        instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7b\" + ak3 + \" \u00a77\u00a7l---------\");\n                    });\n                });\n                return;\n            }\n\n            instance.sendMessage(sender, ak + \":", "first_line_groundtruth": "= instance.getCore().getRestAPI().getTraffic();", "first_line_prediction": " = analytics.getJSONObject(ak);", "match": 0}
{"groundtruth": "Config.setGameShieldID(args[1]);", "prediction": " instance.getCore().getRestAPI().setGameshield(args[1]);\n         instance.sendMessage(sender, localization.get(locale, \"set.gameshield\", args[1]));\n    }\n\n    private void setGamemode(String[] args) {\n        if (args.length < 2) {\n            instance.sendMessage(sender, localization.get(locale, \"set.gamemode.usage\"));\n            return;\n        }\n\n        if (args[1].equalsIgnoreCase(\"creative\")) {\n            instance.getCore().getRestAPI().setGamemode(args[1]);\n            instance.sendMessage(sender,", "first_line_groundtruth": "Config.setGameShieldID(args[1]);", "first_line_prediction": " instance.getCore().getRestAPI().setGameshield(args[1]);", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \"\u00a77\u00a7l----- \u00a7bFirewall (\" + args[0].toUpperCase() + \")\u00a77\u00a7l -----\");", "prediction": " instance.getCore().getFirewall().toggle(args[0]);\n             instance.sendMessage(sender, localization.get(locale, \"command.firewall\", args[0],\n                     localization.get(locale, instance.getCore().getFirewall().isOn(args[0]) ? \"utils.activated\" : \"utils.deactivated\")));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n        }\n    }\n\n    private void debugTool(String[] args) {\n        if (args.length == 1) {\n            if (args[0].equals(\"", "first_line_groundtruth": "instance.sendMessage(sender, \"\u00a77\u00a7l----- \u00a7bFirewall (\" + args[0].toUpperCase() + \")\u00a77\u00a7l -----\");", "first_line_prediction": " instance.getCore().getFirewall().toggle(args[0]);", "match": 0}
{"groundtruth": "Config.setAPIKey(msg);", "prediction": " if (instance.getCore().getRestAPI().isAPIExpired(msg)) {\n            instance.sendMessage(sender, localization.get(locale, \"apikey.expired\"));\n            return;\n        }\n\n        if (instance.getCore().getRestAPI().isAPIDisabled(msg)) {\n            instance.sendMessage(sender, localization.get(locale, \"apikey.disabled\"));\n            return;\n        }\n\n        if (instance.getCore().getRestAPI().isAPIBlocked(msg)) {\n            instance.sendMessage(sender, localization.get(locale, \"apikey.blocked\"));\n            return;\n        }\n\n        if (", "first_line_groundtruth": "Config.setAPIKey(msg);", "first_line_prediction": " if (instance.getCore().getRestAPI().isAPIExpired(msg)) {", "match": 0}
{"groundtruth": "(instance.getPluginType() == NeoProtectPlugin.PluginType.SPIGOT) {", "prediction": " (args.length == 1) {\n            instance.sendMessage(sender, \"\u00a77\u00a7l----- \u00a7bDebug Tool\u00a77\u00a7l -----\");\n            instance.getCore().getRestAPI().getDebugTool().forEach((debugTool ->\n                    instance.sendMessage(sender, \"IP: \" + debugTool.getIp() + \" ID(\" + debugTool.getId() + \")\")));\n        } else if (args.length == 3) {\n            String ip = args[2];\n            String action = args[1];\n            String mode = args[0].toUpperCase();\n            int response = instance.get", "first_line_groundtruth": "(instance.getPluginType() == NeoProtectPlugin.PluginType.SPIGOT) {", "first_line_prediction": " (args.length == 1) {", "match": 0}
{"groundtruth": "instance.getCore().severe(ex.getMessage(), ex);", "prediction": " instance.sendMessage(sender, localization.get(locale, \"debug.finished.error\") + ex.getMessage());\n                         instance.getCore().setDebugRunning(false);\n                     }\n                });\n            }\n        }, 10000, 10000);\n    }", "first_line_groundtruth": "instance.getCore().severe(ex.getMessage(), ex);", "first_line_prediction": " instance.sendMessage(sender, localization.get(locale, \"debug.finished.error\") + ex.getMessage());", "match": 0}
{"groundtruth": "response = instance.getCore().getRestAPI().updateFirewall(ip, action, mode);", "prediction": "irc = 0;\n            int geyser = 0;\n            int bedrock = 0;\n\n            if (mode.equals(\"IRC\")) {\n                irc = 1;\n            } else if (mode.equals(\"Geyser\")) {\n                geyser = 1;\n            } else if (mode.equals(\"Bedrock\")) {\n                bedrock = 1;\n            }\n\n            if (action.equals(\"add\")) {\n                instance.getCore().getRestAPI().addFirewall(ip, irc, geyser, bedrock);\n                instance.sendMessage(sender, \"\u00a7a", "first_line_groundtruth": "response = instance.getCore().getRestAPI().updateFirewall(ip, action, mode);", "first_line_prediction": "irc = 0;", "match": 0}
{"groundtruth": "instance.getCore().getDirectConnectWhitelist().add(args[1]);", "prediction": " instance.getCore().getRestAPI().setDirectConnectWhitelist(args[1]);\n             instance.sendMessage(sender, localization.get(locale, \"command.directconnectwhitelist\", args[1]));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"usage.directconnectwhitelist\"));\n        }\n    }\n\n    private void toggle(String[] args) {\n        if (args.length == 2) {\n            instance.getCore().getRestAPI().toggle(args[1]);\n            instance.sendMessage(sender, localization.get(locale, \"command.toggle\", args[1]));", "first_line_groundtruth": "instance.getCore().getDirectConnectWhitelist().add(args[1]);", "first_line_prediction": " instance.getCore().getRestAPI().setDirectConnectWhitelist(args[1]);", "match": 0}
{"groundtruth": "(\"general.ProxyPlugins\", instance.getPlugins());", "prediction": "(\"general.ProxyPlayers\", stats.getOnlinePlayers());\n                        configuration.set(\"general.ProxyMaxPlayers\", stats.getMaxPlayers());\n                        configuration.set(\"general.ProxyOnlinePlayers\", stats.getOnlinePlayers());\n                        configuration.set(\"general.ProxyMaxPlayers\", stats.getMaxPlayers());\n                        configuration.set(\"general.ProxyOnlinePlayers\", stats.getOnlinePlayers());\n                        configuration.set(\"general.ProxyMaxPlayers\", stats.getMaxPlayers());\n                        configuration.set(\"general.ProxyOnlinePlayers\", stats.getOnlinePlayers());\n                        configuration.set(\"general.ProxyMaxPlayers\", stats.getMaxPlayers());\n                       ", "first_line_groundtruth": "(\"general.ProxyPlugins\", instance.getPlugins());", "first_line_prediction": "(\"general.ProxyPlayers\", stats.getOnlinePlayers());", "match": 0}
{"groundtruth": "if (instance.getCore().getRestAPI().isAPIInvalid(msg)) {", "prediction": " if (this.isViaConsole) {\n             this.instance.getLogger().info(this.msg);\n         } else {\n             if (this.sender instanceof ProxiedPlayer) {\n                 ProxiedPlayer player = (ProxiedPlayer) this.sender;\n                 player.sendMessage(this.msg);\n             } else {\n                 this.instance.getLogger().info(this.msg);\n             }\n         }\n    }\n\n    private void debugEvent(ExecutorBuilder executorBuilder) {\n        initials(executorBuilder);\n\n        if (this.isViaConsole) {\n            this.instance.getLogger().info(this.msg", "first_line_groundtruth": "if (instance.getCore().getRestAPI().isAPIInvalid(msg)) {", "first_line_prediction": " if (this.isViaConsole) {", "match": 0}
{"groundtruth": "instance.getCore().setDebugRunning(false);", "prediction": " instance.sendMessage(sender, localization.get(locale, \"debug.cancel\"));\n                return;\n            }\n\n            if (args[1].equals(\"start\")) {\n                debugTimer.schedule(new DebugTimerTask(), 0, 1000);\n                instance.sendMessage(sender, localization.get(locale, \"debug.start\"));\n                return;\n            }\n\n            if (args[1].equals(\"stop\")) {\n                debugTimer.cancel();\n                instance.sendMessage(sender, localization.get(locale, \"debug.stop\"));\n                return;\n            }\n\n            if (args[1].equals(\"info", "first_line_groundtruth": "instance.getCore().setDebugRunning(false);", "first_line_prediction": " instance.sendMessage(sender, localization.get(locale, \"debug.cancel\"));", "match": 0}
{"groundtruth": "instance.getCore().isDebugRunning()) {", "prediction": "args.length == 1) {\n            if (instance.getCore().isDebugRunning()) {\n                instance.sendMessage(sender, localization.get(locale, \"debug.running\"));\n                return;\n            }\n\n            if (instance.getCore().isDebugRunning()) {\n                instance.sendMessage(sender, localization.get(locale, \"debug.running\"));\n                return;\n            }\n\n            if (instance.getCore().isDebugRunning()) {\n                instance.sendMessage(sender, localization.get(locale, \"debug.running\"));\n                return;\n            }\n\n            if (instance.getCore().isDebugRunning()) {\n                instance.", "first_line_groundtruth": "instance.getCore().isDebugRunning()) {", "first_line_prediction": "args.length == 1) {", "match": 0}
{"groundtruth": "instance.getCore().getPlayerInSetup().add(sender);", "prediction": " instance.getCore().setup();\n    }\n\n    private void iPanic(String[] args) {\n        if (args.length == 1) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.ipanic\"));\n            return;\n        }\n\n        if (args[1].equals(\"on\")) {\n            instance.getCore().setIPPanic(true);\n            instance.sendMessage(sender, localization.get(locale, \"ipanic.on\"));\n        } else if (args[1].equals(\"off\")) {\n            instance.getCore().setIPPanic(false);\n            instance", "first_line_groundtruth": "instance.getCore().getPlayerInSetup().add(sender);", "first_line_prediction": " instance.getCore().setup();", "match": 0}
{"groundtruth": ", instance.getCore().getRestAPI().togglePanicMode() ? \"utils.activated\" : \"utils.deactivated\")));", "prediction": ", \"utils.click\"),\n                    \"OPEN_URL\", \"https://panel.neoprotect.net/profile\",\n                    \"SHOW_TEXT\", localization.get(locale, \"apikey.find\")));\n        }\n    }\n\n    private void directConnectWhitelist(String[] args) {\n        if (args.length != 1) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.directconnectwhitelist\"));\n        } else {\n            instance.sendMessage(sender, localization.get(locale, \"command.directconnectwhitelist\",\n                    localization.get(locale, \"utils.click\"),\n                    \"OPEN_", "first_line_groundtruth": ", instance.getCore().getRestAPI().togglePanicMode() ? \"utils.activated\" : \"utils.deactivated\")));", "first_line_prediction": ", \"utils.click\"),", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7bAnalytics \u00a77\u00a7l---------\");", "prediction": " instance.sendMessage(sender, localization.get(locale, \"command.analytics\"));\n    }\n\n    private void firewall(String[] args) {\n        if (args.length != 2) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));\n            return;\n        }\n\n        if (args[0].equals(\"whitelist\")) {\n            instance.getCore().getFirewall().add(args[1]);\n            instance.sendMessage(sender, localization.get(locale, \"command.firewall.whitelist\", args[1]));\n        } else if (args[0].equals(\"blacklist\")) {", "first_line_groundtruth": "instance.sendMessage(sender, \"\u00a77\u00a7l--------- \u00a7bAnalytics \u00a77\u00a7l---------\");", "first_line_prediction": " instance.sendMessage(sender, localization.get(locale, \"command.analytics\"));", "match": 0}
{"groundtruth": "instance.getCore().getDebugPingResponses().clear();", "prediction": " instance.getCore().getDebugPingResponses().clear();\n\n                        instance.sendMessage(sender, localization.get(locale, \"debug.pasting\") + \" \" + pasteKey);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n        }, 10000, 10000);\n    }", "first_line_groundtruth": "instance.getCore().getDebugPingResponses().clear();", "first_line_prediction": " instance.getCore().getDebugPingResponses().clear();", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \"\u00a7cCan not found setting '\" + args[1] + \"'\");", "prediction": " instance.sendMessage(sender, localization.get(locale, \"err.unknown\"));\n                return;\n            }\n\n            instance.sendMessage(sender, localization.get(locale, \"command.toggle\", args[1], response == 200 ? \"utils.activated\" : \"utils.deactivated\"));\n        }\n    }\n\n    private void analytics() {\n        instance.getCore().getAnalytics().sendAnalytics(sender);\n    }\n\n    private void firewall(String[] args) {\n        if (args.length != 2) {\n            instance.sendMessage(sender, localization.get(locale, \"usage.firewall\"));", "first_line_groundtruth": "instance.sendMessage(sender, \"\u00a7cCan not found setting '\" + args[1] + \"'\");", "first_line_prediction": " instance.sendMessage(sender, localization.get(locale, \"err.unknown\"));", "match": 0}
{"groundtruth": "instance.getCore().setDebugRunning(true);", "prediction": " if (args.length == 1) {\n            instance.getCore().setDebugRunning(true);\n            instance.getCore().setDebugTimer(new Timer());\n            debugTimer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    instance.getCore().setDebugRunning(false);\n                    instance.sendMessage(sender, localization.get(locale, \"debug.cancelled\"));\n                }\n            }, 1000 * 60 * 10);\n            instance.sendMessage(sender, localization.get(locale, \"debug.started\"));\n            return;\n        }\n\n        if", "first_line_groundtruth": "instance.getCore().setDebugRunning(true);", "first_line_prediction": " if (args.length == 1) {", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np analytics\");", "prediction": " instance.sendMessage(sender, \" - /np debug\");\n        instance.sendMessage(sender, \" - /np debug start\");\n        instance.sendMessage(sender, \" - /np debug stop\");\n        instance.sendMessage(sender, \" - /np debug ping\");\n        instance.sendMessage(sender, \" - /np debug ping <amount>\");\n        instance.sendMessage(sender, \" - /np debug paste\");\n        instance.sendMessage(sender, \" - /np debug paste <amount>\");\n        instance.sendMessage(sender, \" - /np debug clear\");\n        instance.sendMessage(sender, \" - /np debug clear <", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np analytics\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np debug\");", "match": 0}
{"groundtruth": "List<Gameshield> gameshieldList = instance.getCore().getRestAPI().getGameshields();", "prediction": " new BukkitRunnable() {\n            @Override\n            public void run() {\n                if (instance.getCore().getGameshieldSelector() != null) {\n                    instance.getCore().getGameshieldSelector().openSelector(sender);\n                    cancel();\n                }\n            }\n        }.runTaskLater(instance, 20L);\n    }\n\n    private void gameshieldSelector(Player player) {\n        instance.sendMessage(player, localization.get(locale, \"select.gameshield\"));", "first_line_groundtruth": "List<Gameshield> gameshieldList = instance.getCore().getRestAPI().getGameshields();", "first_line_prediction": " new BukkitRunnable() {", "match": 0}
{"groundtruth": "instance.getCore().getDebugPingResponses().keySet().forEach((playerName -> {", "prediction": " configuration.set(\"general.uptime\", (System.currentTimeMillis() - startTime) / 1000);\n                        configuration.set(\"general.onlinePlayers\", stats.getOnlinePlayers());\n                        configuration.set(\"general.maxPlayers\", stats.getMaxPlayers());\n                        configuration.set(\"general.tps\", stats.getTps());\n                        configuration.set(\"general.tps_max\", stats.getTpsMax());\n                        configuration.set(\"general.tps_min\", stats.getTpsMin());\n                        configuration.set(\"general.tps_average\", stats.getTpsAverage());\n                        configuration.set(\"general.tps_", "first_line_groundtruth": "instance.getCore().getDebugPingResponses().keySet().forEach((playerName -> {", "first_line_prediction": " configuration.set(\"general.uptime\", (System.currentTimeMillis() - startTime) / 1000);", "match": 0}
{"groundtruth": "instance.getCore().getRestAPI().isGameshieldInvalid(args[1])) {", "prediction": "args.length < 2) {\n            instance.sendMessage(sender, localization.get(locale, \"error.notEnoughArguments\"));\n            return;\n        }\n\n        try {\n            int gameshieldId = Integer.parseInt(args[1]);\n            instance.getCore().setGameshield(gameshieldId);\n            instance.sendMessage(sender, localization.get(locale, \"set.gameshield\", gameshieldId));\n        } catch (NumberFormatException ex) {\n            instance.sendMessage(sender, localization.get(locale, \"error.notAnInteger\"));\n        }\n    }\n\n    private void setGamemode(", "first_line_groundtruth": "instance.getCore().getRestAPI().isGameshieldInvalid(args[1])) {", "first_line_prediction": "args.length < 2) {", "match": 0}
{"groundtruth": "List<DebugPingResponse> list = instance.getCore().getDebugPingResponses().get(playerName);", "prediction": " configuration.set(\"general.debugPingResponses.\" + playerName, instance.getCore().getDebugPingResponses().get(playerName));\n                        }));\n\n                        configuration.set(\"general.debugPingResponses.time\", System.currentTimeMillis() - startTime);\n\n                        configuration.save(file);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n        }, 10000);\n    }\n\n    private boolean isInteger(String s) {\n        try {\n            Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n            return false;\n        }\n        return true;\n   ", "first_line_groundtruth": "List<DebugPingResponse> list = instance.getCore().getDebugPingResponses().get(playerName);", "first_line_prediction": " configuration.set(\"general.debugPingResponses.\" + playerName, instance.getCore().getDebugPingResponses().get(playerName));", "match": 0}
{"groundtruth": "instance.getCore().getRestAPI().getAnalytics().keySet().forEach(ak -> {", "prediction": "\n\n        if (analytics.has(\"total_players\")) {\n            instance.sendMessage(sender, \"\u00a77\u00a7lTotal Players: \u00a7b\" + analytics.getInt(\"total_players\"));\n        }\n\n        if (analytics.has(\"total_online\")) {\n            instance.sendMessage(sender, \"\u00a77\u00a7lTotal Online: \u00a7b\" + analytics.getInt(\"total_online\"));\n        }\n\n        if (analytics.has(\"total_online_bedrock\")) {\n            instance.sendMessage(sender, \"\u00a77\u00a7lTotal Online Bedrock: \u00a7b\" + analytics.getInt(\"total_online_bed", "first_line_groundtruth": "instance.getCore().getRestAPI().getAnalytics().keySet().forEach(ak -> {", "first_line_prediction": "", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np toggle (option)\");", "prediction": " instance.sendMessage(sender, \" - /np debug\");\n        instance.sendMessage(sender, \" - /np debug start\");\n        instance.sendMessage(sender, \" - /np debug stop\");\n        instance.sendMessage(sender, \" - /np debug ping\");\n        instance.sendMessage(sender, \" - /np debug ping <amount>\");\n        instance.sendMessage(sender, \" - /np debug paste\");\n        instance.sendMessage(sender, \" - /np debug paste <amount>\");\n        instance.sendMessage(sender, \" - /np debug clear\");\n        instance.sendMessage(sender, \" - /np debug clear <", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np toggle (option)\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np debug\");", "match": 0}
{"groundtruth": "backendList = instance.getCore().getRestAPI().getBackends();", "prediction": " backendList = instance.getCore().getRestAPI().getBackends();\n\n        instance.sendMessage(sender, localization.get(locale, \"select.java.backend\"));\n\n        for (Backend backend : backendList) {\n            instance.sendMessage(sender, \"\u00a75\" + backend.getName() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setjavabackend \" + backend.getId(),\n                    \"SHOW_TEXT\", localization.get(locale, \"hover.java.backend\", backend.getName(), backend.getId()));\n        }\n    }\n\n    private void setJavaBackend", "first_line_groundtruth": "backendList = instance.getCore().getRestAPI().getBackends();", "first_line_prediction": " backendList = instance.getCore().getRestAPI().getBackends();", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np debugTool (cancel / amount)\");", "prediction": " instance.sendMessage(sender, \" - /np debug (amount)\");\n        instance.sendMessage(sender, \" - /np setgameshield (id)\");\n        instance.sendMessage(sender, \" - /np setbackend (id)\");\n        instance.sendMessage(sender, \" - /np setgeyserbackend (id)\");\n        instance.sendMessage(sender, \" - /np setdebug (true/false)\");\n        instance.sendMessage(sender, \" - /np setlocale (locale)\");\n        instance.sendMessage(sender, \" - /np setdebug (true/false)\");\n        instance.sendMessage(sender, \" - /", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np debugTool (cancel / amount)\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np debug (amount)\");", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np setup\");", "prediction": " instance.sendMessage(sender, \"\u00a75/np reload\", \"RUN_COMMAND\", \"/np reload\", \"SHOW_TEXT\", localization.get(locale, \"hover.reload\"));\n         instance.sendMessage(sender, \"\u00a75/np debug\", \"RUN_COMMAND\", \"/np debug\", \"SHOW_TEXT\", localization.get(locale, \"hover.debug\"));\n         instance.sendMessage(sender, \"\u00a75/np setup\", \"RUN_COMMAND\", \"/np setup\", \"SHOW_TEXT\", localization.get(locale, \"hover.setup\"));\n         instance.sendMessage(sender, \"\u00a75/np", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np setup\");", "first_line_prediction": " instance.sendMessage(sender, \"\u00a75/np reload\", \"RUN_COMMAND\", \"/np reload\", \"SHOW_TEXT\", localization.get(locale, \"hover.reload\"));", "match": 0}
{"groundtruth": "instance.getCore().getPlayerInSetup().remove(sender)) {", "prediction": "instance.getCore().getRestAPI().isGeyserBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.geyserbackend\", args[1]));\n            return;\n        }\n\n        instance.getCore().getRestAPI().testGeyserCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testGeyserCredentials();\n\n        instance.getCore().getRestAPI().testCredentials();\n\n        instance.getCore().getRestAPI().testGeyserCredentials();\n\n        instance.", "first_line_groundtruth": "instance.getCore().getPlayerInSetup().remove(sender)) {", "first_line_prediction": "instance.getCore().getRestAPI().isGeyserBackendInvalid(args[1])) {", "match": 0}
{"groundtruth": "instance.getCore().getRestAPI().testCredentials();", "prediction": "\n\n        neoBackendSelector();\n    }\n\n    private void neoBackendSelector() {\n        List<Backend> backendList = instance.getCore().getRestAPI().getBackends();\n\n        instance.sendMessage(sender, localization.get(locale, \"select.backend\", \"neo\"));\n\n        for (Backend backend : backendList) {\n            if(!backend.isGeyser())continue;\n            instance.sendMessage(sender, \"\u00a75\" + backend.getIp() + \":\" + backend.getPort() + localization.get(locale, \"utils.click\"),\n                     \"RUN_COMMAND\", \"/np setbackend \"", "first_line_groundtruth": "instance.getCore().getRestAPI().testCredentials();", "first_line_prediction": "", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np whitelist (add/remove) (ip)\");", "prediction": " instance.sendMessage(sender, \" - /np debug (option)\");\n        instance.sendMessage(sender, \" - /np setgameshield (id)\");\n        instance.sendMessage(sender, \" - /np setbackend (id)\");\n        instance.sendMessage(sender, \" - /np setgeyserbackend (id)\");\n        instance.sendMessage(sender, \" - /np setlocale (locale)\");\n        instance.sendMessage(sender, \" - /np setdebug (option)\");\n        instance.sendMessage(sender, \" - /np setdebug (option)\");\n        instance.sendMessage(sender, \" - /np setdebug (", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np whitelist (add/remove) (ip)\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np debug (option)\");", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np directConnectWhitelist (ip)\");", "prediction": " instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");\n        instance.", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np directConnectWhitelist (ip)\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np debugPing (cancel / amount)\");", "match": 0}
{"groundtruth": "instance.sendMessage(sender, \" - /np setgameshield [id]\");", "prediction": " instance.sendMessage(sender, \" - /np directConnectBlacklist (ip)\");\n        instance.sendMessage(sender, \" - /np setgameshield (id)\");\n        instance.sendMessage(sender, \" - /np setbackend (id)\");\n        instance.sendMessage(sender, \" - /np setgeyserbackend (id)\");\n        instance.sendMessage(sender, \" - /np setdebug (true/false)\");\n        instance.sendMessage(sender, \" - /np setdebug (true/false)\");\n        instance.sendMessage(sender, \" - /np setdebug (true/false)\");\n        instance.sendMessage(", "first_line_groundtruth": "instance.sendMessage(sender, \" - /np setgameshield [id]\");", "first_line_prediction": " instance.sendMessage(sender, \" - /np directConnectBlacklist (ip)\");", "match": 0}
{"groundtruth": "if(backend.isGeyser())continue;", "prediction": " instance.sendMessage(sender, \"\u00a75\" + backend.getName() + localization.get(locale, \"utils.click\"),\n                     \"RUN_COMMAND\", \"/np setbackend \" + backend.getId(),\n                     \"SHOW_TEXT\", localization.get(locale, \"hover.backend\", backend.getName(), backend.getId()));\n        }\n    }\n\n    private void setBackend(String[] args) {\n\n        if (instance.getCore().getRestAPI().isBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.backend\", args[1]));\n            return", "first_line_groundtruth": "if(backend.isGeyser())continue;", "first_line_prediction": " instance.sendMessage(sender, \"\u00a75\" + backend.getName() + localization.get(locale, \"utils.click\"),", "match": 0}
{"groundtruth": "product.setDescription(\"\u042d\u0442\u043e \u0432\u0430\u0448\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435!\");", "prediction": " product.setDisableButton(true);\n            }\n        }\n        model.addAttribute(\"products\", products);\n        return \"main-user\";\n    }\n\n    @GetMapping(\"/table-products/{productId}\")\n    public String getTableProductsPage(@PathVariable long productId, Model model, HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        Product product = productService.findById(productId).orElseThrow();\n        if (transactionService.isProductInTransactions(product)) {\n            product.setDescription(\"\u042d\u0442\u043e\u0442 \u0442\u043e\u0432\u0430\u0440 \u0443\u0436\u0435 \u043f\u0440\u043e\u0434\u0430\u043d!\");\n            product", "first_line_groundtruth": "product.setDescription(\"\u042d\u0442\u043e \u0432\u0430\u0448\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435!\");", "first_line_prediction": " product.setDisableButton(true);", "match": 0}
{"groundtruth": ".get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));", "prediction": ".get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));\n        }\n    }\n\n    private void setBackend(String[] args) {\n\n        if (instance.getCore().getRestAPI().isBackendInvalid(args[1])) {\n            instance.sendMessage(sender, localization.get(locale, \"invalid.backend\", args[1]));\n            return;\n        }\n\n        Config.setBackendID(args[1]);\n        instance.sendMessage(sender, localization.get(locale, \"set.backend\", args[1]));\n\n        neoBackendSelector();\n    }\n\n   ", "first_line_groundtruth": ".get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));", "first_line_prediction": ".get(locale, \"hover.backend\", backend.getIp(), backend.getPort(), backend.getId()));", "match": 1}
{"groundtruth": "setEmail(user.getEmail());", "prediction": "setPassword(<PASSWORD>());\n                existUser.setRole(user.getRole());\n                existUser.setEmail(user.getEmail());\n                existUser.setFirstName(user.getFirstName());\n                existUser.setLastName(user.getLastName());\n                existUser.setPhoneNumber(user.getPhoneNumber());\n                existUser.setAddress(user.getAddress());\n                existUser.setBirthDate(user.getBirthDate());\n                existUser.setGender(user.getGender());\n                existUser.setAbout(user.getAbout());\n                existUser.setProfileImage(user.getProfileImage());\n               ", "first_line_groundtruth": "setEmail(user.getEmail());", "first_line_prediction": "setPassword(<PASSWORD>());", "match": 0}
{"groundtruth": "gameshield.getName(), gameshield.getId()));", "prediction": "1, gameshield.getName()));\n        }\n    }\n\n    private void gameshieldSelector(Player player) {\n        instance.sendMessage(player, localization.get(locale, \"select.gameshield\"));\n\n        List<Gameshield> gameshieldList = instance.getCore().getRestAPI().getGameshields();\n\n        for (Gameshield gameshield : gameshieldList) {\n            instance.sendMessage(player, \"\u00a75\" + gameshield.getName() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setgameshield \" + gameshield.getId(),\n                    \"SHOW_", "first_line_groundtruth": "gameshield.getName(), gameshield.getId()));", "first_line_prediction": "1, gameshield.getName()));", "match": 0}
{"groundtruth": "existUser.setRole(user.getRole());", "prediction": " userRepository.save(existUser);\n            }\n        }\n        return \"redirect:/table-users\";\n    }\n\n    @PostMapping(\"/delete/{id}\")\n    public String deleteUser(@PathVariable(\"id\") Long id, HttpSession session) {\n        User currentUser = (User) session.getAttribute(\"user\");\n        if (!currentUser.getId().equals(id)) {\n            Optional<User> optUser = userRepository.findById(id);\n            if (optUser.isPresent()) {\n                userRepository.deleteById(id);\n            }\n        }\n        return \"redirect:/table-users\";\n    }", "first_line_groundtruth": "existUser.setRole(user.getRole());", "first_line_prediction": " userRepository.save(existUser);", "match": 0}
{"groundtruth": "Component.text(core.getPrefix() + text);", "prediction": " new TextComponent(text);\n        if (clickAction != null)\n            msg.setClickEvent(new ClickEvent(ClickEvent.Action.valueOf(clickAction), clickMsg));\n        if (hoverAction != null)\n            msg.setHoverEvent(new HoverEvent(HoverEvent.Action.valueOf(hoverAction), new ComponentBuilder(hoverMsg).create()));\n        if (receiver instanceof CommandSource) ((CommandSource) receiver).sendMessage(msg);\n        if (receiver instanceof Player) ((Player) receiver).sendMessage(msg);\n        if (receiver instanceof ConnectedPlayer) ((ConnectedPlayer) receiver).getPlayer().sendMessage(", "first_line_groundtruth": "Component.text(core.getPrefix() + text);", "first_line_prediction": " new TextComponent(text);", "match": 0}
{"groundtruth": "(user.getRole().equals(\"ADMIN\")) {", "prediction": " (user.getRole().equals(\"ADMIN\")) {\n                return \"redirect:/admin\";\n            } else {\n                return \"redirect:/user\";\n            }\n        } else {\n            model.addAttribute(\"error\", \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043b\u043e\u0433\u0438\u043d \u0438\u043b\u0438 \u043f\u0430\u0440\u043e\u043b\u044c!\");\n            return \"authorisation\";\n        }\n    }", "first_line_groundtruth": "(user.getRole().equals(\"ADMIN\")) {", "first_line_prediction": " (user.getRole().equals(\"ADMIN\")) {", "match": 0}
{"groundtruth": "set(\"general.pluginVersion\", stats.getPluginVersion());", "prediction": "set(\"general.osArch\", System.getProperty(\"os.arch\"));\n                        configuration.set(\"general.osVersion\", System.getProperty(\"os.version\"));\n                        configuration.set(\"general.osLanguage\", System.getProperty(\"user.language\"));\n                        configuration.set(\"general.osCountry\", System.getProperty(\"user.country\"));\n                        configuration.set(\"general.osTimezone\", System.getProperty(\"user.timezone\"));\n                        configuration.set(\"general.osLocale\", System.getProperty(\"user.locale\"));\n                        configuration.set(\"general.osName\", System.getProperty(\"os.name\"));\n                        configuration.set(\"", "first_line_groundtruth": "set(\"general.pluginVersion\", stats.getPluginVersion());", "first_line_prediction": "set(\"general.osArch\", System.getProperty(\"os.arch\"));", "match": 0}
{"groundtruth": "if (product.getCreatedBy().getId().equals(currentUserId)) {", "prediction": " else if (product.getCreatedBy().getId().equals(currentUserId)) {\n                product.setDescription(\"\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u044d\u0442\u043e\u0442 \u0442\u043e\u0432\u0430\u0440!\");\n                product.setDisableButton(true);\n            }\n        }\n        model.addAttribute(\"products\", products);\n        return \"main-user\";\n    }\n\n    @GetMapping(\"/table-products/{id}\")\n    public String getTableProductsPage(@PathVariable long id, Model model, HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n\n        List<Product> products = productService.findAll();", "first_line_groundtruth": "if (product.getCreatedBy().getId().equals(currentUserId)) {", "first_line_prediction": " else if (product.getCreatedBy().getId().equals(currentUserId)) {", "match": 0}
{"groundtruth": "\"general.ProxyVersion\", stats.getServerVersion());", "prediction": "stats.getServerName() + \".onlinePlayers\", stats.getOnlinePlayers());\n                        configuration.set(stats.getServerName() + \".maxPlayers\", stats.getMaxPlayers());\n                        configuration.set(stats.getServerName() + \".motd\", stats.getMotd());\n                        configuration.set(stats.getServerName() + \".version\", stats.getVersion());\n                        configuration.set(stats.getServerName() + \".uptime\", stats.getUptime());\n                        configuration.set(stats.getServerName() + \".motd\", stats.getMotd());\n                        configuration.set(stats.getServerName() + \".", "first_line_groundtruth": "\"general.ProxyVersion\", stats.getServerVersion());", "first_line_prediction": "stats.getServerName() + \".onlinePlayers\", stats.getOnlinePlayers());", "match": 0}
{"groundtruth": "user.setStatus(\"\u0410\u043a\u0442\u0438\u0432\u043d\u044b\u0439\");", "prediction": " userRepository.save(user);\n        return \"redirect:/registration\";\n    }", "first_line_groundtruth": "user.setStatus(\"\u0410\u043a\u0442\u0438\u0432\u043d\u044b\u0439\");", "first_line_prediction": " userRepository.save(user);", "match": 0}
{"groundtruth": ", stats.getServerName());", "prediction": " , stats.getProxyName());\n                        configuration.set(\"general.ProxyVersion\" , stats.getProxyVersion());\n                        configuration.set(\"general.ProxyBuild\" , stats.getProxyBuild());\n                        configuration.set(\"general.ProxyBuildDate\" , stats.getProxyBuildDate());\n                        configuration.set(\"general.ProxyBuildTime\" , stats.getProxyBuildTime());\n                        configuration.set(\"general.ProxyBuildTimeMillis\" , stats.getProxyBuildTimeMillis());\n                        configuration.set(\"general.ProxyBuildTimeMillis2\" , stats.getProxyBuildTimeMillis2());\n                        configuration.set(\"", "first_line_groundtruth": ", stats.getServerName());", "first_line_prediction": " , stats.getProxyName());", "match": 0}
{"groundtruth": "(!currentUser.getId().equals(id)) {", "prediction": " (currentUser.getId().equals(id)) {\n            userRepository.save(user);\n            return \"redirect:/table-users\";\n        }\n        return \"redirect:/table-users\";\n    }\n\n    @PostMapping(\"/delete/{id}\")\n    public String deleteUser(@PathVariable(\"id\") Long id, HttpSession session) {\n        User currentUser = (User) session.getAttribute(\"user\");\n        if  (currentUser.getId().equals(id)) {\n            userRepository.deleteById(id);\n            return \"redirect:/table-users\";\n        }\n        return \"redirect:/table-users\";\n    }\n\n    @GetMapping(\"/add", "first_line_groundtruth": "(!currentUser.getId().equals(id)) {", "first_line_prediction": " (currentUser.getId().equals(id)) {", "match": 0}
{"groundtruth": "), gameshield.getId()));", "prediction": "instance.getCore().getLanguage())));\n        }\n    }\n\n    private void gameshieldSelector(Player player) {\n        instance.sendMessage(player, localization.get(locale, \"select.gameshield\"));\n\n        List<Gameshield> gameshieldList = instance.getCore().getRestAPI().getGameshields();\n\n        for (Gameshield gameshield : gameshieldList) {\n            instance.sendMessage(player, \"\u00a75\" + gameshield.getName() + localization.get(locale, \"utils.click\"),\n                    \"RUN_COMMAND\", \"/np setgameshield \" + gameshield.getId(),\n                    \"SHOW", "first_line_groundtruth": "), gameshield.getId()));", "first_line_prediction": "instance.getCore().getLanguage())));", "match": 0}
{"groundtruth": "product.setArtist(updatedProduct.getArtist());", "prediction": " productRepository.save(product);\n        return \"redirect:/table-products\";\n    }", "first_line_groundtruth": "product.setArtist(updatedProduct.getArtist());", "first_line_prediction": " productRepository.save(product);", "match": 0}
{"groundtruth": "user.setCreationDate(LocalDateTime.now());", "prediction": " user.setStatus(\"\u041d\u0435\u043f\u0440\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0439\");\n        user.setCreationDate(LocalDateTime.now());\n        userRepository.save(user);\n        return \"redirect:/registration\";\n    }", "first_line_groundtruth": "user.setCreationDate(LocalDateTime.now());", "first_line_prediction": " user.setStatus(\"\u041d\u0435\u043f\u0440\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0439\");", "match": 0}
{"groundtruth": "\"productId\", product.get().getId());", "prediction": "transactionService.getSalesData());\n            model.addAttribute(transactionService.getTransactionsByProduct(product.get()));\n            model.addAttribute(transactionService.getTransactionsBySeller(product.get()));\n            model.addAttribute(transactionService.getTransactionsByBuyer(product.get()));\n            model.addAttribute(transactionService.getTransactionsByMonth(product.get()));\n            model.addAttribute(transactionService.getTransactionsByYear(product.get()));\n            model.addAttribute(transactionService.getTransactionsByDay(product.get()));\n            model.addAttribute(transactionService.getTransactionsByHour(product.get()));\n           ", "first_line_groundtruth": "\"productId\", product.get().getId());", "first_line_prediction": "transactionService.getSalesData());", "match": 0}
{"groundtruth": "setImageUrl(updatedProduct.getImageUrl());", "prediction": "setPrice(updatedProduct.getPrice());\n        product.setCategory(updatedProduct.getCategory());\n        productRepository.save(product);\n        return \"redirect:/table-products\";\n    }", "first_line_groundtruth": "setImageUrl(updatedProduct.getImageUrl());", "first_line_prediction": "setPrice(updatedProduct.getPrice());", "match": 0}
{"groundtruth": "List<Comment> comments = commentRepository.findByProductId(id);", "prediction": " model.addAttribute(\"product\", product.get());\n             List<Comment> comments = commentRepository.findAllByProduct(product.get());\n             model.addAttribute(\"comments\", comments);\n             return \"product-details\";\n        } else {\n            return \"redirect:/main-user\";\n        }\n    }", "first_line_groundtruth": "List<Comment> comments = commentRepository.findByProductId(id);", "first_line_prediction": " model.addAttribute(\"product\", product.get());", "match": 0}
{"groundtruth": "product.setCreationDate(LocalDateTime.now());", "prediction": " productRepository.save(product);\n        return \"redirect:/table-products\";\n    }\n\n    @GetMapping(\"/{id}\")\n    public String getProductById(@PathVariable long id, Model model) {\n        Optional<Product> product = productRepository.findById(id);\n        if (product.isPresent()) {\n            model.addAttribute(\"product\", product.get());\n            return \"product-details\";\n        }\n        return \"redirect:/table-products\";\n    }\n\n    @GetMapping(\"/{id}/comments\")\n    public String getCommentsByProductId(@PathVariable long id, Model model) {\n        Optional<Product> product = productRepository.", "first_line_groundtruth": "product.setCreationDate(LocalDateTime.now());", "first_line_prediction": " productRepository.save(product);", "match": 0}
{"groundtruth": "user.setRole(\"USER\");", "prediction": " user.setRole(\"USER\");\n        user.setStatus(\"\u041d\u0435\u043f\u0440\u043e\u0432\u0435\u0440\u0435\u043d\u043d\u044b\u0439\");\n        user.setCreatedAt(LocalDateTime.now());\n        userRepository.save(user);\n        return \"redirect:/registration\";\n    }", "first_line_groundtruth": "user.setRole(\"USER\");", "first_line_prediction": " user.setRole(\"USER\");", "match": 0}
{"groundtruth": "product.get().getPrice().doubleValue());", "prediction": "product.get().getPrice());\n            transaction.setProductId(product.get().getId());\n\n            transactionRepository.save(transaction);\n\n            return \"redirect:/main-user\";\n        }\n\n        return \"redirect:/table-products\";\n    }\n\n    @GetMapping(\"/transactions\")\n    public String getTransactions(Model model, HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        List<Transaction> transactions = transactionService.findAllBySellerId(user.getId());\n        model.addAttribute(\"transactions\", transactions);\n        return \"transactions\";\n    }\n\n    @", "first_line_groundtruth": "product.get().getPrice().doubleValue());", "first_line_prediction": "product.get().getPrice());", "match": 0}
{"groundtruth": "System.out.println(transaction.getBuyerId());", "prediction": " transactionService.processTransaction(transaction, productId);\n        } catch (Exception e) {\n            model.addAttribute(\"error\", e.getMessage());\n        }\n        return \"redirect:/table-products/\" + productId;\n    }\n\n    @GetMapping(\"/table-transactions\")\n    public String transactions(Model model, HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        List<Transaction> transactions = transactionRepository.findAllBySellerId(user.getId());\n        model.addAttribute(\"transactions\", transactions);\n        return \"table-transactions\";\n    }\n\n    @GetMapping", "first_line_groundtruth": "System.out.println(transaction.getBuyerId());", "first_line_prediction": " transactionService.processTransaction(transaction, productId);", "match": 0}
{"groundtruth": "<OrderItem> orderItems = productService.findOrderItemsByProduct(id);", "prediction": "<OrderItem> orderItems = productService.findOrderItemsByProduct(id);\n        for (OrderItem orderItem : orderItems) {\n            productService.decrementProductStock(orderItem.getProduct().getId(), orderItem.getQuantity());\n        }\n        productService.deleteProduct(id);\n        redirectAttributes.addFlashAttribute(\"success\", \"\u0422\u043e\u0432\u0430\u0440 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0443\u0434\u0430\u043b\u0435\u043d\");\n        return \"redirect:/products\";\n    }", "first_line_groundtruth": "<OrderItem> orderItems = productService.findOrderItemsByProduct(id);", "first_line_prediction": "<OrderItem> orderItems = productService.findOrderItemsByProduct(id);", "match": 1}
{"groundtruth": "Optional<User> userOptional = userService.validateUser(username, password);", "prediction": " Optional<User> userOptional = userService.findByName(username);\n         if (userOptional.isPresent()) {\n             User user = userOptional.get();\n             if (user.getPassword().equals(password)) {\n                 session.setAttribute(\"user\", user);\n                 return \"redirect:/\";\n             }\n         }\n         model.addAttribute(\"error\", INVALID_USER);\n         return \"login\";\n     }", "first_line_groundtruth": "Optional<User> userOptional = userService.validateUser(username, password);", "first_line_prediction": " Optional<User> userOptional = userService.findByName(username);", "match": 0}
{"groundtruth": "return orderItemRepository.findAllByProduct_Id(productId);", "prediction": " return orderItemRepository.findAllByProduct_Id(productId);\n    }", "first_line_groundtruth": "return orderItemRepository.findAllByProduct_Id(productId);", "first_line_prediction": " return orderItemRepository.findAllByProduct_Id(productId);", "match": 0}
{"groundtruth": "TypeUtils.isPrimitiveOrSimpleType(typeCanonicalText)) {", "prediction": "TypeUtils.isPrimitiveOrSimpleType(typeCanonicalText)) {\n                return Collections.singletonList(new KV(typeCanonicalText, TypeUtils.getExampleValue(typeCanonicalText, true)));\n            }\n            return Collections.emptyList();\n        }\n\n        if (putClass) {\n            return new KV(typeCanonicalText, psiClass.getName());\n        }\n\n        if (psiClass.isEnum()) {\n            PsiField[] enumFields = psiClass.getAllFields();\n            return Collections.singletonList(new KV(psiClass.getName(), enumFields.length > 1 ? enumFields[0].getName()", "first_line_groundtruth": "TypeUtils.isPrimitiveOrSimpleType(typeCanonicalText)) {", "first_line_prediction": "TypeUtils.isPrimitiveOrSimpleType(typeCanonicalText)) {", "match": 1}
{"groundtruth": "(TypeUtils.isMap(typeCanonicalText)) {", "prediction": " (TypeUtils.isMap(typeCanonicalText)) {\n            String keyType = TypeUtils.getMapKeyType(typeCanonicalText);\n            String valueType = TypeUtils.getMapValueType(typeCanonicalText);\n            LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n            map.put(\"keyType\", assemblePsiClass(keyType, project, autoCorrelationCount, putClass));\n            map.put(\"valueType\", assemblePsiClass(valueType, project, autoCorrelationCount, putClass));\n            return map;\n        }\n\n        // \u6570\u7ec4|\u96c6\u5408\n        if (TypeUtils.isArray(typeCanonicalText) || TypeUtils.", "first_line_groundtruth": "(TypeUtils.isMap(typeCanonicalText)) {", "first_line_prediction": " (TypeUtils.isMap(typeCanonicalText)) {", "match": 0}
{"groundtruth": "= TypeUtils.primitiveToBox(typeCanonicalText);", "prediction": " = TypeUtils.getPrimitiveType(typeCanonicalText);\n        PsiShortNamesCache shortNamesCache = PsiShortNamesCache.getInstance(project);\n        return shortNamesCache.getClassesByName(typeCanonicalText, GlobalSearchScope.allScope(project)).stream().findFirst().orElse(null);\n    }", "first_line_groundtruth": "= TypeUtils.primitiveToBox(typeCanonicalText);", "first_line_prediction": " = TypeUtils.getPrimitiveType(typeCanonicalText);", "match": 0}
{"groundtruth": "instance.getCore().getDebugPingResponses().put(player.getUsername(), new ArrayList<>());", "prediction": " map.put(player.getUsername(), new ArrayList<>());\n                        }\n\n                        ArrayList<DebugPingResponse> debugPingResponses = map.get(player.getUsername());\n\n                        debugPingResponses.add(new DebugPingResponse(ping, neoRTT, backendRTT));\n\n                        instance.getCore().debug(\"DebugPingResponse added\");\n                    }\n\n                    pingMap.remove(keepAliveResponseKey);\n                }\n            }\n        });\n    }\n\n    public boolean isIPInRange(String ipRange, String ip) {\n        String[] ipRangeParts = ipRange.split(\"\\\\.\");\n        String[] ipParts = ip.split(\"\\\\", "first_line_groundtruth": "instance.getCore().getDebugPingResponses().put(player.getUsername(), new ArrayList<>());", "first_line_prediction": " map.put(player.getUsername(), new ArrayList<>());", "match": 0}
{"groundtruth": "if (TypeUtils.isPrimitiveOrSimpleType(fieldType.replaceAll(\"\\\\[]\", \"\"))) {", "prediction": " if (TypeUtils.isPrimitiveOrSimpleType(fieldType)) {\n                map.put(field.getName(), TypeUtils.getExampleValue(fieldType, false));\n                continue;\n            }\n            // \u6570\u7ec4|\u96c6\u5408\n            if (TypeUtils.isArray(fieldType) || TypeUtils.isList(fieldType)) {\n                map.put(field.getName(), assemblePsiClass(fieldType, project, autoCorrelationCount, putClass));\n                continue;\n            }\n            // \u5b58\u5728\u6cdb\u578b\n            map.put(field.getName(), assemblePsiClass(fieldType, project, autoCorrelationCount, putClass));\n        }\n        return", "first_line_groundtruth": "if (TypeUtils.isPrimitiveOrSimpleType(fieldType.replaceAll(\"\\\\[]\", \"\"))) {", "first_line_prediction": " if (TypeUtils.isPrimitiveOrSimpleType(fieldType)) {", "match": 0}
{"groundtruth": "TypeUtils.getExampleValue(typeCanonicalText, false);", "prediction": " Collections.singletonList(new KV(\"\", typeCanonicalText));\n            }\n            // \u679a\u4e3e\n            if (typeCanonicalText.contains(\".\")) {\n                return Collections.singletonList(new KV(\"\", typeCanonicalText));\n            }\n            // \u81ea\u5b9a\u4e49\u7c7b\u578b\n            return Collections.singletonList(new KV(\"\", typeCanonicalText));\n        }\n\n        if (putClass) {\n            return new KV(\"\", psiClass.getName());\n        }\n\n        // \u6570\u7ec4|\u96c6\u5408\n        if (TypeUtils.isArray(typeCanonicalText) || TypeUtils.isList(typeCanonicalText)) {\n            String elementType = TypeUtils.isArray(type", "first_line_groundtruth": "TypeUtils.getExampleValue(typeCanonicalText, false);", "first_line_prediction": " Collections.singletonList(new KV(\"\", typeCanonicalText));", "match": 0}
{"groundtruth": ".equals(date) && booking.getTime().equals(time)) {", "prediction": " == date && booking.getTime() == time) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": ".equals(date) && booking.getTime().equals(time)) {", "first_line_prediction": " == date && booking.getTime() == time) {", "match": 0}
{"groundtruth": ".getId() == tableId && booking.getDate().equals(date) && booking.getTime().equals(time)) {", "prediction": " == null) {\n                continue;\n            }\n            if (booking.getTable().getId() == tableId &&\n                    booking.getDate().equals(date) &&\n                    booking.getTime().equals(time)) {\n                return true;\n            }\n        }\n        return false;\n    }", "first_line_groundtruth": ".getId() == tableId && booking.getDate().equals(date) && booking.getTime().equals(time)) {", "first_line_prediction": " == null) {", "match": 0}
{"groundtruth": "staffRepository.findByLogin(login) != null;", "prediction": " staffRepository.findStaffByLogin(login).isPresent();\n    }", "first_line_groundtruth": "staffRepository.findByLogin(login) != null;", "first_line_prediction": " staffRepository.findStaffByLogin(login).isPresent();", "match": 0}
{"groundtruth": "staff.setApparatusEmployed(new java.sql.Date(currentDate.getTime()));", "prediction": " staff.setDismissalFromWork(currentDate);\n        staffService.addStaff(staff);\n        model.addAttribute(\"staff\", staffService.getAllStaff());\n        model.addAttribute(\"newStaff\", new Staff());\n        model.addAttribute(\"currentUser\", getCurrentUser());\n        return \"redirect:/staff\";\n    }\n\n    @GetMapping(\"/staff/edit\")\n    public String editStaff(Model model) {\n        model.addAttribute(\"staff\", staffService.getAllStaff());\n        model.addAttribute(\"newStaff\", new Staff());\n        model.addAttribute(\"currentUser\", getCurrentUser());\n        return \"staff\";\n    }\n\n    @PostMapping(\"/staff/", "first_line_groundtruth": "staff.setApparatusEmployed(new java.sql.Date(currentDate.getTime()));", "first_line_prediction": " staff.setDismissalFromWork(currentDate);", "match": 0}
{"groundtruth": "dishService.editDishDetails(id, name, description, recipe);", "prediction": " dishService.editDishDetails(id, name, description, recipe);\n        return \"redirect:/menu\";\n    }", "first_line_groundtruth": "dishService.editDishDetails(id, name, description, recipe);", "first_line_prediction": " dishService.editDishDetails(id, name, description, recipe);", "match": 0}
{"groundtruth": "DishType dishType = dishTypeRepository.findByName(typeName);", "prediction": " DishType dishType = dishTypeRepository.findByName(typeName);\n         if (dishType != null) {\n             Dish dish = new Dish(name, cost, dishType);\n             dishRepository.save(dish);\n         }\n    }\n\n    public Dish getDishById(int id) {\n        return dishRepository.findById(id).orElse(null);\n    }", "first_line_groundtruth": "DishType dishType = dishTypeRepository.findByName(typeName);", "first_line_prediction": " DishType dishType = dishTypeRepository.findByName(typeName);", "match": 0}
{"groundtruth": "(dishService.checkIfDishIsOrdered(id)) {", "prediction": " (dishService.checkIfDishIsOrdered(id)) {\n            return \"redirect:/menu\";\n        }\n        dishService.editDish(id, name, cost, typeName);\n        return \"redirect:/menu\";\n    }\n\n    @PostMapping(\"/menu/delete\")\n    public String deleteDish(@RequestParam(\"id\") int id) {\n        dishService.deleteDish(id);\n        return \"redirect:/menu\";\n    }\n\n    @PostMapping(\"/menu/add\")\n    public String addDish(@RequestParam(\"name\") String name, @RequestParam(\"cost\") double cost,\n                           @RequestParam(\"type\")", "first_line_groundtruth": "(dishService.checkIfDishIsOrdered(id)) {", "first_line_prediction": " (dishService.checkIfDishIsOrdered(id)) {", "match": 0}
{"groundtruth": "orderedDish.setStatus(status);", "prediction": " orderedDish.setStatus(status);\n             orderedDishRepository.save(orderedDish);\n        }\n        return \"redirect:/kitchen\";\n    }", "first_line_groundtruth": "orderedDish.setStatus(status);", "first_line_prediction": " orderedDish.setStatus(status);", "match": 0}
{"groundtruth": "<OrderedDish> dishesInOrder = orderedDishRepository.findAllByOrder(orderedDish.getOrder());", "prediction": "<OrderedDish> orderedDishes = orderedDishRepository.findAll();\n            List<OrderedDish> acceptedDishes = orderedDishes.stream()\n                    .filter(dish -> dish.getStatus().equals(\"\u041f\u0440\u0438\u043d\u044f\u0442\"))\n                    .collect(Collectors.toList());\n            model.addAttribute(\"orderedDishes\", acceptedDishes);\n        }\n        return \"redirect:/kitchen\";\n    }", "first_line_groundtruth": "<OrderedDish> dishesInOrder = orderedDishRepository.findAllByOrder(orderedDish.getOrder());", "first_line_prediction": "<OrderedDish> orderedDishes = orderedDishRepository.findAll();", "match": 0}
{"groundtruth": "if (dishService.checkIfDishIsOrdered(id)) {", "prediction": " dishService.deleteDish(id);\n         return \"redirect:/menu\";\n    }", "first_line_groundtruth": "if (dishService.checkIfDishIsOrdered(id)) {", "first_line_prediction": " dishService.deleteDish(id);", "match": 0}
{"groundtruth": "model.addAttribute(\"staff\", staffService.getAllStaff());", "prediction": " return \"staff\";\n        }\n        staffService.saveStaff(staff);\n        return \"redirect:/staff\";\n    }\n\n    @GetMapping(\"/staff/edit\")\n    public String editStaff(Model model) {\n        model.addAttribute(\"staff\", staffService.getAllStaff());\n        model.addAttribute(\"newStaff\", new Staff());\n        model.addAttribute(\"currentUser\", getCurrentUser());\n        return \"staff\";\n    }\n\n    @PostMapping(\"/staff/edit\")\n    public String editStaff(@ModelAttribute Staff staff, Model model) {\n        staffService.saveStaff(staff);\n        return \"redirect:/staff\";\n    }\n\n    @GetMapping(\"/", "first_line_groundtruth": "model.addAttribute(\"staff\", staffService.getAllStaff());", "first_line_prediction": " return \"staff\";", "match": 0}
{"groundtruth": "<Tables> allTables = tableBookingService.getAllTables();", "prediction": "<TableBooking> bookings = tableBookingService.getAllBookings();\n        model.addAttribute(\"bookings\", bookings);\n\n        List<Tables> allTables = tableBookingService.getAllTables();\n        model.addAttribute(\"tables\", allTables);\n\n        Date currentDate = Date.valueOf(LocalDate.now());\n        Date maxDate = Date.valueOf(LocalDate.now().plusDays(3));\n\n        model.addAttribute(\"currentDate\", currentDate);\n        model.addAttribute(\"maxDate\", maxDate);\n\n        List<LocalTime> times = new ArrayList<>();\n        for (LocalTime timeOption = LocalTime.of(1", "first_line_groundtruth": "<Tables> allTables = tableBookingService.getAllTables();", "first_line_prediction": "<TableBooking> bookings = tableBookingService.getAllBookings();", "match": 0}
{"groundtruth": "= orderedDish.getOrder();", "prediction": " = orderedDish.getOrder();\n                order.setStatus(status);\n                orderRepository.save(order);\n            }\n        }\n        return \"redirect:/kitchen\";\n    }", "first_line_groundtruth": "= orderedDish.getOrder();", "first_line_prediction": " = orderedDish.getOrder();", "match": 0}
{"groundtruth": "loginExists(staff.getLogin())) {", "prediction": "addStaff(staff)) {\n            model.addAttribute(\"staff\", staffService.getAllStaff());\n            model.addAttribute(\"newStaff\", new Staff());\n            model.addAttribute(\"currentUser\", getCurrentUser());\n            return \"staff\";\n        } else {\n            model.addAttribute(\"staff\", staffService.getAllStaff());\n            model.addAttribute(\"newStaff\", new Staff());\n            model.addAttribute(\"currentUser\", getCurrentUser());\n            return \"staff\";\n        }\n    }\n\n    @PostMapping(\"/staff/delete\")\n    public String deleteStaff(@RequestParam int id, Model model) {\n        staffService.deleteStaff(id);\n        model.addAttribute(\"", "first_line_groundtruth": "loginExists(staff.getLogin())) {", "first_line_prediction": "addStaff(staff)) {", "match": 0}
{"groundtruth": "!config.getMajorRules().isEmpty() || !config.getMinorRules().isEmpty()) {", "prediction": "config.getMajorRules() != null) {\n                for (String majorRule : config.getMajorRules()) {\n                    majorUpdatePatterns.add(Pattern.compile(majorRule, patternFlags));\n                }\n            }\n\n            if (config.getMinorRules() != null) {\n                for (String minorRule : config.getMinorRules()) {\n                    minorUpdatePatterns.add(Pattern.compile(minorRule, patternFlags));\n                }\n            }\n        }\n\n        tagPattern = Pattern.compile(tagRegex, patternFlags);\n    }\n\n    public VersionRules(String tagRegex, List<String> majorRules, List", "first_line_groundtruth": "!config.getMajorRules().isEmpty() || !config.getMinorRules().isEmpty()) {", "first_line_prediction": "config.getMajorRules() != null) {", "match": 0}
{"groundtruth": ").isEmpty() || !config.getMinorRules().isEmpty()) {", "prediction": "false).isEmpty()) {\n                majorUpdatePatterns.clear();\n                for (String majorRule : config.getMajorRules(false)) {\n                    majorUpdatePatterns.add(Pattern.compile(majorRule, patternFlags));\n                }\n            }\n\n            if (!config.getMinorRules(false).isEmpty()) {\n                minorUpdatePatterns.clear();\n                for (String minorRule : config.getMinorRules(false)) {\n                    minorUpdatePatterns.add(Pattern.compile(minorRule, patternFlags));\n                }\n            }\n        }\n\n        tagPattern = Pattern.compile(tagRegex, patternFlags);\n    }\n\n    public Version", "first_line_groundtruth": ").isEmpty() || !config.getMinorRules().isEmpty()) {", "first_line_prediction": "false).isEmpty()) {", "match": 0}
{"groundtruth": "semverConfigVersionTag = config.getVersionTag();", "prediction": " tagRegexOverride = config.getTagRegex();\n            if (tagRegexOverride != null) {\n                tagRegex = tagRegexOverride;\n            }\n            majorUpdatePatterns.addAll(config.getMajorUpdatePatterns());\n            minorUpdatePatterns.addAll(config.getMinorUpdatePatterns());\n        }\n\n        tagPattern = Pattern.compile(tagRegex, patternFlags);\n    }\n\n    public VersionRules(String tagRegex, List<Pattern> majorUpdatePatterns, List<Pattern> minorUpdatePatterns) {\n        this.tagPattern = Pattern.compile(tagRegex, Pattern.MULTILINE | Pattern.DOTALL | Pattern.UNIX", "first_line_groundtruth": "semverConfigVersionTag = config.getVersionTag();", "first_line_prediction": " tagRegexOverride = config.getTagRegex();", "match": 0}
{"groundtruth": "commitHistory.getChanges()) {", "prediction": " commitHistory.getChanges()) {\n            Version.Element element = Version.Element.valueOf(change.getRevision().getRevision().substring(0, 1));\n            if (element.ordinal() > maxElement.ordinal()) {\n                maxElement = element;\n            }\n        }\n        return maxElement;\n    }\n\n    public Pattern getTagPattern() {\n        return tagPattern;\n    }\n\n    public List<Pattern> getMajorUpdatePatterns() {\n        return majorUpdatePatterns;\n    }\n\n    public List<Pattern> getMinorUpdatePatterns() {\n        return minorUpdatePatterns;\n    }\n\n    public static class Builder {\n        private", "first_line_groundtruth": "commitHistory.getChanges()) {", "first_line_prediction": " commitHistory.getChanges()) {", "match": 0}
{"groundtruth": "userRepository.getUserByUserId(userId);", "prediction": " new User(\n                    UUID.randomUUID().toString(),\n                    \"New User\",\n                    false\n            );\n        }\n    }", "first_line_groundtruth": "userRepository.getUserByUserId(userId);", "first_line_prediction": " new User(", "match": 0}
{"groundtruth": "= versionRules.getTagPattern().matcher(tag);", "prediction": " = versionRules.getPattern().matcher(tag);\n                        if (matcher.find()) {\n                            return matcher.group(1);\n                        }\n                        return null;\n                     })\n                     .filter(Objects::nonNull)\n                     .collect(Collectors.toList());\n\n                if (!versionTags.isEmpty()) {\n                    latestVersionTag = versionTags.get(versionTags.size() - 1);\n                }\n            }\n        }\n    }", "first_line_groundtruth": "= versionRules.getTagPattern().matcher(tag);", "first_line_prediction": " = versionRules.getPattern().matcher(tag);", "match": 0}
{"groundtruth": "List<Reservation> reservations = reservationRepository.getAllReservations().stream()\n                .filter(res -> {", "prediction": " return reservationRepository.getAllReservations().stream()\n                 .filter(res -> reservationsId.contains(res.getReservationId()))\n                 .map(res -> {\n                     res.setStatus(Status.APPROVED);\n                     return res;\n                 })\n                 .collect(Collectors.toList());\n    }\n\n    public List<Reservation> getReservationsByHostIdStatusReserved(String hostId) {\n        List<Reservation> reservations = reservationRepository.getAllReservations().stream()\n                 .filter(res -> res.getHost().getHostId().equals(hostId) && res.getStatus().equals(Status.", "first_line_groundtruth": "List<Reservation> reservations = reservationRepository.getAllReservations().stream()", "first_line_prediction": " return reservationRepository.getAllReservations().stream()", "match": 0}
{"groundtruth": "= commitHistory.getLastVersionTag();", "prediction": " = versionRules.getLatestVersionTag(commitHistory);\n        LOG.debug(\"Latest Version Tag      : {}\", latestVersionTag);\n\n        if (latestVersionTag != null) {\n            usingTag = true;\n            version = Version.valueOf(latestVersionTag);\n            LOG.debug(\"Using tag: {}\", version);\n        } else {\n            version = Version.valueOf(versionString);\n            LOG.debug(\"Using version: {}\", version);\n        }\n\n        Version.Element nextElement = version.getNextElement(maxElementSinceLastVersionTag);\n        LOG.debug(\"Next element: {}\", nextElement);\n\n        Version nextVersion =", "first_line_groundtruth": "= commitHistory.getLastVersionTag();", "first_line_prediction": " = versionRules.getLatestVersionTag(commitHistory);", "match": 0}
{"groundtruth": "User existingUser = userRepository.getUserByUserId(userId);", "prediction": " return userRepository.getUserByUserId(userId);\n    }\n\n    public User createUser(User user) {\n        user.setId(UUID.randomUUID().toString());\n        userRepository.save(user);\n        return user;\n    }\n\n    public User updateUser(User user) {\n        userRepository.save(user);\n        return user;\n    }\n\n    public void deleteUser(String userId) {\n        userRepository.deleteById(userId);\n    }", "first_line_groundtruth": "User existingUser = userRepository.getUserByUserId(userId);", "first_line_prediction": " return userRepository.getUserByUserId(userId);", "match": 0}
{"groundtruth": "ArrayList<>(userRepository.getAllUsers());", "prediction": " ArrayList<>(userRepository.getAllUsers());\n    }", "first_line_groundtruth": "ArrayList<>(userRepository.getAllUsers());", "first_line_prediction": " ArrayList<>(userRepository.getAllUsers());", "match": 0}
{"groundtruth": "orgGroupSendHeaders.setXAcsDingtalkAccessToken(accessTokenService.getAccessToken());", "prediction": " orgGroupSendHeaders.setAccessToken(accessTokenService.getAccessToken());\n        OrgGroupSendRequest orgGroupSendRequest = new OrgGroupSendRequest();\n        orgGroupSendRequest.setOpenConversationId(openConversationId);\n        orgGroupSendRequest.setMsgtype(\"text\");\n        orgGroupSendRequest.setText(text);\n        OrgGroupSendResponse orgGroupSendResponse = robotClient.orgGroupSend(orgGroupSendHeaders, orgGroupSendRequest);\n        return orgGroupSendResponse.getMessageId();\n    }", "first_line_groundtruth": "orgGroupSendHeaders.setXAcsDingtalkAccessToken(accessTokenService.getAccessToken());", "first_line_prediction": " orgGroupSendHeaders.setAccessToken(accessTokenService.getAccessToken());", "match": 0}
{"groundtruth": "= deepCopy(object.getApplication());", "prediction": " = deepCopy(object.getApplication());\n        final Map<String, Entity> result = new HashMap<>(bindings.size());\n        for (final Map.Entry<String, Entity> binding : bindings.entrySet()) {\n            if (binding.getValue() instanceof NestedObject) {\n                this.flatOne(\n                    binding.getKey(),\n                    (NestedObject) binding.getValue(),\n                    result\n                );\n            } else {\n                result.put(binding.getKey(), binding.getValue());\n            }\n        }\n        for (final Map.Entry<String, Entity> binding : application.entrySet()) {\n            if (binding.getValue() instanceof", "first_line_groundtruth": "= deepCopy(object.getApplication());", "first_line_prediction": " = deepCopy(object.getApplication());", "match": 0}
{"groundtruth": "locator = ((Locator) binding.getValue()).getPath();", "prediction": "ary = new ArrayList<>();\n                        ary.add(binding.getKey());\n                        final String name = String.format(\"\u03bd%d\", Flatter.counter);\n                        Flatter.counter += 1;\n                        bindings.put(name, new FlatObject(name, \"\u03be\"));\n                        this.box.put(name, new HashMap<>());\n                        this.box.get(name).putAll(this.box.get(binding.getKey()));\n                        this.box.get(name).put(binding.getKey(), new FlatObject(name, \"\u03be\"));\n                        this.box.get(binding.getKey()).", "first_line_groundtruth": "locator = ((Locator) binding.getValue()).getPath();", "first_line_prediction": "ary = new ArrayList<>();", "match": 0}
{"groundtruth": "box.get(object.getName()));", "prediction": "box.content());\n        final Map<String, Entity> application = new HashMap<>();\n        application.put(key, object);\n        final FlatObject flat = new FlatObject(\n            object.name(),\n            application,\n            object.application()\n        );\n        final Map<String, Entity> flatBindings = new HashMap<>();\n        flatBindings.put(key, flat);\n        bindings.put(object.name(), flatBindings);\n        this.box.put(object.name(), bindings);\n        this.box.put(object.name(), user);\n        this.box.put(object.name(), object);\n        this", "first_line_groundtruth": "box.get(object.getName()));", "first_line_prediction": "box.content());", "match": 0}
{"groundtruth": "robotGroupMessagesService.send(openConversationId, \"hello\");", "prediction": " robotGroupMessagesService.send(openConversationId, msg);\n                } catch (Exception e) {\n                    log.error(\"send robot message error, openConversationId={}, msg={}\", openConversationId, msg, e);\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"receive robot message error, message={}\", message, e);\n        }\n        return null;\n    }", "first_line_groundtruth": "robotGroupMessagesService.send(openConversationId, \"hello\");", "first_line_prediction": " robotGroupMessagesService.send(openConversationId, msg);", "match": 0}
{"groundtruth": "tokenizer.getToken();", "prediction": "tokenizer.getToken();\n        if (token instanceof BracketToken) {\n            return this.bracket();\n        }\n        if (token instanceof StringToken) {\n            return this.string();\n        }\n        throw new IllegalStateException(\n            String.format(\"Unexpected token: %s\", token)\n        );\n    }\n\n    /**\n     * Reads one entity.\n     * @return The parsed entity.\n     */\n    public Entity one(final String name) {\n        final Token token = this.tokenizer.getToken();\n        if (token instanceof BracketToken) {\n            return this.bracket(name);\n        }\n        if (token instanceof StringToken)", "first_line_groundtruth": "tokenizer.getToken();", "first_line_prediction": "tokenizer.getToken();", "match": 1}
{"groundtruth": ").getName();", "prediction": "\n                        .reframe()).getName();\n                    if (!uses.contains(value)) {\n                        queue.add(value);\n                    }\n                } else if (binding.getValue() instanceof NestedObject) {\n                    queue.add(binding.getKey());\n                }\n            }\n        }\n        for (final Map.Entry<String, Entity> entry : this.box.content().entrySet()) {\n            if (!uses.contains(entry.getKey())) {\n                this.box.remove(entry.getKey());\n            }\n        }\n    }", "first_line_groundtruth": ").getName();", "first_line_prediction": "", "match": 0}
{"groundtruth": "(storage.getName());", "prediction": "Visible(false);\n        player.setCustomName(Text.of(\"\"));\n        player.setGameProfile(null);\n        player.networkHandler.disconnect(Text.of(\"Visitor left\"));\n        ServerJoinEvent.tempStorage.remove(player);\n    }", "first_line_groundtruth": "(storage.getName());", "first_line_prediction": "Visible(false);", "match": 0}
{"groundtruth": "((FlatObject) binding.getValue()).getLocator())\n                    );", "prediction": "0)\n                    );\n                }\n            }\n        }\n    }", "first_line_groundtruth": "((FlatObject) binding.getValue()).getLocator())", "first_line_prediction": "0)", "match": 0}
{"groundtruth": "this.tokenizer.next();", "prediction": " result.put(name, this.one());\n        }\n        return result;\n    }", "first_line_groundtruth": "this.tokenizer.next();", "first_line_prediction": " result.put(name, this.one());", "match": 0}
{"groundtruth": ".add(BlockRegistry.get(member.brokenRaft()), beautifyName(member.brokenRaft()));", "prediction": ".add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n                builder.add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.brokenRaft()), beautifyName(member.brokenRaft()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").", "first_line_groundtruth": ".add(BlockRegistry.get(member.brokenRaft()), beautifyName(member.brokenRaft()));", "first_line_prediction": ".add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));", "match": 0}
{"groundtruth": ".add(BlockRegistry.get(member.raft()), member.chinese + \"\u7b4f\");", "prediction": ".add(BlockRegistry.get(member.raft()), beautifyName(member.raft()));\n                builder.add(BlockRegistry.get(member.brokenRaft()), beautifyName(member.brokenRaft()));\n                builder.add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n    }", "first_line_groundtruth": ".add(BlockRegistry.get(member.raft()), member.chinese + \"\u7b4f\");", "first_line_prediction": ".add(BlockRegistry.get(member.raft()), beautifyName(member.raft()));", "match": 0}
{"groundtruth": ".add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));", "prediction": ".add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"BlockEntity\", \"Block Entity \").replaceAll(\"BlockItem\", \"Block Item \").replaceAll(\"BlockEntityType\", \"Block", "first_line_groundtruth": ".add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));", "first_line_prediction": ".add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));", "match": 1}
{"groundtruth": "(BlockRegistry.get(member.rack()), beautifyName(member.rack()));", "prediction": "(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"Item\", \"Item \").replaceAll(\"BlockEntity\", \"Block Entity \").replaceAll(\"BlockEntityType\", \"Block Entity Type \").replaceAll(\"BlockEntityTypeBuilder\", \"Block Entity Type Builder \").replaceAll(\"BlockEntityTypeBuilder.Builder\", \"Block Entity Type Builder Builder \").replaceAll(\"BlockEntityTypeBuilder.Builder.create\", \"Block Entity Type Builder Builder Create \").replaceAll(\"BlockEntityTypeBuilder.", "first_line_groundtruth": "(BlockRegistry.get(member.rack()), beautifyName(member.rack()));", "first_line_prediction": "(BlockRegistry.get(member.rack()), beautifyName(member.rack()));", "match": 1}
{"groundtruth": "beautifyName(member.raft()));", "prediction": " \"Raft\");\n                builder.add(BlockRegistry.get(member.rack()), \"Rack\");\n                builder.add(BlockRegistry.get(member.fence()), \"Fence\");\n                builder.add(BlockRegistry.get(member.crossedFence()), \"Crossed Fence\");\n                builder.add(BlockRegistry.get(member.brokenRaft()), \"Broken Raft\");\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").toLowerCase();\n        }\n    }", "first_line_groundtruth": "beautifyName(member.raft()));", "first_line_prediction": " \"Raft\");", "match": 0}
{"groundtruth": "fence()), beautifyName(member.fence()));", "prediction": "fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"BlockEntity\", \"Block Entity \").replaceAll(\"BlockItem\", \"Block Item \").replaceAll(\"BlockEntityType\", \"Block Entity Type \").replaceAll(\"BlockEntityTypeBuilder\", \"", "first_line_groundtruth": "fence()), beautifyName(member.fence()));", "first_line_prediction": "fence()), beautifyName(member.fence()));", "match": 1}
{"groundtruth": "member.rack()), beautifyName(member.rack()));", "prediction": "member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"Item\", \"Item \").replaceAll(\"BlockEntity\", \"Block Entity \").replaceAll(\"BlockEntityType\", \"Block Entity Type \").replaceAll(\"BlockEntityTypeBuilder\", \"Block Entity Type Builder \").replaceAll(\"BlockEntityTypeBuilder.Builder\", \"Block Entity Type Builder Builder \").replaceAll(\"BlockEntityTypeBuilder.Builder.create\", \"Block Entity Type Builder Builder Create \").replaceAll(\"BlockEntityTypeBuilder.Builder.create\", \"Block", "first_line_groundtruth": "member.rack()), beautifyName(member.rack()));", "first_line_prediction": "member.rack()), beautifyName(member.rack()));", "match": 1}
{"groundtruth": ".get(member.crossedFence()), beautifyName(member.crossedFence()));", "prediction": ".get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"Item\", \"Item \").replaceAll(\"BlockEntity\", \"Block Entity \").replaceAll(\"BlockEntityType\", \"Block Entity Type \").replaceAll(\"BlockEntityTypeBuilder\", \"Block Entity Type Builder \").replaceAll(\"BlockEntityTypeBuilder.Builder\", \"Block Entity Type Builder Builder \").", "first_line_groundtruth": ".get(member.crossedFence()), beautifyName(member.crossedFence()));", "first_line_prediction": ".get(member.crossedFence()), beautifyName(member.crossedFence()));", "match": 1}
{"groundtruth": ", beautifyName(member.brokenRaft()));", "prediction": " + \".broken\", beautifyName(member.brokenRaft()));\n                builder.add(BlockRegistry.get(member.fence()), beautifyName(member.fence()));\n                builder.add(BlockRegistry.get(member.crossedFence()), beautifyName(member.crossedFence()));\n                builder.add(BlockRegistry.get(member.rack()), beautifyName(member.rack()));\n            }\n        }\n\n        private String beautifyName(String name) {\n            return name.replaceAll(\"_\", \" \").replaceAll(\"Block\", \"Block \").replaceAll(\"BlockEntity\", \"Block Entity \").", "first_line_groundtruth": ", beautifyName(member.brokenRaft()));", "first_line_prediction": " + \".broken\", beautifyName(member.brokenRaft()));", "match": 0}
{"groundtruth": "Logger.writeError(\"Invalid server response\");", "prediction": "\tLogger.writeError(\"Server is not responding\");\n\t\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t} catch (IOException ex){\n\t\t\tLogger.writeError(ex.getMessage());\n\t\t\tSystem.exit(0);\n\t\t}", "first_line_groundtruth": "Logger.writeError(\"Invalid server response\");", "first_line_prediction": "\tLogger.writeError(\"Server is not responding\");", "match": 0}
{"groundtruth": "(\"position fen \"+b.getFEN());", "prediction": "(\"go depth 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "first_line_groundtruth": "(\"position fen \"+b.getFEN());", "first_line_prediction": "(\"go depth 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "match": 0}
{"groundtruth": "username = jwtUtil.verifyToken(token);", "prediction": " newToken = refreshTokenManager.reissueToken(token);\n\t\t\t\tresponse.setHeader(\"Refresh-Token\", newToken);\n\t\t\t\tresponseUtil.setResponse(response, newToken);\n\t\t\t} catch (RefreshTokenMismatchException e) {\n\t\t\t\tthrow new RefreshTokenMismatchException();\n\t\t\t} catch (RefreshTokenServiceUnavailableException e) {\n\t\t\t\tthrow new RefreshTokenServiceUnavailableException();\n\t\t\t}\n\t\t}", "first_line_groundtruth": "username = jwtUtil.verifyToken(token);", "first_line_prediction": " newToken = refreshTokenManager.reissueToken(token);", "match": 0}
{"groundtruth": "getIncrementTime(), b.getIncrementTime()));", "prediction": "getInc(Color.WHITE), b.getInc(Color.BLACK)));\n\t\treturn getOutput(1000);", "first_line_groundtruth": "getIncrementTime(), b.getIncrementTime()));", "first_line_prediction": "getInc(Color.WHITE), b.getInc(Color.BLACK)));", "match": 0}
{"groundtruth": "Color.WHITE), b.getTime(Color.BLACK), b.getIncrementTime(), b.getIncrementTime()));", "prediction": "Color.WHITE), b.getTime(Color.BLACK), b.getInc(Color.WHITE), b.getInc(Color.BLACK)));\n\t\treturn getOutput(1000);", "first_line_groundtruth": "Color.WHITE), b.getTime(Color.BLACK), b.getIncrementTime(), b.getIncrementTime()));", "first_line_prediction": "Color.WHITE), b.getTime(Color.BLACK), b.getInc(Color.WHITE), b.getInc(Color.BLACK)));", "match": 0}
{"groundtruth": "cm.reply();", "prediction": "", "first_line_groundtruth": "cm.reply();", "first_line_prediction": "", "match": 0}
{"groundtruth": "user = userDetailsService.loadUserByUsername((String)auth.getPrincipal());", "prediction": " userDetails = userDetailsService.loadUserByUsername(auth.getUsername());", "first_line_groundtruth": "user = userDetailsService.loadUserByUsername((String)auth.getPrincipal());", "first_line_prediction": " userDetails = userDetailsService.loadUserByUsername(auth.getUsername());", "match": 0}
{"groundtruth": "ecoproveedor.calcularPuntosTotales();", "prediction": "0;\n        for(Producto p : ecoproveedor.getListaProductos()){\n            puntos += p.getPuntuacion();\n        }\n        ecoproveedor.setPuntuacion(puntos);\n        repository.save(ecoproveedor);\n    }", "first_line_groundtruth": "ecoproveedor.calcularPuntosTotales();", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "auth.eraseCredentials();", "prediction": "\t// \uc778", "first_line_groundtruth": "auth.eraseCredentials();", "first_line_prediction": "\t// \uc778", "match": 0}
{"groundtruth": "builder.add(BlockRegistry.get(member.brokenRaft()), \"\u635f\u574f\u7684\" + member.chinese + \"\u7b4f\");", "prediction": " builder.add(BlockRegistry.get(member.brokenRaft()), member.chinese + \"", "first_line_groundtruth": "builder.add(BlockRegistry.get(member.brokenRaft()), \"\u635f\u574f\u7684\" + member.chinese + \"\u7b4f\");", "first_line_prediction": " builder.add(BlockRegistry.get(member.brokenRaft()), member.chinese + \"", "match": 0}
{"groundtruth": ".stream().filter(piece -> piece.getType().getName() == Piece.PIECE_PAWN).count();", "prediction": ".stream().filter(piece -> piece.getType().getName() == Piece.PIECE_PAWN).count();\n\t\tfor (int i = 0; i < pawns; i++){\n\t\t\tif (i == 0){\n\t\t\t\tif (color == Color.WHITE){\n\t\t\t\t\tcaptures.add(pieces.get(i));\n\t\t\t\t} else {\n\t\t\t\t\tcaptures.add(pieces.get(i+1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color == Color.WHITE){\n\t\t\t\t\tcaptures.add(pieces.get(i+1));\n\t\t\t", "first_line_groundtruth": ".stream().filter(piece -> piece.getType().getName() == Piece.PIECE_PAWN).count();", "first_line_prediction": ".stream().filter(piece -> piece.getType().getName() == Piece.PIECE_PAWN).count();", "match": 1}
{"groundtruth": "Flotage.id(id), block);", "prediction": " Flotage.id(id), block);\n    }", "first_line_groundtruth": "Flotage.id(id), block);", "first_line_prediction": " Flotage.id(id), block);", "match": 0}
{"groundtruth": "().getNamespace(), \"block/\" + member.log().getPath());", "prediction": "().getNamespace(), member.log().getPath());\n        return new TextureMap(id, \"item/generated\");\n    }\n\n    @Override\n    public void generateItemModels(ItemModelGenerator generator) {\n        itemGenerator = generator;\n        for (BlockMember member : BlockMember.values()) {\n            itemMember(member);\n        }\n    }", "first_line_groundtruth": "().getNamespace(), \"block/\" + member.log().getPath());", "first_line_prediction": "().getNamespace(), member.log().getPath());", "match": 0}
{"groundtruth": "() && p.getColor() == piece.getColor()){", "prediction": "()){\n\t\t\t\t\tidentical.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Piece p : identical){\n\t\t\t\tp.setX(p.getX() + (p.getX() - p1[0]));\n\t\t\t\tp.setY(p.getY() + (p.getY() - p1[1]));\n\t\t\t}\n\t\t\tpiece.setX(p2[0]);\n\t\t\tpiece.setY(p2[1]);\n\t\t\t\n\t\t\tif (prom != null){\n\t\t\t\tpromote(piece.getColor(), Piece.Pieces.valueOf(prom));\n\t\t\t}\n\t\t\t\n\t\t\tif", "first_line_groundtruth": "() && p.getColor() == piece.getColor()){", "first_line_prediction": "()){", "match": 0}
{"groundtruth": ").filter(piece -> piece.getType().getName() == Piece.PIECE_KNIGHT).count();", "prediction": "piece -> piece.getType().getName() == Piece.PIECE_KNIGHT).count();\n\t\tint bishops = (int)pieces.stream(piece -> piece.getType().getName() == Piece.PIECE_BISHOP).count();\n\t\tint queens = (int)pieces.stream(piece -> piece.getType().getName() == Piece.PIECE_QUEEN).count();\n\t\tint kings = (int)pieces.stream(piece -> piece.getType().getName() == Piece.PIECE_KING).count();\n\t\tint total = pawns", "first_line_groundtruth": ").filter(piece -> piece.getType().getName() == Piece.PIECE_KNIGHT).count();", "first_line_prediction": "piece -> piece.getType().getName() == Piece.PIECE_KNIGHT).count();", "match": 0}
{"groundtruth": "if (piece == null || piece.getColor() != this.player) return false;", "prediction": "\tif (piece == null) return false;\n\t\t\tif (piece.getColor() != this.player) return false;\n\t\t\tif (piece.getType().getName() == Piece.PIECE_PAWN && piece.getY() == 1 && piece.getX() == p1[1]) return false;\n\t\t\tif (piece.getType().getName() == Piece.PIECE_PAWN && piece.getY() == 6 && piece.getX() == p1[1]) return false;\n\t\t\tif (piece.getType().getName() == Piece.PIECE_PAWN &&", "first_line_groundtruth": "if (piece == null || piece.getColor() != this.player) return false;", "first_line_prediction": "\tif (piece == null) return false;", "match": 0}
{"groundtruth": "> pieces = getPiecesOnBoard().stream().filter(piece -> piece.getColor() == color).toList();", "prediction": "> pieces = getPiecesOnBoard().stream().filter(p -> p.getColor() == color).collect(Collectors.toList());\n\t\tfor (Piece piece : pieces){\n\t\t\tif (piece.getType().getName() == Piece.PIECE_PAWN){\n\t\t\t\tif (piece.getY() == 1){\n\t\t\t\t\tthis.blackCaptured.add(piece);\n\t\t\t\t} else if (piece.getY() == 6){\n\t\t\t\t\tthis.whiteCaptured.add(piece);\n\t\t\t\t}\n\t\t\t}\n\t\t}", "first_line_groundtruth": "> pieces = getPiecesOnBoard().stream().filter(piece -> piece.getColor() == color).toList();", "first_line_prediction": "> pieces = getPiecesOnBoard().stream().filter(p -> p.getColor() == color).collect(Collectors.toList());", "match": 0}
{"groundtruth": "p.getColor() == piece.getColor()){", "prediction": " p.getColor() == piece.getColor()){\n\t\t\t\t\tidentical.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Piece p : identical){\n\t\t\t\tp.setX(p.getX() + p1[0] - p2[0]);\n\t\t\t\tp.setY(p.getY() + p1[1] - p2[1]);\n\t\t\t}\n\t\t\tpiece.setX(p2[0]);\n\t\t\tpiece.setY(p2[1]);\n\t\t\t\n\t\t\tif (prom != null){\n\t\t\t\tpromote(piece.getColor(), Piece.Pieces.valueOf(", "first_line_groundtruth": "p.getColor() == piece.getColor()){", "first_line_prediction": " p.getColor() == piece.getColor()){", "match": 0}
{"groundtruth": ".WHITE && newLegalMoves.contains(convertPosition(this.blackKing.getX(), this.blackKing.getY()))){", "prediction": ".WHITE){\n\t\t\t\tthis.whiteChecks.addAll(boardPiece.getColor() == Color.WHITE ? newLegalMoves.stream().filter(m -> m.startsWith(\"e1\")).collect(Collectors.toList()) : newLegalMoves.stream().filter(m -> m.startsWith(\"e8\")).collect(Collectors.toList()));\n\t\t\t} else {\n\t\t\t\tthis.blackChecks.addAll(boardPiece.getColor() == Color.WHITE ? newLegalMoves.stream().filter(m -> m.startsWith(\"e8\")).collect(Collectors.toList()) : newLegalMoves.stream().filter(m -> m", "first_line_groundtruth": ".WHITE && newLegalMoves.contains(convertPosition(this.blackKing.getX(), this.blackKing.getY()))){", "first_line_prediction": ".WHITE){", "match": 0}
{"groundtruth": "if (MapUtils.isNotEmpty(this.properties.getConfig())) {", "prediction": " // check args length\n        if (args.length != FEIGN_ARGS_LEN) {\n            throw new IllegalArgumentException(\"args length must be \" + FEIGN_ARGS_LEN);\n        }\n        // check args type\n        if (!(args[FEIGN_REQUEST_ARGS_INDEX] instanceof Request)) {\n            throw new IllegalArgumentException(\"args[0] must be Request\");\n        }\n        if (!(args[FEIGN_REQUEST_OPTION_ARGS_INDEX] instanceof Options)) {\n            throw new IllegalArgumentException(\"args[1] must be Options\");\n        }\n        // get request\n        Request request = (Request) args[FEIGN_", "first_line_groundtruth": "if (MapUtils.isNotEmpty(this.properties.getConfig())) {", "first_line_prediction": " // check args length", "match": 0}
{"groundtruth": "pos) == recipe.getMode()) {", "prediction": "1, recipe.getWorkingMode())) {\n                    if (tile.processTime >= tile.processTimeTotal) {\n                        ItemStack itemStack2 = recipe.getOutput().copy();\n                        if (itemStack2.isEmpty()) {\n                            itemStack2 = itemStack.copy();\n                        }\n                        if (!itemStack2.isEmpty()) {\n                            if (itemStack2.getCount() > 1) {\n                                itemStack2.setCount(itemStack2.getCount() - 1);\n                            } else {\n                                itemStack2.setCount(1);\n                            }\n                            tile.setItem(itemStack2);\n                            tile.", "first_line_groundtruth": "pos) == recipe.getMode()) {", "first_line_prediction": "1, recipe.getWorkingMode())) {", "match": 0}
{"groundtruth": ".filter(piece -> piece.getType().getName() == Piece.PIECE_ROOK).count();", "prediction": "\n\t\t\t\t.filter(piece -> piece.getType().getName() == Piece.PIECE_ROOK)\n\t\t\t\t.filter(piece -> piece.getColor() == color)\n\t\t\t\t.count();\n\t\tint knights = (int)pieces.stream()\n\t\t\t\t.filter(piece -> piece.getType().getName() == Piece.PIECE_KNIGHT)\n\t\t\t\t.filter(piece -> piece.getColor() == color)\n\t\t\t\t.count();\n\t\tint bishops = (int)pieces.stream()\n\t\t\t\t.filter(piece -> piece.getType().getName() == Piece.PI", "first_line_groundtruth": ".filter(piece -> piece.getType().getName() == Piece.PIECE_ROOK).count();", "first_line_prediction": "", "match": 0}
{"groundtruth": ".wrapperTimeoutOptions(this.properties.getHostConfig(uri.getHost()), uri);", "prediction": ".options(uri);\n                } else if (args.length == FEIGN_ARGS_LEN + 1) {\n                    Request request = (Request) args[FEIGN_REQUEST_ARGS_INDEX];\n                    URI uri = URI.create(request.url());\n                    options = this.options(uri);\n                    args[FEIGN_REQUEST_OPTION_ARGS_INDEX] = options;\n                }\n                if (options != null) {\n                    List<TimeoutProperty> timeoutProperties = this.properties.getHostConfig(options.host());\n                    if (CollectionUtils.isNotEmpty(timeoutProperties)) {\n                        for (TimeoutProperty", "first_line_groundtruth": ".wrapperTimeoutOptions(this.properties.getHostConfig(uri.getHost()), uri);", "first_line_prediction": ".options(uri);", "match": 0}
{"groundtruth": "[capture.getX()][capture.getY()] = null;", "prediction": "[p2[0]][p1[1]] = null;\n\t\t\t}\n\t\t\t\n\t\t\tthis.board[p1[0]][p1[1]] = null;\n\t\t\tthis.board[p2[0]][p2[1]] = piece;\n\t\t\t\n\t\t\tif (prom != null){\n\t\t\t\tpromote(piece.getColor(), piece.getType());\n\t\t\t}\n\t\t\t\n\t\t\tif (capture != null){\n\t\t\t\tcapture(capture);\n\t\t\t}\n\t\t\t\n\t\t\tif (identical.size() > 0){\n\t\t\t\tfor (Piece p : identical){\n\t\t\t\t\tthis.board[p.getX()][", "first_line_groundtruth": "[capture.getX()][capture.getY()] = null;", "first_line_prediction": "[p2[0]][p1[1]] = null;", "match": 0}
{"groundtruth": "add(BlockRegistry.get(member.crossedFence()), member.chinese + \"\u5341\u5b57\u6805\u680f\");", "prediction": "add(BlockRegistry.get(member.crossedFence()), \"\u7b80\u6613\" + member.chinese + \"", "first_line_groundtruth": "add(BlockRegistry.get(member.crossedFence()), member.chinese + \"\u5341\u5b57\u6805\u680f\");", "first_line_prediction": "add(BlockRegistry.get(member.crossedFence()), \"\u7b80\u6613\" + member.chinese + \"", "match": 0}
{"groundtruth": "display.getMode().toString()));", "prediction": " display.getWorkingMode().toString()));\n        widgets.add(Widgets.createTextWidget(text, new Point(bgBounds.x + 39, bgBounds.y + 18)));\n\n        widgets.add(Widgets.createSlot(new Point(bgBounds.x + 7, bgBounds.y + 29))\n                 .entries(display.getInputEntries().get(1)).markInput().disableBackground());\n\n        widgets.add(Widgets.createSlot(new Point(bgBounds.x + 7, bgBounds.y + 40))\n                 .entries(display.getOutputEntries", "first_line_groundtruth": "display.getMode().toString()));", "first_line_prediction": " display.getWorkingMode().toString()));", "match": 0}
{"groundtruth": "add(BlockRegistry.get(member.rack()), member.chinese + \"\u7f6e\u7269\u67b6\");", "prediction": "add(BlockRegistry.get(member.rack()), member.chinese + \"\u67b6\");\n            }\n        }\n    }", "first_line_groundtruth": "add(BlockRegistry.get(member.rack()), member.chinese + \"\u7f6e\u7269\u67b6\");", "first_line_prediction": "add(BlockRegistry.get(member.rack()), member.chinese + \"\u67b6\");", "match": 0}
{"groundtruth": "member.fence()), \"\u7b80\u6613\" + member.chinese + \"\u6805\u680f\");", "prediction": "member.fence()), member.chinese + \"", "first_line_groundtruth": "member.fence()), \"\u7b80\u6613\" + member.chinese + \"\u6805\u680f\");", "first_line_prediction": "member.fence()), member.chinese + \"", "match": 0}
{"groundtruth": "inventory.getStack(0).getNbt();", "prediction": " itemStack.getNbt();\n        nbtCompound.putInt(\"processtime\", processtime);\n        nbtCompound.putInt(\"mode\", mode.ordinal());\n        return itemStack;\n    }\n\n    @Override\n    public boolean fits(int width, int height) {\n        return true;\n    }\n\n    @Override\n    public ItemStack getOutput() {\n        return this.result;\n    }\n\n    @Override\n    public Identifier getId() {\n        return this.id;\n    }\n\n    @Override\n    public RecipeSerializer<?> getSerializer() {\n        return BlockRegistry.RACK_RECIPE_SERIALIZER;\n    }", "first_line_groundtruth": "inventory.getStack(0).getNbt();", "first_line_prediction": " itemStack.getNbt();", "match": 0}
{"groundtruth": "add(Widgets.withTooltip(arrow, Text.translatable(\"tip.flotage.rack.processtime\", display.getProcesstime() / 20), text));", "prediction": "add(Widgets.createTextWidget(text, new Point(bgBounds.x + 39, bgBounds.y + 18)));\n\n        widgets.add(Widgets.createSlot(new Point(bgBounds.x + 7, bgBounds.y + 29))\n                 .entries(display.getOutputEntries().get(0)).disableBackground());\n\n        widgets.add(Widgets.createTexturedWidget(GUI_TEXTURE, new Rectangle(bgBounds.x + 7, bgBounds.y + 29, 18, 18), 10, 9));\n\n        return", "first_line_groundtruth": "add(Widgets.withTooltip(arrow, Text.translatable(\"tip.flotage.rack.processtime\", display.getProcesstime() / 20), text));", "first_line_prediction": "add(Widgets.createTextWidget(text, new Point(bgBounds.x + 39, bgBounds.y + 18)));", "match": 0}
{"groundtruth": "add(BlockRegistry.get(member.crossedFence()));", "prediction": "add(BlockRegistry.get(member.axe()));\n            pickaxe.add(BlockRegistry.get(member.pickaxe()));\n        }\n    }", "first_line_groundtruth": "add(BlockRegistry.get(member.crossedFence()));", "first_line_prediction": "add(BlockRegistry.get(member.axe()));", "match": 0}
{"groundtruth": ".board.getPlayer() != this.viewPoint && (this.engineMove || !this.overTheBoard)){", "prediction": ".currentSelection == not){\n\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (this.currentSelection == null){\n\t\t\t\t\t\tthis.currentSelection = not;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (this.currentSelection.equals(not)){\n\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (this.currentMoves.contains(not)){\n\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.currentSelection = not;\n\t\t\t\t\t\tthis.currentMoves = getMoves(not);\n\t\t\t\t\t", "first_line_groundtruth": ".board.getPlayer() != this.viewPoint && (this.engineMove || !this.overTheBoard)){", "first_line_prediction": ".currentSelection == not){", "match": 0}
{"groundtruth": "this.client.getColor();", "prediction": "0;\n\t\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\t\t\tthis.draggingPiece = null;\n\t\t\t\t\t\t\tthis.dragX = 0;\n\t\t\t\t\t\t\tthis.dragY = 0;\n\t\t\t\t\t\t\tthis.promotionPiece = null;\n\t\t\t\t\t\t\tthis.engineMove = false;\n\t\t\t\t\t\t\tthis.overTheBoard = false;\n\t\t\t\t\t\t\tthis.gameFinished = false;\n\t\t\t\t\t\t\tthis.engine.setEngine(this.client);\n\t\t\t\t\t\t\tthis.engine.start();\n\t\t\t\t\t\t\talert.close();\n\t\t\t\t\t\t} catch (NumberFormatException ex){\n\t\t\t\t\t\t\tLogger.write", "first_line_groundtruth": "this.client.getColor();", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "this.client.getMessage();", "prediction": " this.client.getMessage();\n\t\t\t\t\t\t\t\t\tif (message != null){\n\t\t\t\t\t\t\t\t\t\tif (message.startsWith(\"move\")){\n\t\t\t\t\t\t\t\t\t\t\tString[] split = message.split(\" \");\n\t\t\t\t\t\t\t\t\t\t\tif (split.length == 4){\n\t\t\t\t\t\t\t\t\t\t\t\tString not = split[2];\n\t\t\t\t\t\t\t\t\t\t\t\tint x = Integer.parseInt(split[3]);\n\t\t\t\t\t\t\t\t\t\t\t\tint y = Integer.parseInt(split[1]);\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.board.getBoard()[x][y] != null){\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.board.getBoard()[x][y].setX(x);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.board.getBoard()[x][", "first_line_groundtruth": "this.client.getMessage();", "first_line_prediction": " this.client.getMessage();", "match": 0}
{"groundtruth": "(this.board.getFEN()+\"\\n\\n\"+this.board.getPGN());", "prediction": "();\n\t\t\t\t\tdata.setEditable(false);\n\t\t\t\t\tdata.setWrapText(true);\n\t\t\t\t\tdata.setPromptText(\"Server data\");\n\t\t\t\t\tdata.setMaxWidth(400);\n\t\t\t\t\tdata.setMaxHeight(400);\n\t\t\t\t\tButton startClient = new Button(\"Start client\");\n\t\t\t\t\tstartClient.setOnAction(ev -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString ip = cip.getText().equals(\"\") ? \"192.168.1.247\" : cip.getText();\n\t\t\t\t\t\t\tint port = cport.getText().equals(\"\") ? ", "first_line_groundtruth": "(this.board.getFEN()+\"\\n\\n\"+this.board.getPGN());", "first_line_prediction": "();", "match": 0}
{"groundtruth": "if (this.board.getBoard()[x][y].getColor() == this.viewPoint){", "prediction": " if (this.board.getBoard()[x][y] != null && this.board.getBoard()[x][y].getColor() == this.viewPoint){\n\t\t\t\t\t\t\t\tthis.premoves.clear();\n\t\t\t\t\t\t\t\tthis.premoves.add(new Premove(not, not, null));\n\t\t\t\t\t\t\t\tthis.currentSelection = not;\n\t\t\t\t\t\t\t\tthis.currentMoves = this.board.getLegalMoves(not);\n\t\t\t\t\t\t\t\tthis.currentHold = null;\n\t\t\t\t\t\t\t\tthis.moveStart = not;\n\t\t\t\t\t\t\t\tthis.moveEnd = not;\n\t\t\t\t\t\t\t\tthis.draggingPiece = this.board.", "first_line_groundtruth": "if (this.board.getBoard()[x][y].getColor() == this.viewPoint){", "first_line_prediction": " if (this.board.getBoard()[x][y] != null && this.board.getBoard()[x][y].getColor() == this.viewPoint){", "match": 0}
{"groundtruth": "out.println(this.board.getFEN());", "prediction": "out.println(\"Double click\");\n\t\t\t\t\tif (this.currentSelection != null){\n\t\t\t\t\t\tString not = getNotation(e);\n\t\t\t\t\t\tint x = (int)(e.getX()/SQUARE_SIZE);\n\t\t\t\t\t\tint y = (int)((e.getY()-SPACE)/SQUARE_SIZE);\n\t\t\t\t\t\tif (this.viewPoint == Color.BLACK){\n\t\t\t\t\t\t\tx = 7-x;\n\t\t\t\t\t\t\ty = 7-y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (not != null){\n\t\t\t\t\t\t\tif (this.board.getBoard()[x][y] != null){\n\t\t\t\t\t\t\t\tif", "first_line_groundtruth": "out.println(this.board.getFEN());", "first_line_prediction": "out.println(\"Double click\");", "match": 0}
{"groundtruth": "(this.board.getBoard()[x][y] == null && !getPremoves().contains(not)){", "prediction": " (this.board.getPieceAt(x, y) != null){\n\t\t\t\t\t\t\t\tthis.currentSelection = not;\n\t\t\t\t\t\t\t\tthis.currentMoves = this.board.getMoves(this.currentSelection);\n\t\t\t\t\t\t\t\tif (this.currentMoves.size() == 0){\n\t\t\t\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (this.currentSelection.equals(not)){\n\t\t\t\t\t\t\tif (this.currentMoves.size() == 0){\n\t\t\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\t\t\tthis.currentMoves", "first_line_groundtruth": "(this.board.getBoard()[x][y] == null && !getPremoves().contains(not)){", "first_line_prediction": " (this.board.getPieceAt(x, y) != null){", "match": 0}
{"groundtruth": "this.board.getBoard()[x][y] != null){", "prediction": "this.currentMoves != null){\n\t\t\t\t\t\t\tshowMoves = makeUserMove(not, x, y, true, \"Q\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (showMoves){\n\t\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (e.getButton() == MouseButton.SECONDARY){\n\t\t\t\tif (this.currentSelection != null){\n\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcanvas.setOnMouseDragged", "first_line_groundtruth": "this.board.getBoard()[x][y] != null){", "first_line_prediction": "this.currentMoves != null){", "match": 0}
{"groundtruth": "this.gameFinished = this.board.isGameFinished();", "prediction": "\n\t\t\t\t\t\t\t\t\t\t\tif (this.board.getBoard()[Integer.parseInt(message.split(\" \")[0])][Integer.parseInt(message.split(\" \")[1])] != null){\n\t\t\t\t\t\t\t\t\t\t\t\tthis.overTheBoard = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (this.board.getGameTime() == 0){\n\t\t\t\t\t\t\t\t\t\t\t\tthis.gameFinished = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlistener.start();\n\t\t\t\t\t\t\talert.close();\n\t\t\t\t\t\t} catch (NumberFormatException ex){\n\t\t\t\t\t\t\tLogger.writeError(ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t", "first_line_groundtruth": "this.gameFinished = this.board.isGameFinished();", "first_line_prediction": "", "match": 0}
{"groundtruth": ")+\"\\n\\n\"+this.board.getPGN());", "prediction": "this.viewPoint));\n\t\t\t\t\tdata.setEditable(false);\n\t\t\t\t\tButton load = new Button(\"Load\");\n\t\t\t\t\tload.setOnAction(ev -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString fen = data.getText();\n\t\t\t\t\t\t\tthis.board = new Board(fen, 180000, 0);\n\t\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\t\t\tthis.currentHold = null;\n\t\t\t\t\t\t\tthis.premoves.clear();\n\t\t\t\t\t\t\tthis.overTheBoard = true;\n\t\t\t\t\t\t\tthis.engineMove = false;\n\t\t\t\t\t\t\tthis", "first_line_groundtruth": ")+\"\\n\\n\"+this.board.getPGN());", "first_line_prediction": "this.viewPoint));", "match": 0}
{"groundtruth": "= Piece.getType(prom);", "prediction": " = piece.getType().getName() == Piece.PIECE_PAWN ? Piece.Pieces.QUEEN : Piece.Pieces.ROOK;\n\t\t\t\t\tpromote(piece.getColor(), promotion);\n\t\t\t\t\tcastle = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (castle){\n\t\t\t\tthis.whiteRightCastleAllowed = true;\n\t\t\t\tthis.whiteLeftCastleAllowed = true;\n\t\t\t\tthis.blackRightCastleAllowed = true;\n\t\t\t\tthis.blackLeftCastleAllowed = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (identical.size() > 0){\n\t\t\t\tfor (Piece p : identical){", "first_line_groundtruth": "= Piece.getType(prom);", "first_line_prediction": " = piece.getType().getName() == Piece.PIECE_PAWN ? Piece.Pieces.QUEEN : Piece.Pieces.ROOK;", "match": 0}
{"groundtruth": "= this.board.getValidMoves(this.board.getBoard()[x][y]);", "prediction": " = this.board.getMoves(this.currentSelection);\n\t\t\t\t\t\t\tthis.currentHold = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.currentSelection != null){\n\t\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\t\tthis.currentHold = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (e.getButton() == MouseButton.SECONDARY){\n\t\t\t\tif (this.currentSelection != null){\n\t\t\t\t\tthis.currentSelection = null;\n\t\t\t\t\tthis.currentMoves = null;\n\t\t\t\t\tthis.", "first_line_groundtruth": "= this.board.getValidMoves(this.board.getBoard()[x][y]);", "first_line_prediction": " = this.board.getMoves(this.currentSelection);", "match": 0}
{"groundtruth": "!this.client.isConnected()){", "prediction": "this.client.isConnected()){\n\t\t\t\t\t\t\t\talert.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (NumberFormatException ex){\n\t\t\t\t\t\t\tLogger.writeError(ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tButton quit = new Button(\"Quit\");\n\t\t\t\t\tquit.setOnAction(ev -> {\n\t\t\t\t\t\talert.close();\n\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t});\n\t\t\t\t\tlayout.add(sip, 0, 0);\n\t\t\t\t\tlayout.add(sport, 1, 0);\n\t\t\t\t\tlayout.add(cip, 0, 1);\n\t\t\t\t\tlayout.add(cport", "first_line_groundtruth": "!this.client.isConnected()){", "first_line_prediction": "this.client.isConnected()){", "match": 0}
{"groundtruth": "println(this.board.getPGN());", "prediction": "println(this.board.getBoard());\n\t\t\t\t\tSystem.out.println(this.board.getBoard()[(int)(e.getX()/SQUARE_SIZE)][(int)((e.getY()-SPACE)/SQUARE_SIZE)]);\n\t\t\t\t\tSystem.out.println(this.board.getBoard()[(int)(e.getX()/SQUARE_SIZE)][(int)((e.getY()-SPACE)/SQUARE_SIZE)].getColor());\n\t\t\t\t\tSystem.out.println(this.board.getBoard()[(int)(e.getX()/SQUARE_SIZE)][(int)((e.getY()-SPACE", "first_line_groundtruth": "println(this.board.getPGN());", "first_line_prediction": "println(this.board.getBoard());", "match": 0}
{"groundtruth": "this.board.getGameTime(), this.board.getIncrementTime());", "prediction": "0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\talert.close();\n\t\t\t\t\t\t} catch (NumberFormatException ex){\n\t\t\t\t\t\t\tLogger.writeError(ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tButton quit = new Button(\"Quit\");\n\t\t\t\t\tquit.setOnAction(ev -> {\n\t\t\t\t\t\talert.close();\n\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t});\n\t\t\t\t\tlayout.add(sip, 0, 0);\n\t\t\t\t\tlayout.add(sport, 1, 0);\n\t\t\t\t\tlayout.add(cip, 0, 1);\n\t\t\t\t\tlayout.add(cport, 1,", "first_line_groundtruth": "this.board.getGameTime(), this.board.getIncrementTime());", "first_line_prediction": "0);", "match": 0}
{"groundtruth": "getAttackers(piece.getColor() == Color.WHITE ? this.whiteKing : this.blackKing) != null){", "prediction": "prom != null){\n\t\t\t\tint[] p3 = convertNotation(prom);\n\t\t\t\tsetPiece(new Piece(piece.getType(), piece.getColor(), p3[0], p3[1]), p2[0], p2[1]);\n\t\t\t}\n\t\t\t\n\t\t\tif (capture != null){\n\t\t\t\tthis.board[capture.getX()][capture.getY()] = capture;\n\t\t\t\tcapture.setX(p2[0]);\n\t\t\t\tcapture.setY(p2[1]);\n\t\t\t}\n\t\t\t\n\t\t\tif (identical.size() > 0){\n\t\t\t\tfor (Piece p :", "first_line_groundtruth": "getAttackers(piece.getColor() == Color.WHITE ? this.whiteKing : this.blackKing) != null){", "first_line_prediction": "prom != null){", "match": 0}
{"groundtruth": "if (booking.isApproved()) {", "prediction": " bookingRepository.delete(booking);\n    }\n\n    public void approve(Long id) {\n        Booking booking = bookingRepository.findById(id).get();\n        booking.setApproved(true);\n        bookingRepository.save(booking);\n        logService.insertedApproved(booking);\n    }\n\n    public boolean isBusy(Booking booking) {\n        return bookingRepository.isBusy(booking.getLab().getId(), booking.getTimeInit(), booking.getTimeFinal());\n    }\n\n    public Optional<Booking> findById(Long id) {\n        return bookingRepository.findById(id);\n    }\n\n    @Async\n    public void insertPending", "first_line_groundtruth": "if (booking.isApproved()) {", "first_line_prediction": " bookingRepository.delete(booking);", "match": 0}
{"groundtruth": "return jdbcProcessors.path(driver, generatedHost, generatedDatabase);", "prediction": " final OddrnPath path = jdbcProcessors.path(generatedHost, generatedDatabase);\n         if (path == null) {\n             throw new IllegalArgumentException(\"Invalid JDBC url.\");\n         }", "first_line_groundtruth": "return jdbcProcessors.path(driver, generatedHost, generatedDatabase);", "first_line_prediction": " final OddrnPath path = jdbcProcessors.path(generatedHost, generatedDatabase);", "match": 0}
{"groundtruth": "bookingRepository.deleteByTimeFinalBefore(LocalDateTime.now());", "prediction": " List<Booking> pending = findPending();\n         for (Booking booking : pending) {\n             if (isBusy(booking)) {\n                 approveBooking(booking);\n             }\n         }\n    }", "first_line_groundtruth": "bookingRepository.deleteByTimeFinalBefore(LocalDateTime.now());", "first_line_prediction": " List<Booking> pending = findPending();", "match": 0}
{"groundtruth": "booking.setTimeRequest(LocalDateTime.now());", "prediction": "\n\n        booking.setTimeInit(initialTime);\n        booking.setTimeFinal(finalTime);\n        booking.setTimeRequest(LocalDateTime.now());\n\n        bookingRepository.save(booking);\n    }", "first_line_groundtruth": "booking.setTimeRequest(LocalDateTime.now());", "first_line_prediction": "", "match": 0}
{"groundtruth": "b.getId());", "prediction": "b.getId());\n        });\n    }\n\n    @Async\n    public void deleteByTimeFinalBefore(LocalDateTime now) {\n        bookingRepository.deleteByTimeFinalBefore(now);\n    }\n\n    @Scheduled(fixedDelay = 10000)\n    public void updatePending() {\n        List<Booking> pending = findPending();\n        pending.forEach(b -> {\n            if (isBusy(b)) {\n                logService.insertedPending(b);\n                bookingRepository.approveBooking(b.getId());\n            }\n        });\n    }", "first_line_groundtruth": "b.getId());", "first_line_prediction": "b.getId());", "match": 1}
{"groundtruth": "protectionRune = CustomItems.createProtectionRune();", "prediction": " protectionRune = CustomItems.createProtectionRune();\n                    protectionRune.setAmount(1);\n                    player.getInventory().addItem(protectionRune);\n                    event.getClickedInventory().setItem(PROTECTION_RUNE_SLOT, protectionRune);\n                }, 3 * 20L);\n            } else {\n                player.sendMessage(\"\u00a7cYou do not have enough levels to buy a Protection Rune!\");\n            }\n        }\n    }", "first_line_groundtruth": "protectionRune = CustomItems.createProtectionRune();", "first_line_prediction": " protectionRune = CustomItems.createProtectionRune();", "match": 0}
{"groundtruth": "bookingService.save(login, subject, lab, date, timeInit, timeFinal);", "prediction": "\n\n        bookingService.save(login, subject, lab, date, timeInit, timeFinal);\n        attributes.addFlashAttribute(\"success\", \"Booking saved successfully!\");\n        return \"redirect:/\";\n    }", "first_line_groundtruth": "bookingService.save(login, subject, lab, date, timeInit, timeFinal);", "first_line_prediction": "", "match": 0}
{"groundtruth": "ItemStack protectionRune = CustomItems.createProtectionRune();", "prediction": " ItemStack protectionRune = new ItemStack(CustomItems.PROTECTION_RUNE);\n         ItemMeta protectionRuneMeta = protectionRune.getItemMeta();\n         if (protectionRuneMeta != null) {\n             protectionRuneMeta.setDisplayName(\"\u00a76Protection Rune\");\n             protectionRune.setItemMeta(protectionRuneMeta);\n         }\n         shop.setItem(PROTECTION_RUNE_SLOT, protectionRune);", "first_line_groundtruth": "ItemStack protectionRune = CustomItems.createProtectionRune();", "first_line_prediction": " ItemStack protectionRune = new ItemStack(CustomItems.PROTECTION_RUNE);", "match": 0}
{"groundtruth": "(professorService.getProfessorByLogin(login));", "prediction": "(professorService.findByLogin(login));\n        booking.setSubject(subjectService.findBySubject(subject));\n        booking.setLab(labService.findByLab(lab));\n        booking.setTimeInit(initialTime);\n        booking.setTimeFinal(finalTime);\n        bookingRepository.save(booking);\n    }", "first_line_groundtruth": "(professorService.getProfessorByLogin(login));", "first_line_prediction": "(professorService.findByLogin(login));", "match": 0}
{"groundtruth": "int count = bookingRepository.isBusy(b.getLab().getId(), b.getTimeInit(), b.getTimeFinal());", "prediction": " return bookingRepository.isBusy(b.getLab().getId(), b.getTimeInit(), b.getTimeFinal());\n        }).orElse(false);\n    }\n\n    public boolean isBusy(Booking booking) {\n        return bookingRepository.isBusy(booking.getLab().getId(), booking.getTimeInit(), booking.getTimeFinal());\n    }\n\n    public void approve(Long id) {\n        Booking booking = bookingRepository.findById(id).get();\n        if (booking.isApproved()) {\n            logService.insertedApproved(booking);\n        } else {\n            logService.insertedPending(booking);\n        }\n        booking.", "first_line_groundtruth": "int count = bookingRepository.isBusy(b.getLab().getId(), b.getTimeInit(), b.getTimeFinal());", "first_line_prediction": " return bookingRepository.isBusy(b.getLab().getId(), b.getTimeInit(), b.getTimeFinal());", "match": 0}
{"groundtruth": "booking.setTimeInit(initialTime);", "prediction": "\n\n        booking.setTimeInit(initialTime);\n        booking.setTimeFinal(finalTime);\n\n        bookingRepository.save(booking);\n    }", "first_line_groundtruth": "booking.setTimeInit(initialTime);", "first_line_prediction": "", "match": 0}
{"groundtruth": ".BOLD + \"\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());", "prediction": ".AQUA + \"Max Enhancement\");\n        } else {\n            return Component.text(Utils.getEnhancementInfo(enhancementLevel).getEnhanceColor() + \"\" + ChatColor.AQUA + \"Enhancement \" + enhancementLevel);\n        }\n    }\n\n    public static EnhancementInfo getEnhancementInfo(int enhancementLevel) {\n        if (enhancementLevel > 15) {\n            return new EnhancementInfo(ChatColor.GREEN, \"Max Enhancement\");\n        } else {\n            return new EnhancementInfo(ChatColor.GREEN, \"Enhancement \" + enhancementLevel);\n        }\n   ", "first_line_groundtruth": ".BOLD + \"\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());", "first_line_prediction": ".AQUA + \"Max Enhancement\");", "match": 0}
{"groundtruth": "), b.getTimeInit(), b.getTimeFinal());", "prediction": " ), b.getTimeInit( ), b.getTimeFinal( ));\n            return count > 0;\n        }).orElse(false);\n    }\n\n    public boolean isBusy(Booking booking) {\n        return isBusy(Optional.of(booking));\n    }\n\n    public void approve(Long id) {\n        Booking booking = bookingRepository.findById(id).get();\n        if (booking.isPending()) {\n            logService.insertedApproved(booking);\n        } else {\n            logService.insertedPending(booking);\n        }\n        booking.setApproved(true);\n        bookingRepository.save(booking);\n    }\n\n    public void", "first_line_groundtruth": "), b.getTimeInit(), b.getTimeFinal());", "first_line_prediction": " ), b.getTimeInit( ), b.getTimeFinal( ));", "match": 0}
{"groundtruth": ", b.getTimeInit(), b.getTimeFinal());", "prediction": " , b.getTimeInit(), b.getTimeFinal());\n            return count > 0;\n        }).orElse(false);\n    }\n\n    public void approve(Long id) {\n        Booking booking = bookingRepository.findById(id).get();\n        booking.setApproved(true);\n        bookingRepository.save(booking);\n        logService.insertedApproved(booking);\n    }\n\n    public void insertPending(Booking booking) {\n        bookingRepository.save(booking);\n        logService.insertedPending(booking);\n    }\n\n    @Async\n    public void insertPendingAsync(Booking booking) {\n        bookingRepository.save(booking);\n       ", "first_line_groundtruth": ", b.getTimeInit(), b.getTimeFinal());", "first_line_prediction": " , b.getTimeInit(), b.getTimeFinal());", "match": 0}
{"groundtruth": "setSubject(subjectService.getSubject(subject));", "prediction": "setSubject(subjectService.getSubjectByName(subject));\n        booking.setLab(labService.getLabByName(lab));\n        booking.setTimeInit(initialTime);\n        booking.setTimeFinal(finalTime);\n        booking.setTimeRequest(LocalDateTime.now());\n        bookingRepository.save(booking);\n    }", "first_line_groundtruth": "setSubject(subjectService.getSubject(subject));", "first_line_prediction": "setSubject(subjectService.getSubjectByName(subject));", "match": 0}
{"groundtruth": "(Environment.getProgram(), taintFunction);", "prediction": "Normalize(program, taintFunction);\n        HighFunction highFunction = decompileResults.getHighFunction();\n        Iterator<PcodeOpAST> asts = highFunction.getPcodeOps();\n        while (asts.hasNext()) {\n            PcodeOpAST ast = asts.next();\n            Varnode[] inputs = ast.getInputs();\n            Varnode output = ast.getOutput();\n            if (output != null) {\n                String exp = PCodeUtil.evaluateVarNode(output);\n                inputLocations.put(output.getAddress(), exp);\n            }\n        }\n    }\n\n    public void identifyIndirectInputLoc", "first_line_groundtruth": "(Environment.getProgram(), taintFunction);", "first_line_prediction": "Normalize(program, taintFunction);", "match": 0}
{"groundtruth": "analyzer.startAnalyzing();", "prediction": "\n\n            // analyzer.run();\n            // analyzer.runMeta();\n            // analyzer.runConnect();\n        }\n\n        // endTime = System.currentTimeMillis();\n        // System.out.println(\"Total time: \" + (endTime - startTime) + \" ms\");\n    }\n\n    private static boolean loadConfig(String configFile) {\n        try {\n            JSONObject config = new JSONObject(new String(new FileInputStream(configFile)));\n            Configs.ANALYZE_CONNECT = config.getBoolean(\"ANALYZE_CONNECT\");\n            Configs.ANALYZE_META = config.getBoolean(\"ANALYZE_META\");\n            Configs.", "first_line_groundtruth": "analyzer.startAnalyzing();", "first_line_prediction": "", "match": 0}
{"groundtruth": "func = FunctionUtil.getFunctionWith(Environment.getProgram(), connAdd);", "prediction": "qlConnectFunc = FunctionUtil.getFunctionWithName(Environment.getProgram(), \"qlConnect\");\n        if (qlConnectFunc == null) {\n            invalid = true;\n            return;\n        }\n        highFunction = new HighFunction(qlConnectFunc);\n\n        // find the connect function\n        highFunction.setStart(startAdd);\n        highFunction.setEnd(connAdd);\n        highFunction.setHighFunction(qlConnectFunc);\n        highFunction.setHighFunction(qlConnectFunc);\n        highFunction.setHighFunction(qlConnectFunc);\n        highFunction.setHighFunction(qlConnectFunc);\n        high", "first_line_groundtruth": "func = FunctionUtil.getFunctionWith(Environment.getProgram(), connAdd);", "first_line_prediction": "qlConnectFunc = FunctionUtil.getFunctionWithName(Environment.getProgram(), \"qlConnect\");", "match": 0}
{"groundtruth": ".decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));", "prediction": ".decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, signalExp));\n            if (decompileResults == null)\n                return;\n            highFunction = decompileResults.getHighFunction();\n            Iterator<PcodeOpAST> pcodeOpASTIterator2 = highFunction.getPcodeOps(signalExp);\n            PcodeOpAST pcodeAST2 = null;\n            while (pcodeOpASTIterator2.hasNext()) {\n                PcodeOpAST tmp = pcodeOpASTIterator2.next();\n                if (tmp.getMnemonic().equals(\"CALL\")) {\n                    pcodeAST2", "first_line_groundtruth": ".decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));", "first_line_prediction": ".decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, signalExp));", "match": 0}
{"groundtruth": "decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));", "prediction": "decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, signalExp));\n            if (decompileResults == null)\n                return;\n            highFunction = decompileResults.getHighFunction();\n            Iterator<PcodeOpAST> pcodeOpASTIterator2 = highFunction.getPcodeOps(signalExp);\n            PcodeOpAST pcodeAST2 = null;\n            while (pcodeOpASTIterator2.hasNext()) {\n                PcodeOpAST tmp = pcodeOpASTIterator2.next();\n                if (tmp.getMnemonic().equals(\"CALL\")) {\n                    pcodeAST2 =", "first_line_groundtruth": "decompileFuncNormalize(Environment.getProgram(), FunctionUtil.getFunctionWith(Environment.getProgram(), startAdd));", "first_line_prediction": "decompileFuncNormalize(program, FunctionUtil.getFunctionWith(program, signalExp));", "match": 0}
{"groundtruth": "= FileUtil.readFromFile(configPath);", "prediction": " = FileUtil.readFromFile(configPath);\n            JSONObject json = new JSONObject(config);\n            Configs.ANALYZE_CONNECT = json.getBoolean(\"ANALYZE_CONNECT\");\n            Configs.ANALYZE_META = json.getBoolean(\"ANALYZE_META\");\n            Configs.OUTPUT_DIR = json.getString(\"OUTPUT_DIR\");\n            Configs.BINARY_FILE_LIST = json.getString(\"BINARY_FILE_LIST\");\n            Configs.DIRECTORY_NAME = json.getString(\"DIRECTORY_NAME\");\n            Configs.PROJECT_NAME = json.getString(\"PROJECT_NAME\");\n           ", "first_line_groundtruth": "= FileUtil.readFromFile(configPath);", "first_line_prediction": " = FileUtil.readFromFile(configPath);", "match": 0}
{"groundtruth": "jo.getProperty(name).cast(JSFunction.class);", "prediction": " context.createJSFunction(object, simpleMethod);\n      JSValue result = function.call(context, parameters);\n      return resultAdapter.fromJSValue(context, result);\n    });\n  }\n\n  @Override\n  public boolean isInstance(Object value) {\n    return rawType.isInstance(value);\n  }\n\n  @Override\n  public boolean isAssignable(Type type) {\n    return rawType.isAssignableFrom(JavaTypes.getRawType(type));\n  }\n\n  @Override\n  public boolean isSubtype(Type type) {\n    return rawType.isAssignableFrom(JavaTypes.getRawType(type));\n  }\n\n  @", "first_line_groundtruth": "jo.getProperty(name).cast(JSFunction.class);", "first_line_prediction": " context.createJSFunction(object, simpleMethod);", "match": 0}
{"groundtruth": "DecompileResults decompileResults = Decompiler.decompileFuncRegister(Environment.getProgram(), currentFunc);", "prediction": " // locate block at the target function\n        CodeBlock[] currentBlocks = BlockUtil.locateBlockWithAddress(program, currentFunc.getEntryPoint());\n        if (currentBlocks == null || currentBlocks.length == 0) {\n            System.out.println(\"Error: block not found for address: \" + currentFunc.getEntryPoint());\n            return;\n        }\n\n        CodeBlock currentBlock = currentBlocks[0];\n        recursiveTaint(currentBlock, new QTaintPath(), new ArrayList<>());\n    }\n\n    public void startTaint() {\n        Program program = Environment.getProgram();\n        taintFunction = Function", "first_line_groundtruth": "DecompileResults decompileResults = Decompiler.decompileFuncRegister(Environment.getProgram(), currentFunc);", "first_line_prediction": " // locate block at the target function", "match": 0}
{"groundtruth": "enhancementLevel).getEnhanceColor() + \"+\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());", "prediction": "enhancementLevel).getEnhanceColor() + \"\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());\n        }\n    }\n\n    public static EnhancementInfo getEnhancementInfo(int enhancementLevel) {\n        if (enhancementLevel > 15) {\n            return new EnhancementInfo(ChatColor.RED, \"Max Enhancement\");\n        } else {\n            return new EnhancementInfo(ChatColor.GREEN, \"Enhancement\");\n        }\n    }\n\n    public static void spawnSuccessParticles(Player player) {\n        player.getWorld().spawnParticle(player.getLocation(), \"heart", "first_line_groundtruth": "enhancementLevel).getEnhanceColor() + \"+\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());", "first_line_prediction": "enhancementLevel).getEnhanceColor() + \"\" + Utils.getEnhancementInfo(enhancementLevel).getEnhanceName());", "match": 0}
{"groundtruth": "getFunctionWith(Environment.getProgram(), inputs[0].getAddress());", "prediction": "getFunctionWith(Environment.getProgram(), op.getSeqnum().getTarget());\n                    String funcName = func.getName();\n                    jsonArray.put(funcName);\n                }\n                else if (mnem.equals(\"STORE\")) {\n                    String expOfSrc = PCodeUtil.evaluateVarNode(inputs[2]);\n                    if (expOfSrc!= null && expOfSrc.contains(taintExpression)) {\n                        String expToAdd = PCodeUtil.evaluateVarNode(inputs[1]);\n                        jsonArray.put(expToAdd);\n                    }\n                }\n                else if (mnem.equals(\"LOAD\"))", "first_line_groundtruth": "getFunctionWith(Environment.getProgram(), inputs[0].getAddress());", "first_line_prediction": "getFunctionWith(Environment.getProgram(), op.getSeqnum().getTarget());", "match": 0}
{"groundtruth": "CustomItems.createBlackStoneWeapon();", "prediction": " CustomItems.createWeapon(amount);\n            } else if (itemType.equals(\"armor\")) {\n                itemToGive =  CustomItems.createArmor(amount);\n            } else if (itemType.equals(\"helmet\")) {\n                itemToGive =  CustomItems.createHelmet(amount);\n            } else if (itemType.equals(\"chestplate\")) {\n                itemToGive =  CustomItems.createChestplate(amount);\n            } else if (itemType.equals(\"leggings\")) {\n                itemToGive =  CustomItems.createLeggings(amount);\n            } else if", "first_line_groundtruth": "CustomItems.createBlackStoneWeapon();", "first_line_prediction": " CustomItems.createWeapon(amount);", "match": 0}
{"groundtruth": "jo.getJavaObject();", "prediction": " Proxy.newProxyInstance(rawType.getClassLoader(), new Class<?>[] {rawType}, (proxy, method, args) -> {\n      String name = method.getName();\n      JavaMethod methodInfo = methods.get(name);\n      if (methodInfo == null) return null;\n\n      Object result = methodInfo.invoke(object, args);\n      if (result == null) return null;\n\n      return result;\n    });\n\n    return new JSValueHolder(object, JS_VALUE_HOLDER_TAG);\n  }", "first_line_groundtruth": "jo.getJavaObject();", "first_line_prediction": " Proxy.newProxyInstance(rawType.getClassLoader(), new Class<?>[] {rawType}, (proxy, method, args) -> {", "match": 0}
{"groundtruth": "protectionStone = random.nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionRune();", "prediction": " protectionStone = CustomItems.createProtectionRune();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), protectionStone);\n        }\n    }\n\n    private boolean isHostileMob(LivingEntity entity) {\n        return entity instanceof Player || entity instanceof Monster || entity instanceof Animals;\n    }\n\n    private boolean shouldDropBlackStone() {\n        return random.nextDouble() < blackStoneDropChance;\n    }\n\n    private boolean shouldDropConcentratedBlackStone() {\n        return random.nextDouble() < concentratedBlackStoneDropChance;\n    }\n\n    private boolean shouldDropProtectionStone() {", "first_line_groundtruth": "protectionStone = random.nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionRune();", "first_line_prediction": " protectionStone = CustomItems.createProtectionRune();", "match": 0}
{"groundtruth": "CustomItems.createConcentratedMagicalBlackStoneWeapon();", "prediction": " CustomItems.createConcentratedMagicalBlackStoneWeapon();\n            } else if (itemType.equals(\"carmor\")) {\n                itemToGive =  CustomItems.createConcentratedMagicalBlackStoneArmor();\n            } else {\n                player.sendMessage(\"Invalid item type. Please enter a valid item type.\");\n                return true;\n            }\n\n            for (int i = 0; i < amount; i++) {\n                targetPlayer.getInventory().addItem(itemToGive);\n            }\n\n            player.sendMessage(\"You have given \" + amount + \" \" + itemType + \" to \" + target", "first_line_groundtruth": "CustomItems.createConcentratedMagicalBlackStoneWeapon();", "first_line_prediction": " CustomItems.createConcentratedMagicalBlackStoneWeapon();", "match": 0}
{"groundtruth": "itemToGive = CustomItems.createProtectionRune();", "prediction": " itemToGive = CustomItems.createProtectionRune();\n            } else if (itemType.equals(\"cstone\")) {\n                itemToGive = CustomItems.createConcentratedProtectionRune();\n            } else {\n                player.sendMessage(\"Invalid item type. Please enter a valid item type.\");\n                return true;\n            }\n\n            if (itemToGive == null) {\n                player.sendMessage(\"An error occurred while trying to give the item.\");\n                return true;\n            }\n\n            for (int i = 0; i < amount; i++) {\n                targetPlayer.getInventory().addItem(itemToGive);\n           ", "first_line_groundtruth": "itemToGive = CustomItems.createProtectionRune();", "first_line_prediction": " itemToGive = CustomItems.createProtectionRune();", "match": 0}
{"groundtruth": "? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "prediction": " ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), blackStone);\n        }\n        if (isHostileMob(entity) && shouldDropProtectionStone()) {\n            ItemStack protectionStone = CustomItems.createProtectionRune();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), protectionStone);\n        }\n    }\n\n    private boolean isHostileMob(LivingEntity entity) {\n        return entity instanceof Player || entity instanceof Monster || entity", "first_line_groundtruth": "? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "first_line_prediction": " ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "match": 0}
{"groundtruth": "25, enhanceGUI.createEnhanceButton());", "prediction": "25, EnhanceGUI.createEnhanceButton());\n        }, 20L);\n    }\n\n    private void enhanceItem(Player player, Inventory inventory, int itemSlot, int blackStoneSlot) {\n        ItemStack itemToEnhance = inventory.getItem(itemSlot);\n        ItemStack blackStone = inventory.getItem(blackStoneSlot);\n\n        if (itemToEnhance == null || itemToEnhance.getType() == Material.AIR || blackStone == null || blackStone.getType() == Material.AIR) {\n            return;\n        }\n\n        ItemMeta blackStoneMeta = blackStone.getItemMeta();\n        if", "first_line_groundtruth": "25, enhanceGUI.createEnhanceButton());", "first_line_prediction": "25, EnhanceGUI.createEnhanceButton());", "match": 0}
{"groundtruth": ".nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionRune();", "prediction": ".nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionStone();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), protectionStone);\n        }\n    }\n\n    private boolean isHostileMob(LivingEntity entity) {\n        return entity instanceof Player || entity instanceof Monster || entity instanceof Animals;\n    }\n\n    private boolean shouldDropBlackStone() {\n        return random.nextDouble() < blackStoneDropChance;\n    }\n\n    private boolean shouldDropConcentratedBlackStone() {\n        return random.nextDouble() < concentratedBlackStoneDropChance;\n   ", "first_line_groundtruth": ".nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionRune();", "first_line_prediction": ".nextBoolean() ? CustomItems.createProtectionRune() : CustomItems.createProtectionStone();", "match": 0}
{"groundtruth": "add(inputBox1.getVBox());", "prediction": "add(inputBox1.getVBox());\n\n        //Crear la segunda instancia de InputBox con el valor de ComboBox \"EUR\"\n        counter++;\n        InputBox inputBox2 = new InputBox();\n        inputBox2.setId(counter);\n        inputBox2.getComboBox().setValue(\"EUR\");\n        inputBox2.getTextField().setText(\"1\");\n        inputBoxes.add(inputBox2);\n        subContainer.getChildren().add(inputBox2.getVBox());\n\n        //Crear la tercera instancia de InputBox con el valor de ComboBox \"GBP\"\n        counter", "first_line_groundtruth": "add(inputBox1.getVBox());", "first_line_prediction": "add(inputBox1.getVBox());", "match": 1}
{"groundtruth": "nextBoolean() ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "prediction": "nextBoolean() ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), blackStone);\n        }\n        if (isHostileMob(entity) && shouldDropProtectionStone()) {\n            ItemStack protectionStone = CustomItems.createProtectionRune();\n            entity.getWorld().dropItemNaturally(entity.getLocation(), protectionStone);\n        }\n    }\n\n    private boolean isHostileMob(LivingEntity entity) {\n        return entity instanceof Player || entity instanceof Mon", "first_line_groundtruth": "nextBoolean() ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "first_line_prediction": "nextBoolean() ? CustomItems.createConcentratedMagicalBlackStoneWeapon() : CustomItems.createConcentratedMagicalBlackStoneArmor();", "match": 1}
{"groundtruth": "inputBox1.setInitialConversion(false);", "prediction": "\n\n    }\n\n    public static void setMainContainer(VBox mainContainer) {\n        MainController.mainContainer = mainContainer;\n    }\n\n    public static void setSubContainer(VBox subContainer) {\n        MainController.subContainer = subContainer;\n    }\n\n    public static void setInputBoxes(List<InputBox> inputBoxes) {\n        MainController.inputBoxes = inputBoxes;\n    }\n\n    public static List<InputBox> getInputBoxes() {\n        return inputBoxes;\n    }\n\n    public static void setCounter(int counter) {\n        MainController.counter = counter;\n    }\n\n    public static int", "first_line_groundtruth": "inputBox1.setInitialConversion(false);", "first_line_prediction": "", "match": 0}
{"groundtruth": "inputBox1.startConversion();", "prediction": "\n\n    }\n\n    public static void setMainContainer(VBox mainContainer) {\n        MainController.mainContainer = mainContainer;\n    }\n\n    public static void setSubContainer(VBox subContainer) {\n        MainController.subContainer = subContainer;\n    }\n\n    public static void setInputBoxes(List<InputBox> inputBoxes) {\n        MainController.inputBoxes = inputBoxes;\n    }\n\n    public static List<InputBox> getInputBoxes() {\n        return inputBoxes;\n    }\n\n    public static void setCounter(int counter) {\n        MainController.counter = counter;\n    }\n\n    public static int", "first_line_groundtruth": "inputBox1.startConversion();", "first_line_prediction": "", "match": 0}
{"groundtruth": "inputBox1.setInitialConversion(true);", "prediction": " convert();\n    }\n\n    public static void convert() {\n        for (InputBox inputBox : inputBoxes) {\n            String base = inputBox.getComboBox().getValue();\n            String number = inputBox.getTextField().getText();\n            String formattedNumber = Utils.convert(base, number);\n            inputBox.getTextField().setText(formattedNumber);\n        }\n    }\n\n    public static VBox getVBox() {\n        return mainContainer;\n    }\n\n    public static void setVBox(VBox vBox) {\n        mainContainer = vBox;\n    }\n\n    public static VBox getSubContainer() {\n        return", "first_line_groundtruth": "inputBox1.setInitialConversion(true);", "first_line_prediction": " convert();", "match": 0}
{"groundtruth": "professorService.deleteById(id);", "prediction": " professorService.deleteById(id);\n    }\n\n    @GetMapping(\"/findAll\")\n    public List<Professor> findAll(){\n        return professorService.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public Professor find(@PathVariable Long id){\n        return professorService.find(id);\n    }", "first_line_groundtruth": "professorService.deleteById(id);", "first_line_prediction": " professorService.deleteById(id);", "match": 0}
{"groundtruth": "List<Booking> bookings = bookingRepository.findByProfessor(id);", "prediction": " List<BookingDTO> bookings = new ArrayList<>();\n         List<Booking> bookingsList = bookingRepository.findBookingsByProfessorId(id);\n         for (Booking booking : bookingsList) {\n             BookingDTO bookingDTO = new BookingDTO();\n             bookingDTO.setId(booking.getId());\n             bookingDTO.setProfessorId(booking.getProfessorId());\n             bookingDTO.setSubjectId(booking.getSubjectId());\n             bookingDTO.setLabId(booking.getLabId());\n             bookingDTO.setTimeInit(booking.getTimeInit());\n             bookingDTO.setTimeFinal", "first_line_groundtruth": "List<Booking> bookings = bookingRepository.findByProfessor(id);", "first_line_prediction": " List<BookingDTO> bookings = new ArrayList<>();", "match": 0}
{"groundtruth": "bookingRepository.approve(id);", "prediction": "\n\n        if (b.isApproved()) {\n            return ResponseEntity.status(HttpStatus.CONFLICT).body(\"This booking is already approved.\");\n        }\n\n        b.setApproved(true);\n        bookingRepository.update(b);\n        logService.Approved(bookingRepository.findById(b.getId()).get());\n        return ResponseEntity.ok(\"Approved.\");\n    }\n\n    public List<BookingDTO> findAll() {\n        List<BookingDTO> bookingDTOs = new ArrayList<>();\n        for (Booking booking : bookingRepository.findAll()) {\n            bookingDTOs.add(new BookingDTO(booking));\n        }\n        return booking", "first_line_groundtruth": "bookingRepository.approve(id);", "first_line_prediction": "", "match": 0}
{"groundtruth": "InputBox.setBaseIndex(1);", "prediction": "\n\n    }\n\n    public static void setMainContainer(VBox mainContainer) {\n        MainController.mainContainer = mainContainer;\n    }\n\n    public static void setSubContainer(VBox subContainer) {\n        MainController.subContainer = subContainer;\n    }\n\n    public static void setInputBoxes(List<InputBox> inputBoxes) {\n        MainController.inputBoxes = inputBoxes;\n    }\n\n    public static List<InputBox> getInputBoxes() {\n        return inputBoxes;\n    }\n\n    public static void setCounter(int counter) {\n        MainController.counter = counter;\n    }\n\n    public static int", "first_line_groundtruth": "InputBox.setBaseIndex(1);", "first_line_prediction": "", "match": 0}
{"groundtruth": "newComponent.getVBox().setId(String.valueOf(counter));", "prediction": " //Crear la instancia de InputBox con el valor de ComboBox \"PEN\"\n        newComponent.getComboBox().setValue(\"PEN\");\n        newComponent.getTextField().setText(\"1\");\n        inputBoxes.add(newComponent);\n        subContainer.getChildren().add(newComponent.getVBox());\n    }\n\n    @FXML\n    protected void addButton2() {\n        InputBox newComponent = new InputBox();\n        counter++;\n        newComponent.setId(counter);\n        //Crear la instancia de InputBox con el valor de ComboBox \"USD\"\n        newComponent.getComboBox().setValue(\"USD\");", "first_line_groundtruth": "newComponent.getVBox().setId(String.valueOf(counter));", "first_line_prediction": " //Crear la instancia de InputBox con el valor de ComboBox \"PEN\"", "match": 0}
{"groundtruth": "String exchangeRate = conversion.getExchangeRate();", "prediction": "\n\n        if (result.equals(\"offline\")) {\n            inputBox.getTextField().setText(\"No hay conexi\u00f3n a internet\");\n            inputBox.getTextField().setTextFill(Color.RED);\n        } else {\n            inputBox.getTextField().setText(result);\n            inputBox.getTextField().setTextFill(Color.GREEN);\n        }\n    }", "first_line_groundtruth": "String exchangeRate = conversion.getExchangeRate();", "first_line_prediction": "", "match": 0}
{"groundtruth": "Errors.noConexion();", "prediction": " return \"offline\";\n        }\n    }\n\n    public String getExchangeRate() {\n        return exchangeRate;\n    }", "first_line_groundtruth": "Errors.noConexion();", "first_line_prediction": " return \"offline\";", "match": 0}
{"groundtruth": "inputBox.getComboBox().getValue());", "prediction": " inputBox.getCurrencyInput());\n        if (result.equals(\"offline\")) {\n            inputBox.setResult(result);\n            inputBox.setResultColor(Color.RED);\n        } else {\n            inputBox.setResult(result);\n            inputBox.setResultColor(Color.GREEN);\n        }\n        inputBox.setResultDate(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"dd/MM/yyyy HH:mm:ss\")));\n        inputBox.setResultTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"HH:mm:ss\")));\n        inputBox.setResult", "first_line_groundtruth": "inputBox.getComboBox().getValue());", "first_line_prediction": " inputBox.getCurrencyInput());", "match": 0}
{"groundtruth": "String resultOffline = conversion.convertOffline(exchangeRateOffline, baseTextField);", "prediction": " Platform.runLater(() -> {\n                             inputBox.setTextField(\"offline\");\n                             inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchangeRateOffline + \" | Fecha: \" + date);\n                         });\n                    }\n                });\n            });\n        }\n    }", "first_line_groundtruth": "String resultOffline = conversion.convertOffline(exchangeRateOffline, baseTextField);", "first_line_prediction": " Platform.runLater(() -> {", "match": 0}
{"groundtruth": "inputBox.setTextField(resultOffline);", "prediction": " ///Guardar propiedades\n                        properties.setProperty(baseComboBox + \"->\" +inputBox.getComboBox().getValue(), resultOffline + \",\" + date);\n                        try (OutputStream outputStream = new FileOutputStream(\"app.properties\")) {\n                            properties.store(outputStream, \"Application Properties\");\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n\n                        Platform.runLater(() -> {\n                            inputBox.setTextField(resultOffline);\n                            inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchange", "first_line_groundtruth": "inputBox.setTextField(resultOffline);", "first_line_prediction": " ///Guardar propiedades", "match": 0}
{"groundtruth": "startsWith(baseComboBox) && key.toString().endsWith(inputBox.getComboBox().getValue())) {", "prediction": "contains(baseComboBox + \"->\" + inputBox.getComboBox().getValue())) {\n                        inputBox.setTextField(\"offline\");\n                        inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + value);\n                    }\n                });\n            });\n        }\n    }", "first_line_groundtruth": "startsWith(baseComboBox) && key.toString().endsWith(inputBox.getComboBox().getValue())) {", "first_line_prediction": "contains(baseComboBox + \"->\" + inputBox.getComboBox().getValue())) {", "match": 0}
{"groundtruth": "inputBox.getComboBox().getValue() + \" : \" + exchangeRate);", "prediction": " inputBox.getComboBox().getValue() + \" = \" + exchangeRate);\n                    inputBox.setBackgroundColor(Color.GREEN);\n                    inputBox.setBorderColor(Color.GREEN);\n                    inputBox.setBorderColor2(Color.GREEN);\n                    inputBox.setBorderColor3(Color.GREEN);\n                    inputBox.setBorderColor4(Color.GREEN);\n                    inputBox.setBorderColor5(Color.GREEN);\n                    inputBox.setBorderColor6(Color.GREEN);\n                    inputBox.setBorderColor7(Color.GREEN);\n                    inputBox.setBorderColor8(Color.GREEN);\n                    inputBox.setBorderColor", "first_line_groundtruth": "inputBox.getComboBox().getValue() + \" : \" + exchangeRate);", "first_line_prediction": " inputBox.getComboBox().getValue() + \" = \" + exchangeRate);", "match": 0}
{"groundtruth": "inputBox.getLabel2().setTextFill(Color.RED);", "prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchangeRateOffline + \" | \" + date);\n                    }\n                });\n            });\n        }\n    }", "first_line_groundtruth": "inputBox.getLabel2().setTextFill(Color.RED);", "first_line_prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchangeRateOffline + \" | \" + date);", "match": 0}
{"groundtruth": "inputBox.setTextField(result);", "prediction": " inputBox.setLabel1(Utils.addSymbol(inputBox.getComboBox().getValue()) + result);\n                     inputBox.setLabel2(exchangeRate + \" \" + inputBox.getComboBox().getValue());\n                     inputBox.setTextField(result);\n                     inputBox.setComboBox(inputBox.getComboBox().getValue());\n                     inputBox.setComboBoxColor(Color.GREEN);\n                     inputBox.setComboBoxColor(Color.BLACK);\n                     inputBox.setComboBoxColor(Color.BLACK);\n                     inputBox.setComboBoxColor(Color.BLACK);\n                     inputBox.setComboBoxColor(Color.BLACK);\n                    ", "first_line_groundtruth": "inputBox.setTextField(result);", "first_line_prediction": " inputBox.setLabel1(Utils.addSymbol(inputBox.getComboBox().getValue()) + result);", "match": 0}
{"groundtruth": "inputBox.setLabel2(\" | Tipo de cambio: \" + exchangeRateOffline + \" (\" + date + \" ) \u26a0\");", "prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchangeRateOffline + \" | Modo sin conexi\u00f3n", "first_line_groundtruth": "inputBox.setLabel2(\" | Tipo de cambio: \" + exchangeRateOffline + \" (\" + date + \" ) \u26a0\");", "first_line_prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \" : \" + exchangeRateOffline + \" | Modo sin conexi\u00f3n", "match": 0}
{"groundtruth": "inputBox.setLabel2(\" | No hay datos guardados \u26a0\");", "prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \"", "first_line_groundtruth": "inputBox.setLabel2(\" | No hay datos guardados \u26a0\");", "first_line_prediction": " inputBox.setLabel2(\" | Tipo de cambio: \" + baseComboBox + \" -> \" + inputBox.getComboBox().getValue() + \"", "match": 0}
{"groundtruth": "Node node : MainController.getVBox().getChildren()) {", "prediction": "InputBox inputBox : inputBoxes) {\n            if (inputBox.getId() == Integer.parseInt(activeInput)) {\n                inputBox.textField.setText(\"\");\n                inputBox.comboBox.setValue(\"USD\");\n                inputBox.textField.requestFocus();\n                break;\n            }\n        }\n    }\n\n    public void startConversion() {\n        if (textField.getText().equals(\"\")) {\n            return;\n        }\n        if (initialConversion) {\n            return;\n        }\n        initialConversion = true;\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.execute(() -> {\n            try {\n                String active", "first_line_groundtruth": "Node node : MainController.getVBox().getChildren()) {", "first_line_prediction": "InputBox inputBox : inputBoxes) {", "match": 0}
{"groundtruth": "= Utils.addCurrencies();", "prediction": " = Utils.addCurrencies();\n        for (String currency : currencies) {\n            comboBox.getItems().add(currency);\n        }\n\n        comboBox.setPromptText(\"Select a currency\");\n        comboBox.setEditable(false);\n\n        vBox.setAlignment(Pos.CENTER);\n        vBox.setPadding(new Insets(0.0, 0.0, 0.0, 0.0));\n\n        inputBoxes.add(this);\n\n        if (inputIdInit) {\n            inputId++;\n        } else {\n            inputIdInit = true;\n            inputId = 1", "first_line_groundtruth": "= Utils.addCurrencies();", "first_line_prediction": " = Utils.addCurrencies();", "match": 0}
{"groundtruth": "modified |= mySettingsComponent.isAutoPopup() != settings.autoPopup;", "prediction": " // modified |= !mySettingsComponent.get_autoPopup().equals(settings.autoPopup);\n        modified |= !mySettingsComponent.get_autoAddComments().equals(settings.autoAddComments);\n        modified |= !mySettingsComponent.get_autoReplaceCode().equals(settings.autoReplaceCode);\n        modified |= !mySettingsComponent.get_customRefactor().equals(settings.customRefactor);\n        modified |= !mySettingsComponent.get_autoSaveToNewFile().equals(settings.autoSaveToNewFile);\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n       ", "first_line_groundtruth": "modified |= mySettingsComponent.isAutoPopup() != settings.autoPopup;", "first_line_prediction": " // modified |= !mySettingsComponent.get_autoPopup().equals(settings.autoPopup);", "match": 0}
{"groundtruth": "Utils.obtenerCodigoPais(item);", "prediction": " item.substring(0, 3);\n                    String currencyName = item.substring(3);\n                    Image image = Utils.getImage(countryCode);\n                    imageView.setImage(image);\n                    setGraphic(imageView);\n                }\n            }\n        });\n\n        comboBox.setItems(currencies);\n\n        vBox.setAlignment(Pos.CENTER);\n        vBox.setPadding(new Insets(0.0, 0.0, 0.0, 0.0));\n\n        inputBoxes.add(this);\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }", "first_line_groundtruth": "Utils.obtenerCodigoPais(item);", "first_line_prediction": " item.substring(0, 3);", "match": 0}
{"groundtruth": "|= mySettingsComponent.isAutoSaveToNewFile() != settings.autoSaveToNewFile;", "prediction": " |= !mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        settings.OPENAI_API_KEY = mySettingsComponent.get_OPENAI_API_KEY();\n        settings.autoPopup = mySettingsComponent.isAutoPopup();\n        settings.autoAddComments = mySettingsComponent.isAutoAddComments();\n        settings.autoReplaceCode = mySettingsComponent.isAutoReplaceCode();\n        settings.customRefactor = mySettingsComponent.getCustom", "first_line_groundtruth": "|= mySettingsComponent.isAutoSaveToNewFile() != settings.autoSaveToNewFile;", "first_line_prediction": " |= !mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);", "match": 0}
{"groundtruth": "modified |= mySettingsComponent.isAutoAddComments() != settings.autoAddComments;", "prediction": " modified |= mySettingsComponent.isAutoAddComments() != settings.autoAddComments;\n         modified |= mySettingsComponent.isAutoReplaceCode() != settings.autoReplaceCode;\n         modified |= !mySettingsComponent.get_customRefactor().equals(settings.customRefactor);\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        settings.OPENAI_API_KEY = mySettingsComponent.get_OPENAI_API_KEY();\n        settings.autoPopup = mySettingsComponent.isAutoPopup();\n        settings.autoAdd", "first_line_groundtruth": "modified |= mySettingsComponent.isAutoAddComments() != settings.autoAddComments;", "first_line_prediction": " modified |= mySettingsComponent.isAutoAddComments() != settings.autoAddComments;", "match": 0}
{"groundtruth": "modified = !mySettingsComponent.get_OPENAI_API_KEY().equals(settings.OPENAI_API_KEY);", "prediction": " modified = false;\n        if (settings != null) {\n            modified = !settings.OPENAI_API_KEY.equals(mySettingsComponent.get_OPENAI_API_KEY());\n        }\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        if (settings != null) {\n            settings.OPENAI_API_KEY = mySettingsComponent.get_OPENAI_API_KEY();\n        }\n    }\n\n    @Override\n    public void reset() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        if (", "first_line_groundtruth": "modified = !mySettingsComponent.get_OPENAI_API_KEY().equals(settings.OPENAI_API_KEY);", "first_line_prediction": " modified = false;", "match": 0}
{"groundtruth": "!mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);", "prediction": " !mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        settings.OPENAI_API_KEY = mySettingsComponent.get_OPENAI_API_KEY();\n        settings.autoPopup = mySettingsComponent.isAutoPopup();\n        settings.autoAddComments = mySettingsComponent.isAutoAddComments();\n        settings.autoReplaceCode = mySettingsComponent.isAutoReplaceCode();\n        settings.autoSaveToNewFile = mySettingsComponent.is", "first_line_groundtruth": "!mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);", "first_line_prediction": " !mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);", "match": 0}
{"groundtruth": ".setText(Utils.addSymbol(baseComboBox) + \"0\");", "prediction": ".setText(\"Valor\");\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setPrefWidth(100.0);\n        label1.setPrefHeight(25.0);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.setAlignment(Pos.CENTER_LEFT);\n        label1.set", "first_line_groundtruth": ".setText(Utils.addSymbol(baseComboBox) + \"0\");", "first_line_prediction": ".setText(\"Valor\");", "match": 0}
{"groundtruth": "mySettingsComponent.isAutoReplaceCode() != settings.autoReplaceCode;", "prediction": " mySettingsComponent.isAutoReplaceCode() != settings.autoReplaceCode;\n        modified |= !mySettingsComponent.getCustomRefactor().equals(settings.customRefactor);\n        return modified;\n    }\n\n    @Override\n    public void apply() {\n        AppSettingsState settings = AppSettingsState.getInstance();\n        settings.OPENAI_API_KEY = mySettingsComponent.get_OPENAI_API_KEY();\n        settings.autoPopup = mySettingsComponent.isAutoPopup();\n        settings.autoAddComments = mySettingsComponent.isAutoAddComments();\n        settings.autoReplaceCode = mySettingsComponent.", "first_line_groundtruth": "mySettingsComponent.isAutoReplaceCode() != settings.autoReplaceCode;", "first_line_prediction": " mySettingsComponent.isAutoReplaceCode() != settings.autoReplaceCode;", "match": 0}
{"groundtruth": "label1.setText(Utils.addSymbol(baseComboBox) + formattedNumber);", "prediction": " textField.setText(formattedNumber);\n        }\n    }\n\n    public void startConversion() {\n        if (textField.getText().equals(\"\") || comboBox.getValue().equals(\"\")) {\n            return;\n        }\n        if (initialConversion) {\n            return;\n        }\n        initialConversion = true;\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.execute(() -> {\n            try {\n                String text = textField.getText();\n                String currency = comboBox.getValue();\n                String symbol = Utils.addSymbol(currency);\n                String url = \"https://free.currconv.com/api/", "first_line_groundtruth": "label1.setText(Utils.addSymbol(baseComboBox) + formattedNumber);", "first_line_prediction": " textField.setText(formattedNumber);", "match": 0}
{"groundtruth": "ok(this.orderService.getCustomerOrders(id));", "prediction": "ok(this.orderService.getOutsideOrders(id));\n    }\n\n    @GetMapping(\"/summary\")\n    public ResponseEntity<List<OrderSummary>> getSummary() {\n        return ResponseEntity.ok(this.orderService.getSummary());\n    }\n\n    @PostMapping\n    public ResponseEntity<OrderEntity> add(@RequestBody RandomOrderDto randomOrderDto) {\n        return ResponseEntity.ok(this.orderService.add(randomOrderDto));\n    }", "first_line_groundtruth": "ok(this.orderService.getCustomerOrders(id));", "first_line_prediction": "ok(this.orderService.getOutsideOrders(id));", "match": 0}
{"groundtruth": "ok(this.pizzaService.getCheapest(price));", "prediction": "ok(this.pizzaService.getCheapest(price));\n    }\n\n    @PostMapping\n    public ResponseEntity<PizzaEntity> save(@RequestBody PizzaEntity pizza) {\n        return ResponseEntity.ok(this.pizzaService.save(pizza));\n    }\n\n    @PutMapping(\"/{idPizza}\")\n    public ResponseEntity<PizzaEntity> update(@PathVariable int idPizza, @RequestBody UpdatePizzaPriceDto updatePizzaPriceDto) {\n        return ResponseEntity.ok(this.pizzaService.update(idPizza, updatePizzaPriceDto));\n    }\n\n    @DeleteMapping(\"/{", "first_line_groundtruth": "ok(this.pizzaService.getCheapest(price));", "first_line_prediction": "ok(this.pizzaService.getCheapest(price));", "match": 1}
{"groundtruth": "orderRepository.findAllByMethodIn(methods);", "prediction": "orderRepository.findAllByMethodIn(methods);\n    }\n\n    public List<OrderEntity> getCustomerOrders(String id) {\n        return this.orderRepository.findCustomerOrders(id);\n    }\n\n    public OrderSummary getSummary(int id) {\n        OrderEntity order = this.orderRepository.findById(id).orElseThrow(() -> new RuntimeException(\"La orden no existe\"));\n        return new OrderSummary(order);\n    }\n\n    @Transactional\n    public OrderEntity save(RandomOrderDto randomOrderDto) {\n        OrderEntity order = new OrderEntity();\n        order.setMethod(randomOrderDto.getMethod());\n       ", "first_line_groundtruth": "orderRepository.findAllByMethodIn(methods);", "first_line_prediction": "orderRepository.findAllByMethodIn(methods);", "match": 1}
{"groundtruth": "orderRepository.findCustomerOrders(idCustomer);", "prediction": "orderRepository.findCustomerOrders(idCustomer);\n    }\n\n    @Transactional\n    public OrderEntity create(RandomOrderDto randomOrderDto) {\n        OrderEntity order = new OrderEntity();\n        order.setMethod(randomOrderDto.getMethod());\n        order.setDate(LocalDateTime.now());\n        order.setTotal(randomOrderDto.getTotal());\n        order.setCustomer(randomOrderDto.getCustomer());\n        order.setPizzas(randomOrderDto.getPizzas());\n        return this.orderRepository.save(order);\n    }\n\n    public OrderSummary getSummary(int id) {\n        OrderEntity order", "first_line_groundtruth": "orderRepository.findCustomerOrders(idCustomer);", "first_line_prediction": "orderRepository.findCustomerOrders(idCustomer);", "match": 1}
{"groundtruth": "this.pizzaRepository.findAllByAvailableTrueAndDescriptionContainingIgnoreCase(ingredient);", "prediction": " this.pizzaRepository.findAllByAvailableTrueAndIngredientsContainingIgnoreCase(ingredient);\n    }\n\n    public List<PizzaEntity> getWithout(String ingredient) {\n        return  this.pizzaRepository.findAllByAvailableTrueAndIngredientsNotContainingIgnoreCase(ingredient);\n    }\n\n    public List<PizzaEntity> getCheapest(double price) {\n        return  this.pizzaRepository.findAllByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);\n    }\n\n    public PizzaEntity get(int idPizza) {\n        return this.pizzaRepository.findById(idPizza).", "first_line_groundtruth": "this.pizzaRepository.findAllByAvailableTrueAndDescriptionContainingIgnoreCase(ingredient);", "first_line_prediction": " this.pizzaRepository.findAllByAvailableTrueAndIngredientsContainingIgnoreCase(ingredient);", "match": 0}
{"groundtruth": "orderRepository.findSummary(orderId);", "prediction": "orderRepository.findSummary(orderId);\n    }\n\n    @Transactional\n    public boolean saveRandomOrder(String idCustomer, String method) {\n        RandomOrderDto randomOrderDto = new RandomOrderDto(idCustomer, method);\n        return this.orderRepository.saveRandomOrder(randomOrderDto);\n    }", "first_line_groundtruth": "orderRepository.findSummary(orderId);", "first_line_prediction": "orderRepository.findSummary(orderId);", "match": 1}
{"groundtruth": "return this.pizzaRepository.findFirstByAvailableTrueAndNameIgnoreCase(name).orElseThrow(() -> new RuntimeException(\"La pizza no existe\"));", "prediction": " return this.pizzaRepository.findByNameIgnoreCase(name);\n    }\n\n    public List<PizzaEntity> getWith(String ingredient) {\n        return this.pizzaRepository.findByNameContainingIgnoreCase(ingredient);\n    }\n\n    public List<PizzaEntity> getWithout(String ingredient) {\n        return this.pizzaRepository.findByNameNotContainingIgnoreCase(ingredient);\n    }\n\n    public PizzaEntity getById(int id) {\n        return this.pizzaRepository.findById(id).orElse(null);\n    }\n\n    public PizzaEntity save(PizzaEntity pizzaEntity) {\n        return this.", "first_line_groundtruth": "return this.pizzaRepository.findFirstByAvailableTrueAndNameIgnoreCase(name).orElseThrow(() -> new RuntimeException(\"La pizza no existe\"));", "first_line_prediction": " return this.pizzaRepository.findByNameIgnoreCase(name);", "match": 0}
{"groundtruth": ".pizzaRepository.findTop3ByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "prediction": ".pizzaRepository.findAllByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);\n    }\n\n    public PizzaEntity add(PizzaEntity pizza) {\n        if (pizza.getIdPizza() == null || !this.pizzaRepository.exists(pizza.getIdPizza())) {\n            return this.pizzaRepository.save(pizza);\n        } else {\n            throw new RuntimeException(\"La pizza ya existe\");\n        }\n    }\n\n    public PizzaEntity update(PizzaEntity pizza) {\n        return this.pizzaRepository.save(pizza);\n    }\n\n    public void delete(", "first_line_groundtruth": ".pizzaRepository.findTop3ByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "first_line_prediction": ".pizzaRepository.findAllByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "match": 0}
{"groundtruth": "return mergePluginManagement != null ? mergePluginManagement : mixins.isMergePluginManagement();", "prediction": " return mergePluginManagement;\n    }\n\n    public void setMergePluginManagement(boolean mergePluginManagement) {\n        this.mergePluginManagement = mergePluginManagement;\n    }\n\n    public boolean isMergePlugins() {\n        return mergePlugins;\n    }\n\n    public void setMergePlugins(boolean mergePlugins) {\n        this.mergePlugins = mergePlugins;\n    }\n\n    public boolean isMergeReporting() {\n        return mergeReporting;\n    }\n\n    public void setMergeReporting(boolean mergeReporting) {\n        this.mergeReporting = mergeReporting;\n    }\n\n    public boolean isMergeProperties() {\n        return mergeProperties;\n    }\n\n    public void", "first_line_groundtruth": "return mergePluginManagement != null ? mergePluginManagement : mixins.isMergePluginManagement();", "first_line_prediction": " return mergePluginManagement;", "match": 0}
{"groundtruth": "null ? mergePlugins : mixins.isMergePlugins();", "prediction": " null ? mergePlugins : mixins.isMergePlugins();\n    }\n\n    public void setMergePlugins(Boolean mergePlugins) {\n        this.mergePlugins = mergePlugins;\n    }\n\n    public boolean isMergeReporting() {\n        return mergeReporting != null ? mergeReporting : mixins.isMergeReporting();\n    }\n\n    public void setMergeReporting(Boolean mergeReporting) {\n        this.mergeReporting = mergeReporting;\n    }\n\n    public boolean isMergeProperties() {\n        return mergeProperties != null ? mergeProperties : mixins.isMergeProperties();\n    }\n\n    public void setMergeProperties(Boolean mergeProperties) {\n        this.mergeProperties", "first_line_groundtruth": "null ? mergePlugins : mixins.isMergePlugins();", "first_line_prediction": " null ? mergePlugins : mixins.isMergePlugins();", "match": 0}
{"groundtruth": "null ? mergeDistributionManagement : mixins.isMergeDistributionManagement();", "prediction": " null ? mergeDistributionManagement : mixins.isMergeDistributionManagement();\n    }\n\n    public void setMergeDistributionManagement(Boolean mergeDistributionManagement) {\n        this.mergeDistributionManagement = mergeDistributionManagement;\n    }\n\n    public boolean isMergeScm() {\n        return mergeScm != null ? mergeScm : mixins.isMergeScm();\n    }\n\n    public void setMergeScm(Boolean mergeScm) {\n        this.mergeScm = mergeScm;\n    }\n\n    public boolean isMergeRepositories() {\n        return mergeRepositories != null ? mergeRepositories : mixins.isMergeRepositories();\n    }\n\n    public void", "first_line_groundtruth": "null ? mergeDistributionManagement : mixins.isMergeDistributionManagement();", "first_line_prediction": " null ? mergeDistributionManagement : mixins.isMergeDistributionManagement();", "match": 0}
{"groundtruth": "!= null ? activateProfiles : mixins.isActivateProfiles();", "prediction": " != null ? activateProfiles : mixins.isActivateProfiles();\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void execute(MavenSession session, MavenProject project) throws MavenExecutionException {\n        if (isActivateProfiles()) {\n            Model model = project.getModel();\n            model.setProfiles(session.getProfiles());\n        }\n        if (isMergePlugin", "first_line_groundtruth": "!= null ? activateProfiles : mixins.isActivateProfiles();", "first_line_prediction": " != null ? activateProfiles : mixins.isActivateProfiles();", "match": 0}
{"groundtruth": "mixins.getDefaultMixinType();", "prediction": " mixins.getDefaultMixinType();\n        }\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getKey() {\n        if (key == null) {\n            key = groupId + \":\" + artifactId;\n        }\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void merge(Model model, MavenSession session, MavenProject project) throws MavenExecutionException {\n        if (isMergePluginManagement()) {\n            model.mergePluginManagement(project.getPluginManagement());\n        }", "first_line_groundtruth": "mixins.getDefaultMixinType();", "first_line_prediction": " mixins.getDefaultMixinType();", "match": 0}
{"groundtruth": "recurse != null ? recurse : mixins.isRecurse();", "prediction": " recurse != null ? recurse : mixins.isRecurse();\n    }\n\n    public void setRecurse(Boolean recurse) {\n        this.recurse = recurse;\n    }\n\n    public boolean isActivateProfiles() {\n        return activateProfiles != null ? activateProfiles : mixins.isActivateProfiles();\n    }\n\n    public void setActivateProfiles(Boolean activateProfiles) {\n        this.activateProfiles = activateProfiles;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n   ", "first_line_groundtruth": "recurse != null ? recurse : mixins.isRecurse();", "first_line_prediction": " recurse != null ? recurse : mixins.isRecurse();", "match": 0}
{"groundtruth": "!= null ? mergeRepositories : mixins.isMergeRepositories();", "prediction": " != null ? mergeRepositories : mixins.isMergeRepositories();\n    }\n\n    public void setMergeRepositories(Boolean mergeRepositories) {\n        this.mergeRepositories = mergeRepositories;\n    }\n\n    public boolean isMergePluginRepositories() {\n        return mergePluginRepositories != null ? mergePluginRepositories : mixins.isMergePluginRepositories();\n    }\n\n    public void setMergePluginRepositories(Boolean mergePluginRepositories) {\n        this.mergePluginRepositories = mergePluginRepositories;\n    }\n\n    public boolean isRecurse() {\n        return recurse != null ? recurse : mixins.isRecurse();\n    }\n\n    public void setRecurse(Boolean recurse)", "first_line_groundtruth": "!= null ? mergeRepositories : mixins.isMergeRepositories();", "first_line_prediction": " != null ? mergeRepositories : mixins.isMergeRepositories();", "match": 0}
{"groundtruth": "ok(eventService.getUserEvents(userId));", "prediction": "ok(eventService.getUserEvents(userId));\n        }\n        return ResponseEntity.ok(eventService.getUserEventsByRole(userId, role));\n    }\n\n    @PostMapping\n    @PreAuthorize(Constants.HAS_ROLE_CORE_AND_ABOVE)\n    public ResponseEntity<Event> createEvent(@RequestBody Event event) {\n        Event createdEvent = eventService.createEvent(event);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdEvent);\n    }\n\n    @PutMapping(\"/{eventId}\")\n    @PreAuthorize(Constants.HAS_ROLE_CORE_AND_ABOVE)\n    public ResponseEntity", "first_line_groundtruth": "ok(eventService.getUserEvents(userId));", "first_line_prediction": "ok(eventService.getUserEvents(userId));", "match": 1}
{"groundtruth": "attendanceRepository.findByUserIdAndRole(userId, role).forEach(\n                attendance -> events.add(attendance.getEvent())\n        );", "prediction": " user.get().getRoles().forEach(\n                role1 -> {\n                    if (Objects.equals(role1.getRole(), role)) {\n                        attendanceRepository.findByUserId(userId).forEach(\n                                attendance -> events.add(attendance.getEvent())\n                        );\n                    }\n                }\n         );\n        return events;\n    }\n\n    public Event createEvent(Event event) {\n        return eventRepository.save(event);\n    }\n\n    public Event updateEvent(Event event) {\n        return eventRepository.save(event);\n    }\n\n    public void deleteEvent(Integer eventId) {\n        eventRepository.deleteById(", "first_line_groundtruth": "attendanceRepository.findByUserIdAndRole(userId, role).forEach(", "first_line_prediction": " user.get().getRoles().forEach(", "match": 0}
{"groundtruth": "eventService.getSingleEvent(eventId);", "prediction": " eventService.getSingleEvent(eventId);\n        return ResponseEntity.ok(event);\n    }\n\n    @PostMapping\n    @PreAuthorize(Constants.HAS_ROLE_CORE_AND_ABOVE)\n    public ResponseEntity<Event> createEvent(@RequestBody Event event) {\n        // TODO : Return pageable response\n        Event createdEvent = eventService.createEvent(event);\n        return ResponseEntity.ok(createdEvent);\n    }\n\n    @PutMapping(\"/{eventId}\")\n    @PreAuthorize(Constants.HAS_ROLE_CORE_AND_ABOVE)\n    public ResponseEntity<Event> updateEvent(@RequestBody Event updatedEvent,", "first_line_groundtruth": "eventService.getSingleEvent(eventId);", "first_line_prediction": " eventService.getSingleEvent(eventId);", "match": 0}
{"groundtruth": "String username = jwtService.extractUsername(jwtToken);", "prediction": " UserDetails userDetails = userService.loadUserByUsername(jwtService.getUsernameFromToken(jwtToken));\n        if(userDetails == null) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(\n                userDetails, null, userDetails.getAuthorities()\n        );\n        authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        filterChain.doFilter(request, response);\n    }", "first_line_groundtruth": "String username = jwtService.extractUsername(jwtToken);", "first_line_prediction": " UserDetails userDetails = userService.loadUserByUsername(jwtService.getUsernameFromToken(jwtToken));", "match": 0}
{"groundtruth": "attendanceRepository.findByUserId(userId).forEach(\n                attendance -> events.add(attendance.getEvent())\n        );", "prediction": " Optional<User> user = userRepository.findById(userId);\n         if (user.isEmpty()) {\n             throw new AcmException(\"User doesn't not exist with id :\" + userId, HttpStatus.NOT_FOUND);\n         }\n         user.get().getEvents().forEach(events::add);\n         return events;\n    }\n\n    public List<Event> getUserEventsByRole(Integer userId, String role) {\n        List<Event> events = new ArrayList<>();\n        Optional<User> user = userRepository.findById(userId);\n        if (user.isEmpty()) {\n            throw new AcmException(\"User doesn't not", "first_line_groundtruth": "attendanceRepository.findByUserId(userId).forEach(", "first_line_prediction": " Optional<User> user = userRepository.findById(userId);", "match": 0}
{"groundtruth": "return this.pizzaRepository.findAllByAvailableTrueAndDescriptionContainingIgnoreCase(ingredient);", "prediction": " return this.pizzaRepository.findAllByAvailableTrueAndIngredientsContainingIgnoreCase(ingredient);\n    }\n\n    public List<PizzaEntity> getWithout(String ingredient) {\n        return this.pizzaRepository.findAllByAvailableTrueAndIngredientsNotContainingIgnoreCase(ingredient);\n    }\n\n    public List<PizzaEntity> getCheapestPizzas(double price) {\n        return this.pizzaRepository.findTop3ByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);\n    }\n\n    public PizzaEntity add(PizzaEntity pizza) {\n        return this.pizzaRepository.save(", "first_line_groundtruth": "return this.pizzaRepository.findAllByAvailableTrueAndDescriptionContainingIgnoreCase(ingredient);", "first_line_prediction": " return this.pizzaRepository.findAllByAvailableTrueAndIngredientsContainingIgnoreCase(ingredient);", "match": 0}
{"groundtruth": ".orderRepository.findCustomerOrders(idCustomer);", "prediction": ".orderRepository.findCustomerOrders(idCustomer);\n    }\n\n    @Transactional\n    public OrderEntity save(OrderEntity order) {\n        return this.orderRepository.save(order);\n    }\n\n    public OrderSummary getSummary(int id) {\n        OrderEntity order = this.orderRepository.findById(id).orElseThrow(() -> new RuntimeException(\"La orden no existe\"));\n        return new OrderSummary(order);\n    }\n\n    public RandomOrderDto getRandomOrder() {\n        RandomOrderDto randomOrderDto = new RandomOrderDto();\n        randomOrderDto.setMethod(ON_SITE);\n        randomOrderDto.setP", "first_line_groundtruth": ".orderRepository.findCustomerOrders(idCustomer);", "first_line_prediction": ".orderRepository.findCustomerOrders(idCustomer);", "match": 1}
{"groundtruth": "this.pizzaRepository.findTop3ByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "prediction": " this.pizzaRepository.findAllByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);\n    }\n\n    public PizzaEntity add(PizzaEntity pizza) {\n        return this.pizzaRepository.save(pizza);\n    }\n\n    public PizzaEntity update(PizzaEntity pizza) {\n        return this.pizzaRepository.save(pizza);\n    }\n\n    public void delete(Long id) {\n        this.pizzaRepository.deleteById(id);\n    }\n\n    public void updatePrice(UpdatePizzaPriceDto updatePizzaPriceDto) {\n        PizzaEntity pizza = this.p", "first_line_groundtruth": "this.pizzaRepository.findTop3ByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "first_line_prediction": " this.pizzaRepository.findAllByAvailableTrueAndPriceLessThanEqualOrderByPriceAsc(price);", "match": 0}
{"groundtruth": "this.orderService.getCustomerOrders(id));", "prediction": "this.orderService.getOutsideOrders(id));\n    }\n\n    @GetMapping(\"/summary\")\n    public ResponseEntity<List<OrderSummary>> getSummary() {\n        return ResponseEntity.ok(this.orderService.getSummary());\n    }\n\n    @PostMapping\n    public ResponseEntity<OrderEntity> add(@RequestBody RandomOrderDto randomOrderDto) {\n        return ResponseEntity.ok(this.orderService.add(randomOrderDto));\n    }", "first_line_groundtruth": "this.orderService.getCustomerOrders(id));", "first_line_prediction": "this.orderService.getOutsideOrders(id));", "match": 0}
{"groundtruth": "loader.mergeMixins();", "prediction": " loader.load();\n        }\n    }", "first_line_groundtruth": "loader.mergeMixins();", "first_line_prediction": " loader.load();", "match": 0}
{"groundtruth": "!= null && !encryptor.isEncrypted(propValue)) {", "prediction": " != null && encryptor.isEncrypted(propValue)) {\n\t\t\t\tpropValue = encryptor.decrypt(propValue).toString();\n\t\t\t}", "first_line_groundtruth": "!= null && !encryptor.isEncrypted(propValue)) {", "first_line_prediction": " != null && encryptor.isEncrypted(propValue)) {", "match": 0}
{"groundtruth": "mDiracSound.getMusic() == 1;", "prediction": " mDiracSound.isEnabled();\n    }\n\n    public void setScenario(int scenario) {\n        mDiracSound.setScenario(scenario);\n    }\n\n    public void setPreset(int preset) {\n        mDiracSound.setPreset(preset);\n    }\n\n    public void setHeadsetType(int type) {\n        mDiracSound.setHeadsetType(type);\n    }\n\n    public void setLevel(int band, float level) {\n        mDiracSound.setLevel(band, level);\n    }\n\n    public void setMusic(int music) {\n        mDiracSound.setMusic(music);", "first_line_groundtruth": "mDiracSound.getMusic() == 1;", "first_line_prediction": " mDiracSound.isEnabled();", "match": 0}
{"groundtruth": "return customerRepository.findCustomerByName(name);", "prediction": " return customerRepository.findCustomerByName(name);\n    }\n\n    public List<Customer> findCustomerByPhone(String phone) {\n        return customerRepository.findCustomerByPhone(phone);\n    }", "first_line_groundtruth": "return customerRepository.findCustomerByName(name);", "first_line_prediction": " return customerRepository.findCustomerByName(name);", "match": 0}
{"groundtruth": "encryptor.decrypt(encryptedValue).toString();", "prediction": " encryptor.decrypt(encryptedValue);\n    }\n\n    private static boolean isTransformationAnnotated(Field field) {\n        return field.isAnnotationPresent(Transformation.class);\n    }\n\n    private static boolean isTypeAnnotated(Field field) {\n        return field.isAnnotationPresent(Encrypted.class);\n    }\n\n    private static boolean isCollectionParameter(Parameter parameter) {\n        return parameter.name().equals(COLLECTION);\n    }\n\n    private static Transformation getTransformationField(Field field) {\n        return field.getAnnotation(Transformation.class);\n    }\n\n    private static Transformation getTransformationField(Field field, Transformation transformationAnnotation) {\n        return", "first_line_groundtruth": "encryptor.decrypt(encryptedValue).toString();", "first_line_prediction": " encryptor.decrypt(encryptedValue);", "match": 0}
{"groundtruth": "= encryptor.decrypt(value).toString();", "prediction": " = encryptor.decrypt(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t} catch (ApiException e) {\n\t\t\tthrow new HibernateException(e);\n\t\t}", "first_line_groundtruth": "= encryptor.decrypt(value).toString();", "first_line_prediction": " = encryptor.decrypt(value);", "match": 0}
{"groundtruth": "return getFriendlyString().compareTo(o.getFriendlyString());", "prediction": " return version.compareTo(o.getFriendlyString());\n    }", "first_line_groundtruth": "return getFriendlyString().compareTo(o.getFriendlyString());", "first_line_prediction": " return version.compareTo(o.getFriendlyString());", "match": 0}
{"groundtruth": "mod.getMetadata().getId() + \"->\" + value;", "prediction": " \"OldEntry{\" +\n                    \"mod=\" + mod +\n                    \", value='\" + value + '\\'' +\n                    '}';\n        }\n\n        @Override\n        public ModContainer getModContainer() {\n            return mod;\n        }\n\n        @Override\n        public <T> T getOrCreate(Class<T> type) throws Exception {\n            if (object == null) {\n                object = mod.getMetadata().getAdapter().getAdapter().create(type, value);\n            }\n            return type.cast(object);\n        }\n\n        @Override\n        public boolean isOptional() {\n            return false;\n        }\n    }\n\n    private static class NewEntry implements", "first_line_groundtruth": "mod.getMetadata().getId() + \"->\" + value;", "first_line_prediction": " \"OldEntry{\" +", "match": 0}
{"groundtruth": "if (encryptor.isEncrypted(value)) {", "prediction": "", "first_line_groundtruth": "if (encryptor.isEncrypted(value)) {", "first_line_prediction": "", "match": 0}
{"groundtruth": "return VersionParser.parseSemantic(s);", "prediction": " return VersionParser.parseSemantic(s);\n    }", "first_line_groundtruth": "return VersionParser.parseSemantic(s);", "first_line_prediction": " return VersionParser.parseSemantic(s);", "match": 0}
{"groundtruth": "return o.hasWildcard() ? 0 : -1;", "prediction": " return -1;\n             } else {\n                 return 1;\n             }\n        }\n\n        Optional<String> buildA = getBuildKey();\n        Optional<String> buildB = o.getBuildKey();\n\n        if (buildA.isPresent() || buildB.isPresent()) {\n            if (buildA.isPresent() && buildB.isPresent()) {\n                StringTokenizer buildATokenizer = new StringTokenizer(buildA.get(), \".\");\n                StringTokenizer buildBTokenizer = new StringTokenizer(buildB.get(), \".\");\n\n                while (buildATokenizer.hasMoreElements()) {\n                    if (buildBTokenizer.hasMore", "first_line_groundtruth": "return o.hasWildcard() ? 0 : -1;", "first_line_prediction": " return -1;", "match": 0}
{"groundtruth": "String name = wrapper.getName();", "prediction": " classTable.put(wrapper.getSimpleName(), wrapper);\n        }\n    }\n\n    public T get(String name) {\n        return classTable.get(name);\n    }\n\n    public List<String> getChildren(String name) {\n        return pointerTable.getOrDefault(name, new ArrayList<>());\n    }\n\n    public boolean isPackage(String name) {\n        return name.contains(\"/\");\n    }\n\n    public boolean isClass(String name) {\n        return !isPackage(name);\n    }\n\n    public List<String> getAbsoluteParents() {\n        return pointerTable.keySet();\n    }", "first_line_groundtruth": "String name = wrapper.getName();", "first_line_prediction": " classTable.put(wrapper.getSimpleName(), wrapper);", "match": 0}
{"groundtruth": "return VersionParser.parse(string, false);", "prediction": " return VersionParser.parse(string);\n    }", "first_line_groundtruth": "return VersionParser.parse(string, false);", "first_line_prediction": " return VersionParser.parse(string);", "match": 0}
{"groundtruth": "().getMetadata().getId(), ex);", "prediction": "().getMetadata().getId(), ex);\n            }\n        }\n        return instance;\n    }\n\n    @Override\n    public ModContainer getProvider() {\n        return entry.getModContainer();\n    }\n\n    @Override\n    public String toString() {\n        return entry.toString();\n    }", "first_line_groundtruth": "().getMetadata().getId(), ex);", "first_line_prediction": "().getMetadata().getId(), ex);", "match": 1}
{"groundtruth": "exception = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);", "prediction": " exception = new EntrypointException(t);\n                }\n\n                exception.addEntry(entry);\n            }\n        }\n\n        if (exception != null) {\n            throw exception;\n        }\n\n        return results;\n    }\n\n    public <T> T getEntrypoint(String key, Class<T> type) {\n        List<Entry> entries = entryMap.get(key);\n        if (entries == null) return null;\n\n        for (Entry entry : entries) {\n            try {\n                T result = entry.getOrCreate(type);\n\n                if (result != null) {\n                    return result;\n                }\n            } catch (", "first_line_groundtruth": "exception = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);", "first_line_prediction": " exception = new EntrypointException(t);", "match": 0}
{"groundtruth": "(ForgePatch.getGameDir());", "prediction": "(new File(System.getProperty(\"user.dir\")));\n    }\n\n    public static FabricLoaderImpl InitHelper() {\n        return INSTANCE;\n    }\n\n    public static FabricLoaderImpl InitHelper(File gameDir) {\n        return new FabricLoaderImpl(gameDir);\n    }\n\n    public static FabricLoaderImpl InitHelper(Path gameDir) {\n        return new FabricLoaderImpl(gameDir);\n    }\n\n    public static FabricLoaderImpl InitHelper(Path gameDir, Path configDir) {\n        return new FabricLoaderImpl(gameDir, configDir);\n    }\n\n    public static FabricLoaderImpl InitHelper(File gameDir,", "first_line_groundtruth": "(ForgePatch.getGameDir());", "first_line_prediction": "(new File(System.getProperty(\"user.dir\")));", "match": 0}
{"groundtruth": "userDAO.getById(id);", "prediction": " userDAO.getById(id);\n    }\n\n    @Override\n    public void add(BotUser user) {\n        userDAO.save(user);\n    }\n\n    @Override\n    public void update(BotUser user) {\n        userDAO.update(user);\n    }\n\n    @Override\n    public void delete(BotUser user) {\n        userDAO.delete(user);\n    }\n\n    @Override\n    public void deleteAll() {\n        userDAO.deleteAll();\n    }", "first_line_groundtruth": "userDAO.getById(id);", "first_line_prediction": " userDAO.getById(id);", "match": 0}
{"groundtruth": "parent.getVersionComponentCount();", "prediction": "0;\n    }\n\n    @Override\n    public int getVersionComponent(int index) {\n        return 0;\n    }\n\n    @Override\n    public String getFriendlyName() {\n        return null;\n    }\n\n    @Override\n    public Optional<String> getBuild() {\n        return Optional.empty();\n    }\n\n    @Override\n    public boolean isSnapshot() {\n        return false;\n    }\n\n    @Override\n    public boolean isRelease() {\n        return false;\n    }\n\n    @Override\n    public boolean isCompatible(Version version) {\n        return false;\n    }\n\n    @Override\n    public boolean isCompatible(SemanticVersion version) {", "first_line_groundtruth": "parent.getVersionComponentCount();", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "userDAO.getCount();", "prediction": " userDAO.getCount();\n    }", "first_line_groundtruth": "userDAO.getCount();", "first_line_prediction": " userDAO.getCount();", "match": 0}
{"groundtruth": "parent = SemanticVersion.parse(version);", "prediction": " this(version, storeX, null);\n    }\n\n    public SemanticVersionImpl(String version, boolean storeX, String prerelease) throws VersionParsingException {\n        if (version == null || version.isEmpty()) {\n            throw new VersionParsingException(\"Version must be a non-empty string!\");\n        }\n\n        int buildDelimPos = version.indexOf('+');\n        if (buildDelimPos >= 0) {\n            build = version.substring(buildDelimPos + 1);\n            version = version.substring(0, buildDelimPos);\n        } else {\n            build = null;\n        }\n        int dashDelimPos", "first_line_groundtruth": "parent = SemanticVersion.parse(version);", "first_line_prediction": " this(version, storeX, null);", "match": 0}
{"groundtruth": "userDAO.getByName(name);", "prediction": " userDAO.getByName(name);\n    }\n\n    @Override\n    public long getUserCount() {\n        return userDAO.getCount();\n    }", "first_line_groundtruth": "userDAO.getByName(name);", "first_line_prediction": " userDAO.getByName(name);", "match": 0}
{"groundtruth": "documentDAO.getCount();", "prediction": "0;\n    }", "first_line_groundtruth": "documentDAO.getCount();", "first_line_prediction": "0;", "match": 0}
{"groundtruth": "return mod.getMetadata().getId() + \"->(0.3.x)\" + value;", "prediction": " return mod.getMetadata().getId() + \"->\" + value;\n        }\n\n        @SuppressWarnings({ \"unchecked\" })\n        @Override\n        public synchronized <T> T getOrCreate(Class<T> type) throws Exception {\n            if (instanceMap.containsKey(type)) {\n                return (T) instanceMap.get(type);\n            } else {\n                T instance = type.cast(mod.getEntrypoint(value).getOrCreate(type));\n                instanceMap.put(type, instance);\n                return instance;\n            }\n        }\n\n        @Override\n        public boolean isOptional() {\n            return false;\n        }\n\n        @", "first_line_groundtruth": "return mod.getMetadata().getId() + \"->(0.3.x)\" + value;", "first_line_prediction": " return mod.getMetadata().getId() + \"->\" + value;", "match": 0}
{"groundtruth": "controllerInfo.getMethod();", "prediction": " controllerInfo.getMethod();\n                PsiUtilBase.ensureValid(targetMethod);\n                targetMethod.navigate(true);\n                // \u5b9a\u4f4d\u5230\u5bf9\u5e94\u7684\u884c\n                int lineNumber = targetMethod.getTextRange().getStartOffset() + controllerInfo.getLineNumber();\n                Editor editor = JavaSourceFileUtil.getEditor(file);\n                editor.getCaretModel().moveToOffset(lineNumber);\n                editor.getScrollingModel().scrollToCaret(ScrollType.CENTER_UP);\n            }\n        }\n    }\n\n    private boolean isMatched(ControllerInfo info, String searchText) {\n        return info.getMethodName().contains(searchText);\n   ", "first_line_groundtruth": "controllerInfo.getMethod();", "first_line_prediction": " controllerInfo.getMethod();", "match": 0}
{"groundtruth": "if(controllerInfo.getRequestMethod().toLowerCase().contains(lowerCase)){", "prediction": " return controllerInfo.getControllerName().toLowerCase().contains(lowerCase) ||\n                 controllerInfo.getMethodName().toLowerCase().contains(lowerCase);\n    }", "first_line_groundtruth": "if(controllerInfo.getRequestMethod().toLowerCase().contains(lowerCase)){", "first_line_prediction": " return controllerInfo.getControllerName().toLowerCase().contains(lowerCase) ||", "match": 0}
{"groundtruth": "if(controllerInfo.getPath().toLowerCase().contains(lowerCase)){", "prediction": " return controllerInfo.getControllerName().toLowerCase().contains(lowerCase);\n    }", "first_line_groundtruth": "if(controllerInfo.getPath().toLowerCase().contains(lowerCase)){", "first_line_prediction": " return controllerInfo.getControllerName().toLowerCase().contains(lowerCase);", "match": 0}
{"groundtruth": "getSwaggerInfo() != null && controllerInfo.getSwaggerInfo().toLowerCase().contains(lowerCase)){", "prediction": "getControllerClass().toLowerCase().contains(lowerCase)){\n            return true;\n        }\n        return false;\n    }", "first_line_groundtruth": "getSwaggerInfo() != null && controllerInfo.getSwaggerInfo().toLowerCase().contains(lowerCase)){", "first_line_prediction": "getControllerClass().toLowerCase().contains(lowerCase)){", "match": 0}
{"groundtruth": "() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){", "prediction": "() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){\n            return true;\n        }\n        return false;\n    }", "first_line_groundtruth": "() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){", "first_line_prediction": "() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){", "match": 1}
{"groundtruth": "controllerInfo.getSwaggerNotes() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){", "prediction": "controllerInfo.getRemarks() != null && controllerInfo.getRemarks().toLowerCase().contains(lowerCase)){\n            return true;\n        }\n        return false;\n    }", "first_line_groundtruth": "controllerInfo.getSwaggerNotes() != null && controllerInfo.getSwaggerNotes().toLowerCase().contains(lowerCase)){", "first_line_prediction": "controllerInfo.getRemarks() != null && controllerInfo.getRemarks().toLowerCase().contains(lowerCase)){", "match": 0}
{"groundtruth": "= controllerInfo.getMethod().getContainingFile();", "prediction": " = controllerInfo.getPsiFile();\n        if (file instanceof PsiJavaFile) {\n            PsiClass psiClass = ((PsiJavaFile) file).getClasses()[0];\n            PsiMethod[] methods = psiClass.findMethodsByName(controllerInfo.getMethodName(), false);\n            if (methods.length > 0) {\n                PsiMethod method = methods[0];\n                Editor editor = PsiUtilBase.findEditor(method);\n                if (editor != null) {\n                    editor.getCaretModel().moveToOffset(method.getTextOffset());\n                    editor.getScrollingModel().scrollToCaret(ScrollType.CENTER_", "first_line_groundtruth": "= controllerInfo.getMethod().getContainingFile();", "first_line_prediction": " = controllerInfo.getPsiFile();", "match": 0}
{"groundtruth": "(feignInfo.getMethod());", "prediction": "(feignInfo.getMethod());\n                }\n            }\n        }\n        return elementList;\n    }\n\n    /**\n     * \u5339\u914d\u65b9\u6cd5\n     *\n     * @param feignInfo feign\u4fe1\u606f\n     * @param controllerMethod controller\u65b9\u6cd5\n     * @return boolean\n     */\n    private boolean isMethodMatch(ControllerInfo feignInfo, PsiMethod controllerMethod) {\n        String controllerMethodName = controllerMethod.getName();\n        String feignMethodName = feignInfo.getMethod().getName();\n        return StringUtils.equals(controllerMethodName, feignMethodName);\n    }\n\n    /**\n     * \u5224\u65ad\u662f\u5426\u5728controller\u4e2d\n     *\n     * @param element", "first_line_groundtruth": "(feignInfo.getMethod());", "first_line_prediction": "(feignInfo.getMethod());", "match": 1}
{"groundtruth": "if(controllerInfo.getSwaggerInfo() != null && controllerInfo.getSwaggerInfo().toLowerCase().contains(lowerCase)){", "prediction": " return false;\n    }", "first_line_groundtruth": "if(controllerInfo.getSwaggerInfo() != null && controllerInfo.getSwaggerInfo().toLowerCase().contains(lowerCase)){", "first_line_prediction": " return false;", "match": 0}
{"groundtruth": "relocation.getPattern(),\n                        relocation.getRelocatedPattern(),\n                        relocation.getIncludes(),\n                        relocation.getExcludes()\n                ));", "prediction": " relocation.getOldName(),\n                         relocation.getNewName(),\n                         relocation.getRepositories(),\n                         relocation.getRelocations()\n                ));\n            }\n\n            final Object jarRelocator = this.jarRelocatorConstructor.newInstance(\n                    in.toFile(),\n                    out.toFile(),\n                    rules\n            );\n\n            this.jarRelocatorRunMethod.invoke(jarRelocator);\n        } catch (final ReflectiveOperationException e) {\n            throw new RuntimeException(e);\n        }\n    }", "first_line_groundtruth": "relocation.getPattern(),", "first_line_prediction": " relocation.getOldName(),", "match": 0}
{"groundtruth": "relocation.getIncludes(),\n                        relocation.getExcludes()\n                ));", "prediction": "0,\n                        0\n                ));\n            }\n\n            final Object jarRelocator = this.jarRelocatorConstructor.newInstance(\n                    in.toFile(),\n                    out.toFile(),\n                    rules\n            );\n\n            this.jarRelocatorRunMethod.invoke(jarRelocator);\n        } catch (final ReflectiveOperationException e) {\n            throw new RuntimeException(e);\n        }\n    }", "first_line_groundtruth": "relocation.getIncludes(),", "first_line_prediction": "0,", "match": 0}
{"groundtruth": "relocation.getRelocatedPattern(),\n                        relocation.getIncludes(),\n                        relocation.getExcludes()\n                ));", "prediction": " relocation.getReplacement(),\n                         relocation.getRepositories(),\n                         relocation.getRelocations()\n                ));\n            }\n\n            final Object jarRelocator = this.jarRelocatorConstructor.newInstance(\n                    in.toFile(),\n                    out.toFile(),\n                    rules\n            );\n\n            this.jarRelocatorRunMethod.invoke(jarRelocator);\n        } catch (final ReflectiveOperationException e) {\n            throw new RuntimeException(e);\n        }\n    }", "first_line_groundtruth": "relocation.getRelocatedPattern(),", "first_line_prediction": " relocation.getReplacement(),", "match": 0}
{"groundtruth": "database.getConnection().close();", "prediction": " // Closing server socket\n            serverSocket.close();\n            System.out.println(\"Server stopped!\");\n        }\n    }", "first_line_groundtruth": "database.getConnection().close();", "first_line_prediction": " // Closing server socket", "match": 0}
{"groundtruth": "genre.setTitle(resultSet.getString(\"title\"));", "prediction": " genre.setId(resultSet.getInt(\"id\"));\n             genre.setTitle(resultSet.getString(\"title\"));\n             genre.setDescription(resultSet.getString(\"description\"));\n        }\n\n        return genre;\n    }\n\n    public List<Genre> getAllGenres() throws SQLException {\n        String query = \"SELECT * FROM genres\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        ResultSet resultSet = statement.executeQuery();\n\n        List<Genre> genres = new ArrayList<>();\n\n        while(resultSet.next()){\n            Genre genre = new Genre();\n            genre.setId(resultSet.getInt(\"id\"));\n            genre.setTitle(resultSet", "first_line_groundtruth": "genre.setTitle(resultSet.getString(\"title\"));", "first_line_prediction": " genre.setId(resultSet.getInt(\"id\"));", "match": 0}
{"groundtruth": "genre.setId(resultSet.getInt(\"id\"));", "prediction": " return genre;\n        }\n        return null;\n    }\n\n    public List<Genre> getAllGenres() throws SQLException {\n        String query = \"SELECT * FROM genres\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        ResultSet res = statement.executeQuery();\n\n        List<Genre> genres = new ArrayList<>();\n\n        while(res.next()){\n            Genre genre = new Genre();\n            genre.setTitle(res.getString(\"title\"));\n            genre.setDescription(res.getString(\"description\"));\n            genre.setId(res.getInt(\"id\"));\n            genres.add(genre);\n        }\n        return gen", "first_line_groundtruth": "genre.setId(resultSet.getInt(\"id\"));", "first_line_prediction": " return genre;", "match": 0}
{"groundtruth": "comment.setText(res.getString(\"text\"));", "prediction": " comment.setId(res.getInt(\"id\"));\n             comment.setText(res.getString(\"text\"));\n             comment.setUser(res.getInt(\"user\"));\n             comment.setMusic(res.getInt(\"music\"));\n             comments.add(comment);\n        }\n        return comments;\n    }\n\n    public void deleteComment(int commentId) throws SQLException {\n        String query = \"DELETE FROM comments WHERE id=?\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        statement.setInt(1, commentId);\n\n        statement.executeUpdate();\n    }", "first_line_groundtruth": "comment.setText(res.getString(\"text\"));", "first_line_prediction": " comment.setId(res.getInt(\"id\"));", "match": 0}
{"groundtruth": "comment.setId(res.getInt(\"id\"));", "prediction": " comments.add(comment);\n        }\n\n        return comments;\n    }\n\n    public void deleteComment(int commentId) throws SQLException {\n        String query = \"DELETE FROM comments WHERE id=?\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        statement.setInt(1, commentId);\n\n        statement.executeUpdate();\n    }", "first_line_groundtruth": "comment.setId(res.getInt(\"id\"));", "first_line_prediction": " comments.add(comment);", "match": 0}
{"groundtruth": "playlist.setUser(res.getInt(\"user\"));", "prediction": " playlist.setDescription(res.getString(\"description\"));\n            playlist.setUser(res.getInt(\"user\"));\n            playlist.setPublic(res.getBoolean(\"is_public\"));\n            playlists.add(playlist);\n        }\n        return playlists;\n    }\n\n    public void addMusicToPlaylist(int playlistId, int musicId) throws SQLException {\n        String query = \"INSERT INTO playlist_musics (playlist, music) VALUES (?,?)\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        statement.setInt(1, playlistId);\n        statement.setInt(2, musicId);\n\n        statement.executeUpdate", "first_line_groundtruth": "playlist.setUser(res.getInt(\"user\"));", "first_line_prediction": " playlist.setDescription(res.getString(\"description\"));", "match": 0}
{"groundtruth": "playlist.setPublic(res.getBoolean(\"is_public\"));", "prediction": " playlist.setPublic(res.getBoolean(\"is_public\"));\n            playlists.add(playlist);\n        }\n\n        return playlists;\n    }\n\n    public void addMusicToPlaylist(int playlistId, int musicId) throws SQLException {\n        String query = \"INSERT INTO playlist_musics (playlist, music) VALUES (?,?)\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        statement.setInt(1, playlistId);\n        statement.setInt(2, musicId);\n\n        statement.executeUpdate();\n    }\n\n    public List<Music> getMusicsOfPlaylist(int playlistId) throws SQLException", "first_line_groundtruth": "playlist.setPublic(res.getBoolean(\"is_public\"));", "first_line_prediction": " playlist.setPublic(res.getBoolean(\"is_public\"));", "match": 0}
{"groundtruth": "String json = request.getJson();", "prediction": " Response response = new Response();\n         response.setStatusCode(401);\n         response.setMessage(\"You are not authorized to perform this action!\");\n         return response;\n    }\n\n    public Response createNewArtist(Request request){\n        Response response = new Response();\n        response.setStatusCode(401);\n        response.setMessage(\"You are not authorized to perform this action!\");\n        return response;\n    }\n\n    public Response login(Request request){\n        Response response = new Response();\n        response.setStatusCode(401);\n        response.setMessage(\"You are not authorized to perform this action!\");\n        return response;\n    }", "first_line_groundtruth": "String json = request.getJson();", "first_line_prediction": " Response response = new Response();", "match": 0}
{"groundtruth": ".setArtistObj(crudArtist.getArtistById(music.getArtist()));", "prediction": ".setArtist(crudArtist.getArtistById(music.getArtist()));\n\n            CrudAlbum crudAlbum = new CrudAlbum(database);\n            music.setAlbum(crudAlbum.getAlbumById(music.getAlbum()));\n\n            return music;\n        }\n        return null;\n    }\n\n    public List<Music> getMusicsByArtist(int artistId) throws SQLException {\n        String query = \"SELECT * FROM musics WHERE artist=?\";\n\n        PreparedStatement statement = database.getConnection().prepareStatement(query);\n        statement.setInt(1,artistId);\n        ResultSet res = statement.executeQuery();\n\n        List<", "first_line_groundtruth": ".setArtistObj(crudArtist.getArtistById(music.getArtist()));", "first_line_prediction": ".setArtist(crudArtist.getArtistById(music.getArtist()));", "match": 0}
{"groundtruth": "response.setMessage(\"Username already exists!\");", "prediction": " response.setMessage(\"Username already exists!\");\n                 response.setStatusCode(400);\n            }\n            else {\n                user.setRole(\"user\");\n                user.setPassword(BCrypt.hashpw(user.getPassword(), BCrypt.gensalt()));\n                crudUser.createUser(user);\n                response.setMessage(\"User created!\");\n                response.setStatusCode(200);\n            }\n        } catch (SQLException e) {\n            response.setMessage(\"Error in creating user!\");\n            response.setStatusCode(500);\n        }\n\n        return response;\n    }\n\n    public Response createNewArtist(Request request){", "first_line_groundtruth": "response.setMessage(\"Username already exists!\");", "first_line_prediction": " response.setMessage(\"Username already exists!\");", "match": 0}
{"groundtruth": "String command = request.getCommand();", "prediction": " // the below code fragment can be found in:\n         // src/main/java/com/ap/spotify/client/controllers/MusicView.java\n         //             File file = new File( \"src/main/resources/com/ap/spotify/downloads/\" + music.getTitle() + \".mp3\");\n         //             try {\n         //                 FileOutputStream fos = new FileOutputStream(file);\n         //                 fos.write(bytes);\n         //                 fos.close();\n         //                 System.out.println(\"downloaded music successfully\");\n         //             } catch (IOException e) {\n         //                 e", "first_line_groundtruth": "String command = request.getCommand();", "first_line_prediction": " // the below code fragment can be found in:", "match": 0}
{"groundtruth": "a.getVariable());", "prediction": " a.getValue()).toLowerCase();\n            String stringB = ((String)  b.getValue()).toLowerCase();\n\n            return stringA + stringB;\n        }\n\n        if (a.isBoolean() && b.isBoolean()) {\n            Boolean booleanA = (Boolean) a.getValue();\n            Boolean booleanB = (Boolean) b.getValue();\n\n            return booleanA.booleanValue() && booleanB.booleanValue();\n        }\n\n        if (a.isBoolean() && b.isNumber()) {\n            Boolean booleanA = (Boolean) a.getValue();\n            Number numberB = b.toNumber();\n\n            return booleanA.", "first_line_groundtruth": "a.getVariable());", "first_line_prediction": " a.getValue()).toLowerCase();", "match": 0}
{"groundtruth": "(buffer.asInputStream())\n                .build()\n            );", "prediction": "(buffer.toString())\n                     .headers(headers)\n                     .build()\n            );\n        }\n    }", "first_line_groundtruth": "(buffer.asInputStream())", "first_line_prediction": "(buffer.toString())", "match": 0}
{"groundtruth": "response.setStatusCode(201);", "prediction": " response.setStatusCode(201);\n            }\n        } catch (SQLException e) {\n            response.setMessage(\"Error in creating user!\");\n            response.setStatusCode(500);\n        }\n        return response;\n    }\n\n    public Response createNewArtist(Request request){\n        String json = request.getJson();\n        Gson gson = new Gson();\n        Artist artist = gson.fromJson(json, Artist.class);\n        CrudUser crudUser = new CrudUser(database);\n        CrudArtist crudArtist = new CrudArtist(database);\n        Response response = new Response();\n\n        try {\n           ", "first_line_groundtruth": "response.setStatusCode(201);", "first_line_prediction": " response.setStatusCode(201);", "match": 0}
{"groundtruth": "a.isString() && b.isString()) {", "prediction": "a.isString() && b.isString()) {\n            return a.toString() + b.toString();\n        }\n\n        if (a.isBoolean() && b.isBoolean()) {\n            return a.toBoolean() + b.toBoolean();\n        }\n\n        if (a.isList() && b.isList()) {\n            return a.toList() + b.toList();\n        }\n\n        if (a.isMap() && b.isMap()) {\n            return a.toMap() + b.toMap();\n        }\n\n        if (a.isMap() && b.isList()) {\n            return a.", "first_line_groundtruth": "a.isString() && b.isString()) {", "first_line_prediction": "a.isString() && b.isString()) {", "match": 1}
{"groundtruth": "loggedInAccount = gson.fromJson(response.getJson(), Artist.class);", "prediction": " role = \"artist\";\n                }\n            }\n            else if(crudUser.doesUserExist(account.getUsername())){\n                response = crudUser.login(account.getUsername(), account.getPassword());\n                if(response.getStatusCode() == 200){\n                    isLoggedIn = true;\n                    role = \"user\";\n                }\n            }\n            else{\n                response.setMessage(\"Username does not exist!\");\n                response.setStatusCode(400);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n            response.setMessage(\"Error while logging in!\");\n            System.out.println(response.getMessage", "first_line_groundtruth": "loggedInAccount = gson.fromJson(response.getJson(), Artist.class);", "first_line_prediction": " role = \"artist\";", "match": 0}
{"groundtruth": "(a.isString() && b.isString()) {", "prediction": " (a.isString() && b.isString()) {\n            return a.toString() + b.toString();\n        }\n\n        if (a.isBoolean() && b.isBoolean()) {\n            return a.toBoolean() + b.toBoolean();\n        }\n\n        if (a.isList() && b.isList()) {\n            return a.toList() + b.toList();\n        }\n\n        if (a.isMap() && b.isMap()) {\n            return a.toMap() + b.toMap();\n        }\n\n        if (a.isMap() && b.isList()) {\n            return a", "first_line_groundtruth": "(a.isString() && b.isString()) {", "first_line_prediction": " (a.isString() && b.isString()) {", "match": 0}
{"groundtruth": "response.setMessage(\"Error while creating the user!\");", "prediction": " response.setMessage(\"Error in creating user!\");\n             response.setStatusCode(500);\n        }\n        return response;\n    }\n\n    public Response createNewArtist(Request request){\n        String json = request.getJson();\n        Gson gson = new Gson();\n        Artist artist = gson.fromJson(json, Artist.class);\n        CrudUser crudUser = new CrudUser(database);\n        CrudArtist crudArtist = new CrudArtist(database);\n        Response response = new Response();\n\n        try {\n            if(crudArtist.doesArtistExist(artist.getUsername()) || crudUser.doesUser", "first_line_groundtruth": "response.setMessage(\"Error while creating the user!\");", "first_line_prediction": " response.setMessage(\"Error in creating user!\");", "match": 0}
{"groundtruth": "[i] = new Token(tokenMethod.getMethod().process(a));", "prediction": "[i] = new Token(method.process(a));\n                }\n                continue;\n            }\n            if (token instanceof TokenString) {\n                TokenString tokenString = (TokenString) token;\n                resultTokens[i] = tokenString;\n            }\n        }\n\n        for (int i = 0; i < resultTokens.length; i++) {\n            if (resultTokens[i] == null) {\n                resultTokens[i] = new TokenString(\"\");\n            }\n        }\n\n        return resultTokens;\n    }\n\n    private List<Instruction> getInstructions(List<Token> tokens) {\n        List<Instruction", "first_line_groundtruth": "[i] = new Token(tokenMethod.getMethod().process(a));", "first_line_prediction": "[i] = new Token(method.process(a));", "match": 0}
{"groundtruth": "((TokenMethod) token).getMethod());", "prediction": "methods.get(token.getVariable().toString()));\n            }\n        }\n        return operators;\n    }\n\n    private int getHighPriority(List<Instruction> operators) {\n        int maxPriority = 0;\n        for (Instruction instruction : operators) {\n            if (instruction.getPriority() > maxPriority) {\n                maxPriority = instruction.getPriority();\n            }\n        }\n        return maxPriority;\n    }\n\n    private List<Token> tokenize(String input) {\n        List<Token> tokens = new ArrayList<>();\n        for (String token : input.split(\" \")) {\n            tokens.add(new TokenString(", "first_line_groundtruth": "((TokenMethod) token).getMethod());", "first_line_prediction": "methods.get(token.getVariable().toString()));", "match": 0}
{"groundtruth": ".setAttribute(\"user_reg\", teacher.getName());", "prediction": ".setAttribute(\"user_mail\", mail);\n\t\t\tresp.sendRedirect(\"teacher_dashboard.jsp\");\n\t\t} else {\n\t\t\tsession.setAttribute(\"errorMsg\", \"invalid email & password\");\n\t\t\tresp.sendRedirect(\"teacher_login.jsp\");\n\t\t}", "first_line_groundtruth": ".setAttribute(\"user_reg\", teacher.getName());", "first_line_prediction": ".setAttribute(\"user_mail\", mail);", "match": 0}
{"groundtruth": "(response.getStatusCode() == 200) {", "prediction": " (response.getStatusCode() == 200){\n            System.out.println(response.getMessage());\n            if(response.getMessage().equals(\"Success\")){\n                StaticData.currentUser = gson.fromJson(response.getJson(), User.class);\n                StaticData.currentUser.setUsername(username);\n                StaticData.currentUser.setPassword(password);\n                StaticData.currentUser.setToken(response.getToken());\n                StaticData.currentUser.setTokenExpiration(response.getTokenExpiration());\n                StaticData.currentUser.setRefreshToken(response.getRefreshToken());\n                StaticData.currentUser.setRefreshTokenExpiration(response.", "first_line_groundtruth": "(response.getStatusCode() == 200) {", "first_line_prediction": " (response.getStatusCode() == 200){", "match": 0}
{"groundtruth": "album.setReleaseDate(new java.sql.Date(new java.util.Date().getTime()));", "prediction": " FileChooser fileChooser = new FileChooser();\n         fileChooser.setTitle(\"Select a file\");\n         File file = fileChooser.showOpenDialog(new Stage());\n         if(file != null){\n             album.setCoverPicPath(file.getAbsolutePath());\n             Request request = new Request(\"addAlbum\");\n             request.setJson(new Gson().toJson(album));\n             try {\n                 StaticData.objOut.writeObject(request);\n                 StaticData.objOut.flush();\n                 Response response = (Response) StaticData.objIn.readObject();\n                 System.out.println(response.getMessage());\n                 if", "first_line_groundtruth": "album.setReleaseDate(new java.sql.Date(new java.util.Date().getTime()));", "first_line_prediction": " FileChooser fileChooser = new FileChooser();", "match": 0}
{"groundtruth": "u.setName(rs.getString(3));", "prediction": "", "first_line_groundtruth": "u.setName(rs.getString(3));", "first_line_prediction": "", "match": 0}
{"groundtruth": ".setText(String.valueOf(album.getArtist()));", "prediction": ".setText(album.getArtist());\n        dateTxt.setText(album.getDate());\n        popularityTxt.setText(String.valueOf(album.getPopularity()));\n        pathTxt.setText(album.getPath());\n        genreCombo.getItems().addAll(album.getGenres());\n        genreCombo.setValue(album.getGenre());\n        coverImg.setImage(new Image(album.getPath()));\n    }\n\n    public void saveAlbum() {\n        Request request = new Request(\"editAlbum\");\n        request.setJson(new Gson().toJson(album));\n        try {\n            StaticData.objOut.writeObject(", "first_line_groundtruth": ".setText(String.valueOf(album.getArtist()));", "first_line_prediction": ".setText(album.getArtist());", "match": 0}
{"groundtruth": "u.setPassword(rs.getString(4));", "prediction": "", "first_line_groundtruth": "u.setPassword(rs.getString(4));", "first_line_prediction": "", "match": 0}
{"groundtruth": "genre.getId() == albumId){", "prediction": "genre.getId() == album.getGenre()){\n                        albumGenre = genre;\n                    }\n                }\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void save(){\n        Request request = new Request(\"editAlbum\");\n        request.setJson(new Gson().toJson(album));\n        try {\n            StaticData.objOut.writeObject(request);\n            StaticData.objOut.flush();\n            Response response = (Response) StaticData.objIn.readObject();\n            System.out.println(response.getMessage());\n            if(response.", "first_line_groundtruth": "genre.getId() == albumId){", "first_line_prediction": "genre.getId() == album.getGenre()){", "match": 0}
{"groundtruth": "u.setMail(rs.getString(1));", "prediction": "\tu.setMail(rs.getString(1));\n\t\t\t\t\tu.setPassword(rs.getString(2));\n\t\t\t\t\tu.setFullname(rs.getString(3));\n\t\t\t\t\tu.setReg(rs.getString(4));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn u;", "first_line_groundtruth": "u.setMail(rs.getString(1));", "first_line_prediction": "\tu.setMail(rs.getString(1));", "match": 0}
{"groundtruth": "u.setPass(rs.getString(2));", "prediction": "\tu.setPassword(rs.getString(2));\n\t\t\t\t\tu.setFullname(rs.getString(3));\n\t\t\t\t\tu.setReg(rs.getString(4));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn u;", "first_line_groundtruth": "u.setPass(rs.getString(2));", "first_line_prediction": "\tu.setPassword(rs.getString(2));", "match": 0}
{"groundtruth": "u.setReg(rs.getString(3));", "prediction": "\tu.setReg(rs.getString(2));\n\t\t\t\t\tu.setPassword(rs.getString(3));\n\t\t\t}", "first_line_groundtruth": "u.setReg(rs.getString(3));", "first_line_prediction": "\tu.setReg(rs.getString(2));", "match": 0}
{"groundtruth": "return reduce.get(0).getVariable();", "prediction": " return reduce.get(0).getVariable();\n        }\n        return process(reduce, operators);\n    }\n\n    private List<Token> reduce(Token[] tokens) {\n        List<Token> result = new ArrayList<>();\n        for (Token token : tokens) {\n            if (token != null) {\n                result.add(token);\n            }\n        }\n        return result;\n    }\n\n    private List<Instruction> getInstructions(List<Token> tokens) {\n        List<Instruction> result = new ArrayList<>();\n        for (Token token : tokens) {\n            if (token instanceof TokenOperator) {\n                TokenOperator tokenOperator", "first_line_groundtruth": "return reduce.get(0).getVariable();", "first_line_prediction": " return reduce.get(0).getVariable();", "match": 0}
{"groundtruth": "u.setFullname(rs.getString(1));", "prediction": "\tu.setReg(rs.getString(1));\n\t\t\t\t\tu.setPassword(rs.getString(2));\n\t\t\t\t\tu.setFullname(rs.getString(3));\n\t\t\t}", "first_line_groundtruth": "u.setFullname(rs.getString(1));", "first_line_prediction": "\tu.setReg(rs.getString(1));", "match": 0}
{"groundtruth": "genre.getId() == music.getGenre()){", "prediction": "genre.getId() == music.getGenreId()){\n                        musicGenre = genre;\n                    }\n                }\n                genreMenu.getSelectionModel().select(musicGenre);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n\n        Request request2 = new Request(\"getAlbums\");\n        try {\n            StaticData.objOut.writeObject(request2);\n            StaticData.objOut.flush();\n            Response response2 = (Response) StaticData.objIn.readObject();\n            System.out.println(response2.getMessage());\n            if(response2.getStatusCode", "first_line_groundtruth": "genre.getId() == music.getGenre()){", "first_line_prediction": "genre.getId() == music.getGenreId()){", "match": 0}
{"groundtruth": "Operator operator = tokenOperator.getOperation();", "prediction": " if (tokenOperator.getOperation().getPriority() <= maxPriority) {\n                     resultTokens[i] = new TokenString(tokenOperator.getOperation().getName());\n                 }\n            }\n        }\n\n        for (int i = 0; i < operators.size(); i++) {\n            Instruction instruction = operators.get(i);\n            if (instruction instanceof InstructionOperator) {\n                InstructionOperator instructionOperator = (InstructionOperator) instruction;\n                if (instructionOperator.getOperator().getPriority() <= maxPriority) {\n                    resultTokens[i] = new TokenString(instructionOperator.getOperator().getName());\n                }", "first_line_groundtruth": "Operator operator = tokenOperator.getOperation();", "first_line_prediction": " if (tokenOperator.getOperation().getPriority() <= maxPriority) {", "match": 0}
{"groundtruth": "Token(operator.getName() + resultTokens[i + 1].getVariable());", "prediction": " TokenString(\"null\");\n                    continue;\n                }\n                Token b = getSafeToken(resultTokens, i + 1);\n                if (b == null) {\n                    setSafeToken(resultTokens, i, null);\n                    resultTokens[i - 1] = new  TokenString(\"null\");\n                    continue;\n                }\n                if (operator.validate(a, b)) {\n                    setSafeToken(resultTokens, i, null);\n                    resultTokens[i - 1] = new  TokenString(\"null\");\n                    resultTokens[i + 1] = new  TokenString(\"null\");\n                    continue", "first_line_groundtruth": "Token(operator.getName() + resultTokens[i + 1].getVariable());", "first_line_prediction": " TokenString(\"null\");", "match": 0}
{"groundtruth": "= new Token(operator.getName() + resultTokens[i + 1].getVariable());", "prediction": " = new Token(operator.getName() + resultTokens[i + 1].getVariable());\n                    continue;\n                }\n\n                Token b = getSafeToken(resultTokens, i + 1);\n                if (b == null) {\n                    setSafeToken(resultTokens, i, null);\n                    resultTokens[i - 1] = new Token(operator.getName() + resultTokens[i - 1].getVariable());\n                    continue;\n                }\n\n                if (b instanceof TokenOperator) {\n                    setSafeToken(resultTokens, i, null);\n                    setSafeToken(resultTokens, i + 1", "first_line_groundtruth": "= new Token(operator.getName() + resultTokens[i + 1].getVariable());", "first_line_prediction": " = new Token(operator.getName() + resultTokens[i + 1].getVariable());", "match": 0}
{"groundtruth": "a.getVariable().toString().isEmpty()) {", "prediction": " !(a instanceof TokenMethod)) {\n                    setSafeToken(resultTokens, i, null);\n                    setSafeToken(resultTokens, i - 1, null);\n                    resultTokens[i + 1] = new Token(operator.getName() + resultTokens[i + 1].getVariable());\n                    continue;\n                }\n\n                Token b = getSafeToken(resultTokens, i + 1);\n                if (b == null) {\n                    setSafeToken(resultTokens, i, null);\n                    resultTokens[i + 1] = new Token(operator.getName() + resultTokens[i + ", "first_line_groundtruth": "a.getVariable().toString().isEmpty()) {", "first_line_prediction": " !(a instanceof TokenMethod)) {", "match": 0}
{"groundtruth": "album.getId() == music.getArtist()){", "prediction": "album.getId() == music.getAlbum()){\n                        musicAlbum = album;\n                    }\n                }\n\n                albumMenu.setValue(musicAlbum);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void saveMusic(ActionEvent event) {\n        if(titleTxt.getText().isEmpty()){\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setTitle(\"Error\");\n            alert.setHeaderText(\"Please enter a title\");\n            alert.showAndWait();\n            return;\n        }\n\n        if(pathTxt.getText().isEmpty()){\n           ", "first_line_groundtruth": "album.getId() == music.getArtist()){", "first_line_prediction": "album.getId() == music.getAlbum()){", "match": 0}
{"groundtruth": "(album.getId() == music.getArtist()){", "prediction": "(album.getId() == music.getAlbum()){\n                        musicAlbum = album;\n                    }\n                }\n\n                albumMenu.setValue(musicAlbum);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void saveMusic(ActionEvent event) {\n        if(titleTxt.getText().isEmpty()){\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setTitle(\"Error\");\n            alert.setHeaderText(\"Please enter a title\");\n            alert.showAndWait();\n            return;\n        }\n\n        if(pathTxt.getText().isEmpty()){", "first_line_groundtruth": "(album.getId() == music.getArtist()){", "first_line_prediction": "(album.getId() == music.getAlbum()){", "match": 0}
{"groundtruth": "playlistName.setText(playlist.getTitle());", "prediction": " for(int i = 0; i < musics.size(); i++){\n                     Music music = new Gson().fromJson(new Gson().toJson(musics.get(i)), Music.class);\n                     musicsList.add(music.getId());\n                 }\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n\n        for(int i = 0; i < musicsList.size(); i++){\n            String musicId = musicsList.get(i);\n            Request request1 = new Request(\"viewMusic\");\n            request1.setJson(new", "first_line_groundtruth": "playlistName.setText(playlist.getTitle());", "first_line_prediction": " for(int i = 0; i < musics.size(); i++){", "match": 0}
{"groundtruth": "final GptTurboModel model = GptTurboDto.convertToGptTurboModel(dto);", "prediction": " List<GptTurboModel.Messages> messages = chatServiceimpl.completions(dto);\n            return Result.data(messages);\n        } catch (Exception e) {\n            log.error(\"GPT-Turbo 3.5 \u63a5\u53e3\u8c03\u7528\u5931\u8d25\", e);\n            return Result.error(\"GPT-Turbo 3.5 \u63a5\u53e3\u8c03\u7528\u5931\u8d25\", 500);\n        }\n    }", "first_line_groundtruth": "final GptTurboModel model = GptTurboDto.convertToGptTurboModel(dto);", "first_line_prediction": " List<GptTurboModel.Messages> messages = chatServiceimpl.completions(dto);", "match": 0}
{"groundtruth": "(genre.getId() == music.getGenre()){", "prediction": "(genre.getId() == music.getGenreId()){\n                        musicGenre = genre;\n                    }\n                }\n                genreMenu.getSelectionModel().select(musicGenre);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n\n        Request request2 = new Request(\"getAlbums\");\n        try {\n            StaticData.objOut.writeObject(request2);\n            StaticData.objOut.flush();\n            Response response2 = (Response) StaticData.objIn.readObject();\n            System.out.println(response2.getMessage());\n            if(response2.", "first_line_groundtruth": "(genre.getId() == music.getGenre()){", "first_line_prediction": "(genre.getId() == music.getGenreId()){", "match": 0}
{"groundtruth": "() + \"_\" + getIdentityResolver().getIdentityKey(), getConfiguration());", "prediction": "(), getConfiguration());\n    }", "first_line_groundtruth": "() + \"_\" + getIdentityResolver().getIdentityKey(), getConfiguration());", "first_line_prediction": "(), getConfiguration());", "match": 0}
{"groundtruth": "el.getTypename();", "prediction": " el.getType();\n            var id = el.getId();\n            var entity = new JsonObject();\n            entity.addProperty(\"type\", type);\n            entity.addProperty(\"id\", id);\n            entities.getAsJsonArray().add(entity);\n        }\n\n        json.add(\"query\", body.getQuery());\n        json.add(\"variables\", variables);\n        json.add(\"operationName\", body.getOperationName());\n        json.add(\"entities\", entities);\n\n        var document = new Parser().parseDocument(json.toString());\n        var operationDefinition = document.getDefinitions().get(0);\n        var operationName = operationDefinition.", "first_line_groundtruth": "el.getTypename();", "first_line_prediction": " el.getType();", "match": 0}
{"groundtruth": "dslParser.parse(arrangement);", "prediction": " dslParser.parse(arrangement);\n    }\n\n    public TransferableTask<?> getTask(String name) {\n        return TASKS.get(name);\n    }\n\n    public TaskPushDownTable getPushDownTable() {\n        return PUSH_DOWN_TABLE;\n    }", "first_line_groundtruth": "dslParser.parse(arrangement);", "first_line_prediction": " dslParser.parse(arrangement);", "match": 0}
{"groundtruth": "body.getVariables().getRepresentations();", "prediction": " new ArrayList<RepresentationsItem>();\n        for (Map.Entry<String, Object> entry : variables.entrySet()) {\n            list.add(new RepresentationsItem(entry.getKey(), entry.getValue()));\n        }\n\n        var document = new Document();\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(new ArrayList<>());\n        document.setDefinitions(", "first_line_groundtruth": "body.getVariables().getRepresentations();", "first_line_prediction": " new ArrayList<RepresentationsItem>();", "match": 0}
{"groundtruth": "query = body.getQuery().replaceFirst(\".+?\\\\)\", \"\");", "prediction": "ql = body.getQuery();\n        var variables = body.getVariables();\n        var operationName = body.getOperationName();\n\n        Document document = new Parser().parseDocument(ql);\n        Map<String, Object> variablesMap = new HashMap<>();\n        if (variables != null) {\n            variablesMap = variables.getVariables();\n        }\n\n        List<OperationDefinition> operationDefinitions = document.getDefinitionsOfType(OperationDefinition.class);\n        if (operationDefinitions.size() != 1) {\n            throw new RuntimeException(\"Invalid graphql query\");\n        }\n\n        OperationDefinition operationDefinition = operationDefinitions.get(0);\n       ", "first_line_groundtruth": "query = body.getQuery().replaceFirst(\".+?\\\\)\", \"\");", "first_line_prediction": "ql = body.getQuery();", "match": 0}
{"groundtruth": "response.getJson(), Music.class);", "prediction": "response.getJson(), Music.class);\n            musicTitleLbl.setText(music.getTitle());\n            musicTimeline.setProgress(0);\n            musicTimeline.setMin(0);\n            musicTimeline.setMax(music.getDuration());\n            musicTimeline.setShowTickLabels(true);\n            musicTimeline.setShowTickMarks(true);\n            musicTimeline.setMajorTickUnit(1000);\n            musicTimeline.setMinorTickCount(0);\n            musicTimeline.setBlockIncrement(1000);\n            musicTimeline.setSnapToTicks(true);\n            musicTimeline.setShowTickLabels", "first_line_groundtruth": "response.getJson(), Music.class);", "first_line_prediction": "response.getJson(), Music.class);", "match": 1}
{"groundtruth": "int status = ProcessUtils.runAndWait(cmd, tempDir);", "prediction": "\n\n            ProcessUtils.runAndWait(cmd, tempDir, new StdListener() {\n                @Override\n                public void onReceive(String value) {\n                    System.out.print(value);\n                }\n            });\n\n            FileUtils.delete(installerFile);\n            FileUtils.delete(tempDir);\n        }\n    }", "first_line_groundtruth": "int status = ProcessUtils.runAndWait(cmd, tempDir);", "first_line_prediction": "", "match": 0}
{"groundtruth": "System.out.println(\"test\" + response.getMessage());", "prediction": " music = new Gson().fromJson(response.getJson(), Music.class);\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException(e);\n            }\n\n            try {\n                String musicFile = \"src/main/resources/com/ap/spotify/downloads/\" + musics.get(songIndex);\n                sound = new Media(new File(musicFile).toURI().toString());\n            }\n            catch (Exception e){\n                download();\n                String musicFile = \"src/main/resources/com/ap/spotify/downloads/\" + musics.get(songIndex);\n                sound =", "first_line_groundtruth": "System.out.println(\"test\" + response.getMessage());", "first_line_prediction": " music = new Gson().fromJson(response.getJson(), Music.class);", "match": 0}
{"groundtruth": "FileUtils.writeFile(new File(cwd, \"eula.txt\"), \"eula=true\");", "prediction": " cmd += \" -eula\";\n        }\n\n        if (this.software.getConsole()) {\n            cmd += \" -console\";\n        }\n\n        return ProcessUtils.runAndWait(cmd, cwd, listener);\n    }", "first_line_groundtruth": "FileUtils.writeFile(new File(cwd, \"eula.txt\"), \"eula=true\");", "first_line_prediction": " cmd += \" -eula\";", "match": 0}
{"groundtruth": "setHeaderText(response1.getMessage());", "prediction": "setHeaderText(response1.getMessage());\n                            alert.show();\n                        } catch (IOException | ClassNotFoundException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                });\n                addToPlaylistVbox.getChildren().add(button);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void putMusic(Music music){\n        musicName.setText(music.getName());\n        artist.setText(music.getArtist());\n        genre.setText(music.getGenre());\n        date.setText(music.getDate());\n        popularity.setText(String", "first_line_groundtruth": "setHeaderText(response1.getMessage());", "first_line_prediction": "setHeaderText(response1.getMessage());", "match": 1}
{"groundtruth": "Logger.info(\"Process exited with code: \" + exitCode);", "prediction": " if (exitCode != 0) {\n                 Logger.crit(\"Server exited with code \" + exitCode);\n             } else {\n                 Logger.info(\"Server exited with code \" + exitCode);\n             }\n            return exitCode;\n        } catch (MCDException e) {\n            Logger.crit(e.getMessage());\n            return 1;\n        }\n    }", "first_line_groundtruth": "Logger.info(\"Process exited with code: \" + exitCode);", "first_line_prediction": " if (exitCode != 0) {", "match": 0}
{"groundtruth": "(album.getCoverPicPath() != null) {", "prediction": " (album.getCoverPicPath() != null) {\n                        try {\n                            albumCover = new ImageView(Test.class.getResource(\"cloud/\").toExternalForm() + album.getCoverPicPath());\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    albumCover.setFitHeight(110);\n                    albumCover.setPreserveRatio(false);\n                    albumCover.setFitWidth(130);\n                    albumCover.setFitHeight(130);\n\n                    Label title = new Label(album.getTitle());\n                    title.setPrefWidth(Double.MAX_", "first_line_groundtruth": "(album.getCoverPicPath() != null) {", "first_line_prediction": " (album.getCoverPicPath() != null) {", "match": 0}
{"groundtruth": "setNumero(endereco.getNumero());", "prediction": "setCep(endereco.getCep());\n        enderecoSalvo.setNumero(endereco.getNumero());\n        enderecoSalvo.setBairro(endereco.getBairro());\n        enderecoSalvo.setCidade(endereco.getCidade());\n        enderecoSalvo.setUf(endereco.getUf());\n        enderecoSalvo.setComplemento(endereco.getComplemento());\n    }\n\n    public void removerEndereco(UUID uuid) {\n        if(!enderecoMap.containsKey(uuid)) {\n           ", "first_line_groundtruth": "setNumero(endereco.getNumero());", "first_line_prediction": "setCep(endereco.getCep());", "match": 0}
{"groundtruth": "endereco = modelMapper.getMapper().map(enderecoForm, Endereco.class);", "prediction": " endereco = modelMapper.getMapper().map(enderecoForm, Endereco.class);\n        enderecoRepository.save(endereco);\n\n        return ResponseEntity.ok().body(endereco);\n    }\n\n    private List<String> validar(EnderecoForm enderecoForm) {\n        List<String> errors = new ArrayList<>();\n\n        Set<ConstraintViolation<EnderecoForm>> violations = validator.validate(enderecoForm);\n\n        violations.forEach(violation -> {\n            String fieldName = violation.getPropertyPath().toString();\n            String errorMessage = violation.getMessage();\n\n            errors.add", "first_line_groundtruth": "endereco = modelMapper.getMapper().map(enderecoForm, Endereco.class);", "first_line_prediction": " endereco = modelMapper.getMapper().map(enderecoForm, Endereco.class);", "match": 0}
{"groundtruth": "setComplemento(endereco.getComplemento());", "prediction": "setBairro(endereco.getBairro());\n        enderecoSalvo.setCidade(endereco.getCidade());\n        enderecoSalvo.setUf(endereco.getUf());\n        enderecoSalvo.setComplemento(endereco.getComplemento());\n        enderecoMap.put(uuid, enderecoSalvo);\n    }\n\n    public void removerEndereco(UUID uuid) {\n        if(!enderecoMap.containsKey(uuid)) {\n            throw new EnderecoNaoEncontradoException(String.format(\"Endere\u00e7o", "first_line_groundtruth": "setComplemento(endereco.getComplemento());", "first_line_prediction": "setBairro(endereco.getBairro());", "match": 0}
{"groundtruth": "DownloadUtils.download(this.url, finalFile, ignoreExist);", "prediction": " if (finalFile.exists() && !ignoreExist) {\n            return;\n        } else {\n            DownloadUtils.download(this.url, finalFile, ignoreExist);\n        }\n    }\n\n    public void install(File directory, StdListener listener) throws IOException {\n        File finalFile = new File(directory, this.getJARName());\n        if (finalFile.exists()) {\n            ProcessUtils.run(this.software.getInstaller().getCommand(), finalFile, listener);\n        } else {\n            throw new IOException(\"File \" + finalFile.getAbsolutePath() + \" does not exist!\");\n        }\n    }", "first_line_groundtruth": "DownloadUtils.download(this.url, finalFile, ignoreExist);", "first_line_prediction": " if (finalFile.exists() && !ignoreExist) {", "match": 0}
{"groundtruth": "FileUtils.deleteRecursive(tempDir);", "prediction": " FileUtils.deleteRecursive(tempDir);\n        }\n    }", "first_line_groundtruth": "FileUtils.deleteRecursive(tempDir);", "first_line_prediction": " FileUtils.deleteRecursive(tempDir);", "match": 0}
{"groundtruth": "installerFile = DownloadUtils.downloadTemp(this.url);", "prediction": "uberJar = installer.getJAR();\n            File jar = new File(options.cwd, uberJar.getName());\n            FileUtils.copy(uberJar, jar);\n            ProcessUtils.run(options.cwd, \"java\", \"-jar\", jar.getAbsolutePath(), \"-install\", this.version);\n        }\n    }\n\n    public void uninstall(RunOptions options) throws IOException, InterruptedException {\n        ProcessUtils.run(options.cwd, \"java\", \"-jar\", this.getJARName(), \"-uninstall\", this.version);\n    }\n\n    public void run(RunOptions options) throws IOException, InterruptedException {\n        ProcessUtils", "first_line_groundtruth": "installerFile = DownloadUtils.downloadTemp(this.url);", "first_line_prediction": "uberJar = installer.getJAR();", "match": 0}
{"groundtruth": "FileUtils.writeFile(new File(options.cwd, \".mcdeploy\"), this.getJARName());", "prediction": " if (options.eula) {\n             String eula = this.software.getEULA();\n             if (eula != null) {\n                 File eulaFile = new File(options.cwd, eula);\n                 FileUtils.moveAll(eulaFile, options.cwd);\n             }\n         }\n    }", "first_line_groundtruth": "FileUtils.writeFile(new File(options.cwd, \".mcdeploy\"), this.getJARName());", "first_line_prediction": " if (options.eula) {", "match": 0}
{"groundtruth": "FileUtils.readFile(dotMCDFile);", "prediction": " dotMCDFile.exists() ? FileUtils.readFile(dotMCDFile) : \"\";\n        }\n        if (this.file != null && !this.file.isEmpty()) {\n            options.setFile(this.file);\n        }\n\n        if (this.console) {\n            options.setConsole(true);\n        }\n\n        try {\n            Logger.info(\"Fetching for versions...\");\n            mcd.prepare();\n            Logger.info(\"Preparing for download artifact: \" + options.file);\n            mcd.install(options);\n            Logger.info(\"Installed successfully.\");\n        } catch (MCDException e)", "first_line_groundtruth": "FileUtils.readFile(dotMCDFile);", "first_line_prediction": " dotMCDFile.exists() ? FileUtils.readFile(dotMCDFile) : \"\";", "match": 0}
{"groundtruth": "modelMapper.getMapper().map(enderecoForm, Endereco.class);", "prediction": " enderecoRepository.getEnderecoPorUUID(uuid);\n        endereco = modelMapper.getMapper().map(enderecoForm, Endereco.class);\n        endereco = enderecoRepository.salvarEndereco(endereco);\n        return ResponseEntity.ok().body(endereco);\n    }\n\n    @Operation(summary = \"Excluir endere\u00e7o\", description = \"Excluir endere\u00e7o\", tags = { \"Endere\u00e7o\" })\n    @ApiResponses(value = {\n            @ApiResponse(responseCode = \"200\", description = \"Sucesso\", content = @Content),", "first_line_groundtruth": "modelMapper.getMapper().map(enderecoForm, Endereco.class);", "first_line_prediction": " enderecoRepository.getEnderecoPorUUID(uuid);", "match": 0}
{"groundtruth": "DebugChannel channel = Preconditions.checkNonNull(getChannel(key));", "prediction": " DebugChannel channel = getChannel(key);\n        if (channel == null) return false;\n\n        if (channel.getListeners().add(player)) {\n            player.sendMessage(debugMessage.replaceText(\n                    TextReplacementConfig.builder()\n                            .match(\"%channel%\")\n                            .replacement(channel.getFriendlyName())\n                            .build()\n            ));\n            return true;\n        }\n        return false;\n    }", "first_line_groundtruth": "DebugChannel channel = Preconditions.checkNonNull(getChannel(key));", "first_line_prediction": " DebugChannel channel = getChannel(key);", "match": 0}
{"groundtruth": "List<Endereco> enderecoPelosCEP = enderecoRepository.getEnderecosPeloCEP(cep);", "prediction": " Optional<Endereco> endereco = enderecoRepository.findByCep(cep);", "first_line_groundtruth": "List<Endereco> enderecoPelosCEP = enderecoRepository.getEnderecosPeloCEP(cep);", "first_line_prediction": " Optional<Endereco> endereco = enderecoRepository.findByCep(cep);", "match": 0}
{"groundtruth": "listaEnderecos = enderecoRepository.getEnderecoList();", "prediction": " enderecos = enderecoRepository.getEnderecoList();\n        return ResponseEntity.ok().body(enderecos);\n    }\n\n    private List<String> validar(Object object) {\n        Set<ConstraintViolation<Object>> violations = validator.validate(object);\n        return violations.stream()\n                .map(ConstraintViolation::getMessage)\n                .collect(Collectors.toList());\n    }", "first_line_groundtruth": "listaEnderecos = enderecoRepository.getEnderecoList();", "first_line_prediction": " enderecos = enderecoRepository.getEnderecoList();", "match": 0}
{"groundtruth": "return R.error(\"\u672a\u77e5\u9519\u8bef\");", "prediction": " return R.success(res);\n    }", "first_line_groundtruth": "return R.error(\"\u672a\u77e5\u9519\u8bef\");", "first_line_prediction": " return R.success(res);", "match": 0}
{"groundtruth": ").put(\"name\", source.name()).put(\"version\", source.version()));", "prediction": "\n                \"name\", source.name(), \"version\", source.version(), \"pkgManager\", source.pkgManager()));\n  }\n\n  private ObjectNode createNode(PackageRef source, Set<com.redhat.exhort.api.PackageRef> allDeps) {\n    ObjectNode node = mapper.createObjectNode();\n    node.put(\"id\", getId(source));\n    node.set(\n        \"info\",\n        mapper.createObjectNode(\n            \"name\", source.name(), \"version\", source.version(), \"pkgManager\", source.pkgManager()));\n    node.set(\"dependencies\", addDependencies(source, all", "first_line_groundtruth": ").put(\"name\", source.name()).put(\"version\", source.version()));", "first_line_prediction": "", "match": 0}
{"groundtruth": ").purl().getType());", "prediction": "0).getPurl());\n        }\n      }\n      return DependencyTree.builder().root(root).dependencies(deps).build();\n    } catch (InvalidSPDXAnalysisException | IOException e) {\n      LOGGER.error(\"Error parsing SPDX document\", e);\n      throw new ClientErrorException(Response.Status.BAD_REQUEST);\n    }\n  }\n\n  private Map<PackageRef, DirectDependency> buildDeps(SpdxWrapper wrapper) {\n    Map<PackageRef, DirectDependency> deps = new HashMap<>();\n    for (SpdxPackage pkg : wrapper.getPackages()) {\n      deps.put(toPackageRef(pkg),", "first_line_groundtruth": ").purl().getType());", "first_line_prediction": "0).getPurl());", "match": 0}
{"groundtruth": "().map(v -> v.purl().getType()).distinct().toList();", "prediction": "().map(PackageRef::getType).collect(Collectors.toList());\n        if (types.contains(packageManager)) {\n          treeBuilder.root(\n              PackageRef.builder()\n                   .purl(bom.getComponents().get(0).getPurl())\n                   .type(packageManager)\n                   .build());\n        }\n      }\n      if (bom.getComponents() != null) {\n        bom.getComponents().forEach(c -> {\n          if (c.getDependencies() != null) {\n            c.getDependencies().forEach(d -> {\n              if (d.getPurl() != null) {\n               ", "first_line_groundtruth": "().map(v -> v.purl().getType()).distinct().toList();", "first_line_prediction": "().map(PackageRef::getType).collect(Collectors.toList());", "match": 0}
{"groundtruth": "severity(SeverityUtils.fromScore(score));", "prediction": "unique(Boolean.TRUE);\n  }", "first_line_groundtruth": "severity(SeverityUtils.fromScore(score));", "first_line_prediction": "unique(Boolean.TRUE);", "match": 0}
{"groundtruth": "tree.root(), allDeps);", "prediction": "allDeps);\n    depGraph.set(\"root\", rootNode);\n    return rootNode;\n  }\n\n  private ObjectNode createNode(Set<com.redhat.exhort.api.PackageRef> allDeps) {\n    ObjectNode rootNode = mapper.createObjectNode();\n    ArrayNode deps = mapper.createArrayNode();\n    allDeps.stream().forEach(dep -> deps.add(dep.getCoordinates()));\n    rootNode.set(\"dependencies\", deps);\n    return rootNode;\n  }\n\n  private String toSnykPackageManager(String pkgManager) {\n    return pkgManager.equals(Constants.PACKAGE", "first_line_groundtruth": "tree.root(), allDeps);", "first_line_prediction": "allDeps);", "match": 0}
{"groundtruth": "\"/*?\" + stonecutter.currentActive() + \" {", "prediction": " \"/*?\");\n                editor.getSelectionModel().setSelection(selectionStart, selectionStart + 4);\n            });\n        }\n\n        private void clickNewElse(ActionEvent e) {\n            StackingPopupDispatcher.getInstance().closeActivePopup();\n            String selectionText = editor.getSelectionModel().getSelectedText();\n            if (selectionText == null)\n                return;\n            WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                int selectionStart = editor.getSelectionModel().getSelectionStart(),\n                        selectionEnd = editor.getSelectionModel().getSelectionEnd(),\n                        startLine = editor.getDocument().getLineNumber(selectionStart", "first_line_groundtruth": "\"/*?\" + stonecutter.currentActive() + \" {", "first_line_prediction": " \"/*?\");", "match": 0}
{"groundtruth": "(\"pkgs\", addPackages(depGraph, req.tree()));", "prediction": "(\"nodes\", mapper.valueToTree(req.tree().getAll()));\n    depGraph.set(\"edges\", mapper.valueToTree(req.tree().getEdges()));\n\n    return mapper.writeValueAsString(depGraph);\n  }\n\n  public String fromPackageRefs(Set<PackageRef> packages) throws JsonProcessingException {\n    ArrayNode coordinates = mapper.createArrayNode();\n    packages.stream()\n        .map(PackageRef::purl)\n        .filter(Objects::nonNull)\n        .forEach(purl -> coordinates.add(purl.getCoordinates()));\n    ObjectNode root = mapper.createObjectNode().set(\"", "first_line_groundtruth": "(\"pkgs\", addPackages(depGraph, req.tree()));", "first_line_prediction": "(\"nodes\", mapper.valueToTree(req.tree().getAll()));", "match": 0}
{"groundtruth": ").missingTokens.isEmpty() ? \"\" : stonecutter.tokenCache().missingTokens.iterator().next());", "prediction": "project).generateIdentifier());\n        tReader.setText(stonecutter.tokenCache(project).generateReader());\n        tWriter.setText(stonecutter.tokenCache(project).generateWriter());\n    }\n\n    private void initValidation() {\n        tIdentifier.addDocumentListener(e -> {\n            if (tIdentifier.getText().isBlank()) {\n                tIdentifier.setText(stonecutter.tokenCache(project).generateIdentifier());\n            }\n        });\n        tReader.addDocumentListener(e -> {\n            if (tReader.getText().isBlank()) {\n                tReader.setText(stonecutter.tokenCache", "first_line_groundtruth": ").missingTokens.isEmpty() ? \"\" : stonecutter.tokenCache().missingTokens.iterator().next());", "first_line_prediction": "project).generateIdentifier());", "match": 0}
{"groundtruth": "().add(createPkg(tree.root()));", "prediction": "();\n    allDeps.stream().forEach(pkg -> pkgs.add(createNode(pkg, allDeps)));\n    depGraph.set(\"pkgs\", pkgs);\n    return nodes;\n  }\n\n  private ObjectNode createNode(com.redhat.exhort.api.PackageRef pkg, Set<com.redhat.exhort.api.PackageRef> allDeps) {\n    ObjectNode node = mapper.createObjectNode();\n    node.put(\"name\", pkg.name());\n    node.put(\"version\", pkg.version());\n    node.put(\"type\", pkg.type());\n    node.put(\"pkgManager", "first_line_groundtruth": "().add(createPkg(tree.root()));", "first_line_prediction": "();", "match": 0}
{"groundtruth": "c -> PackageRef.builder().purl(c.getPurl()).build())));", "prediction": " c -> new PackageRef(c.getBomRef().getType(), c.getBomRef().getName(), c.getBomRef().getVersion()))));\n      }\n      Map<String, Set<String>> links = new HashMap<>();\n      if (bom.getComponents() != null) {\n        bom.getComponents().stream()\n             .filter(c -> c.getDependencies() != null)\n             .forEach(c -> {\n               c.getDependencies().stream()\n                    .filter(d -> d.getRef() != null)\n                    .forEach(d -> {\n                      String ref = d.getRef().getType", "first_line_groundtruth": "c -> PackageRef.builder().purl(c.getPurl()).build())));", "first_line_prediction": " c -> new PackageRef(c.getBomRef().getType(), c.getBomRef().getName(), c.getBomRef().getVersion()))));", "match": 0}
{"groundtruth": "&& !req.tree().getAll().isEmpty();", "prediction": " && req.tree().dependencies() != null && !req.tree().dependencies().isEmpty();\n  }\n\n  public String buildRequest(GraphRequest req) throws JsonProcessingException {\n    ObjectNode depGraph = mapper.createObjectNode();\n    depGraph.put(\"schemaVersion\", \"1.2.0\");\n    depGraph.set(\n         \"pkgManager\",\n         mapper.createObjectNode().put(\"name\", toOssIndexPackageManager(req.pkgManager())));\n\n    ArrayNode nodes = mapper.createArrayNode();\n    ArrayNode pkgs = mapper.createArrayNode();\n    req.tree().dependencies().values().stream", "first_line_groundtruth": "&& !req.tree().getAll().isEmpty();", "first_line_prediction": " && req.tree().dependencies() != null && !req.tree().dependencies().isEmpty();", "match": 0}
{"groundtruth": "ref.name()).append(\"@\").append(ref.version()).toString();", "prediction": "Constants.PACKAGE_PREFIX)\n        .append(ref.name())\n        .append(Constants.PACKAGE_VERSION_SEPARATOR)\n        .append(ref.version())\n        .toString();\n  }\n\n  private String toSnykPackageManager(String pkgManager) {\n    return pkgManager.toLowerCase();\n  }", "first_line_groundtruth": "ref.name()).append(\"@\").append(ref.version()).toString();", "first_line_prediction": "Constants.PACKAGE_PREFIX)", "match": 0}
{"groundtruth": "stonecutter.tokenCache().tokensByVersion.get(cVersion.getSelectedItem()).values());", "prediction": "stonecutter.tokens().getTokens().values());\n            tTokens.setModel(new AbstractTableModel() {\n                @Override\n                public int getRowCount() {\n                    return loadedTokens.size();\n                }\n\n                @Override\n                public int getColumnCount() {\n                    return 2;\n                }\n\n                @Override\n                public Object getValueAt(int rowIndex, int columnIndex) {\n                    return loadedTokens.get(rowIndex).name;\n                }\n            });\n        }\n\n        private void versionChanged(ActionEvent e) {\n            WriteCommandAction.runWriteCommandAction(project, null, null, () -> {\n                stonecutter.currentActive", "first_line_groundtruth": "stonecutter.tokenCache().tokensByVersion.get(cVersion.getSelectedItem()).values());", "first_line_prediction": "stonecutter.tokens().getTokens().values());", "match": 0}
{"groundtruth": "CharUtil.isBlankChar(str.charAt(i))) {", "prediction": "Character.isWhitespace(str.charAt(i))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static boolean isNotBlank(CharSequence str) {\n        return !isBlank(str);\n    }\n\n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return ts.length() == 0 ? null : ts;\n    }\n\n    public static String trimToEmpty(String str) {\n        return str == null ? \"\" :", "first_line_groundtruth": "CharUtil.isBlankChar(str.charAt(i))) {", "first_line_prediction": "Character.isWhitespace(str.charAt(i))) {", "match": 0}
{"groundtruth": "(stonecutter.currentActive());", "prediction": "(\"Versions\");\n        bTokens.setText(\"Tokens\");\n\n        bVersions.setIcon(ICON);\n        bTokens.setIcon(ICON);\n\n        bVersions.setFocusable(false);\n        bTokens.setFocusable(false);\n\n        bVersions.setFocusable(false);\n        bTokens.setFocusable(false);\n\n        bVersions.setFocusable(false);\n        bTokens.setFocusable(false);\n\n        bVersions.setFocusable(false);\n        bTokens.setFocusable(false);\n\n        bVersions.setFocusable(false);\n        bTokens.setFocusable(false);\n\n       ", "first_line_groundtruth": "(stonecutter.currentActive());", "first_line_prediction": "(\"Versions\");", "match": 0}
{"groundtruth": "PackageRef.builder().purl(pkgRef).build();", "prediction": " mapper.readValue(pkgRef, PackageRef.class);\n            List<Issue> issues = new ArrayList<>();\n            JsonNode issuesNode = n.get(\"issues\");\n            if (issuesNode != null) {\n              issuesNode.forEach(\n                  issue -> {\n                    String issueId = issue.get(\"id\").asText();\n                    JsonNode issueData = n.get(\"issuesData\").get(issueId);\n                    JsonNode issueDataNode = issueData.get(\"data\");\n                    JsonNode issueDataNode = issueDataNode.get(\"vulnerabilities\");\n                    if (issueDataNode != null) {\n                      issueDataNode.forEach(\n                          vulnerability ->", "first_line_groundtruth": "PackageRef.builder().purl(pkgRef).build();", "first_line_prediction": " mapper.readValue(pkgRef, PackageRef.class);", "match": 0}
{"groundtruth": "(ref.name(), issues);", "prediction": "(pkgRef, issues);\n            }\n          } catch (Exception e) {\n            LOGGER.error(\"Failed to parse response: \" + pkgRef, e);\n          }\n        });\n    return reports;\n  }\n\n  private Issue toIssue(JsonNode vulnerability) {\n    String id = vulnerability.get(\"id\").asText();\n    JsonNode data = vulnerability.get(\"data\");\n    JsonNode cvss = data.get(\"cvss\");\n    String cvssScore = cvss.get(\"score\").asText();\n    String cvssVector = cvss.get(\"vector\").asText();\n    String cvssVectorString = C", "first_line_groundtruth": "(ref.name(), issues);", "first_line_prediction": "(pkgRef, issues);", "match": 0}
{"groundtruth": "(moduleByRoot.get((setup.gradleProject().getChildProjects().get(version)).getProjectDir()), setup);", "prediction": "(moduleManager.findModuleByName(version), setup);\n    }\n\n    private void exploreGradleProject(ExternalProject externalProject, Function<File, Module> moduleByRoot) {\n        File projectDir = externalProject.getProjectDir();\n        File buildFile = new File(projectDir, \"build.gradle\");\n        if (!buildFile.exists())\n            return;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(buildFile, StandardCharsets.UTF_8))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"apply plugin: 'io.", "first_line_groundtruth": "(moduleByRoot.get((setup.gradleProject().getChildProjects().get(version)).getProjectDir()), setup);", "first_line_prediction": "(moduleManager.findModuleByName(version), setup);", "match": 0}
{"groundtruth": "add(ref.purl().getType());", "prediction": "add(ref.getType());\n    }\n    for (DependencyTree child : tree.children()) {\n      validate(child);\n      types.add(child.root().getType());\n    }\n    Predicate<PackageRef> isType = p -> types.contains(p.getType());\n    if (!tree.dependencies().stream().allMatch(isType)) {\n      throw new IllegalArgumentException(String.format(\"Invalid dependency tree: %s\", tree));\n    }\n  }\n\n  protected abstract ObjectNode createNode(PackageRef ref, Set<PackageRef> allDeps);\n\n  protected abstract ObjectNode createPkg(PackageRef ref);", "first_line_groundtruth": "add(ref.purl().getType());", "first_line_prediction": "add(ref.getType());", "match": 0}
{"groundtruth": "conditionResult = stonecutter.testVersion(expression);", "prediction": " conditionResult = Boolean.parseBoolean(expression);\n                    conditions.push(conditionResult);\n                }\n            }\n        }\n    }\n\n    private String read(String pattern, Reader input, StringBuilder output) throws IOException {\n        StringBuilder builder = new StringBuilder();\n        int c;\n        while ((c = input.read()) != -1) {\n            if (c == '/') {\n                if (input.read() == '/') {\n                    while ((c = input.read()) != -1 && c != '\\n')\n                        builder.append((char) c);\n                } else if (input.read() == '*') {\n                    while ((", "first_line_groundtruth": "conditionResult = stonecutter.testVersion(expression);", "first_line_prediction": " conditionResult = Boolean.parseBoolean(expression);", "match": 0}
{"groundtruth": "(ref.name()).append(\"@\").append(ref.version()).toString();", "prediction": "(Constants.PACKAGE_PREFIX)\n        .append(ref.name())\n        .append(Constants.PACKAGE_VERSION_SEPARATOR)\n        .append(ref.version())\n        .toString();\n  }\n\n  private String toSnykPackageManager(String pkgManager) {\n    switch (pkgManager) {\n      case \"maven\":\n        return \"maven\";\n      case \"npm\":\n        return \"npm\";\n      case \"pip\":\n        return \"pip\";\n      case \"rubygems\":\n        return \"rubygems\";\n      case \"cargo\":\n        return \"cargo\";\n      case \"nuget\":\n        return \"nuget\";\n      case \"docker\":\n       ", "first_line_groundtruth": "(ref.name()).append(\"@\").append(ref.version()).toString();", "first_line_prediction": "(Constants.PACKAGE_PREFIX)", "match": 0}
{"groundtruth": ".of(param.outputSideParam()), RetryJob.NEVER_RETRY);", "prediction": ".of(param.outputSideParam()));\n        this.delJob = RetryJob.wrap(DelJob.of(param.inputSideParam()));\n    }\n\n    public static MoveJob of(DualSideParam param) {\n        return new MoveJob(param);\n    }\n\n    @Override\n    public void run() {\n        copyJob.run();\n        rollBackJob.run();\n        delJob.run();\n    }", "first_line_groundtruth": ".of(param.outputSideParam()), RetryJob.NEVER_RETRY);", "first_line_prediction": ".of(param.outputSideParam()));", "match": 0}
{"groundtruth": "findExternalProject(entry.getValue().gradleProject(), entry.getKey()).keySet()) {", "prediction": "getSourceSetNames(entry.getKey()))\n                if (sourceSetName.equals(\"main\"))\n                    continue;\n                else\n                    byVersioned.remove(entry.getKey());\n    }\n\n    private void exploreGradleProject(ExternalProject externalProject, Function<File, Module> moduleByRoot) {\n        if (externalProject.isDisposed())\n            return;\n\n        if (externalProject.isRoot()) {\n            for (ExternalProject child : externalProject.getChildProjects().values())\n                exploreGradleProject(child, moduleByRoot);\n        } else {\n            Module module = moduleByRoot.apply(externalProject.getProjectDir());\n           ", "first_line_groundtruth": "findExternalProject(entry.getValue().gradleProject(), entry.getKey()).keySet()) {", "first_line_prediction": "getSourceSetNames(entry.getKey()))", "match": 0}
{"groundtruth": "job.setJobIndex(listIndexHolder.getAndIncrement());", "prediction": " {\n                if (jobList.size() > listIndexHolder.getAndIncrement()) {\n                    jobList.get(listIndexHolder.get()).run();\n                } else {\n                    jobList.get(listIndexHolder.get()).run();\n                }\n            };\n        };\n        List<IJob> jobList = new ArrayList<>();\n        inputs.forEach(input -> {\n            input.list(path).forEach(fileMeta -> {\n                if (filePredicate.test(fileMeta)) {\n                    jobList.add(new CloneJob(new DualSideParam(path, fileMeta, input)));\n                }\n            });", "first_line_groundtruth": "job.setJobIndex(listIndexHolder.getAndIncrement());", "first_line_prediction": " {", "match": 0}
{"groundtruth": "(StrUtil.isBlank(str)) {", "prediction": " (str == null || str.length() == 0) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }", "first_line_groundtruth": "(StrUtil.isBlank(str)) {", "first_line_prediction": " (str == null || str.length() == 0) {", "match": 0}
{"groundtruth": "req.tree() != null && !req.tree().getAll().isEmpty();", "prediction": " req.tree() != null && req.tree().dependencies() != null && !req.tree().dependencies().isEmpty();\n  }\n\n  public String buildRequest(GraphRequest req) throws JsonProcessingException {\n    ObjectNode depGraph = mapper.createObjectNode();\n    depGraph.put(\"schemaVersion\", \"1.2.0\");\n    depGraph.set(\n         \"pkgManager\",\n         mapper.createObjectNode().put(\"name\", toOssIndexPackageManager(req.pkgManager())));\n\n    ArrayNode nodes = mapper.createArrayNode();\n    ArrayNode pkgs = mapper.createArrayNode();\n    req.tree", "first_line_groundtruth": "req.tree() != null && !req.tree().getAll().isEmpty();", "first_line_prediction": " req.tree() != null && req.tree().dependencies() != null && !req.tree().dependencies().isEmpty();", "match": 0}
{"groundtruth": "filePipe.close();", "prediction": " System.out.println(\"filePipe.run() end\");\n        }\n    }", "first_line_groundtruth": "filePipe.close();", "first_line_prediction": " System.out.println(\"filePipe.run() end\");", "match": 0}
{"groundtruth": "deleteJob.run();", "prediction": " try (InputStream inputStream = input.read(path)) {\n             output.write(path, inputStream);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         } finally {\n             deleteJob.run();\n         }\n    }", "first_line_groundtruth": "deleteJob.run();", "first_line_prediction": " try (InputStream inputStream = input.read(path)) {", "match": 0}
{"groundtruth": "PackageRef ref = tree.root();", "prediction": " Set<PackageRef> visited = new HashSet<>();\n     validate(tree, visited);\n  }\n\n  private void validate(DependencyTree tree, Set<PackageRef> visited) {\n    if (visited.contains(tree.root())) {\n      return;\n    }\n    visited.add(tree.root());\n    for (DirectDependency dep : tree.dependencies()) {\n      validate(dep.dependency(), visited);\n    }\n  }\n\n  protected void validate(DirectDependency dep, Set<PackageRef> visited) {\n    if (visited.contains(dep.dependency())) {\n      return;\n    }\n    visited.add(dep.", "first_line_groundtruth": "PackageRef ref = tree.root();", "first_line_prediction": " Set<PackageRef> visited = new HashSet<>();", "match": 0}
{"groundtruth": "deleteJob = RetryJob.fastFailWrap(DelJob.of(param.outputSideParam()));", "prediction": "deleteJob = RetryJob.wrap(DelJob.of(param.inputSideParam()), RetryJob.NEVER_RETRY);\n    }\n\n    public static CopyJob of(DualSideParam param) {\n        return new CopyJob(param);\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream inputStream = input.getInputStream(path);\n            output.putInputStream(path, inputStream);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            deleteJob.run();\n        }\n    }", "first_line_groundtruth": "deleteJob = RetryJob.fastFailWrap(DelJob.of(param.outputSideParam()));", "first_line_prediction": "deleteJob = RetryJob.wrap(DelJob.of(param.inputSideParam()), RetryJob.NEVER_RETRY);", "match": 0}
{"groundtruth": "stonecutter.versions())\n                versionModel.add(version);", "prediction": " stonecutter.currentActive().getVersions())\n                versionModel.addElement(version);\n            cVersion.setModel(versionModel);\n            cVersion.addActionListener(e -> {\n                if (cVersion.getSelectedItem() == null)\n                    return;\n                bTokens.setEnabled(true);\n                bNewToken.setEnabled(true);\n                bCreateFlag.setEnabled(true);\n                bTokens.setText(\"Tokens for \" + cVersion.getSelectedItem());\n                tTokens.setModel(new TokensTableModel(stonecutter.currentActive().getTokens(cVersion.getSelectedItem())));\n            });\n\n            bNewToken.addActionListener(", "first_line_groundtruth": "stonecutter.versions())", "first_line_prediction": " stonecutter.currentActive().getVersions())", "match": 0}
{"groundtruth": "= param.getSubParams(MIRROR_MODE_PARAM, MIRROR_MODE_FULL).equals(MIRROR_MODE_APPEND);", "prediction": " = param.getSubParams().get(MIRROR_MODE_PARAM).equals(MIRROR_MODE_APPEND);\n        this.cloneResultStorePath = param.getSubParams().get(CLONE_FLAG_STORE_PATH_PARAM);\n    }\n\n    public static CloneJob of(DualSideParam param) {\n        return new CloneJob(param);\n    }\n\n    @Override\n    public void run() {\n        try {\n            if (Files.exists(Paths.get(path))) {\n                if (Files.isDirectory(Paths.get(path))) {\n                    if (Files.exists(Paths.get(path,", "first_line_groundtruth": "= param.getSubParams(MIRROR_MODE_PARAM, MIRROR_MODE_FULL).equals(MIRROR_MODE_APPEND);", "first_line_prediction": " = param.getSubParams().get(MIRROR_MODE_PARAM).equals(MIRROR_MODE_APPEND);", "match": 0}
{"groundtruth": "return ActivityJDBC.instance().update(ctx.body().asPojo(Activity.class).setId(id));", "prediction": " return ActivityJDBC.instance().update(found);\n        }).onComplete(ar -> {\n            if(ar.failed()) ctx.fail(ar.cause());\n            ctx.response().end();\n        });\n    }\n\n    private static void apiDelete(RoutingContext ctx) {\n        Long id = Long.valueOf(ctx.request().getParam(\"id\"));\n        ActivityJDBC.instance().getById(id).compose(found -> {\n            if(found == null || found.getIdUserCreate() != ctx.user().principal().getLong(\"sub\").longValue()) return Future.failedFuture(new ExceptionWithHttpCode(HttpResponseStatus.FOR", "first_line_groundtruth": "return ActivityJDBC.instance().update(ctx.body().asPojo(Activity.class).setId(id));", "first_line_prediction": " return ActivityJDBC.instance().update(found);", "match": 0}
{"groundtruth": "(request.getLogin(), request.getPassword()).onComplete(ar -> {", "prediction": "(request.getUsername(), request.getPassword()).compose(user -> {\n            if(user == null) return Future.failedFuture(new ExceptionWithHttpCode(HttpResponseStatus.UNAUTHORIZED.code(), \"Invalid username or password\"));\n            return auth.generateToken(user.getId().toString());\n        }).onFailure(ctx::fail).onSuccess(token -> {\n            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE.toString(), \"application/json;charset=utf-8\").end(new JsonObject().put(\"token\", token).encode());\n        });\n    }\n\n    private static void apiChangePassword(", "first_line_groundtruth": "(request.getLogin(), request.getPassword()).onComplete(ar -> {", "first_line_prediction": "(request.getUsername(), request.getPassword()).compose(user -> {", "match": 0}
{"groundtruth": "ActivityJDBC.instance().getById(id).compose(found -> {", "prediction": " ActivityJDBC.instance().update(id, ctx.body().asJsonObject().mapTo(Activity.class)).onComplete(ar -> {\n            if(ar.failed()) ctx.fail(ar.cause());\n            ctx.response().end();\n         });\n    }\n\n    private static void apiDelete(RoutingContext ctx) {\n        Long id = Long.valueOf(ctx.request().getParam(\"id\"));\n        ActivityJDBC.instance().delete(id).onComplete(ar -> {\n            if(ar.failed()) ctx.fail(ar.cause());\n            ctx.response().end();\n         });\n    }", "first_line_groundtruth": "ActivityJDBC.instance().getById(id).compose(found -> {", "first_line_prediction": " ActivityJDBC.instance().update(id, ctx.body().asJsonObject().mapTo(Activity.class)).onComplete(ar -> {", "match": 0}
{"groundtruth": "UserJDBC.instance().login(request.getLogin(), request.getPassword()).onComplete(ar -> {", "prediction": " UserJDBC.instance().login(request.getUsername(), request.getPassword()).onComplete(ar -> {\n             if(ar.failed()) ctx.fail(ar.cause());\n             ctx.response().putHeader(HttpHeaders.CONTENT_TYPE.toString(), \"application/json;charset=utf-8\").end(ar.result().encode());\n         });\n    }\n\n    private static void apiChangePassword(RoutingContext ctx) {\n        RequestChangePassword request = ctx.body().asPojo(RequestChangePassword.class);\n        UserJDBC.instance().changePassword(request.getUsername(), request.getPassword()).onComplete(ar ->", "first_line_groundtruth": "UserJDBC.instance().login(request.getLogin(), request.getPassword()).onComplete(ar -> {", "first_line_prediction": " UserJDBC.instance().login(request.getUsername(), request.getPassword()).onComplete(ar -> {", "match": 0}
{"groundtruth": "task.getOutputDir().set(task.getInputDir().get());", "prediction": " task.getOutputDir().set(new File(versionProject.getBuildDir(), \"chiseledSrc\"));\n            }\n        });\n    }\n\n    public void afterEvaluate(Project project) {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n\n        try {\n            Files.createDirectories(loaderCopy.toPath());\n            Files.createFile(loaderCopy.toPath().resolve(\"loader.json\"));\n            Files.write(loaderCopy.toPath().resolve(\"loader.json\"), new ArrayList<String>() {{\n                add(\"{\");\n                add(\"\\\"loader\\\": \\\"fabric-loader", "first_line_groundtruth": "task.getOutputDir().set(task.getInputDir().get());", "first_line_prediction": " task.getOutputDir().set(new File(versionProject.getBuildDir(), \"chiseledSrc\"));", "match": 0}
{"groundtruth": "instance().login(request.getLogin(), request.getPassword()).onComplete(ar -> {", "prediction": "instance().login(request.getUsername(), request.getPassword()).compose(user -> {\n            if(user == null) return Future.failedFuture(new ExceptionWithHttpCode(HttpResponseStatus.UNAUTHORIZED.code(), \"Invalid username or password\"));\n            return auth.generateToken(user.getId().toString());\n        }).onFailure(ctx::fail).onSuccess(token -> {\n            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE.toString(), \"application/json;charset=utf-8\").end(new JsonObject().put(\"token\", token).encode());\n        });\n    }\n\n    private static void api", "first_line_groundtruth": "instance().login(request.getLogin(), request.getPassword()).onComplete(ar -> {", "first_line_prediction": "instance().login(request.getUsername(), request.getPassword()).compose(user -> {", "match": 0}
{"groundtruth": "task.getInputDir().set(afterEvaluate.file(\"./src\"));", "prediction": " task.getInputDir().set(versionProject.file(\"./src\"));\n                task.getOutputDir().set(new File(versionProject.getBuildDir(), \"chiseledSrc\"));\n            }\n        });\n    }\n\n    public void afterEvaluate(Project project) {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n\n        try {\n            Files.createDirectories(loaderCopy.toPath());\n            Files.createFile(loaderCopy.toPath().resolve(\"loader.json\"));\n            Files.write(loaderCopy.toPath().resolve(\"loader.json\"), new ArrayList<String", "first_line_groundtruth": "task.getInputDir().set(afterEvaluate.file(\"./src\"));", "first_line_prediction": " task.getInputDir().set(versionProject.file(\"./src\"));", "match": 0}
{"groundtruth": ".getOutputDir().set(task.getInputDir().get());", "prediction": ".getOutputDir().set(new File(versionProject.getBuildDir(), \"chiseledSrc\"));\n            }\n        });\n    }\n\n    public void afterEvaluate(Project project) {\n        File loaderCopy = new File(project.getRootDir(), \".gradle/stonecutter\");\n\n        try {\n            Files.createDirectories(loaderCopy.toPath());\n            Files.createFile(loaderCopy.toPath().resolve(\"loader.json\"));\n            Files.write(loaderCopy.toPath().resolve(\"loader.json\"), new ArrayList<String>() {{\n                add(\"{\");\n                add(\"\\\"loader\\\": \\\"fabric-loader:", "first_line_groundtruth": ".getOutputDir().set(task.getInputDir().get());", "first_line_prediction": ".getOutputDir().set(new File(versionProject.getBuildDir(), \"chiseledSrc\"));", "match": 0}
{"groundtruth": "switch (matchPlayer.getTeam()) {", "prediction": " if(matchPlayer.getTeam() == MatchTeam.RED) {\n                 redPlayers.add(matchPlayer);\n             } else {\n                 bluePlayers.add(matchPlayer);\n             }\n        }\n\n        red = new MatchTeam(redPlayers);\n        blue = new MatchTeam(bluePlayers);\n\n        rounds = new LinkedList<>();\n\n        JsonArray roundData = object.getAsJsonObject(\"rounds\").getAsJsonArray(\"rounds\");\n\n        for (JsonElement roundElement : roundData) {\n            rounds.add(new MatchRound(valorantAPI).fetchData(roundElement.getAsJsonObject()));\n        }\n\n        fetched = true;\n\n        return", "first_line_groundtruth": "switch (matchPlayer.getTeam()) {", "first_line_prediction": " if(matchPlayer.getTeam() == MatchTeam.RED) {", "match": 0}
{"groundtruth": "(valorantAPI.sendRestRequest(\"/v2/match/\" + matchId).getAsJsonObject().getAsJsonObject(\"data\"));", "prediction": "(valorantAPI.sendRestRequest(\"/v3/matches/\" + region.getQuery() + \"/\" + matchId).getAsJsonObject());\n    }\n\n    public String getMatchId() {\n        return matchId;\n    }\n\n    public Map getMap() {\n        return map;\n    }\n\n    public String getGameVersion() {\n        return gameVersion;\n    }\n\n    public long getGameLength() {\n        return gameLength;\n    }\n\n    public String getGameStart() {\n        return gameStart;\n    }\n\n    public int getRoundsPlayed() {\n        return roundsPlayed;\n    }\n\n    public GameMode getGameMode", "first_line_groundtruth": "(valorantAPI.sendRestRequest(\"/v2/match/\" + matchId).getAsJsonObject().getAsJsonObject(\"data\"));", "first_line_prediction": "(valorantAPI.sendRestRequest(\"/v3/matches/\" + region.getQuery() + \"/\" + matchId).getAsJsonObject());", "match": 0}
{"groundtruth": "JsonObject statusData = sendRestRequest(\"/v1/status/\" + region.getQuery()).getAsJsonObject().getAsJsonObject(\"data\");", "prediction": " return new ServerStatus(this).fetchData(region);\n    }\n\n    public List<StatusEntry> getServerStatus(Region region, Language language) throws IOException {\n        return new ServerStatus(this).fetchData(region, language);\n    }\n\n    public List<StatusEntry> getServerStatus(Region region, Language language, String locale) throws IOException {\n        return new ServerStatus(this).fetchData(region, language, locale);\n    }\n\n    public List<StatusEntry> getServerStatus(Region region, Language language, String locale, String version) throws IOException {\n        return new ServerStatus(this).fetch", "first_line_groundtruth": "JsonObject statusData = sendRestRequest(\"/v1/status/\" + region.getQuery()).getAsJsonObject().getAsJsonObject(\"data\");", "first_line_prediction": " return new ServerStatus(this).fetchData(region);", "match": 0}
{"groundtruth": "+ region.getQuery() + \"?name=\" + data[0] + \"&tag=\" + data[1]).getAsJsonArray();", "prediction": " + region.getQuery() + \"/\" + data[0] + \"/\" + data[1]).getAsJsonArray();\n        }\n\n        List<LeaderboardPlayer> players = new LinkedList<>();\n        for(JsonElement element : leaderboardData) {\n            players.add(new LeaderboardPlayer(this).fetchData(element.getAsJsonObject()));\n        }\n        return players;\n    }\n\n    public List<LeaderboardPlayer> getLeaderboard(Region region, String riotId, int limit) throws IOException {\n        JsonArray leaderboardData;\n\n        if(riotId == null) {\n            leaderboardData = sendRestRequest(\"/", "first_line_groundtruth": "+ region.getQuery() + \"?name=\" + data[0] + \"&tag=\" + data[1]).getAsJsonArray();", "first_line_prediction": " + region.getQuery() + \"/\" + data[0] + \"/\" + data[1]).getAsJsonArray();", "match": 0}
{"groundtruth": "commands.getOrderById(orderId),\n                HttpStatus.OK);", "prediction": " commands.getOrder(orderId),\n                 HttpStatus.OK);\n    }\n\n    @PostMapping(\"{orderId}/status\")\n    public ResponseEntity<Map<String, String>> changeOrderStatus(@PathVariable Long orderId, @RequestBody Map<String, OrderStatus> body) {\n        Map<String, String> response = new HashMap<>();\n        String result = commands.setStatusToOrder(orderId, body.get(\"status\"))\n                 .toString();\n        response.put(\"operationResult\", result);\n        return new ResponseEntity<>(response,HttpStatus.OK);\n    }", "first_line_groundtruth": "commands.getOrderById(orderId),", "first_line_prediction": " commands.getOrder(orderId),", "match": 0}
{"groundtruth": "= commands.createRequest(body.get(\"bookId\"))\n                .toString();", "prediction": " = commands.createRequest(body.get(\"bookId\"), body.get(\"quantity\"))\n                .toString();\n        response.put(\"operationResult\", result);\n        return new ResponseEntity<>(response, HttpStatus.OK);\n    }\n\n    @PostMapping(\"new-with-book-id\")\n    public ResponseEntity<Map<String,String>> createRequestWithBookId(@RequestBody Map<String, Long> body) {\n        Map<String, String> response = new HashMap<>();\n        String result  = commands.createRequestWithBookId(body.get(\"bookId\"))\n                .toString();\n        response.put(\"operationResult\",", "first_line_groundtruth": "= commands.createRequest(body.get(\"bookId\"))", "first_line_prediction": " = commands.createRequest(body.get(\"bookId\"), body.get(\"quantity\"))", "match": 0}
{"groundtruth": "> booksToOrder = bookService.getBooksByIds(ids);", "prediction": "> books = bookService.getBooksByIds(ids);\n        if (books.isEmpty()) {\n            return ResultOfOperation.CreateOrder.WRONG_BOOK_ID;\n        }\n        Order order = entityFactory.buildOrder(books);\n        orderService.saveOrder(order);\n        if (order.getStatus() == OrderStatus.IN_PROCESS) {\n            return ResultOfOperation.CreateOrder.ORDER_CREATED;\n        }\n        if (order.getStatus() == OrderStatus.COMPLETED) {\n            return ResultOfOperation.CreateOrder.ORDER_AND_REQUESTS_CREATED;\n        }\n        return ResultOf", "first_line_groundtruth": "> booksToOrder = bookService.getBooksByIds(ids);", "first_line_prediction": "> books = bookService.getBooksByIds(ids);", "match": 0}
{"groundtruth": "<>(commands.getNumberOfRequestsOnBook(bookId),\n                HttpStatus.OK);", "prediction": "<>(commands.getNumberOfRequestsOnBook(bookId),\n                HttpStatus.OK);\n    }\n\n    @GetMapping(\"book/{bookId}/request\")\n    public ResponseEntity<List<Request>> getRequestsOnBook(@PathVariable Long bookId) {\n        return new ResponseEntity<>(commands.getRequestsOnBook(bookId),\n                HttpStatus.OK);\n    }\n\n    @GetMapping(\"book/{bookId}/request/{requestId}\")\n    public ResponseEntity<Request> getRequest(@PathVariable Long bookId, @PathVariable Long requestId) {\n        return new ResponseEntity<>(commands.getRequest(bookId, requestId),\n                HttpStatus.OK);\n    }\n\n    @PostMapping(\"", "first_line_groundtruth": "<>(commands.getNumberOfRequestsOnBook(bookId),", "first_line_prediction": "<>(commands.getNumberOfRequestsOnBook(bookId),", "match": 1}
{"groundtruth": "dependency.getVersion(),\n                dependency.getType(),\n                dependency.getClassifier(),\n                dependency.getScope()\n        );", "prediction": " dependency.getVersion(),\n                dependency.getType(),\n                dependency.getClassifier(),\n                dependency.getScope());\n    }\n\n    private static BiConsumer<String, String> nodeChanger(PomTransformer.NodeGavtcs nodeGavtcs) {\n        return (key, value) -> {\n            if (nodeGavtcs.hasProperty(key)) {\n                nodeGavtcs.setProperty(key, value);\n            } else {\n                nodeGavtcs.addProperty(key, value);\n            }\n        };\n    }", "first_line_groundtruth": "dependency.getVersion(),", "first_line_prediction": " dependency.getVersion(),", "match": 0}
{"groundtruth": "dependency.getClassifier(),\n                dependency.getScope()\n        );", "prediction": " dependency.getClassifier(),\n                dependency.getScope());\n    }\n\n    private static BiConsumer<String, String> nodeChanger(PomTransformer.NodeGavtcs nodeGavtcs) {\n        return (key, value) -> {\n            if (nodeGavtcs.hasProperty(key)) {\n                nodeGavtcs.setProperty(key, value);\n            } else {\n                nodeGavtcs.addProperty(key, value);\n            }\n        };\n    }", "first_line_groundtruth": "dependency.getClassifier(),", "first_line_prediction": " dependency.getClassifier(),", "match": 0}
{"groundtruth": "pomFile).execute(() -> dependencyCommand().accept(pomFile, dependency));", "prediction": "pomFile, dependency);\n\n            getLog().info(String.format(\"dependency: %s has been added to the \\\"%s\\\" file successfully.\", dependency, pomFile));\n        } catch (RuntimeException ex) {\n            throw new MojoFailureException(\n                    String.format(\"cannot add the dependency: %s to the \\\"%s\\\" file: %s\", dependency, pomFile, ex.getMessage()), ex);\n        }\n    }\n\n    private Dependency buildDependency() {\n        return new Dependency(gav, type, classifier, scope);\n    }\n\n    private void change(Path pomFile, Dependency dependency) {\n        if (addDependency", "first_line_groundtruth": "pomFile).execute(() -> dependencyCommand().accept(pomFile, dependency));", "first_line_prediction": "pomFile, dependency);", "match": 0}
{"groundtruth": "List<jenaTripleParser> result = serviceJena.getTriples(filePath, url, ontologyContentEncoded64) ;", "prediction": "\tString result = serviceJena.rdfToTriples(filePath, url,ontologyContentEncoded64);\n        \t\t\t\treturn ResponseEntity.ok(result);\n        \t\t} catch (Exception e) {\n        \t\t\treturn ResponseEntity.badRequest().body(\"Error in the request\");\n        \t\t}\n    }\n    \n    @PostMapping(\"/rdftriples\")\n    public ResponseEntity<?> rdfTriplesToJena(@RequestBody jenaTripleParserInput request ){\n    \t\n         // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntology", "first_line_groundtruth": "List<jenaTripleParser> result = serviceJena.getTriples(filePath, url, ontologyContentEncoded64) ;", "first_line_prediction": "\tString result = serviceJena.rdfToTriples(filePath, url,ontologyContentEncoded64);", "match": 0}
{"groundtruth": "dependency.getType(),\n                dependency.getClassifier(),\n                dependency.getScope()\n        );", "prediction": " dependency.getType(),\n                 dependency.getClassifier(),\n                 dependency.getScope());\n    }\n\n    private static BiConsumer<String, String> nodeChanger(PomTransformer.NodeGavtcs nodeGavtcs) {\n        return (key, value) -> {\n            if (nodeGavtcs.hasProperty(key)) {\n                nodeGavtcs.setProperty(key, value);\n            } else {\n                nodeGavtcs.addProperty(key, value);\n            }\n        };\n    }", "first_line_groundtruth": "dependency.getType(),", "first_line_prediction": " dependency.getType(),", "match": 0}
{"groundtruth": "SWRLService.SWRLruleReclassification(filePath, url,reqBodies,reqHead);", "prediction": " SWRLService.postReclassification(filePath, url,ontologyContentDecoded64,reqBodies,reqHead);\n            \t}else {\n            \t\tresult =  SWRLService.postReclassification(ontologyContentDecoded64,reqBodies,reqHead);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n    }\n    \n    //Post API For STRING\n    @PostMapping(\"/alternative_exec_rule_complex\")\n    public ResponseEntity<?> postReclassificationComplex(@RequestBody(required = false) rule", "first_line_groundtruth": "SWRLService.SWRLruleReclassification(filePath, url,reqBodies,reqHead);", "first_line_prediction": " SWRLService.postReclassification(filePath, url,ontologyContentDecoded64,reqBodies,reqHead);", "match": 0}
{"groundtruth": "equivalentClass = request.getEquivalentClass();", "prediction": " isAll = request.getIsAll();\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    \tbyte[] ontologyContentDecoded64Bytes = null;\n    \tString ontologyContentDecoded64 = null;\n    \tif (ontologyContentEncoded64 != null && !ontologyContentEncoded64.isEmpty()) {\n    \t ontologyContentDecoded64Bytes = Base64.getMimeDecoder().decode(ontologyContentEncoded64);\n    \t ontologyContentDecoded64 = new String(ontologyContentDecoded64Bytes", "first_line_groundtruth": "equivalentClass = request.getEquivalentClass();", "first_line_prediction": " isAll = request.getIsAll();", "match": 0}
{"groundtruth": "result = SWRLService.SWRLruleReclassificationB64(ontologyContentDecoded64,reqBodies,reqHead);", "prediction": "\tresult = SWRLService.SWRLruleReclassification(ontologyContentDecoded64, reqBodies,reqHead);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n    }\n    \n    //Post API For STRING\n    @PostMapping(\"/alternative_exec_rule_complex\")\n    public ResponseEntity<?> postReclassificationComplex(@RequestBody(required = false) ruleSWRLInputComplex request) { \n    \t// This Class works only for Classess\n        String filePath = request.getFilePath();\n        String", "first_line_groundtruth": "result = SWRLService.SWRLruleReclassificationB64(ontologyContentDecoded64,reqBodies,reqHead);", "first_line_prediction": "\tresult = SWRLService.SWRLruleReclassification(ontologyContentDecoded64, reqBodies,reqHead);", "match": 0}
{"groundtruth": "DisjointClasses  = request.getDisjointClasses();", "prediction": " DisjointClasses = request.getDisjointClasses();\n        Boolean differentIndividual = request.getDifferentIndividual();\n        Boolean HasValue = request.getHasValue();\n        Boolean InverseObjectProperties = request.getInverseObjectProperties();\n        Boolean AllValuesFrom = request.getAllValuesFrom();\n        Boolean SomeValuesFrom = request.getSomeValuesFrom();\n        Boolean DomainAndRange = request.getDomainAndRange();\n        Boolean ClassAssertion = request.getClassAssertion();\n        Boolean SubClass = request.getSubClass();\n        Boolean DataPropertyCharacteristic = request.getDataPropertyCharacteristic();\n        Boolean EquivalentDataProperty = request.getEquivalentData", "first_line_groundtruth": "DisjointClasses  = request.getDisjointClasses();", "first_line_prediction": " DisjointClasses = request.getDisjointClasses();", "match": 0}
{"groundtruth": "= request.getParams();", "prediction": " = request.getReqParametres();\n        String[] reqBodies = request.getReqBodies();\n        String[] reqHead = request.getReqHead();\n        String[] reqRules = request.getReqRules();\n        String[] reqRulesBody = request.getReqRulesBody();\n        String[] reqRulesHead = request.getReqRulesHead();\n        String[] reqRulesBodyBody = request.getReqRulesBodyBody();\n        String[] reqRulesBodyHead = request.getReqRulesBodyHead();\n        String[] reqRulesHeadBody = request.getReqRulesHeadBody();\n        String[] reqRulesHead", "first_line_groundtruth": "= request.getParams();", "first_line_prediction": " = request.getReqParametres();", "match": 0}
{"groundtruth": "= reasonerService.getUnsatisfaisableClasses(filePath, url);", "prediction": " = reasonerService.getUnsatisfaisableClasses(filePath, url);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n    }\n\n    @GetMapping(\"/satisfiable\")\n    public ResponseEntity<?> getSatisfiableClasses(\n            @RequestParam(required = false) String filePath,\n            @RequestParam(required = false) String url) { \n    \tint parametersCount = countNumberOfParametres( filePath, url);\n        if (parametersCount == 0) {\n            return ResponseEntity.badRequest().body(\"At least one of params", "first_line_groundtruth": "= reasonerService.getUnsatisfaisableClasses(filePath, url);", "first_line_prediction": " = reasonerService.getUnsatisfaisableClasses(filePath, url);", "match": 0}
{"groundtruth": "= reasonerService.postConsistency(filePath, url);", "prediction": " = reasonerService.getConsistency(filePath, url);\n            \t}else {\n            \tresult = reasonerService.getConsistencyB64(ontologyContentDecoded64);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        \n    \t}\n    \t@PostMapping(\"/inference\")\n    public ResponseEntity<?> postInference(@RequestBody(required = false) reasonerInput request) { \n         // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n       ", "first_line_groundtruth": "= reasonerService.postConsistency(filePath, url);", "first_line_prediction": " = reasonerService.getConsistency(filePath, url);", "match": 0}
{"groundtruth": "reasonerService.postConsistencyContent(ontologyContentDecoded64);", "prediction": " reasonerService.postConsistency(ontologyContentDecoded64);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        \n    \t}\n    \t//Post API For FILE\n    \t@PostMapping(\"/inference\")\n    public ResponseEntity<?> postInference(@RequestBody(required = false) reasonerInput request) { \n         // extract input parameters from the request object\n        String filePath = request.getFilePath();\n        String url = request.getUrl();\n        String ontologyContentEncoded64 = request.getOntologyContentEncoded64();\n    ", "first_line_groundtruth": "reasonerService.postConsistencyContent(ontologyContentDecoded64);", "first_line_prediction": " reasonerService.postConsistency(ontologyContentDecoded64);", "match": 0}
{"groundtruth": "reasonerService.postInferences(filePath, url,valuesList);", "prediction": " reasonerService.postInference(filePath, url, valuesList);\n                 // Here if we use filePath or Url\n            \t }else {\n            \tresult = reasonerService.postInferenceContent(ontologyContentDecoded64, valuesList);\n            \t // Here if we use the Encoded Content\n            \t }\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n         }\n     //Post API For STRING\n     @PostMapping(\"/unsatisfaisableClasses\")\n     public ResponseEntity<?> postUnsatisfaisableClasses(@RequestBody(required = false", "first_line_groundtruth": "reasonerService.postInferences(filePath, url,valuesList);", "first_line_prediction": " reasonerService.postInference(filePath, url, valuesList);", "match": 0}
{"groundtruth": "result = reasonerService.postInferencesContent(ontologyContentDecoded64,valuesList);", "prediction": "\tresult = reasonerService.postInferencesContent(ontologyContentDecoded64,valuesList);\n            \t}\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n         }\n     //Post API For STRING\n     @PostMapping(\"/unsatisfaisableClasses\")\n     public ResponseEntity<?> postUnsatisfaisableClasses(@RequestBody(required = false) reasonerInput request) { \n         // extract input parameters from the request object\n         String filePath = request.getFilePath();\n         String url = request.getUrl();\n         String ontology", "first_line_groundtruth": "result = reasonerService.postInferencesContent(ontologyContentDecoded64,valuesList);", "first_line_prediction": "\tresult = reasonerService.postInferencesContent(ontologyContentDecoded64,valuesList);", "match": 0}
{"groundtruth": "result = reasonerService.getInferences(filePath, url);", "prediction": " result = reasonerService.getInference(filePath, url);\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n            \n        \t\n        \n     }\n     @PostMapping(\"/inferences\")\n     public ResponseEntity<?> postInferences(@RequestBody reasonerInput reqBody,\n             @RequestParam(required = false) String filePath,\n             @RequestParam(required = false) String url) {\n        \tint parametersCount = countNumberOfParametres( filePath, url);\n        \tif (parametersCount == 0) {\n            \treturn ResponseEntity.badRequest().", "first_line_groundtruth": "result = reasonerService.getInferences(filePath, url);", "first_line_prediction": " result = reasonerService.getInference(filePath, url);", "match": 0}
{"groundtruth": "= reasonerService.postUnsatisfaisableClasses(filePath, url);", "prediction": " = reasonerService.postUnsatisfiable(filePath, url);\n                 // Here if we use filePath or Url\n            \t }else {\n            \tresult = reasonerService.postUnsatisfiableContent(ontologyContentDecoded64);\n            \t // Here if we use the Encoded Content\n            \t }\n                return ResponseEntity.ok(result);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().body(e.getMessage());\n            }\n        \n    \t}\n     //Post API For STRING\n     @PostMapping(\"/satisfiable\")\n     public ResponseEntity<?> postSatisfiable(@RequestBody(required = false) reasonerInput request) { \n        ", "first_line_groundtruth": "= reasonerService.postUnsatisfaisableClasses(filePath, url);", "first_line_prediction": " = reasonerService.postUnsatisfiable(filePath, url);", "match": 0}
{"groundtruth": "writer.writeInt(length);", "prediction": " writer.writeInt(length);\n        for (int i = 0; i < length; i++) {\n            writer.writeInt(value[i]);\n        }\n    }\n\n    public void writeLongArray(long[] value) throws IOException {\n        int length = value.length;", "first_line_groundtruth": "writer.writeInt(length);", "first_line_prediction": " writer.writeInt(length);", "match": 0}
{"groundtruth": ": return NbtTagValue.fromByte(readByte());", "prediction": ": return NbtTagValue.of(readByte());\n            case NbtTagValue.TAG_SHORT: return NbtTagValue.of(readShort());\n            case NbtTagValue.TAG_INT: return NbtTagValue.of(readInt());\n            case NbtTagValue.TAG_LONG: return NbtTagValue.of(readLong());\n            case NbtTagValue.TAG_FLOAT: return NbtTagValue.of(readFloat());\n            case NbtTagValue.TAG_DOUBLE: return NbtTagValue.of(readDouble());\n            case NbtTagValue.TAG_BYTE_ARRAY: return NbtTagValue.of", "first_line_groundtruth": ": return NbtTagValue.fromByte(readByte());", "first_line_prediction": ": return NbtTagValue.of(readByte());", "match": 0}
{"groundtruth": "writer.writeShortUnsigned(value.length());", "prediction": " writeString(value, 32767);\n    }\n\n    public void writeString(String value, int maxLength) throws IOException {\n        int length = value.length();\n        if (length > maxLength) {\n            throw new RuntimeException(\"String exceed max length. maxLength: \" + maxLength + \" length: \" + length);\n        }\n\n        writer.writeVarInt(length);\n        writer.writeBytes(value.getBytes());\n    }\n\n    public void writeIdentifier(String value) throws IOException {\n        writeString(value, 32767);\n    }\n\n    public void writeBoolean(boolean value) throws", "first_line_groundtruth": "writer.writeShortUnsigned(value.length());", "first_line_prediction": " writeString(value, 32767);", "match": 0}
{"groundtruth": "visitor.visitByte(value);", "prediction": " visitor.visitByte(value);\n            }\n        };\n    }\n\n    public static NbtTagValue<Short> fromShort(short value) {\n        return new NbtTagValue<>() {\n            @Override\n            public byte getType() {\n                return TAG_SHORT;\n            }\n\n            @Override\n            public Short getValue() {\n                return value;\n            }\n\n            @Override\n            public void visit(NbtTagVisitor visitor) {\n                visitor.visitShort(value);\n            }\n        };\n    }\n\n    public static NbtTagValue<Integer> fromInt(int value) {\n        return new NbtTagValue<>() {\n            @Override\n           ", "first_line_groundtruth": "visitor.visitByte(value);", "first_line_prediction": " visitor.visitByte(value);", "match": 0}
{"groundtruth": "writer.writeInt(value.length);", "prediction": " writer.writeByteArray(value);\n    }\n\n    public void writeString(String value) throws IOException {\n        writer.writeString(value);\n    }\n\n    public void writeString(String value, int maxLength) throws IOException {\n        writer.writeString(value, maxLength);\n    }\n\n    public void writeBoolean(boolean value) throws IOException {\n        writer.writeBoolean(value);\n    }\n\n    public void writeByteList(NbtTagList<NbtTagValue<Byte>> value) throws IOException {\n        writer.writeByteList(value);\n    }\n\n    public void writeShortList(NbtTagList<NbtTag", "first_line_groundtruth": "writer.writeInt(value.length);", "first_line_prediction": " writer.writeByteArray(value);", "match": 0}
{"groundtruth": "DoMainUtil.firstLevel(subDoMain)) {", "prediction": "DoMainUtil.firstLevel(subDoMain)) {\n            domain = \"@\";\n            rr = \"A\";\n        } else {\n            domain = subDoMain.substring(0, subDoMain.indexOf('.'));\n            rr = subDoMain.substring(subDoMain.indexOf('.') + 1);\n        }\n        AliDnsUtils.createRecord(client, domain, rr, RecordTypeEnum.getNameByIndex(parsingRecord.getRecordType()), ip);\n    }\n\n    @Override\n    public void update(ParsingRecord parsingRecord, String ip, String recordId) throws Exception {\n        //call dns api\n        Client client", "first_line_groundtruth": "DoMainUtil.firstLevel(subDoMain)) {", "first_line_prediction": "DoMainUtil.firstLevel(subDoMain)) {", "match": 1}
{"groundtruth": "= reader.readInt();", "prediction": " = readVarInt();\n        byte[] bytes = reader.readByteArray(length);\n\n        return bytes;\n    }\n\n    public String readString() throws IOException {\n        return readString(32767);\n    }\n\n    public String readString(int maxLength) throws IOException {\n        int length = readVarInt();\n        if (length > maxLength) {\n            throw new RuntimeException(\"String exceed max length. maxLength: \" + maxLength + \" length: \" + length);\n        }\n\n        byte[] bytes = reader.readByteArray(length);\n        return new String(bytes, StandardCharsets.UTF_8);\n    }\n\n    public", "first_line_groundtruth": "= reader.readInt();", "first_line_prediction": " = readVarInt();", "match": 0}
{"groundtruth": "reader.readBytes(data);", "prediction": " reader.readBytes(data);\n\n        return data;\n    }\n\n    public String readString() throws IOException {\n        return readString(32767);\n    }\n\n    public String readString(int maxLength) throws IOException {\n        int length = reader.readVarInt();\n        if (length > maxLength) {\n            throw new RuntimeException(\"String exceed max length. maxLength: \" + maxLength + \" length: \" + length);\n        }\n\n        byte[] data = new byte[length];\n        reader.readBytes(data);\n\n        return new String(data, StandardCharsets.UTF_8);\n    }\n\n    public NbtTag", "first_line_groundtruth": "reader.readBytes(data);", "first_line_prediction": " reader.readBytes(data);", "match": 0}
{"groundtruth": "int length = reader.readShort();", "prediction": " return readString(32767);\n    }\n\n    public String readString(int maxLength) throws IOException {\n        int length = reader.readVarInt();\n        if (length > maxLength) {\n            throw new RuntimeException(\"String exceed max length. maxLength: \" + maxLength + \" length: \" + length);\n        }\n        byte[] buf = new byte[length];\n        reader.readBytes(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    public NbtTagCompound readCompound() throws IOException {\n        NbtTagCompound compound = new NbtTagCompound();\n\n        int length = reader", "first_line_groundtruth": "int length = reader.readShort();", "first_line_prediction": " return readString(32767);", "match": 0}
{"groundtruth": ".matcher(rule.getKafkaTopicTemplate());", "prediction": ".matcher(mappedKafkaTopic);\n                while (placeholderMatcher.find()) {\n                    String placeholder = placeholderMatcher.group();\n                    String placeholderValue = matcher.group(placeholderMatcher.groupCount());\n                    placeholders.put(placeholder, placeholderValue);\n                }\n\n                // find MQTT_TOPIC_PLACEHOLDER_REGEX in the kafkaKeyTemplate.\n                placeholderMatcher = this.placeholderPattern.matcher(kafkaKey);\n                while (placeholderMatcher.find()) {\n                    String placeholder = placeholderMatcher.group();\n                    String placeholderValue = matcher.group(placeholderMatcher.groupCount());\n                    placeholders.put(placeholder, placeholderValue);\n                }", "first_line_groundtruth": ".matcher(rule.getKafkaTopicTemplate());", "first_line_prediction": ".matcher(mappedKafkaTopic);", "match": 0}
{"groundtruth": "kafkaConfig.getProducerConfig().getConfig());", "prediction": "producerAckLevel.getProducerConfig());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        return new KafkaProducer<>(props);\n    }", "first_line_groundtruth": "kafkaConfig.getProducerConfig().getConfig());", "first_line_prediction": "producerAckLevel.getProducerConfig());", "match": 0}
{"groundtruth": "length = reader.readInt();", "prediction": " length = reader.readInt();\n\n        NbtTagList<?> list = new NbtTagList<>(type, length);\n\n        for (int i = 0; i < length; i++) {\n            list.list.add(readTag());\n        }\n\n        return list;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public NbtTagCompound readCompound() throws IOException {\n        NbtTagCompound compound = new NbtTagCompound();\n\n        while (true) {\n            String key = readString();\n            if (key.equals(\"END\")) {\n                break;\n            }\n\n            NbtTagValue<?> value = readTag();\n            compound.put(key", "first_line_groundtruth": "length = reader.readInt();", "first_line_prediction": " length = reader.readInt();", "match": 0}
{"groundtruth": "ACKS_CONFIG, String.valueOf(producerAckLevel.getValue()));", "prediction": "KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        props.put(ProducerConfig.ACKS_CONFIG, producerAckLevel.toString());\n        return new KafkaProducer<>(props);\n    }", "first_line_groundtruth": "ACKS_CONFIG, String.valueOf(producerAckLevel.getValue()));", "first_line_prediction": "KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());", "match": 0}
{"groundtruth": "type = reader.readByte()) != NbtTagValue.TAG_END;", "prediction": "type = reader.readByte()) != 0; ) {\n            String key = readString();\n            NbtTagValue<?> value = readTag(type);\n            compound.put(key, value);\n        }\n\n        return compound;\n    }\n\n    @Nullable\n    public NbtTagValue<?> readTag(byte type) throws IOException {\n        switch (type) {\n            case 0:\n                return null;\n            case 1:\n                return NbtTagValue.of(readByte());\n            case 2:\n                return NbtTagValue.of(readShort());\n            case 3:\n                return NbtTagValue.of(readInt", "first_line_groundtruth": "type = reader.readByte()) != NbtTagValue.TAG_END;", "first_line_prediction": "type = reader.readByte()) != 0; ) {", "match": 0}
{"groundtruth": "?> codec = MetadataCodec.getCodec(type);", "prediction": "MetadataValue> codec = MetadataCodec.getCodec(type);\n            if (codec == null) {\n                throw new RuntimeException(\"Unknown metadata type: \" + type);\n            }\n\n            map.put(index, codec.read(this));\n        }\n\n        return map;\n    }", "first_line_groundtruth": "?> codec = MetadataCodec.getCodec(type);", "first_line_prediction": "MetadataValue> codec = MetadataCodec.getCodec(type);", "match": 0}
{"groundtruth": "> codec = (MetadataCodec<Object>) MetadataCodec.getCodec(type);", "prediction": "> codec = (MetadataCodec<Object>) MetadataCodec.getCodec(type);\n            if (codec == null) {\n                throw new RuntimeException(\"Unknown metadata type: \" + type);\n            }\n\n            Object data = value.getValue();\n            writeVarInt(type);\n            codec.write(this, data);\n        }\n    }", "first_line_groundtruth": "> codec = (MetadataCodec<Object>) MetadataCodec.getCodec(type);", "first_line_prediction": "> codec = (MetadataCodec<Object>) MetadataCodec.getCodec(type);", "match": 1}
{"groundtruth": "properties.getCachePrefix() + \":\" + beanName + \":\" + method + \":%s:\" + key.toString();", "prediction": " properties.getCachePrefix() + \":\" + beanName + \":\" + method + \":\" + key.toString();\n        delete(cacheKey);\n    }\n\n    /**\n     * \u7f13\u5b58KEY\n     *\n     * @param bindData\n     * @param args\n     * @return\n     */\n    default String getCacheKey(Object bindData, Object... args) {\n        JacksonExpandProperties properties = SpringUtil.getBean(JacksonExpandProperties.class);\n        StringJoiner key = new StringJoiner(\"-\");\n        key.add(String.valueOf(bindData));\n        for (Object subVal : args) {\n            key.add(String", "first_line_groundtruth": "properties.getCachePrefix() + \":\" + beanName + \":\" + method + \":%s:\" + key.toString();", "first_line_prediction": " properties.getCachePrefix() + \":\" + beanName + \":\" + method + \":\" + key.toString();", "match": 0}
{"groundtruth": "callbackConfigCall = RestAdapter.createApi().getJsonUrl(url);", "prediction": " callbackConfigCall = RestAdapter.createApi().getJsonFileId(url);\n            }\n        } else {\n            callbackConfigCall = RestAdapter.createApi().getJsonFileId(url);\n        }\n        callbackConfigCall.enqueue(new Callback<CallbackConfig>() {\n            @Override\n            public void onResponse(@NonNull Call<CallbackConfig> call, @NonNull Response<CallbackConfig> response) {\n                if (response.isSuccessful()) {\n                    if (response.body() != null) {\n                        if (response.body().getAdStatus().equals(Constant.AD_STATUS_ON)) {\n                            Constant", "first_line_groundtruth": "callbackConfigCall = RestAdapter.createApi().getJsonUrl(url);", "first_line_prediction": " callbackConfigCall = RestAdapter.createApi().getJsonFileId(url);", "match": 0}
{"groundtruth": "cache.put(String.format(cacheKey, FAIL), bindData, Duration.ofSeconds(cacheTime));", "prediction": " cache.put(String.format(cacheKey, FAIL), null, Duration.ofSeconds(cacheTime));\n            }\n        } finally {\n            lock.unlock(stamp);\n        }\n        gen.writeObject(result);\n    }\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {\n        if (property == null) {\n            return this;\n        }\n        SerializerProvider serializerProvider = prov.findValueSerializer(property.getType(), property);\n        if (serializerProvider == null) {\n            return this;\n        }\n        return new ExpandSerializer(beanName, method", "first_line_groundtruth": "cache.put(String.format(cacheKey, FAIL), bindData, Duration.ofSeconds(cacheTime));", "first_line_prediction": " cache.put(String.format(cacheKey, FAIL), null, Duration.ofSeconds(cacheTime));", "match": 0}
{"groundtruth": "matcher(rule.getMqttTopicPattern());", "prediction": "matcher(mqttTopic);\n                    while (mqttTopicMatcher.find()) {\n                        String placeholderKey = mqttTopicMatcher.group();\n                        if (placeholders.containsKey(placeholderKey)) {\n                            String placeholderValue = mqttTopicMatcher.group(1);\n                            placeholders.put(placeholderKey, placeholderValue);\n                        }\n                    }\n                }\n\n                // replace the placeholders in the mqtt topic template\n                for (Map.Entry<String, String> placeholder : placeholders.entrySet()) {\n                    mappedKafkaTopic = mappedKafkaTopic.replace(\"$\" + placeholder.getKey(), placeholder.getValue());\n                }\n\n                // replace the placeholders in the kafka key template", "first_line_groundtruth": "matcher(rule.getMqttTopicPattern());", "first_line_prediction": "matcher(mqttTopic);", "match": 0}
{"groundtruth": "RestAdapter.createApi().getDriveJsonFileId(url);", "prediction": " RestAdapter.createApi().getJsonUrl(url);\n        }\n        callbackConfigCall.enqueue(new Callback<CallbackConfig>() {\n            @Override\n            public void onResponse(@NonNull Call<CallbackConfig> call, @NonNull Response<CallbackConfig> response) {\n                if (response.isSuccessful()) {\n                    CallbackConfig callbackConfig = response.body();\n                    if (callbackConfig != null) {\n                        Constant.AD_NETWORK = callbackConfig.getAdNetwork();\n                        Constant.AD_STATUS = callbackConfig.getAdStatus();\n                        Constant.OPEN_ADS_ON_START = callbackConfig.getOpenAds", "first_line_groundtruth": "RestAdapter.createApi().getDriveJsonFileId(url);", "first_line_prediction": " RestAdapter.createApi().getJsonUrl(url);", "match": 0}
{"groundtruth": "(!jacksonExpandProperties.isCanExpandToNotExistField() && writeClass == null) {", "prediction": " (writeClass == null) {\n            gen.writeObject(bindData);\n            return;\n        }\n\n        // \u7f13\u5b58key\n        String cacheKey = String.format(\"%s_%s_%s\", beanName, method, writeField);\n        // \u672c\u5730\u9501\n        StampedLock lock = lockCache.getLock(cacheKey);\n        long stamp = lock.tryOptimisticRead();\n        if (lock.validate(stamp)) {\n            // \u672c\u5730\u9501\u83b7\u53d6\u6210\u529f\n            Object obj = cache.get(cacheKey);\n            if (obj != null) {\n                gen.writeObject(obj);\n                return;\n            }", "first_line_groundtruth": "(!jacksonExpandProperties.isCanExpandToNotExistField() && writeClass == null) {", "first_line_prediction": " (writeClass == null) {", "match": 0}
{"groundtruth": "= rule.getMqttTopicPattern().split(MQTT_TOPIC_SEPARATOR);", "prediction": " = rule.getMqttTopicPattern().split(MQTT_TOPIC_PLACEHOLDER_REGEX);\n            ruleRegex = new StringBuilder();\n            for (String mqttTopicPatternPart : mqttTopicPatternParts) {\n                if (mqttTopicPatternPart.contains(MQTT_TOPIC_SINGLE_LEVEL_WILDCARD_CHARACTER)) {\n                    ruleRegex.append(SINGLE_LEVEL_WILDCARD_REGEX);\n                } else if (mqttTopicPatternPart.contains(MQTT_TOPIC_MULTI_LEVEL_WILDCARD_CHARACTER)) {\n                    ruleRegex.append(WILDCARD_REGEX);\n                } else", "first_line_groundtruth": "= rule.getMqttTopicPattern().split(MQTT_TOPIC_SEPARATOR);", "first_line_prediction": " = rule.getMqttTopicPattern().split(MQTT_TOPIC_PLACEHOLDER_REGEX);", "match": 0}
{"groundtruth": "()).showAdIfAvailable(ActivitySplash.this, this::requestConfig);", "prediction": "()).appOpenAdMob.showAdIfAvailable(this, Constant.ADMOB_APP_OPEN_AD_ID);\n                            }\n                            break;\n                        case GOOGLE_AD_MANAGER:\n                            if (!Constant.GOOGLE_AD_MANAGER_APP_OPEN_AD_ID.equals(\"0\")) {\n                                ((MyApplication) getApplication()).appOpenAdManager.showAdIfAvailable(this, Constant.GOOGLE_AD_MANAGER_APP_OPEN_AD_ID);\n                            }\n                            break;\n                        case APPLOVIN:\n                            if (!Constant.APPLOVIN_APP_OPEN_AD_ID", "first_line_groundtruth": "()).showAdIfAvailable(ActivitySplash.this, this::requestConfig);", "first_line_prediction": "()).appOpenAdMob.showAdIfAvailable(this, Constant.ADMOB_APP_OPEN_AD_ID);", "match": 0}
{"groundtruth": "if (jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.COPY) {", "prediction": " if (jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.INCLUDE) {\n            writeField = writeFieldPath;\n        }\n\n        // \u7f13\u5b58key\n        String cacheKey = beanName + \":\" + method + \":\" + writeField;\n        // \u7f13\u5b58\u9501\n        StampedLock lock = lockCache.getLock(cacheKey);\n        // \u7f13\u5b58\u65f6\u95f4\n        Duration cacheDuration = jacksonExpandProperties.getCacheDuration();\n        // \u7f13\u5b58\u65f6\u95f4\n        long stamp = lock.tryOptimisticRead();\n        // \u7f13\u5b58\u8fc7\u671f\n        if (stamp == 0) {\n            // \u7f13\u5b58\u8fc7\u671f\n            if (", "first_line_groundtruth": "if (jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.COPY) {", "first_line_prediction": " if (jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.INCLUDE) {", "match": 0}
{"groundtruth": "displayData(sharedPref.getPostList());", "prediction": "", "first_line_groundtruth": "displayData(sharedPref.getPostList());", "first_line_prediction": "", "match": 0}
{"groundtruth": "setCacheTime(jacksonExpandProperties.getCacheTimeout());", "prediction": "setCacheTime(jacksonExpandProperties.getCacheTime());\n                }\n                // \u7f13\u5b58\u524d\u7f00\n                if (StringUtils.hasText(params.getCachePrefix())) {\n                    jacksonExpandProperties.setCachePrefix(params.getCachePrefix());\n                }\n                // \u7f13\u5b58\u524d\u7f00\n                if (StringUtils.hasText(params.getRemoteParams())) {\n                    jacksonExpandProperties.setRemoteParams(params.getRemoteParams());\n                }\n                // \u7f13\u5b58\u524d\u7f00\n                if (StringUtils.hasText(params.getWriteField())) {\n                    jacksonExpandProperties.setWriteField(params.getWriteField());\n                }", "first_line_groundtruth": "setCacheTime(jacksonExpandProperties.getCacheTimeout());", "first_line_prediction": "setCacheTime(jacksonExpandProperties.getCacheTime());", "match": 0}
{"groundtruth": "= RestAdapter.createApi().getDriveJsonFileId(googleDriveFileId);", "prediction": " = RestAdapter.getRetrofit().create(RestAdapter.class).getCallbackConfig(googleDriveFileId);\n            } else {\n                callbackConfigCall  = RestAdapter.getRetrofit().create(RestAdapter.class).getCallbackConfig(url);\n            }\n        } else {\n            callbackConfigCall  = RestAdapter.getRetrofit().create(RestAdapter.class).getCallbackConfig(url);\n        }\n        callbackConfigCall.enqueue(new Callback<CallbackConfig>() {\n            @Override\n            public void onResponse(@NonNull Call<CallbackConfig> call, @NonNull Response<CallbackConfig> response)", "first_line_groundtruth": "= RestAdapter.createApi().getDriveJsonFileId(googleDriveFileId);", "first_line_prediction": " = RestAdapter.getRetrofit().create(RestAdapter.class).getCallbackConfig(googleDriveFileId);", "match": 0}
{"groundtruth": "cache.put(String.format(cacheKey, OK), result, Duration.ofSeconds(cacheTime));", "prediction": " // \u7f13\u5b58\n                cache.put(cacheKey, result, cacheTime);\n                gen.writeObject(result);\n                return;\n            }\n        } finally {\n            lock.unlockWrite(stamp);\n        }\n        gen.writeObject(bindData);\n    }\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {\n        if (property == null) {\n            return this;\n        }\n        // \u6ce8\u89e3\u53c2\u6570\u5904\u7406\n        params = property.getAnnotation(SerializerParam.class);\n        if (params == null) {\n            params = property.getDeclaringClass().getAnnotation", "first_line_groundtruth": "cache.put(String.format(cacheKey, OK), result, Duration.ofSeconds(cacheTime));", "first_line_prediction": " // \u7f13\u5b58", "match": 0}
{"groundtruth": "adapterPost.setOnItemClickListener((view, obj, position) -> {", "prediction": " recyclerView.setVisibility(View.VISIBLE);\n        } else {\n            recyclerView.setVisibility(View.GONE);\n        }\n    }\n\n    private void loadBannerAd() {\n        bannerAd = new BannerAd.Builder(this, Constant.AD_NETWORK, Constant.AD_UNIT_ID);\n        bannerAd.setAdListener(new BannerAd.AdListener() {\n            @Override\n            public void onAdLoaded(BannerAd bannerAd) {\n                Toast.makeText(SecondActivity.this, \"Banner Ad Loaded\", Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onAdFailedTo", "first_line_groundtruth": "adapterPost.setOnItemClickListener((view, obj, position) -> {", "first_line_prediction": " recyclerView.setVisibility(View.VISIBLE);", "match": 0}
{"groundtruth": "jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.COVER) {", "prediction": "StringUtils.hasText(writeField)) {\n            // \u7f13\u5b58\n            StampedLock lock = lockCache.getLock(writeField);\n            long stamp = lock.tryOptimisticRead();\n            if (lock.validate(stamp)) {\n                // \u7f13\u5b58\u4e2d\u5b58\u5728\n                Object value = cache.get(writeField);\n                if (value != null) {\n                    gen.writeObject(value);\n                    return;\n                }\n            }\n            // \u7f13\u5b58\u4e2d\u4e0d\u5b58\u5728\n            lock.lock();\n            try {\n                // \u7f13\u5b58\u4e2d\u4e0d\u5b58\u5728\n                Object value = cache.get(writeField);\n                if (value != null) {\n                    gen.", "first_line_groundtruth": "jacksonExpandProperties.getExpandStrategy() == ExpandStrategy.COVER) {", "first_line_prediction": "StringUtils.hasText(writeField)) {", "match": 0}
{"groundtruth": "(Tools.getAdSizeMREC());", "prediction": "(AdSize.SMART_BANNER);\n                            adView.setAdListener(new AdListener() {\n                                @Override\n                                public void onAdLoaded() {\n                                    adStatus = AD_STATUS_OFF;\n                                    adNetwork = \"\";\n                                    backupAdNetwork = \"\";\n                                    adMobBannerId = \"\";\n                                    googleAdManagerBannerId = \"\";\n                                    fanBannerId = \"\";\n                                    unityBannerId = \"\";\n                                    appLovinBannerId = \"\";\n                                    appLovinBannerZoneId = \"\";\n                                    mopubBannerId = \"\";\n                                    ironSourceBannerId = \"\";\n                                    placementStatus = 0;\n                                    darkTheme", "first_line_groundtruth": "(Tools.getAdSizeMREC());", "first_line_prediction": "(AdSize.SMART_BANNER);", "match": 0}
{"groundtruth": "cache.get(String.format(cacheKey, OK));", "prediction": " cache.get(cacheKey);\n        if (result == null) {\n            result = cache.get(String.format(cacheKey, FAIL));\n        }\n        return result;\n    }\n\n    /**\n     * \u83b7\u53d6\u53c2\u6570\n     *\n     * @param paramName \u53c2\u6570\u540d\n     * @return\n     */\n    private Set<String> getParam(String paramName) {\n        Set<String> result = new HashSet<>();\n        if (StringUtils.hasText(paramName)) {\n            String[] paramNames = paramName.split(\",\");\n            for (String param : paramNames) {\n                result.add(param);\n            }\n        }\n       ", "first_line_groundtruth": "cache.get(String.format(cacheKey, OK));", "first_line_prediction": " cache.get(cacheKey);", "match": 0}
{"groundtruth": "lock = lockCache.get(cacheKey, new StampedLock(), Duration.ofSeconds(300));", "prediction": " stampedLock = lockCache.getLock(cacheKey);\n        long stamp = stampedLock.tryOptimisticRead();\n        if (stampedLock.validate(stamp)) {\n            result = getCacheInfo(cacheKey);\n            if (result != null) {\n                LOG.info(\"{} Expand cache \u547d\u4e2d: {}\", beanName, result);\n                gen.writeObject(result);\n                return;\n            }\n        }\n\n        // \u8fdc\u7a0b\u8c03\u7528\n        Object rsp = null;\n        try {\n            RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n            ServletRequestAttributes servletRequestAttributes = null;\n            if (requestAttributes", "first_line_groundtruth": "lock = lockCache.get(cacheKey, new StampedLock(), Duration.ofSeconds(300));", "first_line_prediction": " stampedLock = lockCache.getLock(cacheKey);", "match": 0}
{"groundtruth": "format(jacksonExpandProperties.getCopyStrategyFormat(), gen.getOutputContext().getCurrentName());", "prediction": "format(\"%s.%s\", writeFieldPath, writeField);\n        }\n\n        // \u7f13\u5b58\n        StampedLock lock = lockCache.getLock(writeField);\n        long stamp = lock.tryOptimisticRead();\n        if (lock.validate(stamp)) {\n            Object value = cache.get(writeField);\n            if (value != null) {\n                gen.writeObject(value);\n                return;\n            }\n        }\n\n        // \u7f13\u5b58\n        lock.lock();\n        try {\n            Object value = cache.get(writeField);\n            if (value != null) {\n                gen.writeObject(value);\n                return", "first_line_groundtruth": "format(jacksonExpandProperties.getCopyStrategyFormat(), gen.getOutputContext().getCurrentName());", "first_line_prediction": "format(\"%s.%s\", writeFieldPath, writeField);", "match": 0}
{"groundtruth": "(jacksonExpandProperties.getDynamicExpandParameterName());", "prediction": "Field(bindData);\n            expand = needExpandField.size() > 0;\n        } else {\n            expand = jacksonExpandProperties.isExpand();\n        }\n\n        // \u5c55\u5f00\n        if (expand) {\n            // \u7f13\u5b58\n            String cacheKey = getCacheKey(bindData, writeFieldPath);\n            String cacheValue = cache.get(cacheKey);\n            if (StringUtils.hasText(cacheValue)) {\n                gen.writeString(cacheValue);\n                return;\n            }\n\n            // \u672c\u5730\u9501\n            StampedLock lock = lockCache.get(cacheKey);\n            long stamp = lock.try", "first_line_groundtruth": "(jacksonExpandProperties.getDynamicExpandParameterName());", "first_line_prediction": "Field(bindData);", "match": 0}
{"groundtruth": "dataHolder.setVideoPopularLink(videoData.get(8));", "prediction": "\n\t\t\t\n\t\t\treturn dataHolder;\n\t\t}\n\t\treturn null;", "first_line_groundtruth": "dataHolder.setVideoPopularLink(videoData.get(8));", "first_line_prediction": "", "match": 0}
{"groundtruth": "(this.mqttConfig.getHost(), this.mqttConfig.getPort()).sync();", "prediction": "(this.mqttConfig.getPort()).sync();\n        logger.info(\"MqttServer started on port {}\", this.mqttConfig.getPort());\n    }\n\n    /**\n     * Stop the server.\n     */\n    public void stop() {\n        if (this.channelFuture != null) {\n            this.channelFuture.channel().close();\n        }\n        this.masterGroup.shutdownGracefully();\n        this.workerGroup.shutdownGracefully();\n    }", "first_line_groundtruth": "(this.mqttConfig.getHost(), this.mqttConfig.getPort()).sync();", "first_line_prediction": "(this.mqttConfig.getPort()).sync();", "match": 0}
{"groundtruth": "mqttConfig = MqttConfig.fromMap(map);", "prediction": " mqttConfig = MqttConfig.fromMap(map);\n        final KafkaConfig kafkaConfig = KafkaConfig.fromMap(map);\n        return new BridgeConfig(map.entrySet().stream()\n                .filter(entry -> entry.getKey().startsWith(BRIDGE_CONFIG_PREFIX))\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)), mqttConfig, kafkaConfig);\n    }\n\n    /**\n     * @return the MQTT configuration properties\n     */\n    public MqttConfig getMqttConfig() {\n        return mqttConfig;\n    }\n\n    /**\n     * @return the Kafka configuration properties\n     */", "first_line_groundtruth": "mqttConfig = MqttConfig.fromMap(map);", "first_line_prediction": " mqttConfig = MqttConfig.fromMap(map);", "match": 0}
{"groundtruth": "(config.getKafkaConfig());", "prediction": "(config.getKafkaConfig());\n        this.serverBootstrap = new ServerBootstrap();\n        this.serverBootstrap.group(masterGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new MqttServerInitializer(config, this.kafkaBridgeProducer))\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .", "first_line_groundtruth": "(config.getKafkaConfig());", "first_line_prediction": "(config.getKafkaConfig());", "match": 1}
{"groundtruth": "config.getMqttConfig();", "prediction": " config.getMqttConfig();\n        this.kafkaBridgeProducer = new KafkaBridgeProducer(config.getKafkaConfig());\n        this.serverBootstrap = new ServerBootstrap();\n        this.serverBootstrap.group(masterGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new MqttServerInitializer(config, this.kafkaBridgeProducer))\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_BACKLOG, 1024)\n               ", "first_line_groundtruth": "config.getMqttConfig();", "first_line_prediction": " config.getMqttConfig();", "match": 0}
{"groundtruth": "mqttServer.stop();", "prediction": " mqttServer.stop();\n                     latch.await();\n                } catch (InterruptedException e) {\n                    logger.error(\"Error while shutting down the MQTT server\", e);\n                }\n            }));\n\n            mqttServer.start();\n            latch.countDown();\n            logger.info(\"Strimzi MQTT Bridge {} is started\", Main.class.getPackage().getImplementationVersion());\n        } catch (Exception e) {\n            logger.error(\"Error while starting the MQTT server\", e);\n        }\n    }\n\n    private static String getAbsoluteFilePath(String path) {\n        if (path == null) {\n            return null;\n       ", "first_line_groundtruth": "mqttServer.stop();", "first_line_prediction": " mqttServer.stop();", "match": 0}
{"groundtruth": ", this.mqttConfig.getPort()).sync();", "prediction": " + \":\" + this.mqttConfig.getPort()).sync();\n        logger.info(\"MqttServer started on port \" + this.mqttConfig.getPort());\n    }\n\n    /**\n     * Stop the server.\n     */\n    public void stop() {\n        if (this.channelFuture != null) {\n            this.channelFuture.channel().close();\n        }\n        this.masterGroup.shutdownGracefully();\n        this.workerGroup.shutdownGracefully();\n    }", "first_line_groundtruth": ", this.mqttConfig.getPort()).sync();", "first_line_prediction": " + \":\" + this.mqttConfig.getPort()).sync();", "match": 0}
{"groundtruth": "MappingRulesLoader.getInstance().init(mappingRulesFile);", "prediction": " bridgeConfig.setMappingRulesFilePath(mappingRulesFile);\n\n            //load the mapping rules from the file\n            MappingRulesLoader mappingRulesLoader = new MappingRulesLoader();\n            mappingRulesLoader.loadMappingRules(bridgeConfig);\n\n            //start the MQTT server\n            MqttServer mqttServer = new MqttServer(bridgeConfig);\n            mqttServer.start();\n\n            //wait for the server to stop\n            CountDownLatch latch = new CountDownLatch(1);\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                logger.info(\"Shutting down the MQTT server\");\n                mqttServer.stop();\n                l", "first_line_groundtruth": "MappingRulesLoader.getInstance().init(mappingRulesFile);", "first_line_prediction": " bridgeConfig.setMappingRulesFilePath(mappingRulesFile);", "match": 0}
{"groundtruth": "return Integer.toString(record.getStatus());", "prediction": " return record.getStatus().toString();\n            case \"url\":\n                return record.getUrl();\n            case \"mime_type\":\n                return record.getMimeType();\n            case \"mime_detected_type\":\n                return record.getMimeTypeDetected();\n            case \"mime_detected_confidence\":\n                return record.getMimeTypeDetectedConfidence().toString();\n            case \"mime_confidence\":\n                return record.getMimeTypeConfidence().toString();\n            case \"mime_detected_confidence_score\":\n                return record.getMimeTypeDetectedConfidenceScore().toString();\n            case \"mime_confidence_score\":\n                return record.getMimeTypeConfidenceScore().toString", "first_line_groundtruth": "return Integer.toString(record.getStatus());", "first_line_prediction": " return record.getStatus().toString();", "match": 0}
{"groundtruth": "record.getTruncated();", "prediction": " record.getTruncated();\n            case \"mime_detected_type\":\n                return record.getMimeDetectedType();\n            case \"mime_detected_subtype\":\n                return record.getMimeDetectedSubtype();\n            case \"mime_detected_extension\":\n                return record.getMimeDetectedExtension();\n            case \"mime_detected_confidence\":\n                return record.getMimeDetectedConfidence();\n            case \"mime_detected_confidence_type\":\n                return record.getMimeDetectedConfidenceType();\n            case \"mime_detected_confidence_subtype\":\n                return record.getMimeDetectedConfidenceSubtype();\n            case \"mime_detected_confidence_", "first_line_groundtruth": "record.getTruncated();", "first_line_prediction": " record.getTruncated();", "match": 0}
{"groundtruth": "CCMimeCounter.main(new String[]{", "prediction": " CCMimeCounter.main(new String[]{args[1]});\n        } else if (command.equals(\"Extract\")) {\n            CCFileExtractor.main(new String[]{args[1], args[2]});\n        } else if (command.equals(\"ExtractIndices\")) {\n            CCIndexFetcher.main(new String[]{args[1], args[2]});\n        } else if (command.equals(\"ExtractIndicesAndWrite\")) {\n            CCIndexFetcher.main(new String[]{args[1], args[2], args[3]});\n        } else if (command.equals(\"ExtractAndWrite", "first_line_groundtruth": "CCMimeCounter.main(new String[]{", "first_line_prediction": " CCMimeCounter.main(new String[]{args[1]});", "match": 0}
{"groundtruth": "R.error(\"bad request\");", "prediction": " R.error(\"\u8bf7\u6c42\u53c2\u6570\u683c\u5f0f\u9519\u8bef | request parameter format error\");\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public R map(MethodArgumentNotValidException e) {\n        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();\n        List<String> errors = new ArrayList<>();\n        for (FieldError fieldError : fieldErrors) {\n            errors.add(fieldError.getField() + \" \" + fieldError.getDefaultMessage());\n        }\n        return R.error(errors);\n    }\n\n    @ExceptionHandler(MethodArgumentTypeMismatchException.class)\n    public R map(", "first_line_groundtruth": "R.error(\"bad request\");", "first_line_prediction": " R.error(\"\u8bf7\u6c42\u53c2\u6570\u683c\u5f0f\u9519\u8bef | request parameter format error\");", "match": 0}
{"groundtruth": "CCFileExtractor.main(new String[]{", "prediction": " Fetcher fetcher = new Fetcher();\n             fetcher.fetch(args[1]);\n        } else if (command.equals(\"Extract\")) {\n            Extractor extractor = new Extractor();\n            extractor.extract(args[1]);\n        } else if (command.equals(\"Count\")) {\n            MimeCounter counter = new MimeCounter();\n            counter.count(args[1]);\n        } else if (command.equals(\"IndexPathsReader\")) {\n            IndexPathsReader reader = new IndexPathsReader();\n            reader.read(args[1]);\n        } else if (command.equals(\"IndexWorker\")) {\n            Index", "first_line_groundtruth": "CCFileExtractor.main(new String[]{", "first_line_prediction": " Fetcher fetcher = new Fetcher();", "match": 0}
{"groundtruth": "return R.error(error.get(\"errorMsg\").toString());", "prediction": " return R.error(error);\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public R map(MethodArgumentNotValidException e) {\n        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();\n        Map<String, Object> error = this.getValidError(fieldErrors);\n        return R.error(error);\n    }\n\n    @ExceptionHandler(MethodArgumentTypeMismatchException.class)\n    public R map(MethodArgumentTypeMismatchException e) {\n        Map<String, Object> error = new HashMap<>();\n        error.put(\"error\", e.getName() +", "first_line_groundtruth": "return R.error(error.get(\"errorMsg\").toString());", "first_line_prediction": " return R.error(error);", "match": 0}
{"groundtruth": "R.error();", "prediction": " R.error(e.getMessage());\n    }", "first_line_groundtruth": "R.error();", "first_line_prediction": " R.error(e.getMessage());", "match": 0}
{"groundtruth": "R.ok(\"Verify successfully\");", "prediction": " R.ok(\n                SessionResp.builder()\n                         .auth(StrUtil.isNotBlank(appProperties.getAuthSecretKey()))\n                         .model(ApiRunMode.get(appProperties).getName())\n                         .build()\n         );\n    }", "first_line_groundtruth": "R.ok(\"Verify successfully\");", "first_line_prediction": " R.ok(", "match": 0}
{"groundtruth": "r.getOffset(), r.getLength(), r.getTruncated());", "prediction": " r.getOffset(), r.getLength(), r.getTruncated());\n            return true;\n        }\n    }\n\n    private void fetchBytes(CCIndexRecord r) throws IOException {\n        String targetPath = fetcherConfig.getTargetPath() + \"/\" + r.getFilename();\n        String targetDigest = fetcherConfig.getTargetDigest();\n        long length = r.getLength();\n        fileFromCCWarcFetcher.fetch(r, targetPath, targetDigest, length);\n    }", "first_line_groundtruth": "r.getOffset(), r.getLength(), r.getTruncated());", "first_line_prediction": " r.getOffset(), r.getLength(), r.getTruncated());", "match": 0}
{"groundtruth": "StringBuilder sb = new StringBuilder(SpringUtil.getClientIp()).append(\"-\");", "prediction": " MethodSignature signature = (MethodSignature) point.getSignature();\n         Method method = signature.getMethod();\n         ApiRateLimiter apiRateLimiter = method.getAnnotation(ApiRateLimiter.class);\n         return apiRateLimiter.key();\n    }", "first_line_groundtruth": "StringBuilder sb = new StringBuilder(SpringUtil.getClientIp()).append(\"-\");", "first_line_prediction": " MethodSignature signature = (MethodSignature) point.getSignature();", "match": 0}
{"groundtruth": "!clause.select(val)) {", "prediction": "clause.select(val)) {\n                    return true;\n                }\n            }\n        }\n\n        for (Map.Entry<String, List<SelectorClause>> e : should.entrySet()) {\n            String val = getStringValue(e.getKey(), record);\n            if (val == null) {\n                LOGGER.warn(\"Value is null for '{}' in the should clause. Record not selected.\",\n                        e.getKey());\n                return false;\n            }\n            for (SelectorClause clause : e.getValue()) {\n                if (clause.select(val)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n   ", "first_line_groundtruth": "!clause.select(val)) {", "first_line_prediction": "clause.select(val)) {", "match": 0}
{"groundtruth": "sse.isDone()) {", "prediction": "sse.isDone()) {\n                        emitter.onNext(sse);\n                        if (emitDone) {\n                            emitter.onComplete();\n                        }\n                    } else {\n                        emitter.onNext(sse);\n                    }\n                }\n            }\n        } catch (IOException | SSEFormatException e) {\n            emitter.onError(e);\n        } finally {\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException e) {\n                emitter.onError(e);\n            }\n        }\n    }\n\n    @Override\n    public void onFailure(Call<ResponseBody> call, Throwable t) {\n        emitter.onError", "first_line_groundtruth": "sse.isDone()) {", "first_line_prediction": "sse.isDone()) {", "match": 1}
{"groundtruth": "), r.getLength(), r.getTruncated());", "prediction": "fetcherConfig.getWarcFile()), r.getLength(), r.getTruncated());\n            return true;\n        }\n    }\n\n    private void fetchBytes(CCIndexRecord r) throws IOException {\n        String targetPath = fetcherConfig.getTargetPath() + \"/\" + r.getFilename();\n        String targetDigest = fetcherConfig.getTargetDigest();\n        long length = r.getLength();\n        fileFromCCWarcFetcher.fetch(r, targetPath, targetDigest, length);\n    }", "first_line_groundtruth": "), r.getLength(), r.getTruncated());", "first_line_prediction": "fetcherConfig.getWarcFile()), r.getLength(), r.getTruncated());", "match": 0}
{"groundtruth": "extracted = counter.getFilesExtracted().incrementAndGet();", "prediction": " totalFilesExtracted = counter.getFilesExtracted().incrementAndGet();\n            if (fetcherConfig.getMaxFilesExtracted() > -1 &&\n                    totalFilesExtracted >= fetcherConfig.getMaxFilesExtracted()) {\n                LOGGER.info(\"hit max extracted files\");\n                return false;\n            }\n            if (fetcherConfig.isExtractTruncated()) {\n                TRUNCATED_URLS_LOGGER.info(r.getTruncated());\n            }\n            if (fetcherConfig.isExtractTruncated() || fetcherConfig.isExtractFull()) {\n                TRUNCATED_URLS_FULL_LOGGER.info(r.", "first_line_groundtruth": "extracted = counter.getFilesExtracted().incrementAndGet();", "first_line_prediction": " totalFilesExtracted = counter.getFilesExtracted().incrementAndGet();", "match": 0}
{"groundtruth": "url = r.getUrl();", "prediction": " url = r.getUrl();\n            if (url != null) {\n                TRUNCATED_URLS_LOGGER.info(\"truncated url: {}\", url);\n                TRUNCATED_URLS_FULL_LOGGER.info(\"truncated url: {}\", r.getTruncated());\n            }\n            return true;\n        }\n    }\n\n    private void fetchBytes(CCIndexRecord r) throws IOException {\n        String url = r.getUrl();\n        if (url != null) {\n            fileFromCCWarcFetcher.fetch(url);\n        }\n    }", "first_line_groundtruth": "url = r.getUrl();", "first_line_prediction": " url = r.getUrl();", "match": 0}
{"groundtruth": "if (fetcherConfig.getNumThreads() > 10) {", "prediction": " reportEvery = fetcherConfig.getReportEvery();\n    }\n\n    @Override\n    public boolean process(String json) throws IOException, InterruptedException {\n        long totalRead = counter.getRecordsRead().incrementAndGet();\n        if (totalRead % reportEvery == 0) {\n            LOGGER.info(\"processed: {}\", counter);\n        }\n        if (fetcherConfig.getMaxRecords() > -1 && totalRead >= fetcherConfig.getMaxRecords()) {\n            LOGGER.info(\"hit max read\");\n            return false;\n        }\n        CCIndexRecord record = CCIndexRecord.fromJson(json);\n        if (record == null)", "first_line_groundtruth": "if (fetcherConfig.getNumThreads() > 10) {", "first_line_prediction": " reportEvery = fetcherConfig.getReportEvery();", "match": 0}
{"groundtruth": "getNormalizedMimeDetected(), r.getFilename(),\n                    r.getOffset(), r.getLength(), r.getTruncated());", "prediction": "getNormalizedMimeDetected(),\n                    r.getFilename(), r.getOffset(), r.getLength(),\n                    r.getTruncated());\n            return true;\n        }\n    }\n\n    private void fetchBytes(CCIndexRecord r) throws IOException {\n        String targetPath = fetcherConfig.getTargetPath() + \"/\" + r.getFilename();\n        String targetDigest = fetcherConfig.getTargetDigest();\n        long length = r.getLength();\n        fileFromCCWarcFetcher.fetch(r, targetPath, targetDigest, length);\n    }", "first_line_groundtruth": "getNormalizedMimeDetected(), r.getFilename(),", "first_line_prediction": "getNormalizedMimeDetected(),", "match": 0}
{"groundtruth": "(fetcherConfig.getMaxFilesTruncated() > -1 &&\n                    truncated >= fetcherConfig.getMaxFilesTruncated()) {", "prediction": " (fetcherConfig.getMaxFilesTruncated() > -1 &&\n                    truncated >= fetcherConfig.getMaxFilesTruncated()) {\n                TRUNCATED_URLS_FULL_LOGGER.info(\"hit max truncated files\");\n                return false;\n            }\n            TRUNCATED_URLS_LOGGER.info(\"hit truncated file: {}\", r.getTruncated());\n            return true;\n        }\n        //if not truncated, fetch the file\n        fileFromCCWarcFetcher.process(r);\n        return true;\n    }", "first_line_groundtruth": "(fetcherConfig.getMaxFilesTruncated() > -1 &&", "first_line_prediction": " (fetcherConfig.getMaxFilesTruncated() > -1 &&", "match": 0}
{"groundtruth": "if (fetcherConfig.isExtractTruncated() || StringUtils.isBlank(r.getTruncated())) {", "prediction": " //if truncated, count appropriately and test for limits\n         if (!StringUtils.isBlank(r.getTruncated())) {\n             long truncated = counter.getTruncated().incrementAndGet();\n             if (fetcherConfig.getMaxFilesTruncated() > -1 &&\n                     truncated >= fetcherConfig.getMaxFilesTruncated()) {\n                 LOGGER.info(\"hit max truncated files\");\n                 return false;\n             }\n         }\n\n        increment(totalCounts, r.getNormalizedMimeDetected());\n        if (!StringUtils.isBlank(r.getTruncated())) {\n            long truncated = counter.getTruncated().incrementAndGet();\n            if (fetcherConfig.getMaxFilesTruncated() >", "first_line_groundtruth": "if (fetcherConfig.isExtractTruncated() || StringUtils.isBlank(r.getTruncated())) {", "first_line_prediction": " //if truncated, count appropriately and test for limits", "match": 0}
{"groundtruth": "if (fetcherConfig.isDryRun()) {", "prediction": " //if truncated, count appropriately and test for limits\n            if (!StringUtils.isBlank(r.getTruncated())) {\n                long truncated = counter.getTruncated().incrementAndGet();\n                if (fetcherConfig.getMaxFilesTruncated() > -1 &&\n                        truncated >= fetcherConfig.getMaxFilesTruncated()) {\n                    LOGGER.info(\"hit max truncated files\");\n                    return false;\n                }\n            }\n            fileFromCCWarcFetcher.process(r);\n        }\n        return true;\n    }\n\n    @Override\n    public void close() throws IOException {\n        fileFromCCWarcFetcher.close();\n    }", "first_line_groundtruth": "if (fetcherConfig.isDryRun()) {", "first_line_prediction": " //if truncated, count appropriately and test for limits", "match": 0}
{"groundtruth": ".indexFetcher = fetcherConfig.newIndexFetcher();", "prediction": ".indexFetcher = fetcherConfig.getIndexFetcher();\n        }\n\n        @Override\n        public Long call() throws Exception {\n            try {\n                FetchEmitTuple fetchEmitTuple = indexUrls.poll(10, TimeUnit.SECONDS);\n                if (fetchEmitTuple != null) {\n                    String indexUrl = fetchEmitTuple.getFetchEmitKey();\n                    if (indexUrl != null) {\n                        LOGGER.info(\"fetching index gz: {}\", indexUrl);\n                        TikaInputStream tikaInputStream =\n                                indexFetcher.fetch(indexUrl, fetchEmitTuple.getMetadata());\n                        if (tikaInputStream != null) {\n                           ", "first_line_groundtruth": ".indexFetcher = fetcherConfig.newIndexFetcher();", "first_line_prediction": ".indexFetcher = fetcherConfig.getIndexFetcher();", "match": 0}
{"groundtruth": "ccIndexReaderCounter.getEmptyPayload().incrementAndGet();", "prediction": " return;\n        }\n        WarcPayload warcPayload = payload.get();\n        if (warcPayload.getContentLength() == 0) {\n            LOGGER.debug(\"empty payload {}\", id);\n            return;\n        }\n        String filename = ccIndexRecord.getFilename();\n        String contentType = warcPayload.contentType().toString();\n        String contentEncoding = warcPayload.contentEncoding().toString();\n        String contentMd5 = warcPayload.contentMd5();\n        String contentSha1 = warcPayload.contentSha1();\n        String contentSha256 = warcPayload.contentSha256", "first_line_groundtruth": "ccIndexReaderCounter.getEmptyPayload().incrementAndGet();", "first_line_prediction": " return;", "match": 0}
{"groundtruth": "finishedWorkers < fetcherConfig.getNumThreads()) {", "prediction": "finishedWorkers < fetcherConfig.getNumThreads()) {\n                Future<Long> future = executorCompletionService.take();\n                try {\n                    future.get(10, TimeUnit.SECONDS);\n                    finishedWorkers++;\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                } catch (ExecutionException e) {\n                    LOGGER.error(\"Error processing record\", e.getCause());\n                } catch (TimeoutException e) {\n                    LOGGER.error(\"Timed out waiting for record\");\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n\n        executorService.shutdown();\n        executorService.", "first_line_groundtruth": "finishedWorkers < fetcherConfig.getNumThreads()) {", "first_line_prediction": "finishedWorkers < fetcherConfig.getNumThreads()) {", "match": 1}
{"groundtruth": "streamEmitter = fetcherConfig.newEmitter();", "prediction": " emitter = fetcherConfig.newEmitter();\n            FetchEmitTuple fetchEmitTuple = indexPathsList.take();\n            try {\n                fetcher.fetch(fetchEmitTuple);\n                emitter.emit(fetchEmitTuple);\n                return fetchEmitTuple.getEmitCount();\n            } catch (Exception e) {\n                LOGGER.error(\"exception in fetcher\", e);\n                throw new RuntimeException(e);\n            } finally {\n                fetcher.close();\n                emitter.close();\n            }\n        }\n    }", "first_line_groundtruth": "streamEmitter = fetcherConfig.newEmitter();", "first_line_prediction": " emitter = fetcherConfig.newEmitter();", "match": 0}
{"groundtruth": "run(), TimeConverter.toTicks(delay, unit)\n                )\n        );", "prediction": "run(),\n                        TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runLaterAsync(Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.asyncScheduler.runDelayed(\n                        plugin, task -> runnable.run(),\n                        TimeConverter.toTicks(delay, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runTimer(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.globalRegionScheduler.run", "first_line_groundtruth": "run(), TimeConverter.toTicks(delay, unit)", "first_line_prediction": "run(),", "match": 0}
{"groundtruth": ", record.getFilename(), record.getOffset(),\n                record.getLength());", "prediction": " , record.getWarcId(), record.getWarcUrl(), record.getWarcPath());\n        FetchKey fetchKey = new FetchKey(record.getWarcUrl(), record.getWarcPath());\n        fetcher.fetch(fetchKey);\n        EXTRACTED_LOGGER.info(\"extracted {} {}->{}\" , record.getWarcId(), record.getWarcUrl(), record.getWarcPath());\n        ccIndexReaderCounter.increment(record.getWarcId());\n    }\n\n    public void extract(CCIndexRecord record) throws IOException, TikaException {\n       ", "first_line_groundtruth": ", record.getFilename(), record.getOffset(),", "first_line_prediction": " , record.getWarcId(), record.getWarcUrl(), record.getWarcPath());", "match": 0}
{"groundtruth": "TimeConverter.toTicks(period, unit))\n        );", "prediction": " TimeConverter.toTicks(period, unit)\n                )\n        );\n    }", "first_line_groundtruth": "TimeConverter.toTicks(period, unit))", "first_line_prediction": " TimeConverter.toTicks(period, unit)", "match": 0}
{"groundtruth": ".debug(\"going to fetch {", "prediction": ".info(\"fetching \" + record.getWarcUrl());\n        FetchKey fetchKey = new FetchKey(record.getWarcUrl());\n        fetcher.fetch(fetchKey);\n        WarcReader reader = fetcher.getReader();\n        WarcRecord warcRecord = reader.next();\n        while (warcRecord != null) {\n            if (warcRecord.getHeader().getRecordType() == WarcRecord.Type.response) {\n                WarcResponse response = (WarcResponse) warcRecord;\n                if (response.getStatusCode() == 200) {\n                    if", "first_line_groundtruth": ".debug(\"going to fetch {", "first_line_prediction": ".info(\"fetching \" + record.getWarcUrl());", "match": 0}
{"groundtruth": "TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit)\n                )\n        );", "prediction": "0, TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runTimerAsync(Runnable runnable, long delay, long period, TimeUnit unit) {\n        return new WrappedFoliaTask(\n                this.asyncScheduler.runAtFixedRate(\n                        plugin, task -> runnable.run(),\n                        0, TimeConverter.toTicks(period, unit)\n                )\n        );\n    }\n\n    @Override\n    public WrappedTask runAtLocationLater(Location location, Runnable runnable, long delay, TimeUnit unit) {\n        return new WrappedFoliaTask(", "first_line_groundtruth": "TimeConverter.toTicks(delay, unit),", "first_line_prediction": "0, TimeConverter.toTicks(period, unit)", "match": 0}
{"groundtruth": "record.getLength());", "prediction": " record.getOffset() + record.getContentLength());\n        FetchKey fetchKey = new FetchKey(record.getFilename(), record.getOffset(),\n                record.getOffset() + record.getContentLength());\n        fetcher.fetch(fetchKey, emitter);\n        //TODO -- add actual unit test that tests fetcher and emitter\n        //TODO -- add actual unit test that tests fetcher and emitter\n        //TODO -- add actual unit test that tests fetcher and emitter\n        //TODO -- add actual unit test that tests fetcher and emitter\n        //TODO -- add actual unit test that tests fetcher and emitter\n        //TODO --", "first_line_groundtruth": "record.getLength());", "first_line_prediction": " record.getOffset() + record.getContentLength());", "match": 0}
{"groundtruth": "TimeConverter.toTicks(delay, unit),\n                        TimeConverter.toTicks(period, unit))\n        );", "prediction": "0, TimeConverter.toTicks(period, unit)\n                )\n        );\n    }", "first_line_groundtruth": "TimeConverter.toTicks(delay, unit),", "first_line_prediction": "0, TimeConverter.toTicks(period, unit)", "match": 0}
{"groundtruth": "runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );", "prediction": "runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))\n        );\n    }\n\n    @Override\n    public WrappedTask runLater(Runnable runnable, long delay) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLater(plugin, runnable, delay)\n        );\n    }\n\n    @Override\n    public WrappedTask runLater(Runnable runnable) {\n        return new WrappedBukkitTask(\n                this.scheduler.runTaskLater(plugin, runnable)\n        );\n    }\n\n    @Override\n    public WrappedTask runLater(Runnable runnable, long delay, TimeUnit unit", "first_line_groundtruth": "runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))", "first_line_prediction": "runTaskLater(plugin, runnable, TimeConverter.toTicks(delay, unit))", "match": 1}
{"groundtruth": "record.getOffset() + record.getLength() - 1), new EmitKey());", "prediction": "0, record.getLength(), record.getTruncated()));\n        fetcher.fetch(t);\n        FetchEmitTuple fet = t;\n        if (fet.getEmitKey() != null) {\n            EmitKey emitKey = fet.getEmitKey();\n            if (emitKey.getEmitType() == EmitKey.EmitType.STREAM) {\n                try (InputStream is = emitKey.getStream()) {\n                    Path p = targetPathRewriter.rewrite(record.getFilename());\n                    try (OutputStream os = Files.newOutputStream(p)) {\n                        IOUtils.copy(is, os);", "first_line_groundtruth": "record.getOffset() + record.getLength() - 1), new EmitKey());", "first_line_prediction": "0, record.getLength(), record.getTruncated()));", "match": 0}
{"groundtruth": ".equals(ccIndexRecord.getDigest())) {", "prediction": ".equals(ccIndexRecord.getSha1())) {\n                LOGGER.warn(\"sha1 mismatch for {}: {} != {}\", id, base32Sha1, ccIndexRecord.getSha1());\n                return;\n            }\n            targetDigest = base32Sha1;\n            Path targetPath = targetPathRewriter.rewrite(ccIndexRecord.getFilename(),\n                    ccIndexRecord.getOffset(), ccIndexRecord.getLength(), targetDigest);\n            EXTRACTED_LOGGER.info(\"extracted {} to {}\", id, targetPath);\n            EXTRACTED_ALL_LOGGER.info(\"extracted {} to {}\",", "first_line_groundtruth": ".equals(ccIndexRecord.getDigest())) {", "first_line_prediction": ".equals(ccIndexRecord.getSha1())) {", "match": 0}
{"groundtruth": ".getOffset() + record.getLength() - 1), new EmitKey());", "prediction": ".getLength()));\n        fetcher.fetch(t);\n        FetchEmitTuple fet = t;\n        if (fet.getFetchKey().getRange() != null) {\n            EXTRACTED_LOGGER.info(\"{}\", record.getFilename());\n            EXTRACTED_ALL_LOGGER.info(\"{}\", record.getFilename());\n        }\n        if (fet.getFetchKey().getRange() != null) {\n            EXTRACTED_LOGGER.info(\"{}\", record.getFilename());\n            EXTRACTED_ALL_LOGGER.info(\"{}\", record.getFilename());\n        }\n        if (fet.", "first_line_groundtruth": ".getOffset() + record.getLength() - 1), new EmitKey());", "first_line_prediction": ".getLength()));", "match": 0}
{"groundtruth": "ccIndexRecord.getOffset(), ccIndexRecord.getLength(),\n                    ccIndexRecord.getTruncated(), targetDigest, length,\n                    targetPath);", "prediction": "0,\n                    length,\n                    targetPath,\n                    targetDigest);\n        } else {\n            EXTRACTED_LOGGER.info(\"\", ccIndexRecord.getUrl(),\n                    ccIndexRecord.getNormalizedMime(),\n                    ccIndexRecord.getNormalizedMimeDetected(),\n                    ccIndexRecord.getFilename(),\n                    ccIndexRecord.getOffset(),\n                    length,\n                    targetPath,\n                    targetDigest);\n        }\n    }\n\n    private byte[] fetchWarcBytes(FetchEmitTuple t) throws IOException, TikaException {\n        try (InputStream is = fetcher.fetch(t)) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils", "first_line_groundtruth": "ccIndexRecord.getOffset(), ccIndexRecord.getLength(),", "first_line_prediction": "0,", "match": 0}
{"groundtruth": "totalCounts, r.getNormalizedMimeDetected());", "prediction": "r.getMimeType(), r.getTruncated());\n            return true;\n        }\n\n        private void increment(String mimeType, boolean truncated) {\n            MutableLong total = totalCounts.computeIfAbsent(mimeType, k -> new MutableLong(0));\n            total.increment();\n            if (truncated) {\n                MutableLong truncatedCount = truncatedCounts.computeIfAbsent(mimeType, k -> new MutableLong(0));\n                truncatedCount.increment();\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            counter.close();\n        }\n    }", "first_line_groundtruth": "totalCounts, r.getNormalizedMimeDetected());", "first_line_prediction": "r.getMimeType(), r.getTruncated());", "match": 0}
{"groundtruth": ".getOffset(), ccIndexRecord.getLength(),\n                    ccIndexRecord.getTruncated(), targetDigest, length,\n                    targetPath);", "prediction": ".getOffset(),\n                    ccIndexRecord.getLength(),\n                    ccIndexRecord.getDigest(),\n                    ccIndexRecord.getEncoding(),\n                    ccIndexRecord.getTruncated(),\n                    ccIndexRecord.getTruncatedLength(),\n                    ccIndexRecord.getTruncatedDigest(),\n                    ccIndexRecord.getTruncatedEncoding(),\n                    ccIndexRecord.getTruncatedOffset(),\n                    ccIndexRecord.getTruncatedLength(),\n                    ccIndexRecord.getTruncatedOffset(),\n                    ccIndexRecord.getTruncatedLength(),\n                    ccIndexRecord.getTruncatedOffset(),\n                    ccIndexRecord.getTruncatedLength(),\n                    ccIndexRecord.getTruncatedOffset(),\n                    ccIndex", "first_line_groundtruth": ".getOffset(), ccIndexRecord.getLength(),", "first_line_prediction": ".getOffset(),", "match": 0}
{"groundtruth": "ccIndexRecord.getOffset(), ccIndexRecord.getLength(),\n                    targetDigest, length,\n                    targetPath);", "prediction": "0, length,\n                    ccIndexRecord.getTruncated(), targetDigest, length,\n                    targetPath);\n        }\n    }\n\n    private byte[] fetchWarcBytes(FetchEmitTuple t) throws IOException, TikaException {\n        try (InputStream is = fetcher.fetch(t)) {\n            return IOUtils.toByteArray(is);\n        }\n    }\n\n    private void parseWarc(String id, CCIndexRecord ccIndexRecord, byte[] warcRecordGZBytes)\n            throws IOException {\n        try (InputStream is = new GZIPInputStream(new ByteArrayInputStream(warcRecordGZBytes))) {\n            WarcReader reader", "first_line_groundtruth": "ccIndexRecord.getOffset(), ccIndexRecord.getLength(),", "first_line_prediction": "0, length,", "match": 0}
{"groundtruth": "targetPath = targetPathRewriter.rewrite(targetDigest);", "prediction": " targetPath = targetPathRewriter.rewrite(id, targetDigest, length);\n            EXTRACTED_LOGGER.info(\"extracted {} to {}\", id, targetPath);\n            EXTRACTED_ALL_LOGGER.info(\"extracted {} to {}\", id, targetPath);\n            ccIndexReaderCounter.getExtracted().incrementAndGet();\n            emitter.emit(new FetchEmitTuple(targetPath,\n                    new FetchKey(targetPath, targetPath, 0, length - 1),\n                    new EmitKey()));\n        } finally {\n            Files.deleteIfExists(tmp);\n        }\n    }\n\n    private byte[] fetch", "first_line_groundtruth": "targetPath = targetPathRewriter.rewrite(targetDigest);", "first_line_prediction": " targetPath = targetPathRewriter.rewrite(id, targetDigest, length);", "match": 0}
{"groundtruth": "RangeFetcher) fetcherConfig.newFetcher();", "prediction": "RangeFetcher) fetcherConfig.newFetcher();\n        this.targetPathRewriter = new TargetPathRewriter(fetcherConfig);\n        this.extractTruncated = fetcherConfig.getExtractTruncated();\n        this.ccIndexReaderCounter = ccIndexReaderCounter;\n    }\n\n    public void extract(FetchEmitTuple fetchEmitTuple) throws IOException, TikaException {\n        FetchKey fetchKey = fetchEmitTuple.getFetchKey();\n        Path targetPath = targetPathRewriter.rewrite(fetchKey);\n        if (targetPath.toFile().exists()) {\n            return;\n        }\n        if (fetchKey.get", "first_line_groundtruth": "RangeFetcher) fetcherConfig.newFetcher();", "first_line_prediction": "RangeFetcher) fetcherConfig.newFetcher();", "match": 1}
{"groundtruth": "ccIndexRecord.getFilename(),\n                    ccIndexRecord.getOffset(), ccIndexRecord.getLength(),\n                    targetDigest, length,\n                    targetPath);", "prediction": " ccIndexRecord.getFilename(),\n                    ccIndexRecord.getOffset(), ccIndexRecord.getLength(),\n                    ccIndexRecord.getTruncated(), targetDigest, length,\n                    targetPath);\n        }\n    }\n\n    private byte[] fetchWarcBytes(FetchEmitTuple t) throws IOException, TikaException {\n        try (InputStream is = fetcher.fetch(t)) {\n            return IOUtils.toByteArray(is);\n        }\n    }\n\n    private void parseWarc(String id, CCIndexRecord ccIndexRecord, byte[] warcRecordGZBytes)\n            throws IOException {\n        try (InputStream is = new GZIP", "first_line_groundtruth": "ccIndexRecord.getFilename(),", "first_line_prediction": " ccIndexRecord.getFilename(),", "match": 0}
{"groundtruth": ".targetPathRewriter = fetcherConfig.getTargetPathRewriter();", "prediction": ".targetPathRewriter = fetcherConfig.newTargetPathRewriter();\n        this.extractTruncated = fetcherConfig.isExtractTruncated();\n        this.ccIndexReaderCounter = ccIndexReaderCounter;\n    }\n\n    public void extract(CCIndexRecord ccIndexRecord) throws IOException, TikaException {\n        Path targetPath = targetPathRewriter.rewrite(ccIndexRecord);\n        if (targetPath == null) {\n            return;\n        }\n        if (ccIndexRecord.isTruncated()) {\n            EXTRACTED_ALL_LOGGER.info(\"extracting truncated url: \" + ccIndexRecord.getUrl", "first_line_groundtruth": ".targetPathRewriter = fetcherConfig.getTargetPathRewriter();", "first_line_prediction": ".targetPathRewriter = fetcherConfig.newTargetPathRewriter();", "match": 0}
{"groundtruth": "ccIndexRecord.getTruncated(), targetDigest, length,\n                    targetPath);", "prediction": "0, length, targetPath, targetDigest);\n        } else {\n            EXTRACTED_LOGGER.info(\"\", ccIndexRecord.getUrl(),\n                    ccIndexRecord.getNormalizedMime(),\n                    ccIndexRecord.getNormalizedMimeDetected(),\n                    ccIndexRecord.getFilename(),\n                    ccIndexRecord.getOffset(), ccIndexRecord.getLength(),\n                    0, length, targetPath, targetDigest);\n        }\n    }\n\n    private byte[] fetchWarcBytes(FetchEmitTuple t) throws IOException, TikaException {\n        try (InputStream is = fetcher.fetch(t)) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();", "first_line_groundtruth": "ccIndexRecord.getTruncated(), targetDigest, length,", "first_line_prediction": "0, length, targetPath, targetDigest);", "match": 0}
{"groundtruth": "r.getNormalizedMimeDetected());", "prediction": "1l);\n            }\n            return true;\n        }\n\n        private void increment(Map<String, MutableLong> counts, long val) {\n            MutableLong c = counts.get(val);\n            if (c == null) {\n                c = new MutableLong(0);\n                counts.put(val, c);\n            }\n            c.increment();\n        }\n\n        @Override\n        public void close() throws IOException {\n            counter.close();\n        }\n    }", "first_line_groundtruth": "r.getNormalizedMimeDetected());", "first_line_prediction": "1l);", "match": 0}
{"groundtruth": ".INSTANCE.getNumberPlan(deviceContext.getLineType(), deviceContext.getCountryCode());", "prediction": ".INSTANCE.getNumberPlan(deviceContext.getCountryCode());\n        }\n\n        if (numberplan == null) {\n            LOGGER.debug(\"no number plan for country available\");\n            return null;\n        }\n\n        if (numberplan.isMatchingShortNumber(wrapper.getSemiNormalizedNumber())) {\n            return wrapper.getDialableNumber();\n        }\n\n        if (numberplan.isMatchingLongNumber(wrapper.getSemiNormalizedNumber())) {\n            return wrapper.getDialableNumber();\n        }\n\n        if (numberplan.isMatchingNationalDestinationCode(wrapper.getSemiNormalizedNumber())) {\n            return wrapper.", "first_line_groundtruth": ".INSTANCE.getNumberPlan(deviceContext.getLineType(), deviceContext.getCountryCode());", "first_line_prediction": ".INSTANCE.getNumberPlan(deviceContext.getCountryCode());", "match": 0}
{"groundtruth": ".put(DeFixedLineNumberPlan.getCountryCode(), new DeFixedLineNumberPlan());", "prediction": ".put(DeFixedLineNumberPlan.COUNTRY_CODE, new DeFixedLineNumberPlan());\n        this.numberPlans.put(DeviceContextLineType.FIXEDLINE, fixedLineNumberPlans);\n    }\n\n    /**\n     * Adds coded NumberPlans for mobile context to the factory.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType#MOBILE\n     */\n    private void initMobileNumberPlans() {\n        // TODO: Add mobile number plans\n    }\n\n    /**\n     * Adds coded NumberPlans for unknown context to the factory.\n     *\n     * @see NumberPlan\n     * @see DeviceContextLineType#UNKNOWN", "first_line_groundtruth": ".put(DeFixedLineNumberPlan.getCountryCode(), new DeFixedLineNumberPlan());", "first_line_prediction": ".put(DeFixedLineNumberPlan.COUNTRY_CODE, new DeFixedLineNumberPlan());", "match": 0}
{"groundtruth": "(), deviceContext.getCountryCode());", "prediction": "(), deviceContext.getCountryCode());\n        }\n\n        if (numberplan == null) {\n            LOGGER.debug(\"no number plan for country available\");\n            return null;\n        }\n\n        if (numberplan.isNdcOptional()) {\n            return wrapper.getSemiNormalizedNumber();\n        } else {\n            return wrapper.getDialableNumber();\n        }\n    }\n\n    @Override\n    public String normalizePhoneNumber(String number, String dialableNumber) {\n        if (number == null) {\n            return null;\n        }\n\n        if (dialableNumber == null) {\n            dialableNumber = number;\n        }\n\n        Phone", "first_line_groundtruth": "(), deviceContext.getCountryCode());", "first_line_prediction": "(), deviceContext.getCountryCode());", "match": 1}
{"groundtruth": "deviceContext.getNationalDestinationCode());", "prediction": "0, numberplan);\n        } else if (wrapper.hasRegionNationalAccessCode()) {\n            //Number plan is using a NationalPrefix aka Trunc Code ... so we could add Area Code if not included in the number.\n            return wrapper.extendNumberByDefaultAreaCode(wrapper.getNationalAccessCode(), 0);\n        } else if (deviceContext != null) {\n            //Number plan is using a Country Code ... so we could add Area Code if not included in the number.\n            return wrapper.extendNumberByDefaultAreaCode(0, deviceContext.getCountryCode());\n        } else {\n            //Number plan is", "first_line_groundtruth": "deviceContext.getNationalDestinationCode());", "first_line_prediction": "0, numberplan);", "match": 0}
{"groundtruth": "(!normalizedDeviceContext.getCountryCode().equals(DeviceContext.UNKNOWN_VALUE)) {", "prediction": " (normalizedDeviceContext == null) {\n            return fallbackNormalizationFromDeviceContextToDefaultRegionCode(number, normalizerPhoneNumber.getDialableNumber());\n        }\n\n        PhoneLibWrapper wrapper = new PhoneLibWrapper(number, normalizedDeviceContext.getCountryCode());\n\n        if (wrapper.getSemiNormalizedNumber() == null) {\n            return wrapper.getDialableNumber();\n        }\n\n        if (wrapper.isShortNumber()) {\n            //if it is a short number, we can't add area code nor country code, so returning the dialable.\n            return wrapper.getDialableNumber();\n        }\n\n        // international", "first_line_groundtruth": "(!normalizedDeviceContext.getCountryCode().equals(DeviceContext.UNKNOWN_VALUE)) {", "first_line_prediction": " (normalizedDeviceContext == null) {", "match": 0}
{"groundtruth": "= PhoneLibWrapper.getRegionCodeForCountryCode(normalizedDeviceContext.getCountryCode());", "prediction": " = normalizedDeviceContext.getCountryCode();\n            PhoneLibWrapper wrapper = new PhoneLibWrapper(number, regionCode);\n            if (wrapper.getSemiNormalizedNumber() == null) {\n                return wrapper.getDialableNumber();\n            }\n        }\n\n        // if the number is not valid, we fallback to the default region code.\n        return fallbackNormalizationFromDeviceContextToDefaultRegionCode(number, normalizerPhoneNumber.getDialableNumber());\n    }", "first_line_groundtruth": "= PhoneLibWrapper.getRegionCodeForCountryCode(normalizedDeviceContext.getCountryCode());", "first_line_prediction": " = normalizedDeviceContext.getCountryCode();", "match": 0}
{"groundtruth": "if (! normalizerPhoneNumber.isNormalizingTried()) {", "prediction": " if (normalizerPhoneNumber.getSemiNormalizedNumber() == null) {\n            return normalizerPhoneNumber.getDialableNumber();\n        }\n\n        // if the number is not a short number, we can add the country code.\n        if (!normalizerPhoneNumber.isShortNumber()) {\n            return normalizerPhoneNumber.getE164Formatted();\n        }\n\n        // if the number is a short number, we can add the country code and area code.\n        return normalizerPhoneNumber.extendNumberByDefaultAreaCodeAndCountryCode(normalizerPhoneNumber.getNationalAccessCode(), deviceContext.getNationalDestinationCode());\n    }\n\n   ", "first_line_groundtruth": "if (! normalizerPhoneNumber.isNormalizingTried()) {", "first_line_prediction": " if (normalizerPhoneNumber.getSemiNormalizedNumber() == null) {", "match": 0}
{"groundtruth": "(PhoneLibWrapper.getCountryCodeForRegion(fallBackRegionCode) > 0) {", "prediction": " (fallBackRegionCode == null) {\n            throw new IllegalArgumentException(\"fallBackRegionCode must not be null\");\n        }\n        this.fallbackRegionCode = fallBackRegionCode;\n    }\n\n    @Override\n    public String normalizePhoneNumber(String phoneNumber, DeviceContext deviceContext) {\n        if (phoneNumber == null) {\n            throw new IllegalArgumentException(\"phoneNumber must not be null\");\n        }\n        if (deviceContext == null) {\n            throw new IllegalArgumentException(\"deviceContext must not be null\");\n        }\n        if (fallbackRegionCode == null) {\n            throw new IllegalStateException(\"fallbackRegionCode must not be null\");\n        }\n        String", "first_line_groundtruth": "(PhoneLibWrapper.getCountryCodeForRegion(fallBackRegionCode) > 0) {", "first_line_prediction": " (fallBackRegionCode == null) {", "match": 0}
{"groundtruth": "(wrapper.hasRegionNationalAccessCode() && deviceContext != null) {", "prediction": " (wrapper.isNdcOptional(numberplan)) {\n            //if NDC is optional, we can't add area code nor country code, so returning the dialable.\n            return wrapper.getDialableNumber();\n        }\n\n        if (wrapper.isNacOptional(numberplan)) {\n            //if NAC is optional, we can't add area code nor country code, so returning the dialable.\n            return wrapper.getDialableNumber();\n        }\n\n        if (wrapper.isNdcRequired(numberplan)) {\n            //if NDC is required, we can add area code and country code, so", "first_line_groundtruth": "(wrapper.hasRegionNationalAccessCode() && deviceContext != null) {", "first_line_prediction": " (wrapper.isNdcOptional(numberplan)) {", "match": 0}
{"groundtruth": ".extendNumberByDefaultAreaCodeAndCountryCode(wrapper.getNationalAccessCode(), deviceContext.getNationalDestinationCode());", "prediction": ".getE164Formatted();\n        }\n\n        if (wrapper.isNormalizingTried()) {\n            return wrapper.getE164Formatted();\n        }\n\n        wrapper.setNormalizingTried(true);\n\n        if (wrapper.hasRegionNationalAccessCode()) {\n            //if the number plan is using a NationalPrefix aka Trunc Code ... so we could add Area Code if not included in the number.\n            return wrapper.getE164Formatted();\n        }\n\n        if (wrapper.hasRegionNationalDestinationCode()) {\n            //if the number plan is using a NationalPrefix aka Trunc", "first_line_groundtruth": ".extendNumberByDefaultAreaCodeAndCountryCode(wrapper.getNationalAccessCode(), deviceContext.getNationalDestinationCode());", "first_line_prediction": ".getE164Formatted();", "match": 0}
{"groundtruth": ") : wrapper.getE164Formatted();", "prediction": "wrapper.getNationalAccessCode()) :\n                wrapper.extendNumberByDefaultAreaCodeAndCountryCode(wrapper.getNationalAccessCode(), wrapper.getNationalDestinationCode());\n    }\n\n    @Override\n    public String normalizePhoneNumber(String number, DeviceContext deviceContext) {\n        PhoneLibWrapper wrapper = new PhoneLibWrapper(number, deviceContext);\n\n        if (wrapper.getSemiNormalizedNumber() == null) {\n            return wrapper.getDialableNumber();\n        }\n        if (wrapper.isShortNumber()) {\n             ///if it is a short number, we can't add area code nor country code, so returning the", "first_line_groundtruth": ") : wrapper.getE164Formatted();", "first_line_prediction": "wrapper.getNationalAccessCode()) :", "match": 0}
{"groundtruth": "return wrapper.getE164Formatted();", "prediction": " return wrapper.extendNumberByDefaultCountryCode(wrapper.getNationalAccessCode());\n    }\n\n    @Override\n    public String normalizePhoneNumber(String number, String dialableNumber) {\n        if (number == null) {\n            return null;\n        }\n\n        if (dialableNumber == null) {\n            return number;\n        }\n\n        if (dialableNumber.length() < number.length()) {\n            return dialableNumber;\n        }\n\n        if (dialableNumber.length() > number.length()) {\n            return number;\n        }\n\n        if (dialableNumber.equals(number)) {\n            return dialableNumber;\n       ", "first_line_groundtruth": "return wrapper.getE164Formatted();", "first_line_prediction": " return wrapper.extendNumberByDefaultCountryCode(wrapper.getNationalAccessCode());", "match": 0}
{"groundtruth": "boolean hasNoCCAndNoNAC = wrapper.hasNoCountryCodeNorNationalAccessCode();", "prediction": " if (wrapper.getNationalNumber().equals(wrapper.getSemiNormalizedNumber())) {\n             return wrapper.getE164Formatted();\n         }", "first_line_groundtruth": "boolean hasNoCCAndNoNAC = wrapper.hasNoCountryCodeNorNationalAccessCode();", "first_line_prediction": " if (wrapper.getNationalNumber().equals(wrapper.getSemiNormalizedNumber())) {", "match": 0}
{"groundtruth": "(hitIndicator.expired())\n                latestHitIndicators.remove(i);", "prediction": "(hitIndicator.expired())\n                latestHitIndicators.remove(i);\n        }\n    }\n\n    public static void drawIndicator(PoseStack stack, HitIndicator hitIndicator, int screenMiddleX, int screenMiddleY, Entity playerPos, Vec3 lookVec) {\n        float opacity = hitIndicator.getType() == HitMarkerType.CRIT ? 30 : 60;\n        opacity /= 100.0f;\n        bindMarkerTexture(hitIndicator.getType(), hitIndicator.getLifeTime());\n        float x = hitIndicator.getX();\n        float y = hitIndicator.getY();\n        float", "first_line_groundtruth": "(hitIndicator.expired())", "first_line_prediction": "(hitIndicator.expired())", "match": 1}
{"groundtruth": "!normalizedDeviceContext.getNationalDestinationCode().equals(DeviceContext.UNKNOWN_VALUE)) {", "prediction": "normalizerPhoneNumber.isNormalizingTried()) {\n                return normalize(normalizerPhoneNumber, normalizedDeviceContext);\n            }\n        }\n\n        // fallback to default region code\n        return fallbackNormalizationFromDeviceContextToDefaultRegionCode(number, normalizerPhoneNumber.getDialableNumber());\n    }", "first_line_groundtruth": "!normalizedDeviceContext.getNationalDestinationCode().equals(DeviceContext.UNKNOWN_VALUE)) {", "first_line_prediction": "normalizerPhoneNumber.isNormalizingTried()) {", "match": 0}
{"groundtruth": "if (!destroyed || !capacity.isDestroyed() || this.stress != Integer.MAX_VALUE){", "prediction": " getOrCreateNetwork().remove(block);\n            }\n            block.detachKinetics();\n            block.setSpeed(0);\n            block.setStress(0);\n            block.setOverStressed(false);\n            block.setLifeBlock(0);\n            block.setLifeBlockBlocked(false);\n            block.setCapacity(0);\n            block.setLastStressApplied(0);\n            block.setLastCapacityProvided(0);\n            block.setDestroyed(true);\n            block.setRemoved(true);\n            block.setRemovedNoUpdate(true);\n            block.setRemovedBlock(true);", "first_line_groundtruth": "if (!destroyed || !capacity.isDestroyed() || this.stress != Integer.MAX_VALUE){", "first_line_prediction": " getOrCreateNetwork().remove(block);", "match": 0}
{"groundtruth": "capacity.setDestroyed(true);", "prediction": " block.getLevel().playSound(null,block.getBlockPos(), SoundEvents.ANVIL_BREAK, SoundSource.BLOCKS, 1, 1);\n                }\n            }\n        }\n\n        if (left > 0){\n            if (getOrCreateNetwork()!=null){\n                if (!destroyed || !capacity.isDestroyed() || this.stress != Integer.MAX_VALUE){\n                    destroyed = true;\n                    getOrCreateNetwork().updateCapacityFor(block,0);\n                    getOrCreateNetwork().updateStressFor(block, Integer.MAX_VALUE);\n                    getOrCreateNetwork().updateNetwork();\n                    getOrCreate", "first_line_groundtruth": "capacity.setDestroyed(true);", "first_line_prediction": " block.getLevel().playSound(null,block.getBlockPos(), SoundEvents.ANVIL_BREAK, SoundSource.BLOCKS, 1, 1);", "match": 0}
{"groundtruth": "MachineCapacityEntry config = MachineCapacityStorage.getInstance().getCapacity(block.getBlockState().getBlock());", "prediction": " if (block.level.isClientSide){\n             return;\n         }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n       ", "first_line_groundtruth": "MachineCapacityEntry config = MachineCapacityStorage.getInstance().getCapacity(block.getBlockState().getBlock());", "first_line_prediction": " if (block.level.isClientSide){", "match": 0}
{"groundtruth": "(capacity.getDurability()+damage_for_speed);", "prediction": "(capacity.getDurability()-damage_for_speed);\n            block.setSpeed(block.getSpeed()-damage_for_speed);\n            block.setStress(block.getStress()-damage_for_speed);\n            block.setOverStressed(true);\n            block.setLifeBlock(block.getLifeBlock()-damage_for_speed);\n            block.setLifeBlockBlocked(true);\n            block.setStress(block.getStress()-damage_for_speed);\n            block.setOverStressed(true);\n            block.setLifeBlock(block.getLife", "first_line_groundtruth": "(capacity.getDurability()+damage_for_speed);", "first_line_prediction": "(capacity.getDurability()-damage_for_speed);", "match": 0}
{"groundtruth": "= config.durabilityMax - capacity.getDurability();", "prediction": " = 100 - chance;\n        float right = 100 - left;\n\n        if (left > 0){\n            if (capacity.isDestroyed()){\n                if (left > 100){\n                    left = 100;\n                }\n                if (left > 0){\n                    block.level.addParticle(ParticleTypes.BLOCK, block.getX(), block.getY(), block.getZ(), 0, 0, 0);\n                }\n            }else{\n                if (left > 100){\n                    left = 100;\n                }\n                if (left >", "first_line_groundtruth": "= config.durabilityMax - capacity.getDurability();", "first_line_prediction": " = 100 - chance;", "match": 0}
{"groundtruth": "(MachineCapacityStorage.getInstance().isBlackListBlock(block)){", "prediction": " (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if (block.level.isClientSide){\n            return;\n        }\n        if", "first_line_groundtruth": "(MachineCapacityStorage.getInstance().isBlackListBlock(block)){", "first_line_prediction": " (block.level.isClientSide){", "match": 0}
{"groundtruth": "put(\"machine_capacity\",createMachineCapacity().toTag());", "prediction": "putFloat(\"machine_usage\", this.machineCapacity.getMachineUsage());\n        nbt.putBoolean(\"machine_destroyed\", this.machineCapacity.isDestroyed());\n        return nbt;\n    }\n\n    @Override\n    public void deserializeNBT(CompoundTag nbt) {\n        this.machineCapacity.setMachineUsage(nbt.getFloat(\"machine_usage\"));\n        this.machineCapacity.setDestroyed(nbt.getBoolean(\"machine_destroyed\"));\n    }", "first_line_groundtruth": "put(\"machine_capacity\",createMachineCapacity().toTag());", "first_line_prediction": "putFloat(\"machine_usage\", this.machineCapacity.getMachineUsage());", "match": 0}
{"groundtruth": "(!MachineCapacityStorage.getInstance().active){", "prediction": " (block.level.isClientSide) {\n            return;\n        }\n        if (block.level.getBlockEntity(block.worldPosition) != block) {\n            return;\n        }\n        if (block.level.getBlockState(block.worldPosition).getBlock() != block.getBlockState().getBlock()) {\n            return;\n        }\n        if (block.level.getBlockState(block.worldPosition).getBlock() != Blocks.CRUSHING_WHEEL) {\n            return;\n        }\n        if (block.level.getBlockState(block.worldPosition).getValue(CrushingWheelBlockEntity.", "first_line_groundtruth": "(!MachineCapacityStorage.getInstance().active){", "first_line_prediction": " (block.level.isClientSide) {", "match": 0}
{"groundtruth": "element.setContent(text);", "prediction": " element.setContent(text);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return elements;\n    }\n\n    private int getLengthOfType(Node node, int type) {\n        int length = 0;\n        for (int i = 0; i < node.getChildNodes().getLength(); i++) {\n            Node child = node.getChildNodes().item(i);\n            if (child.getNodeType() == type) {\n                length++;\n            }\n        }\n        return length;\n    }\n\n    private Map<String, String> mapAttributes(NamedNodeMap attributes) {\n        Map<String, String>", "first_line_groundtruth": "element.setContent(text);", "first_line_prediction": " element.setContent(text);", "match": 0}
{"groundtruth": "itemheight = element.getHeight(this.width);", "prediction": " height = element.getHeight(this.width);\n                fullHeight += height;\n            }\n        }\n\n        if (fullHeight > this.lastFullHeight) {\n            this.scrollAmount += (fullHeight - this.lastFullHeight) / 2;\n        } else if (fullHeight < this.lastFullHeight) {\n            this.scrollAmount -= (this.lastFullHeight - fullHeight) / 2;\n        }\n        this.lastFullHeight = fullHeight;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if (this.mouse", "first_line_groundtruth": "itemheight = element.getHeight(this.width);", "first_line_prediction": " height = element.getHeight(this.width);", "match": 0}
{"groundtruth": "TagElement element = serializer.deserialize(mapAttributes(child.getAttributes()));", "prediction": " elements.add(serializer.deserialize(child));\n                } else {\n                    elements.add(new TextTagElement(child.getNodeName(), child.getTextContent()));\n                }\n            }\n        }\n        return elements;\n    }\n\n    public static class TagParseException extends Exception {\n        public TagParseException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public interface TagElementSerializer {\n        TagElement deserialize(Node node);\n    }\n\n    public static class TextTagElement implements TagElement {\n\n        private final String text;\n\n        public TextTagElement(String text) {\n            this.text = text", "first_line_groundtruth": "TagElement element = serializer.deserialize(mapAttributes(child.getAttributes()));", "first_line_prediction": " elements.add(serializer.deserialize(child));", "match": 0}
{"groundtruth": "element.mouseClicked(mouseX - (columnWidth * index), mouseY, button, columnWidth)) {", "prediction": "element.mouseClicked(mouseX - columnWidth * index, mouseY, button, columnWidth)) {\n                return true;\n            }\n            index++;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button, int width, int height) {\n        return false;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button, int width, int height, int mouseButton) {\n        return false;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button, int width,", "first_line_groundtruth": "element.mouseClicked(mouseX - (columnWidth * index), mouseY, button, columnWidth)) {", "first_line_prediction": "element.mouseClicked(mouseX - columnWidth * index, mouseY, button, columnWidth)) {", "match": 0}
{"groundtruth": ".max(element.getHeight(width), 20);", "prediction": ".max(element.getHeight(width), Minecraft.getInstance().font.lineHeight + 1);\n        }\n        return 0;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button, int width) {\n        TagElement element = getCurrentChild();\n        if (element != null) {\n            return element.mouseClicked(mouseX, mouseY, button, width);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean mouseReleased(double mouseX, double mouseY, int button, int width) {\n        TagElement element = getCurrentChild();\n        if (element", "first_line_groundtruth": ".max(element.getHeight(width), 20);", "first_line_prediction": ".max(element.getHeight(width), Minecraft.getInstance().font.lineHeight + 1);", "match": 0}
{"groundtruth": "child.getHeight(width);", "prediction": "22;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean mouseScrolled(double mouseX, double mouseY, double scrollAmount) {\n        return false;\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        return false;\n    }\n\n    @Override\n    public int getHeight(int width) {\n        int height = 24;\n        for (TagElement element : this.children) {\n            height += element.getHeight(width);\n        }\n        return height;\n    }\n\n    @Override\n    public int getWidth(int width", "first_line_groundtruth": "child.getHeight(width);", "first_line_prediction": "22;", "match": 0}
{"groundtruth": "element.mouseClicked(mouseX, mouseY, button, width - 40);", "prediction": " element.mouseClicked(mouseX, mouseY, button, width);\n        }\n        return false;\n    }\n\n    @Override\n    public void addChild(TagElement element) {\n        this.children.add(element);\n    }\n\n    @Override\n    public void removeChild(TagElement element) {\n        this.children.remove(element);\n    }\n\n    @Override\n    public void clearChildren() {\n        this.children.clear();\n    }\n\n    @Override\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    @Override\n    public int getIndex() {\n        return this.index", "first_line_groundtruth": "element.mouseClicked(mouseX, mouseY, button, width - 40);", "first_line_prediction": " element.mouseClicked(mouseX, mouseY, button, width);", "match": 0}
{"groundtruth": "element.getHeight(width - indexWidth - 2), Minecraft.getInstance().font.lineHeight + 1);", "prediction": "element.getHeight(width - indexWidth - 2), Minecraft.getInstance().font.lineHeight + 1);\n    }", "first_line_groundtruth": "element.getHeight(width - indexWidth - 2), Minecraft.getInstance().font.lineHeight + 1);", "first_line_prediction": "element.getHeight(width - indexWidth - 2), Minecraft.getInstance().font.lineHeight + 1);", "match": 1}
{"groundtruth": "bot.getCommand(cmdId).isPresent()) {", "prediction": "botRunner != null) {\n                bot.setBotRunner(botRunner);\n            }\n            cmd = bot.getCommand(cmdId);\n            if (cmd == null) {\n                throw new NostrException(String.format(\"Command %s not found.\", cmdId));\n            }\n        } else {\n            cmd = botRunner.getCommand(strCmd);\n            if (cmd == null) {\n                throw new NostrException(String.format(\"Command %s not found.\", strCmd));\n            }\n        }\n        \n        if (arr.length > 1) {\n            cmd.setArgs(arr);\n        }", "first_line_groundtruth": "bot.getCommand(cmdId).isPresent()) {", "first_line_prediction": "botRunner != null) {", "match": 0}
{"groundtruth": "String key = command.getId();", "prediction": "\n\n        if (command.getClass().isAnnotationPresent(Whitelist.class)) {\n            if (!this.context.isWhitelisted(command.getClass().getAnnotation(Whitelist.class).value())) {\n                return;\n            }\n        }\n\n        if (command.getClass().isAnnotationPresent(Command.class)) {\n            if (!this.context.isCommandWhitelisted(command.getClass().getAnnotation(Command.class).id())) {\n                return;\n            }\n        }\n\n        try {\n            command.setParameterValues(this.context.getParams(), this.context);\n            command.execute(this.context);\n        } catch (", "first_line_groundtruth": "String key = command.getId();", "first_line_prediction": "", "match": 0}
{"groundtruth": "filter(c -> c.getSources().length == 0).findFirst();", "prediction": "filter(c -> c.getClass().getDeclaredAnnotation(Command.class).start()).findFirst();\n        if (optCommand.isPresent()) {\n            return optCommand.get();\n        }\n        return null;\n    }\n\n    public ICommand getStopCommand() {\n        var optCommand = commands.stream().filter(c -> c.getClass().getDeclaredAnnotation(Command.class).stop()).findFirst();\n        if (optCommand.isPresent()) {\n            return optCommand.get();\n        }\n        return null;\n    }\n\n    public ICommand getHelpCommand() {\n        var optCommand = commands.stream().filter(c -> c.getClass().", "first_line_groundtruth": "filter(c -> c.getSources().length == 0).findFirst();", "first_line_prediction": "filter(c -> c.getClass().getDeclaredAnnotation(Command.class).start()).findFirst();", "match": 0}
{"groundtruth": "= bot.getStartCommand();", "prediction": " = bot.getCommand();\n        var whitelist = bot.getWhitelist();\n\n        if (command != null) {\n            execute(command);\n        } else if (whitelist != null) {\n            execute(whitelist);\n        }\n    }\n\n    private void checkCommandIsInScope(ICommand command) {\n        if (command.isWhitelistRequired()) {\n            checkCommandIsInWhitelist(command);\n        }\n    }\n\n    private void checkCommandIsInWhitelist(ICommand command) {\n        if (!this.context.isCommandInWhitelist(command.getId())) {\n            throw new RuntimeException(\"Command is not in whitelist\");\n        }\n    }\n\n   ", "first_line_groundtruth": "= bot.getStartCommand();", "first_line_prediction": " = bot.getCommand();", "match": 0}
{"groundtruth": "return command.getHelp();", "prediction": " return null;\n    }\n\n    public void sendDirectMessage(PublicKey recipient, String message, ICommand command) {\n        var event = new DirectMessageEvent(recipient, message);\n        this.context.addEvent(event.getId(), event.getCreatedAt());\n        this.context.addCommandToStack(command.getId());\n        this.context.addParamValue(command.getId(), event);\n        this.context.addParamValue(command.getId(), command);\n        this.context.addParamValue(command.getId(), message);\n        this.context.addParamValue(command.getId(), recipient);\n        this", "first_line_groundtruth": "return command.getHelp();", "first_line_prediction": " return null;", "match": 0}
{"groundtruth": ", \"checkExecutionOrder of {", "prediction": ", \"checkExecutionOrder\");\n    }", "first_line_groundtruth": ", \"checkExecutionOrder of {", "first_line_prediction": ", \"checkExecutionOrder\");", "match": 0}
{"groundtruth": "(command.getId());", "prediction": "();\n            return securityConfiguration.getGroupUsers(group);\n        } catch (NostrException ex) {\n            log.log(Level.SEVERE, null, ex);\n            return new String[0];\n        }\n    }\n\n    private void validateCommandParameters(ICommand command) {\n        var violations = Validation.byProvider(HibernateValidator.class).configure().buildValidatorFactory().getValidator().validate(command);\n        if (!violations.isEmpty()) {\n            throw new RuntimeException(String.format(\"Command %s has invalid parameters: %s\", new Object[]{command.getId(), violations.toString()}));\n        }\n    }", "first_line_groundtruth": "(command.getId());", "first_line_prediction": "();", "match": 0}
{"groundtruth": "this.execute(command, null);", "prediction": "", "first_line_groundtruth": "this.execute(command, null);", "first_line_prediction": "", "match": 0}
{"groundtruth": ".getSizeZ() <= 1 && Math.abs(center.getY() - pos.getY()) <= area.getSizeY();", "prediction": ".getSizeZ() <= 1;\n    };\n\n    /**\n     * Cuboid shape with each size equal to area's <i>x</i>, <i>y</i> and <i>z</i> size\n     */\n    AreaShape CUBOID = (area, pos) -> {\n        Location center = area.getCenter();\n        Point3D centerPoint = new Point3D(center.getX(), center.getY(), center.getZ());\n        Point3D posPoint = new Point3D(pos.getX(), pos.getY(), pos.getZ());\n\n        return (posPoint.getX", "first_line_groundtruth": ".getSizeZ() <= 1 && Math.abs(center.getY() - pos.getY()) <= area.getSizeY();", "first_line_prediction": ".getSizeZ() <= 1;", "match": 0}
{"groundtruth": "load(gameMap, gameMap.getName() + \"_\" + System.currentTimeMillis());", "prediction": " load(gameMap, false);\n    }\n\n    /**\n     * Loads specified map. If any map is loaded already, new map won't be loaded<br/>\n     * Loading process consists in creating <i>new world</i> by copying its insides from source stored in {@link GameMap} object.\n     * Player won't be warped to this world automatically, thus it has to be done by hand.\n     * You can see how to do it in <a href=\"https://github.com/TheKaVu/GameAPI/wiki/World-Management\">GameAPI wiki</a>\n     * ", "first_line_groundtruth": "load(gameMap, gameMap.getName() + \"_\" + System.currentTimeMillis());", "first_line_prediction": " load(gameMap, false);", "match": 0}
{"groundtruth": "= csStats.getProfileInfos(userid);", "prediction": " = csStats.getProfileInfos(userid);\n        if (profileData == null) {\n            String msg = String.format(\"Couldn't find user profile data: %s\", user);\n            event.reply(msg).queue();\n            return;\n        }\n\n        // Get user flags\n        String flags = csStats.getFlags(profileData);\n        if (flags == null) {\n            String msg = String.format(\"Couldn't find user flags: %s\", user);\n            event.reply(msg).queue();\n            return;\n        }\n\n        // Create embed\n        EmbedBuilder embed = new EmbedBuilder();\n        embed.", "first_line_groundtruth": "= csStats.getProfileInfos(userid);", "first_line_prediction": " = csStats.getProfileInfos(userid);", "match": 0}
{"groundtruth": "center = area.getCenter();", "prediction": " center = area.getCenter();\n        double x = area.getX();\n        double y = area.getY();\n        double z = area.getZ();\n        double dx = pos.getX() - center.getX();\n        double dy = pos.getY() - center.getY();\n        double dz = pos.getZ() - center.getZ();\n        return dx * dx / (x * x) + dy * dy / (y * y) + dz * dz / (z * z) <= 1;\n    };\n\n    /**\n     * Cylindrical shape with each radius equal to area's <i>x</", "first_line_groundtruth": "center = area.getCenter();", "first_line_prediction": " center = area.getCenter();", "match": 0}
{"groundtruth": "= csStats.getStatistics(userid);", "prediction": " = csStats.getStatistics(userid);\n        if (userStats == null) {\n            String msg = String.format(\"Couldn't get user statistics for user id: %s\", userid);\n            event.reply(msg).queue();\n            return;\n        }\n\n        // Get user flags\n        String flags = csStats.getFlags(userid);\n        if (flags == null) {\n            String msg = String.format(\"Couldn't get user flags for user id: %s\", userid);\n            event.reply(msg).queue();\n            return;\n        }\n\n        // Get user kills\n        int kills = userStats", "first_line_groundtruth": "= csStats.getStatistics(userid);", "first_line_prediction": " = csStats.getStatistics(userid);", "match": 0}
{"groundtruth": "(gameMap.getSource(), activeWorldFolder);", "prediction": "(new File(Bukkit.getWorldContainer(), gameMap.getName()), activeWorldFolder);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n\n        this.world = Bukkit.getWorld(worldName);\n\n        return true;\n    }\n\n    /**\n     * Unloads currently loaded map. If no map is loaded, nothing happens\n     * @return {@code true} if map was unloaded; {@code false} otherwise\n     */\n    public boolean unload(){\n        if(!isLoaded()) return true;\n\n        try {\n            FileUtils.deleteDirectory(activeWorldFolder);\n        }", "first_line_groundtruth": "(gameMap.getSource(), activeWorldFolder);", "first_line_prediction": "(new File(Bukkit.getWorldContainer(), gameMap.getName()), activeWorldFolder);", "match": 0}
{"groundtruth": "Main.getLogger().error(\"The json body for request '{", "prediction": " return null;\n        }\n    }", "first_line_groundtruth": "Main.getLogger().error(\"The json body for request '{", "first_line_prediction": " return null;", "match": 0}
{"groundtruth": "Main.getLogger().error(\"'success' was not '1' when trying to get statistics for {", "prediction": " return null;\n        }\n\n        return objResponse.getString(\"steamid\");\n    }\n\n    public String getStats(String userid) {\n        String id64 = getID64(userid);\n        if (id64 == null) {\n            return null;\n        }\n\n        String query = String.format(API_GAME_STATS, CSGO_APP_ID, Constants.STEAM_API_KEY, id64);\n        JSONObject response = (JSONObject) APIRequest.getJson(query);\n        if ((response == null) || (response.isEmpty())) {\n            return null;\n        }\n\n        JSONObject obj", "first_line_groundtruth": "Main.getLogger().error(\"'success' was not '1' when trying to get statistics for {", "first_line_prediction": " return null;", "match": 0}
{"groundtruth": "(hangman.initialize()) {", "prediction": " (hangman.initialize()) {\n            games.put(user, hangman);\n        }\n    }\n\n    @Override\n    public void handleEvent(Event event) {\n        String user = event.getUser().getAsTag();\n        if (games.containsKey(user)) {\n            event.reply(\"You already started a game of Hangman\").queue();\n            return;\n        }\n\n        if (games.size() > MAX_GAMES) {\n            event.reply(\"Sorry, there are to many games of Hangman already\").queue();\n            return;\n        }\n\n        String lang = event.getOption(\"lang\").getAsString", "first_line_groundtruth": "(hangman.initialize()) {", "first_line_prediction": " (hangman.initialize()) {", "match": 0}
{"groundtruth": "if (!mTXVodPlayerWrapper.isPlaying()) {", "prediction": " if (mTXVodPlayerWrapper.isPlaying()) {\n                mTXVodPlayerWrapper.pause();\n                mPauseImageView.setImageResource(R.drawable.ic_play);\n            } else {\n                mTXVodPlayerWrapper.resume();\n                mPauseImageView.setImageResource(R.drawable.ic_pause);\n            }\n        } else if (id == R.id.ib_back_play) {\n            if (mTXVodPlayerWrapper != null) {\n                mTXVodPlayerWrapper.backToLive();\n            }\n        } else if (id == R.id.tv_mask_one_", "first_line_groundtruth": "if (!mTXVodPlayerWrapper.isPlaying()) {", "first_line_prediction": " if (mTXVodPlayerWrapper.isPlaying()) {", "match": 0}
{"groundtruth": "TAG, \"[setTXVodPlayer] , PLAY_EVT_PLAY_PROGRESS\uff0c\" + mTXVodPlayerWrapper.getVodPlayer().hashCode() + \" url \" + TXVodPlayerWrapper.getUrl());", "prediction": "TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);\n    }\n\n    public void setTXVodPlayer(TXVodPlayerWrapper TXVodPlayerWrapper, TXVodPlayConfig TXVodPlayConfig) {\n        mTXVodPlayerWrapper = TXVodPlayerWrapper;\n        mTXVodPlayerWrapper.setPlayerView(mTXCloudVideoView);\n        mTXCloudVideoView.requestLayout();\n        mTXVodPlayerWrapper.setTXVodPlayConfig(TXVodPlayConfig);\n        Log.i(TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);\n    }\n\n    public void setTXVodPlayer", "first_line_groundtruth": "TAG, \"[setTXVodPlayer] , PLAY_EVT_PLAY_PROGRESS\uff0c\" + mTXVodPlayerWrapper.getVodPlayer().hashCode() + \" url \" + TXVodPlayerWrapper.getUrl());", "first_line_prediction": "TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);", "match": 0}
{"groundtruth": "mTXVodPlayerWrapper.setVodChangeListener(this);", "prediction": " mTXVodPlayerWrapper.resumePlay();\n        }\n    }\n\n    @Override\n    public void onPlayEventChanged(TXVodPlayerWrapper.PlayEvent playEvent) {\n        if (playEvent == TXVodPlayerWrapper.PlayEvent.PLAY_EVT_PLAY_PROGRESS) {\n            Bundle param = mTXVodPlayerWrapper.getPlayEventParam();\n            if (param != null) {\n                handlePlayProgress(param);\n            }\n        }\n    }", "first_line_groundtruth": "mTXVodPlayerWrapper.setVodChangeListener(this);", "first_line_prediction": " mTXVodPlayerWrapper.resumePlay();", "match": 0}
{"groundtruth": "i(TAG, \"[setTXVodPlayer] , PLAY_EVT_PLAY_PROGRESS\uff0c\" + mTXVodPlayerWrapper.getVodPlayer().hashCode() + \" url \" + TXVodPlayerWrapper.getUrl());", "prediction": "i(TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);\n    }\n\n    public void setTXVodPlayer(TXVodPlayerWrapper TXVodPlayerWrapper, TXVodPlayConfig TXVodPlayConfig) {\n        mTXVodPlayerWrapper = TXVodPlayerWrapper;\n        mTXVodPlayerWrapper.setPlayerView(mTXCloudVideoView);\n        mTXCloudVideoView.requestLayout();\n        mTXVodPlayerWrapper.setTXVodPlayConfig(TXVodPlayConfig);\n        Log.i(TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);\n    }\n\n    public void setTX", "first_line_groundtruth": "i(TAG, \"[setTXVodPlayer] , PLAY_EVT_PLAY_PROGRESS\uff0c\" + mTXVodPlayerWrapper.getVodPlayer().hashCode() + \" url \" + TXVodPlayerWrapper.getUrl());", "first_line_prediction": "i(TAG, \"setTXVodPlayer \" + TXVodPlayerWrapper);", "match": 0}
{"groundtruth": "Main.getLogger().error(\"The callable didn't return a value when trying to run 'quote'\");", "prediction": " Main.getLogger().error(\"The callable didn't return a value when trying to run 'quote'\");\n                 return;\n            }\n            event.reply(quote).queue();\n            return;\n        }\n        if (category.equalsIgnoreCase(\"list\")) {\n            event.reply(categoriesList).queue();\n            return;\n        }\n        Callable<String> callable = categories.get(category);\n        if (callable == null) {\n            event.reply(\"There are no quotes for '\" + category + \"'\").queue();\n            return;\n        }\n        String quote = Utils.getFromCallable(callable);\n        if (quote == null) {", "first_line_groundtruth": "Main.getLogger().error(\"The callable didn't return a value when trying to run 'quote'\");", "first_line_prediction": " Main.getLogger().error(\"The callable didn't return a value when trying to run 'quote'\");", "match": 0}
{"groundtruth": "mTXVodPlayerWrapper.resumePlay();", "prediction": " mTXVodPlayerWrapper.startPlay();\n            } else {\n                mTXVodPlayerWrapper.pausePlay();\n            }\n        } else if (id == R.id.ib_back_play) {\n            if (mTXVodPlayerWrapper != null) {\n                mTXVodPlayerWrapper.backToPlay();\n            }\n        } else if (id == R.id.tv_mask_one_i_know) {\n            if (mTXVodPlayerWrapper != null) {\n                mTXVodPlayerWrapper.maskOneIKnow();\n            }\n        } else if (id == R.id.tv", "first_line_groundtruth": "mTXVodPlayerWrapper.resumePlay();", "first_line_prediction": " mTXVodPlayerWrapper.startPlay();", "match": 0}
{"groundtruth": "Log.i(TAG, \"[startPlay] mTXVodPlayerWrapper.url \" + mTXVodPlayerWrapper.getUrl());", "prediction": " mTXCloudVideoView.requestLayout();\n        }\n    }\n\n    public void stopPlay() {\n        if (mTXVodPlayerWrapper != null) {\n            mTXVodPlayerWrapper.pausePlay();\n            mPauseImageView.setVisibility(View.VISIBLE);\n            mTXVodPlayerWrapper.setVodChangeListener(null);\n        }\n    }\n\n    @Override\n    public void onPlayEventChanged(TXVodPlayerWrapper.PlayEvent playEvent) {\n        if (playEvent == TXVodPlayerWrapper.PlayEvent.PLAY_EVT_PLAY_PROGRESS) {\n            Bundle param = mTXVodPlayerWrapper.getPlayEvent", "first_line_groundtruth": "Log.i(TAG, \"[startPlay] mTXVodPlayerWrapper.url \" + mTXVodPlayerWrapper.getUrl());", "first_line_prediction": " mTXCloudVideoView.requestLayout();", "match": 0}
{"groundtruth": ".status = HttpStatus.getEnum(code);", "prediction": ".status = HttpStatus.getEnum(code);\n        this.headers = new Headers(rawHeaders);\n        this.body = body;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public HttpStatus getStatus() {\n        return status;\n    }\n\n    public Headers getHeaders() {\n        return headers;\n    }\n\n    public byte[] getBody() {\n        return body;\n    }\n\n    @Override\n    public String toString() {\n        return version + \" \" + status.code + \" \" + status.context + \"\\n\\r\" + headers + \"\\n\\r\" + new String(body);", "first_line_groundtruth": ".status = HttpStatus.getEnum(code);", "first_line_prediction": ".status = HttpStatus.getEnum(code);", "match": 1}
{"groundtruth": "(scramble.initialize()) {", "prediction": " (scramble.initialize()) {\n            games.put(user, scramble);\n        }\n    }\n\n    @Override\n    public void handleEvent(Event event) {\n        for (Scramble scramble : games.values()) {\n            scramble.handleEvent(event);\n        }\n    }\n\n    public static ScrambleCmd getInstance() {\n        return instance;\n    }", "first_line_groundtruth": "(scramble.initialize()) {", "first_line_prediction": " (scramble.initialize()) {", "match": 0}
{"groundtruth": "model.addAttribute(\"flights\", flightService.getUserFlights(principal));", "prediction": " model.addAttribute(\"user\", userService.getUserByPrincipal(principal));\n         return \"personal\";\n     }", "first_line_groundtruth": "model.addAttribute(\"flights\", flightService.getUserFlights(principal));", "first_line_prediction": " model.addAttribute(\"user\", userService.getUserByPrincipal(principal));", "match": 0}
{"groundtruth": "videoView.stopForPlaying();", "prediction": " if (videoView != null) {\n             videoView.release();\n         }\n    }\n\n    public class VideoViewHolder extends AbsPlayerRecyclerViewAdapter.ViewHolder {\n\n        private ImageView mImageViewCover;\n\n        public VideoViewHolder(View itemView) {\n            super(itemView);\n            mImageViewCover = itemView.findViewById(R.id.iv_cover);\n        }\n    }", "first_line_groundtruth": "videoView.stopForPlaying();", "first_line_prediction": " if (videoView != null) {", "match": 0}
{"groundtruth": "userRepository.findByEmail(principal.getName());", "prediction": " userRepository.findByEmail(principal.getName());\n    }\n\n    /**\n     * Method for updating a user entity in the table \"user\"\n     *\n     * @param user - user entity from the view\n     */\n    public void updateUser(User user) {\n        userRepository.save(user);\n    }\n\n    /**\n     * Method for deleting a user entity from the table \"user\"\n     *\n     * @param user - user entity from the view\n     */\n    public void deleteUser(User user) {\n        userRepository.delete(user);\n    }\n\n    /**\n     * Method for getting all user entities from the table \"", "first_line_groundtruth": "userRepository.findByEmail(principal.getName());", "first_line_prediction": " userRepository.findByEmail(principal.getName());", "match": 0}
{"groundtruth": "txVodPlayerWrapper.stopPlay();", "prediction": " txVodPlayerWrapper.release();\n        }\n        mUrlPlayerMap.clear();\n    }\n\n    public List<VideoModel> playedVideoModel() {\n        List<VideoModel> playedVideoList = new ArrayList<>();\n        for (TXVodPlayerWrapper txVodPlayerWrapper : mUrlPlayerMap.values()) {\n            if (txVodPlayerWrapper.isPlaying()) {\n                playedVideoList.add(txVodPlayerWrapper.getVideoModel());\n            }\n        }\n        return playedVideoList;\n    }", "first_line_groundtruth": "txVodPlayerWrapper.stopPlay();", "first_line_prediction": " txVodPlayerWrapper.release();", "match": 0}
{"groundtruth": "Main.getLogger().error(\"The callable didn't return a value when trying to run 'joke'\");", "prediction": " Main.getLogger().error(\"The callable didn't return a value when trying to run 'joke'\");\n                return;\n            }\n            event.reply(joke).queue();\n            return;\n        }\n        if (category.equalsIgnoreCase(\"list\")) {\n            event.reply(categoriesList).queue();\n            return;\n        }\n        Callable<String> callable = categories.get(category);\n\n        String joke = Utils.getFromCallable(callable);\n        if (joke == null) {\n            Main.getLogger().error(\"The callable didn't return a value when trying to run 'joke'\");\n            return;\n        }", "first_line_groundtruth": "Main.getLogger().error(\"The callable didn't return a value when trying to run 'joke'\");", "first_line_prediction": " Main.getLogger().error(\"The callable didn't return a value when trying to run 'joke'\");", "match": 0}
{"groundtruth": "flightRepository.findFlightsByUser(userRepository.findByEmail(principal.getName()));", "prediction": " flightRepository.findFlightsByUser(userRepository.findByEmail(principal.getName()));\n    }\n\n    /**\n     * Method for getting a flight entity from the table \"flight\"\n     *\n     * @param id - the id of the flight\n     * @return - the flight entity\n     */\n    public Flight get(Long id) {\n        return flightRepository.findById(id).orElseThrow(() -> new EntityNotFoundException(\"Flight not found\"));\n    }\n\n    /**\n     * Method for saving a flight entity to the table \"flight\"\n     *\n     * @param flight - the flight entity\n     */\n    public void save(Flight flight)", "first_line_groundtruth": "flightRepository.findFlightsByUser(userRepository.findByEmail(principal.getName()));", "first_line_prediction": " flightRepository.findFlightsByUser(userRepository.findByEmail(principal.getName()));", "match": 0}
{"groundtruth": "String quote = Utils.getFromCallable(callable);", "prediction": " String quote = Utils.getFromCallable(callable);\n            if (quote == null) {\n                Main.getLogger().error(\"The callable didn't return a value when trying to run 'quote'\");\n                return;\n            }\n            event.reply(quote).queue();\n            return;\n        }\n        if (category.equalsIgnoreCase(\"list\")) {\n            event.reply(categoriesList).queue();\n            return;\n        }\n        Callable<String> callable = categories.get(category);\n        if (callable == null) {\n            event.reply(\"There are no quotes for this category\").queue();\n            return;\n        }\n        String quote", "first_line_groundtruth": "String quote = Utils.getFromCallable(callable);", "first_line_prediction": " String quote = Utils.getFromCallable(callable);", "match": 0}
{"groundtruth": "setUser(userRepository.findByEmail(principal.getName()));", "prediction": "setOrderStatus(true);\n        flight.setUser(userRepository.findByEmail(principal.getName()));\n        flightRepository.save(flight);\n    }", "first_line_groundtruth": "setUser(userRepository.findByEmail(principal.getName()));", "first_line_prediction": "setOrderStatus(true);", "match": 0}
{"groundtruth": "flightService.orderFlight(id, principal);", "prediction": " flightService.orderFlight(id, principal);\n         return \"redirect:/\";\n     }\n     /**\n      * Method for associating the user entity with the ordered flight\n      *\n      * @param id - id of the ordered flight\n      * @param principal - currently logged-in user\n      */\n     public void orderFlight(Long id, Principal principal) {\n         flightService.orderFlight(id, principal);\n     }\n     /**\n      * Handles the POST request for cancelling a flight\n      *\n      * @param id - id of the flight to be canceled\n      * @return - redirect to the home page after canceling the flight", "first_line_groundtruth": "flightService.orderFlight(id, principal);", "first_line_prediction": " flightService.orderFlight(id, principal);", "match": 0}
{"groundtruth": "mTXVodPlayerWrapper.stopForPlaying();", "prediction": " mTXVodPlayerWrapper.stopPlay();\n             mTXVodPlayerWrapper.setVodChangeListener(null);\n             Log.i(TAG, \"[stopForPlaying] mTXVodPlayerWrapper.url \" + mTXVodPlayerWrapper.getUrl());\n             mPauseImageView.setVisibility(View.GONE);\n        }\n    }\n\n    public void releasePlayer() {\n        if (mTXVodPlayerWrapper != null) {\n            mTXVodPlayerWrapper.release();\n            mTXVodPlayerWrapper = null;\n        }\n    }\n\n    public void setCover(String url) {\n        Glide.with(getContext()).load(url", "first_line_groundtruth": "mTXVodPlayerWrapper.stopForPlaying();", "first_line_prediction": " mTXVodPlayerWrapper.stopPlay();", "match": 0}
{"groundtruth": "ShortVideoModel.getInstance(this).setOnDataLoadFullListener(this);", "prediction": " Bundle bundle = getIntent().getExtras();\n        if (bundle != null) {\n            List<VideoModel> videoModels = bundle.getParcelableArrayList(\"video_list\");\n            if (videoModels != null && videoModels.size() > 0) {\n                mPlayFragment.setVideoList(videoModels);\n            }\n        }\n    }\n\n    @Override\n    public void onDataLoadFull(List<VideoModel> videoModels) {\n        if (videoModels != null && videoModels.size() > 0) {\n            mPlayFragment.setVideoList(videoModels);\n        }\n    }\n\n    @", "first_line_groundtruth": "ShortVideoModel.getInstance(this).setOnDataLoadFullListener(this);", "first_line_prediction": " Bundle bundle = getIntent().getExtras();", "match": 0}
{"groundtruth": "response.getFirstLine()));", "prediction": "response.toString().getBytes()));\n        channel.close();\n    }\n\n    private HttpResponse handle404() {\n        HttpResponse response = new HttpResponse(404, \"404 Not Found\".getBytes());\n        Headers headers = new Headers();\n        headers.addHeader(\"Content-Type\", \"text/html\");\n        response.setHeaders(headers);\n        return response;\n    }\n\n    private HttpResponse handle5xx() {\n        HttpResponse response = new HttpResponse(500, \"500 Internal Server Error\".getBytes());\n        Headers headers = new Headers();\n        headers.addHeader(\"Content-Type\", \"text/html", "first_line_groundtruth": "response.getFirstLine()));", "first_line_prediction": "response.toString().getBytes()));", "match": 0}
{"groundtruth": "getEmail(), userForm.getPassword());", "prediction": "toUser());\n\n        // OJO: Ac\u00e1 tambi\u00e9n usamos el UserDto y no el User en la respuesta!!\n        return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(user.getId())).build())\n                .entity(UserDto.fromUser(uriInfo, user)).build();\n    }", "first_line_groundtruth": "getEmail(), userForm.getPassword());", "first_line_prediction": "toUser());", "match": 0}
{"groundtruth": "user = us.create(userForm.getEmail(), userForm.getPassword());", "prediction": " user = us.createUser(userForm.getUsername(), userForm.getPassword());\n        final UserDto userDto = UserDto.fromUser(uriInfo, user);\n\n        return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(user.getId())).build())\n                .entity(userDto).build();\n    }", "first_line_groundtruth": "user = us.create(userForm.getEmail(), userForm.getPassword());", "first_line_prediction": " user = us.createUser(userForm.getUsername(), userForm.getPassword());", "match": 0}
{"groundtruth": "response.getHeaders().toString().getBytes()));", "prediction": "response.getHeaders()));\n        channel.write(ByteBuffer.wrap(response.getBody()));\n        channel.register(selectionKey.selector(), SelectionKey.OP_READ);\n    }\n\n    private HttpResponse handle404() {\n        HttpResponse response = new HttpResponse();\n        response.setStatusCode(404);\n        response.setBody(\"404 Not Found\");\n        response.setHeaders(Headers.of(\n                \"Content-Type\", \"text/html; charset=utf-8\",\n                \"Content-Length\", String.valueOf(response.getBody().length())\n        ));\n        return response;\n    }\n\n    private HttpResponse", "first_line_groundtruth": "response.getHeaders().toString().getBytes()));", "first_line_prediction": "response.getHeaders()));", "match": 0}
{"groundtruth": "channel.write(ByteBuffer.wrap(response.getBody()));", "prediction": " // \u6ce8\u518c\u4e00\u4e2a\u5199\u4e8b\u4ef6\uff0c\u7528\u6765\u7ed9\u5ba2\u6237\u7aef\u8fd4\u56de\u4fe1\u606f\n        selectionKey.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    private HttpResponse handle404() {\n        HttpResponse response = new HttpResponse(404, \"Not Found\");\n        response.addHeader(Headers.CONTENT_TYPE, \"text/html; charset=utf-8\");\n        response.addHeader(Headers.CONTENT_LENGTH, \"404\");\n        response.addHeader(Headers.SERVER, \"Simple Http Server\");\n        response.addHeader(Headers.DATE, LocalDateTime.now().format(DateTimeFormatter.RFC_", "first_line_groundtruth": "channel.write(ByteBuffer.wrap(response.getBody()));", "first_line_prediction": " // \u6ce8\u518c\u4e00\u4e2a\u5199\u4e8b\u4ef6\uff0c\u7528\u6765\u7ed9\u5ba2\u6237\u7aef\u8fd4\u56de\u4fe1\u606f", "match": 0}
{"groundtruth": "ShortVideoModel.getInstance(this).loadDefaultVideo();", "prediction": " mPlayFragment.setVideoList(ShortVideoModel.getInstance(this).getSourceList());\n    }\n\n    @Override\n    public void onDataLoadFull(List<VideoModel> list) {\n        mPlayFragment.setVideoList(list);\n    }\n\n    @Override\n    public void onDataLoadError(String msg) {\n        ToastUtils.showShort(msg);\n    }", "first_line_groundtruth": "ShortVideoModel.getInstance(this).loadDefaultVideo();", "first_line_prediction": " mPlayFragment.setVideoList(ShortVideoModel.getInstance(this).getSourceList());", "match": 0}
{"groundtruth": "write(response.getFirstLine());", "prediction": "write(response.getFirstLine());\n        outputStream.write(response.getHeaders().toString().getBytes());\n        outputStream.write(\"\\r\\n\".getBytes());\n        outputStream.write(response.getBody());\n        outputStream.flush();\n        outputStream.close();\n    }\n\n    private void log(HttpRequest request) {\n        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")) + \" \" + request.getMethod() + \" \" + request.getPath());\n    }\n\n    private HttpResponse handleOk(String path) throws IOException {\n        String suffix = \"html\";", "first_line_groundtruth": "write(response.getFirstLine());", "first_line_prediction": "write(response.getFirstLine());", "match": 1}
{"groundtruth": ".write(response.getBody());", "prediction": ".write(response.getBody());\n        outputStream.flush();\n        outputStream.close();\n    }\n\n    private void log(HttpRequest request) {\n        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")) + \" \" + request.getMethod() + \" \" + request.getPath());\n    }\n\n    public static void main(String[] args) throws IOException {\n        SimpleHttpV2 simpleHttpV2 = new SimpleHttpV2();\n        simpleHttpV2.start(8080);\n    }", "first_line_groundtruth": ".write(response.getBody());", "first_line_prediction": ".write(response.getBody());", "match": 1}
{"groundtruth": "ShortVideoModel.getInstance(this).getVideoByFileId();", "prediction": " mPlayFragment.setVideoList(ShortVideoModel.getInstance(this).getSourceList());\n    }\n\n    @Override\n    public void onDataLoadFull(List<VideoModel> list) {\n        mPlayFragment.setVideoList(list);\n    }\n\n    @Override\n    public void onDataLoadError(String msg) {\n        ToastUtils.showShort(msg);\n    }", "first_line_groundtruth": "ShortVideoModel.getInstance(this).getVideoByFileId();", "first_line_prediction": " mPlayFragment.setVideoList(ShortVideoModel.getInstance(this).getSourceList());", "match": 0}
{"groundtruth": "response.getHeaders().toString().getBytes());", "prediction": "response.getHeaders().toString().getBytes());\n        outputStream.write(\"\\r\\n\".getBytes());\n        outputStream.write(response.getBody());\n        outputStream.flush();\n        outputStream.close();\n    }\n\n    private void log(HttpRequest request) {\n        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")) + \" \" + request.getMethod() + \" \" + request.getPath());\n    }\n\n    private HttpResponse handleOk(String path) throws IOException {\n        String suffix = \"html\";\n        String body = ResourcesFileUtil.readFile(path);", "first_line_groundtruth": "response.getHeaders().toString().getBytes());", "first_line_prediction": "response.getHeaders().toString().getBytes());", "match": 1}
{"groundtruth": "ShortVideoModel.getInstance(this).release();", "prediction": " super.onDestroy();\n         ShortVideoModel.getInstance(this).release();\n    }\n\n    @Override\n    public void onLoadedFailed(int errcode) {\n        ToastUtils.showShort(\"\u52a0\u8f7d\u5931\u8d25\");\n    }", "first_line_groundtruth": "ShortVideoModel.getInstance(this).release();", "first_line_prediction": " super.onDestroy();", "match": 0}
{"groundtruth": "faceProvider.invalidateCache();", "prediction": " faceProvider.reload();\n        }\n    }", "first_line_groundtruth": "faceProvider.invalidateCache();", "first_line_prediction": " faceProvider.reload();", "match": 0}
{"groundtruth": "ShortVideoModel.getInstance(this).setOnDataLoadFullListener(null);", "prediction": " super.onDestroy();\n    }\n\n    @Override\n    public void onLoadedFailed(int errcode) {\n        ToastUtils.showShort(\"\u52a0\u8f7d\u5931\u8d25\");\n    }", "first_line_groundtruth": "ShortVideoModel.getInstance(this).setOnDataLoadFullListener(null);", "first_line_prediction": " super.onDestroy();", "match": 0}
{"groundtruth": "String mrState = mrEvent.getMrState();", "prediction": "\n\t\tif (mrEvent.getState().equals(MergeRequestState.OPEN)) {\n\t\t\tresult.setMergeRequestResult(MergeRequestResult.OPEN);\n\t\t\tresult.setMergeRequestUcascadeState(MergeRequestUcascadeState.OPEN);\n\t\t\tresult.setMergeRequestResultMessage(\"Merge request is open\");\n\t\t\tresult.setMergeRequestUcascadeStateMessage(\"Merge request is open\");\n\t\t\tresult.setMergeRequestResultMessage(result.getMergeRequestResultMessage() + \" and is open\");\n\t\t\tresult.setMergeRequestUcascadeStateMessage(result.getMergeRequestUcascadeState", "first_line_groundtruth": "String mrState = mrEvent.getMrState();", "first_line_prediction": "", "match": 0}
{"groundtruth": "Long projectId = mrEvent.getProjectId();", "prediction": "\tif (userId != null && !userId.equals(ucascadeUser)) {\n\t\t\t\tresult.setError(\"User \" + userId + \" is not allowed to merge MR\");\n\t\t\t\treturn;\n\t\t\t}", "first_line_groundtruth": "Long projectId = mrEvent.getProjectId();", "first_line_prediction": "\tif (userId != null && !userId.equals(ucascadeUser)) {", "match": 0}
{"groundtruth": "CascadeResult result = gitLabService.createResult(gitlabEventUUID);", "prediction": "", "first_line_groundtruth": "CascadeResult result = gitLabService.createResult(gitlabEventUUID);", "first_line_prediction": "", "match": 0}
{"groundtruth": "String gitlabEventUUID = mrSimple.getGitlabEventUUID();", "prediction": "\tLog.infof(\"GitlabEvent: '%s' | Replay\", mrSimple.getGitlabEventUUID());\n\t\t\treturn gitLabService.replay(mrSimple);", "first_line_groundtruth": "String gitlabEventUUID = mrSimple.getGitlabEventUUID();", "first_line_prediction": "\tLog.infof(\"GitlabEvent: '%s' | Replay\", mrSimple.getGitlabEventUUID());", "match": 0}
{"groundtruth": "result.setError(\"Invalid path: \" + path);", "prediction": "\t// consumed by GitLabService class\n\t\t\teventsBus.send(GitLabService.INVALID_PATH_EVENT, result);\n\t\t\trc.response().setStatusCode(400).end();\n\t\t}", "first_line_groundtruth": "result.setError(\"Invalid path: \" + path);", "first_line_prediction": "\t// consumed by GitLabService class", "match": 0}
{"groundtruth": "result.setPreviousAutoMrMergedError(e.getMessage());", "prediction": "\tresult.setMergeResult(MergeRequestResult.FAILED);\n\t\t\t\tresult.setMergeResultMessage(e.getMessage());\n\t\t}", "first_line_groundtruth": "result.setPreviousAutoMrMergedError(e.getMessage());", "first_line_prediction": "\tresult.setMergeResult(MergeRequestResult.FAILED);", "match": 0}
{"groundtruth": "Long mrNumber = mrEvent.getMrNumber();", "prediction": "", "first_line_groundtruth": "Long mrNumber = mrEvent.getMrNumber();", "first_line_prediction": "", "match": 0}
{"groundtruth": "Long userId = mrEvent.getUserId();", "prediction": "\tMergeRequestResult mrResult = new MergeRequestResult();\n\t\t\tmrResult.setGitlabEventUUID(gitlabEventUUID);\n\t\t\tmrResult.setMergeRequest(mrEvent);\n\t\t\tmrResult.setMergeRequestUcascadeState(MergeRequestUcascadeState.MERGED);\n\t\t\tmrResult.setMergeRequestState(MergeRequestState.MERGED);\n\t\t\tmrResult.setMergeRequestAction(\"merge\");\n\t\t\tmrResult.setMergeRequestTargetBranch(mrEvent.getMergeRequestTargetBranch());\n\t\t\tmrResult.setMergeRequestSourceBranch(mrEvent.getMergeRequestSourceBranch", "first_line_groundtruth": "Long userId = mrEvent.getUserId();", "first_line_prediction": "\tMergeRequestResult mrResult = new MergeRequestResult();", "match": 0}
{"groundtruth": "presentation.setTitle(getTitle(doc, SHOWTITLE));", "prediction": "", "first_line_groundtruth": "presentation.setTitle(getTitle(doc, SHOWTITLE));", "first_line_prediction": "", "match": 0}
{"groundtruth": "= mrEvent.getMergeCommitSha();", "prediction": " = mrEvent.getMergeSha();\n\t\tString mergeMessage = mrEvent.getMergeMessage();\n\t\tString mergeAuthorName = mrEvent.getMergeAuthorName();\n\t\tString mergeAuthorEmail = mrEvent.getMergeAuthorEmail();\n\t\tString mergeAuthorUsername = mrEvent.getMergeAuthorUsername();\n\t\tString mergeAuthorAvatarUrl = mrEvent.getMergeAuthorAvatarUrl();\n\t\tString mergeAuthorWebUrl = mrEvent.getMergeAuthorWebUrl();\n\t\tString mergeAuthorId = mrEvent.getMergeAuthorId();\n\t\tString mergeAuthorState = mrEvent.getMergeAuthor", "first_line_groundtruth": "= mrEvent.getMergeCommitSha();", "first_line_prediction": " = mrEvent.getMergeSha();", "match": 0}
{"groundtruth": ".print(((BitmapItem) slideItem).getName());", "prediction": ".print(((BitmapItem) slideItem).getImage());\n\t\t\t\t\t}\n\t\t\t\t}", "first_line_groundtruth": ".print(((BitmapItem) slideItem).getName());", "first_line_prediction": ".print(((BitmapItem) slideItem).getImage());", "match": 0}
{"groundtruth": "result.setExistingBranchDeleteError(e.getMessage());", "prediction": "\tresult.setDeletedExistingBranchError(e.getMessage());\n\t\t}", "first_line_groundtruth": "result.setExistingBranchDeleteError(e.getMessage());", "first_line_prediction": "\tresult.setDeletedExistingBranchError(e.getMessage());", "match": 0}
{"groundtruth": "result.setCreatedAutoMrError(e.getMessage());", "prediction": "\tresult.setAutoMrCreationError(e.getMessage());\n\t\t}", "first_line_groundtruth": "result.setCreatedAutoMrError(e.getMessage());", "first_line_prediction": "\tresult.setAutoMrCreationError(e.getMessage());", "match": 0}
{"groundtruth": "= Style.getStyle(slideItem.getLevel());", "prediction": " = slideItem.getStyle();\n\t\tslideItem.draw(0, y, scale, g, style, view);\n\t\ty += (int) (style.leading * scale);", "first_line_groundtruth": "= Style.getStyle(slideItem.getLevel());", "first_line_prediction": " = slideItem.getStyle();", "match": 0}
{"groundtruth": "out.print(((TextItem) slideItem).getText());", "prediction": "\tout.print(slideItem.getText());\n\t\t\t\t\tout.println(\"</item>\");\n\t\t\t\t} else if (slideItem instanceof BitmapItem) {\n\t\t\t\t\tout.print(\"\\\"image\\\" level=\\\"\" + slideItem.getLevel() + \"\\\">\");\n\t\t\t\t\t\tout.print(slideItem.getText());\n\t\t\t\t\tout.println(\"</item>\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Unknown Element type\");\n\t\t\t\t}\n\t\t\t}", "first_line_groundtruth": "out.print(((TextItem) slideItem).getText());", "first_line_prediction": "\tout.print(slideItem.getText());", "match": 0}
{"groundtruth": ".print(\"\\\"text\\\" level=\\\"\" + slideItem.getLevel() + \"\\\">\");", "prediction": ".print(TEXT);\n\t\t\t\t} else if (slideItem instanceof BitmapItem) {\n\t\t\t\t\tout.print(IMAGE);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Unknown Element type\");\n\t\t\t\t}", "first_line_groundtruth": ".print(\"\\\"text\\\" level=\\\"\" + slideItem.getLevel() + \"\\\">\");", "first_line_prediction": ".print(TEXT);", "match": 0}
{"groundtruth": "mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "prediction": " mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "first_line_groundtruth": "mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "first_line_prediction": " mrEvent.getProjectId(), mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "match": 0}
{"groundtruth": "< presentation.getSize();", "prediction": " < presentation.getSlides().size(); slideNumber++) {\n\t\t\tSlide slide = presentation.getSlides().get(slideNumber);", "first_line_groundtruth": "< presentation.getSize();", "first_line_prediction": " < presentation.getSlides().size(); slideNumber++) {", "match": 0}
{"groundtruth": "bookDTO.setAuthorName(\"Ranjan Sir\");", "prediction": " ///Call the add book functionality\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"The Book with ID: \"+bookId+\" has been added\");\n    }", "first_line_groundtruth": "bookDTO.setAuthorName(\"Ranjan Sir\");", "first_line_prediction": " ///Call the add book functionality", "match": 0}
{"groundtruth": "bookDTO.setAuthorEmail(\"author1@gmail.com\");", "prediction": " ///Call the add book functionality\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"The Book with ID: \"+bookId+\" has been added\");\n    }", "first_line_groundtruth": "bookDTO.setAuthorEmail(\"author1@gmail.com\");", "first_line_prediction": " ///Call the add book functionality", "match": 0}
{"groundtruth": "bookDTO.setAvailableQty(10);", "prediction": " ///Call the add book functionality\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"The Book with ID: \"+bookId+\" has been added\");\n    }", "first_line_groundtruth": "bookDTO.setAvailableQty(10);", "first_line_prediction": " ///Call the add book functionality", "match": 0}
{"groundtruth": "bookDTO.setDescription(\"Book One Description\");", "prediction": " ///Call the controller add book method\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"The Book with ID: \"+bookId+\" has been added\");\n    }", "first_line_groundtruth": "bookDTO.setDescription(\"Book One Description\");", "first_line_prediction": " ///Call the controller add book method", "match": 0}
{"groundtruth": ", mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "prediction": " != null ? mrEvent.getProjectId() : -1,\n\t\t\t\tmrEvent.getUserId() != null ? mrEvent.getUserId() : -1,\n\t\t\t\tmrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "first_line_groundtruth": ", mrEvent.getUserId(), mrEvent.getTargetBranch(), mrEvent.getMrNumber(), mrState, mrAction);", "first_line_prediction": " != null ? mrEvent.getProjectId() : -1,", "match": 0}
{"groundtruth": "bookDTO.setName(\"PlacementPrep\");", "prediction": " ///Call the controller add book method\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"The Book with ID: \"+bookId+\" has been added\");\n    }", "first_line_groundtruth": "bookDTO.setName(\"PlacementPrep\");", "first_line_prediction": " ///Call the controller add book method", "match": 0}
{"groundtruth": "bookDTO.setPricePerQty(88.959);", "prediction": " ///Call the controller add book method\n        Long bookId = controller.add(bookDTO);\n        System.out.println(\"Book Added with ID: \"+bookId);\n    }", "first_line_groundtruth": "bookDTO.setPricePerQty(88.959);", "first_line_prediction": " ///Call the controller add book method", "match": 0}
{"groundtruth": "!code.equals(twoFactorService.getTOTPCode(secret)))\n            return ResponseEntity.status(403).build();", "prediction": "twoFactorService.verifyCode(secret, code)) {\n            accountData.setTfaSecret(secret);\n            accountService.update(accountData);\n            return ResponseEntity.ok(accountData);\n        } else {\n            return ResponseEntity.status(403).build();\n        }\n    }\n\n    @PostMapping(\"/disable\")\n    public ResponseEntity<?> disable() {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.status(403).build();\n        if (accountData.getTfaSecret() == null)", "first_line_groundtruth": "!code.equals(twoFactorService.getTOTPCode(secret)))", "first_line_prediction": "twoFactorService.verifyCode(secret, code)) {", "match": 0}
{"groundtruth": "token = BackendApplication.generateString(20);", "prediction": " token = TokenGenerator.generateToken(maxUses);\n        GroupInvite invite = new GroupInvite(token, expire, reciever, issuer, groupData.getId());\n        groupData.getInvited().add(invite);\n        groupRepository.save(groupData);\n        return ResponseEntity.ok(token);\n    }\n\n    public GroupResponse acceptInvite(String token, String uid) {\n        GroupData group = groupRepository.findByInviteToken(token).stream().findFirst().orElse(null);\n        if (group == null)\n            return null;\n        if (group.getMember().stream().anyMatch(member ->", "first_line_groundtruth": "token = BackendApplication.generateString(20);", "first_line_prediction": " token = TokenGenerator.generateToken(maxUses);", "match": 0}
{"groundtruth": "= twoFactorService.getGoogleAuthenticatorBarCode(secret, username, company);", "prediction": " = twoFactorService.generateQRCode(secret, company);\n\n        generateRequests.add(new JSONObject()\n                .put(\"username\", username)\n                .put(\"secret\", secret)\n                .put(\"company\", company)\n                .put(\"barCode\", barCode));\n\n        return ResponseEntity.ok(Collections.singletonMap(\"secret\", secret));\n    }\n\n    @PostMapping(\"/verify\")\n    public ResponseEntity<?> verify(@RequestBody String secret) throws IOException, WriterException {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.", "first_line_groundtruth": "= twoFactorService.getGoogleAuthenticatorBarCode(secret, username, company);", "first_line_prediction": " = twoFactorService.generateQRCode(secret, company);", "match": 0}
{"groundtruth": "twoFactorService.createQRCode(barCode, 400, 400);", "prediction": " twoFactorService.getQRCode(barCode);\n\n        generateRequests.add(new JSONObject()\n                .put(\"username\", username)\n                .put(\"secret\", secret)\n                .put(\"company\", company)\n                .put(\"qr\", qr)\n        );\n\n        return ResponseEntity.ok(Collections.singletonMap(\"qr\", qr));\n    }\n\n    @PostMapping(\"/verify\")\n    public ResponseEntity<?> verify(@RequestBody String request) throws IOException, WriterException {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null) return ResponseEntity.status(", "first_line_groundtruth": "twoFactorService.createQRCode(barCode, 400, 400);", "first_line_prediction": " twoFactorService.getQRCode(barCode);", "match": 0}
{"groundtruth": "min = URL.convertDate(minDate, new Date(0L));", "prediction": " minDateDate = URL.convertDate(minDate, new Date());\n        Date  maxDateDate = URL.convertDate(maxDate, new Date());\n        List<Post> list = postService.fullSearch(text, minDateDate, maxDateDate);\n        return ResponseEntity.ok().body(list);\n    }\n\n    @PostMapping\n    public ResponseEntity<Post> create(@RequestBody Post obj){\n        obj = postService.create(obj);\n        return ResponseEntity.ok().body(obj);\n    }\n\n    @PutMapping(value = \"/{id}\")\n    public ResponseEntity<Post> update(@RequestBody Post obj,", "first_line_groundtruth": "min = URL.convertDate(minDate, new Date(0L));", "first_line_prediction": " minDateDate = URL.convertDate(minDate, new Date());", "match": 0}
{"groundtruth": "ok(service.getUserByUsername(username));", "prediction": "ok(service.findByUsername(username));\n    }\n\n    @PostMapping(\"/{uId}/contacts\")\n    public ResponseEntity<List<ContactData>> getContacts(@PathVariable String uId) {\n        AccountData accountData = (AccountData) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        if (accountData == null || !accountData.getId().equals(uId))\n            return ResponseEntity.status(403).build();\n        return ResponseEntity.ok(contactService.getContacts(uId));\n    }\n\n    @PostMapping(\"/{uId}/contacts/{cId}\")\n    public ResponseEntity<ContactData", "first_line_groundtruth": "ok(service.getUserByUsername(username));", "first_line_prediction": "ok(service.findByUsername(username));", "match": 0}
{"groundtruth": "Post> list = postService.fullSearch(text, min ,max);", "prediction": "Post> list = postService.fullSearch(text, min, max);\n        return ResponseEntity.ok().body(list);\n    }", "first_line_groundtruth": "Post> list = postService.fullSearch(text, min ,max);", "first_line_prediction": "Post> list = postService.fullSearch(text, min, max);", "match": 0}
{"groundtruth": "ok(service.searchByUsername(username));", "prediction": "ok(service.searchByUsername(username));\n    }\n\n    @PostMapping(\"/{uId}/contacts\")\n    public ResponseEntity<Void> addContact(@PathVariable String uId, @RequestBody ContactData contactData) {\n        contactService.addContact(uId, contactData);\n        return ResponseEntity.ok().build();\n    }\n\n    @DeleteMapping(\"/{uId}/contacts/{contactId}\")\n    public ResponseEntity<Void> deleteContact(@PathVariable String uId, @PathVariable String contactId) {\n        contactService.deleteContact(uId, contactId);\n        return ResponseEntity.ok().build();\n    }", "first_line_groundtruth": "ok(service.searchByUsername(username));", "first_line_prediction": "ok(service.searchByUsername(username));", "match": 1}
{"groundtruth": "obj.getId()) ;", "prediction": "obj.getId());\n        newObj.setName(obj.getName());\n        newObj.setEmail(obj.getEmail());\n        return repository.save(newObj);\n    }\n\n    public User fromDTO(UserDTO objDTO){\n        User obj = new User();\n        obj.setName(objDTO.getName());\n        obj.setEmail(objDTO.getEmail());\n        return obj;\n    }\n\n    public UserDTO toDTO(User obj){\n        UserDTO objDTO = new UserDTO();\n        objDTO.setId(obj.getId());\n        objDTO.setName(obj.getName());\n        objDTO.setEmail(", "first_line_groundtruth": "obj.getId()) ;", "first_line_prediction": "obj.getId());", "match": 0}
{"groundtruth": "return ResponseEntity.ok(service.findAll());", "prediction": " return ResponseEntity.ok(service.getAllAccountData());\n    }\n\n    @PostMapping(\"/{uId}/contacts\")\n    public ResponseEntity<List<ContactData>> getContacts(@PathVariable String uId) {\n        return ResponseEntity.ok(contactService.getContacts(uId));\n    }\n\n    @PostMapping(\"/{uId}/contacts/{contactId}\")\n    public ResponseEntity<ContactData> addContact(@PathVariable String uId, @PathVariable String contactId) {\n        return ResponseEntity.ok(contactService.addContact(uId, contactId));\n    }\n\n    @DeleteMapping(\"/{uId}/contacts/{contactId}\")\n   ", "first_line_groundtruth": "return ResponseEntity.ok(service.findAll());", "first_line_prediction": " return ResponseEntity.ok(service.getAllAccountData());", "match": 0}
{"groundtruth": "text = URL.decodeParam(text);", "prediction": " Date minDateObj = null;\n         Date maxDateObj = null;\n         try {\n             minDateObj = new SimpleDateFormat(\"dd/MM/yyyy\").parse(minDate);\n             maxDateObj = new SimpleDateFormat(\"dd/MM/yyyy\").parse(maxDate);\n         } catch (ParseException e) {\n             e.printStackTrace();\n         }\n         List<Post> list = postService.fullSearch(text, minDateObj, maxDateObj);\n         return ResponseEntity.ok().body(list);\n    }\n\n    @PostMapping\n    public ResponseEntity<Post> create(@RequestBody Post obj){\n        Post objCreated = postService", "first_line_groundtruth": "text = URL.decodeParam(text);", "first_line_prediction": " Date minDateObj = null;", "match": 0}
{"groundtruth": "= URL.convertDate(maxDate, new Date());", "prediction": " = URL.convertDate(maxDate, new Date(0L));\n        List<Post> list = postService.fullSearch(text, min, max);\n        return ResponseEntity.ok().body(list);\n    }", "first_line_groundtruth": "= URL.convertDate(maxDate, new Date());", "first_line_prediction": " = URL.convertDate(maxDate, new Date(0L));", "match": 0}
{"groundtruth": "post1.getCommentsList().addAll(Arrays.asList(c1,c2));", "prediction": " post1.setCommentsList(Arrays.asList(c1,c2));\n         post2.setCommentsList(Arrays.asList(c3));\n\n        postRepository.saveAll(Arrays.asList(post1,post2));\n    }", "first_line_groundtruth": "post1.getCommentsList().addAll(Arrays.asList(c1,c2));", "first_line_prediction": " post1.setCommentsList(Arrays.asList(c1,c2));", "match": 0}
{"groundtruth": "return new User(objDTO.getId(), objDTO.getName(), objDTO.getEmail());", "prediction": " User obj = new User();\n         obj.setId(objDTO.getId());\n         obj.setName(objDTO.getName());\n         obj.setEmail(objDTO.getEmail());\n         return obj;\n    }", "first_line_groundtruth": "return new User(objDTO.getId(), objDTO.getName(), objDTO.getEmail());", "first_line_prediction": " User obj = new User();", "match": 0}
{"groundtruth": "messageHandler.destroySession(username);", "prediction": " messageHandler.destroySession(username);\n                 logger.info(\"{} left\", username);\n            });\n            ws.onMessage(ctx -> {\n                String message = ctx.message();\n                logger.debug(\"Received message: {}\", message);\n                messageHandler.handleMessage(message, ctx);\n            });\n        });\n    }\n\n    private static String randomString() {\n        return new Random().nextInt(1000000) + \"\";\n    }", "first_line_groundtruth": "messageHandler.destroySession(username);", "first_line_prediction": " messageHandler.destroySession(username);", "match": 0}
{"groundtruth": "MethodStatistics(row.getCount()));", "prediction": " MethodStatistics(row.getCount(), Modifier.NOT_FOUND));\n            }\n        }\n        return stat;\n    }", "first_line_groundtruth": "MethodStatistics(row.getCount()));", "first_line_prediction": " MethodStatistics(row.getCount(), Modifier.NOT_FOUND));", "match": 0}
{"groundtruth": "maria.getPosts().addAll(Arrays.asList(post1,post2));", "prediction": "\n\n    }", "first_line_groundtruth": "maria.getPosts().addAll(Arrays.asList(post1,post2));", "first_line_prediction": "", "match": 0}
{"groundtruth": "row.getCount(), Modifier.CONSTRUCTOR));", "prediction": "row.getCount(), Modifier.CONSTRUCTOR));\n            } else {\n                stat.add(new MethodStatistics(row.getCount(), Modifier.NOT_FOUND));\n            }\n        }\n        return stat;\n    }", "first_line_groundtruth": "row.getCount(), Modifier.CONSTRUCTOR));", "first_line_prediction": "row.getCount(), Modifier.CONSTRUCTOR));", "match": 1}
{"groundtruth": "return this.modifiers.isInstanceOverridden();", "prediction": " return this.modifiers.isInstancePublic()\n             && this.modifiers.isInstanceOverridden();\n    }\n\n    boolean isInstancePublic() {\n        return this.modifiers.isInstancePublic();\n    }\n\n    boolean isInstanceOverridden() {\n        return this.modifiers.isInstanceOverridden();\n    }\n\n    boolean isStaticPackagePrivate() {\n        return this.modifiers.isStaticPackagePrivate();\n    }\n\n    boolean isStaticPublic() {\n        return this.modifiers.isStaticPublic();\n    }\n\n    boolean isStaticPrivate() {\n        return this.modifiers.isStaticPrivate();\n    }\n\n    boolean isConstructor() {\n       ", "first_line_groundtruth": "return this.modifiers.isInstanceOverridden();", "first_line_prediction": " return this.modifiers.isInstancePublic()", "match": 0}
{"groundtruth": "new GitHubMetrics(this.project.githubUrl())\n        ).cells();", "prediction": " new StatisticsCaseWithModifiers(title, csv, project, filters)\n        ).cells();\n    }", "first_line_groundtruth": "new GitHubMetrics(this.project.githubUrl())", "first_line_prediction": " new StatisticsCaseWithModifiers(title, csv, project, filters)", "match": 0}
{"groundtruth": "method -> !method.isConstructor())\n            .mapToLong(MethodStatistics::total)\n            .sum();", "prediction": "MethodStatistics::isMethod)\n             .mapToLong(MethodStatistics::total)\n             .sum();\n    }\n\n    private long constructors() {\n        return this.statistics.stream()\n             .filter(MethodStatistics::isConstructor)\n             .mapToLong(MethodStatistics::total)\n             .sum();\n    }", "first_line_groundtruth": "method -> !method.isConstructor())", "first_line_prediction": "MethodStatistics::isMethod)", "match": 0}
{"groundtruth": "(this.project.path())) {", "prediction": "(this.project.path())) {\n            return files.filter(Files::isRegularFile)\n                     .filter(path -> path.toString().endsWith(\".java\"))\n                     .map(path -> {\n                         try {\n                             return new ParsedClass(path);\n                         } catch (final IOException e) {\n                             throw new IllegalStateException(e);\n                         }\n                     })\n                     .collect(Collectors.toMap(ParsedClass::name, parsed -> parsed));\n        } catch (final IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }", "first_line_groundtruth": "(this.project.path())) {", "first_line_prediction": "(this.project.path())) {", "match": 1}
{"groundtruth": "obj.setId(id);", "prediction": " service.update(obj);\n             return ResponseEntity.noContent().build();\n    }\n\n    @DeleteMapping(value = \"/{id}\")\n    public ResponseEntity<Void> delete(@PathVariable String id){\n        service.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }", "first_line_groundtruth": "obj.setId(id);", "first_line_prediction": " service.update(obj);", "match": 0}
{"groundtruth": ".modifiers.isStaticPackagePrivate();", "prediction": ".modifiers.isStaticPackagePrivate();\n    }\n\n    boolean isStaticPublic() {\n        return this.modifiers.isStaticPublic();\n    }\n\n    boolean isStaticPrivate() {\n        return this.modifiers.isStaticPrivate();\n    }\n\n    boolean isStatic() {\n        return this.modifiers.isStatic();\n    }\n\n    boolean isInstancePrivateStatic() {\n        return this.modifiers.isInstancePrivateStatic();\n    }\n\n    boolean isInstancePackagePrivateStatic() {\n        return this.modifiers.isInstancePackagePrivateStatic();\n    }\n\n    boolean isInstancePublicOverriddenStatic() {\n        return this.modifiers.isInstancePublic", "first_line_groundtruth": ".modifiers.isStaticPackagePrivate();", "first_line_prediction": ".modifiers.isStaticPackagePrivate();", "match": 1}
{"groundtruth": "modifiers.isInstancePackage();", "prediction": "modifiers.isInstancePackagePrivate();\n    }\n\n    boolean isInstancePublic() {\n        return this.modifiers.isInstancePublic();\n    }\n\n    boolean isInstanceOverridden() {\n        return this.modifiers.isInstanceOverridden();\n    }\n\n    boolean isStaticPrivate() {\n        return this.modifiers.isStaticPrivate();\n    }\n\n    boolean isStaticPackagePrivate() {\n        return this.modifiers.isStaticPackagePrivate();\n    }\n\n    boolean isStaticPublic() {\n        return this.modifiers.isStaticPublic();\n    }\n\n    boolean isStaticOverridden() {\n        return this.modifiers.isStaticOverridden();\n   ", "first_line_groundtruth": "modifiers.isInstancePackage();", "first_line_prediction": "modifiers.isInstancePackagePrivate();", "match": 0}
{"groundtruth": "proxyServer.open();", "prediction": " proxyServer.start();\n        }\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        super.channelActive(ctx);\n        AttributeKey<CountDownLatch> attributeKey = AttributeKey.valueOf(ctx.channel().id().asLongText());\n        Attribute<CountDownLatch> attr = ctx.attr(attributeKey);\n        CountDownLatch latch = new CountDownLatch(1);\n        attr.set(latch);\n        latch.await();\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);\n        proxyServerMap", "first_line_groundtruth": "proxyServer.open();", "first_line_prediction": " proxyServer.start();", "match": 0}
{"groundtruth": "proxyClient.authSuccess();", "prediction": " Frame frame = new Frame(0x11, serviceKey, null);\n             ctx.writeAndFlush(frame);\n        } else if (opCode == 0x12) {\n            log.info(\"proxy disconnect server\");\n            close();\n        } else if (opCode == 0x13) {\n            log.info(\"proxy reconnect server\");\n            close();\n        } else if (opCode == 0x14) {\n            log.info(\"proxy reconnect server success\");\n            Frame frame = new Frame(0x14, serviceKey, null);\n            ctx.writeAndFlush(", "first_line_groundtruth": "proxyClient.authSuccess();", "first_line_prediction": " Frame frame = new Frame(0x11, serviceKey, null);", "match": 0}
{"groundtruth": "proxyClient.shutdown();", "prediction": " map.forEach((k, v) -> {\n             try {\n                 v.close();\n             } catch (Exception e) {\n                 log.error(\"close channel error\", e);\n             }\n         });\n         map.clear();\n         proxyClient.close();\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        super.channelActive(ctx);\n        Frame frame = new Frame(0x11, null, null);\n        proxyClient.send(frame);\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);", "first_line_groundtruth": "proxyClient.shutdown();", "first_line_prediction": " map.forEach((k, v) -> {", "match": 0}
{"groundtruth": "proxyClient.updateHeatbeatTime();", "prediction": " Frame frame = new Frame(0x6, serviceKey, null);\n             ctx.writeAndFlush(frame);\n        } else if (opCode == 0x4) {\n            log.info(\"proxy send to service data {}\", payload);\n            TaskExecutor.get().addTask(new Task(ctx.channel(), Unpooled.copiedBuffer(payload)));\n            Frame frame = new Frame(0x41, serviceKey, null);\n            ctx.writeAndFlush(frame);\n        } else if (opCode == 0x1) {\n            log.info(\"proxy send to service data {}\", payload", "first_line_groundtruth": "proxyClient.updateHeatbeatTime();", "first_line_prediction": " Frame frame = new Frame(0x6, serviceKey, null);", "match": 0}
{"groundtruth": "().write(Json.parseToJson(this.body));", "prediction": "().write(this.json.toJson(this.body));\n        response.getWriter().close();\n    }\n\n    public static <T> StatusBuilder<T> status(HttpStatus status) {\n        return new StatusBuilder<>(status);\n    }\n\n    public static class StatusBuilder<T> {\n        private final HttpStatus status;\n        private T body;\n\n        StatusBuilder(HttpStatus status) {\n            this.status = status;\n        }\n\n        public ResponseEntity<T> body(T body) {\n            this.body = body;\n            return new ResponseEntity<>(this.status, this.body);\n        }\n    }", "first_line_groundtruth": "().write(Json.parseToJson(this.body));", "first_line_prediction": "().write(this.json.toJson(this.body));", "match": 0}
{"groundtruth": "ResponseEntity.ok().body(obj.getPosts());", "prediction": " ResponseEntity.ok().body(obj.getPosts());\n    }\n\n    @DeleteMapping(value = \"/{id}\")\n    public ResponseEntity<Void> delete(@PathVariable String id){\n        service.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }", "first_line_groundtruth": "ResponseEntity.ok().body(obj.getPosts());", "first_line_prediction": " ResponseEntity.ok().body(obj.getPosts());", "match": 0}
{"groundtruth": "message, status.getValue(), request.getRequestURI(), new Date())).build(response);", "prediction": "message, status.getValue(), request.getRequestURI(), new Date())).build(response, ContentType.APPLICATION_JSON);\n    }", "first_line_groundtruth": "message, status.getValue(), request.getRequestURI(), new Date())).build(response);", "first_line_prediction": "message, status.getValue(), request.getRequestURI(), new Date())).build(response, ContentType.APPLICATION_JSON);", "match": 0}
{"groundtruth": "= tenantRepository.findByTenantId(tenant).get();", "prediction": " = tenantRepository.findByTenantId(tenant).orElseThrow(() -> new RuntimeException(\"No such tenant: \" + tenant));\n            properties.put(AvailableSettings.DEFAULT_SCHEMA, dbTenant.getSchema());\n        }\n\n        emfBean.setJpaPropertyMap(properties);\n        emfBean.setJpaVendorAdapter(vendorAdapter);\n        emfBean.setJpaPropertyMap(properties);\n        emfBean.setJpaPropertyMap(properties);\n        emfBean.setJpaPropertyMap(properties);\n        emfBean.setJpaPropertyMap(properties);\n        emfBean.setJpaPropertyMap(properties);", "first_line_groundtruth": "= tenantRepository.findByTenantId(tenant).get();", "first_line_prediction": " = tenantRepository.findByTenantId(tenant).orElseThrow(() -> new RuntimeException(\"No such tenant: \" + tenant));", "match": 0}
{"groundtruth": "String encryptedPassword = encryptionService.encrypt(password, secret, salt);", "prediction": " // Verify tenant id to prevent SQL injection\n        if (!tenantId.matches(VALID_DB_SCHEMA_NAME_REGEXP)) {\n            throw new TenantCreationException(\"Invalid tenant id: \" + tenantId);\n        }\n\n        // Verify tenant username to prevent SQL injection\n        if (!userName.matches(VALID_DB_SCHEMA_NAME_REGEXP)) {\n            throw new TenantCreationException(\"Invalid tenant username: \" + userName);\n        }\n\n        // Verify tenant password to prevent SQL injection\n        if (!password.matches(VALID_DB_SCHEMA_NAME_REGEXP)) {\n            throw new TenantCreationException(\"Invalid tenant password", "first_line_groundtruth": "String encryptedPassword = encryptionService.encrypt(password, secret, salt);", "first_line_prediction": " // Verify tenant id to prevent SQL injection", "match": 0}
{"groundtruth": "= masterTenantRepository.findByTenantId(key)\n                                .orElseThrow(() -> new RuntimeException(\"No such tenant: \" + key));", "prediction": " = masterTenantRepository.findByTenantId(key);\n                        String decryptedPassword = encryptionService.decrypt(tenant.getPassword(), secret, salt);\n                        log.info(\"Creating datasource for tenant \" + tenant.getTenantId() + \" and password \" + decryptedPassword);\n                        HikariDataSource dataSource = dataSourceProperties.initializeDataSourceBuilder()\n                                .type(HikariDataSource.class)\n                                .build();\n                        dataSource.setPoolName(key + TENANT_POOL_NAME_SUFFIX);\n                        dataSource.setJdbcUrl(urlPrefix + tenant.getDbOrSchema());\n                        dataSource.setUsername(tenant.getUsername());\n                        dataSource.", "first_line_groundtruth": "= masterTenantRepository.findByTenantId(key)", "first_line_prediction": " = masterTenantRepository.findByTenantId(key);", "match": 0}
{"groundtruth": "String tenant = TenantContext.getTenantId();", "prediction": " // the below code fragment can be found in:\n         // hybrid-multitenancy-customer-service/src/main/java/com/github/wenqiglantz/service/customer/multitenancy/config/master/MasterHibernateConfig.java\n        // properties.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, connectionProvider);\n        // properties.put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantResolver);\n\n        // the below code fragment can be found in:\n        // hybrid-multitenancy-customer-service/src/main/java/com", "first_line_groundtruth": "String tenant = TenantContext.getTenantId();", "first_line_prediction": " // the below code fragment can be found in:", "match": 0}
{"groundtruth": "gpuTestCurlAnimView.flipSetToDefault();", "prediction": " gpuTestCurlAnimView.flipFinish();\n                        break;\n                }\n                return true;\n            }\n        });\n    }", "first_line_groundtruth": "gpuTestCurlAnimView.flipSetToDefault();", "first_line_prediction": " gpuTestCurlAnimView.flipFinish();", "match": 0}
{"groundtruth": "f.setXY(width, height);", "prediction": " f.setXY(0, 0);\n        }\n        g.setXY(width, height);\n        e.setXY(0, height);\n        h.setXY(0, 0);\n        c.setXY(x, y);\n        j.setXY(x, y);\n        b.setXY(x, y);\n        k.setXY(x, y);\n        d.setXY(x, y);\n        i.setXY(x, y);\n    }\n\n    public void flip(float x, float y) {\n        if (y < height / 2) {", "first_line_groundtruth": "f.setXY(width, height);", "first_line_prediction": " f.setXY(0, 0);", "match": 0}
{"groundtruth": "animationEffecter.onScroll();", "prediction": " animationEffecter.computeScroll();\n        }\n    }\n\n    @Override\n    public void onEventProxy(int event) {\n        if (null != animationEffecter) {\n            animationEffecter.onEventProxy(event);\n        }\n    }\n\n    @Override\n    public void onEventProxy(int event, int x, int y) {\n        if (null != animationEffecter) {\n            animationEffecter.onEventProxy(event, x, y);\n        }\n    }\n\n    @Override\n    public void onEventProxy(int event, int x, int y, int dx, int dy) {\n        if (", "first_line_groundtruth": "animationEffecter.onScroll();", "first_line_prediction": " animationEffecter.computeScroll();", "match": 0}
{"groundtruth": "return animationEffecter.animInEffect();", "prediction": " return animationEffecter.animRunning();\n        }\n        return false;\n    }\n\n    @Override\n    public void setPreviousBitmap(Bitmap previousViewBitmap) {\n        this.previousViewBitmap = previousViewBitmap;\n    }\n\n    @Override\n    public void setCurrentBitmap(Bitmap currentViewBitmap) {\n        this.currentViewBitmap = currentViewBitmap;\n    }\n\n    @Override\n    public void setNextBitmap(Bitmap nextViewBitmap) {\n        this.nextViewBitmap = nextViewBitmap;\n    }\n\n    @Override\n    public void setCurlTexture(boolean performDrawCurlTexture) {\n        this.performDrawCurlTexture = perform", "first_line_groundtruth": "return animationEffecter.animInEffect();", "first_line_prediction": " return animationEffecter.animRunning();", "match": 0}
{"groundtruth": "f.setXY(0, 0);", "prediction": " f.setXY(width, height);\n    }\n\n    public void flipSetTo(float x, float y) {\n        a.setXY(x, y);\n        f.setXY(x, y);\n    }\n\n    public void flipSetTo(FPoint f) {\n        a.setXY(f.x, f.y);\n        f.setXY(f.x, f.y);\n    }\n\n    public void flipSetTo(FPoint a, FPoint f) {\n        this.a.setXY(a.x, a.y);\n        this.f.setXY", "first_line_groundtruth": "f.setXY(0, 0);", "first_line_prediction": " f.setXY(width, height);", "match": 0}
{"groundtruth": "readAnimView.buildBitmap(coverSlideDirection);", "prediction": " touchDown(downArea, coverSlideDirection);\n                }\n                if (coverSlideDirection != AnimHelper.SLID_DIRECTION_UNKNOWN) {\n                    if (curDistance > 0) {\n                        touchMove(x, y, coverSlideDirection, true, false);\n                    } else {\n                        touchMove(x, y, coverSlideDirection, false, true);\n                    }\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                isTouching = false;\n                if (coverSlideDirection != AnimHelper.SLID_DIRECTION_UNKNOWN) {\n                    touchUp(true);\n                }\n                break;", "first_line_groundtruth": "readAnimView.buildBitmap(coverSlideDirection);", "first_line_prediction": " touchDown(downArea, coverSlideDirection);", "match": 0}
{"groundtruth": "animationEffecter.onViewAttachedToWindow();", "prediction": " animationEffecter.onAttachedToWindow();\n        }\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        if (null != animationEffecter) {\n            animationEffecter.onDetachedFromWindow();\n        }\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        vWidth = w;\n        vHeight = h;\n        if (null != animationEffecter) {\n            animationEffecter.onSize", "first_line_groundtruth": "animationEffecter.onViewAttachedToWindow();", "first_line_prediction": " animationEffecter.onAttachedToWindow();", "match": 0}
{"groundtruth": "f.setXY(width, 0);", "prediction": " //\u4e0a\u534a\u90e8\u5206\n            a.setXY(x, y);\n            f.setXY(x, y);\n            g.setXY(x, y);\n            e.setXY(x, y);\n            h.setXY(x, y);\n            c.setXY(x, y);\n            j.setXY(x, y);\n            b.setXY(x, y);\n            k.setXY(x, y);\n            d.setXY(x, y);\n            i.setXY(x, y);\n        } else {\n            //\u4e0b\u534a\u90e8\u5206\n            a.setXY", "first_line_groundtruth": "f.setXY(width, 0);", "first_line_prediction": " //\u4e0a\u534a\u90e8\u5206", "match": 0}
{"groundtruth": "a.setXY(-1, -1);", "prediction": " //\u521d\u59cb\u5316\u56fe\u5f62\n        initPath();\n    }\n\n    private void initPath() {\n        //\u521d\u59cb\u5316\u56fe\u5f62\n        pointPaint = new Paint();\n        pointPaint.setAntiAlias(true);\n        pointPaint.setColor(Color.RED);\n        pointPaint.setStrokeWidth(10);\n\n        a = new FPoint(0, 0);\n        f = new FPoint(0, 0);\n        g = new FPoint(0, 0);\n        e = new FPoint(0, 0);\n        h = new FPoint(0, 0);\n        c = new FPoint(0", "first_line_groundtruth": "a.setXY(-1, -1);", "first_line_prediction": " //\u521d\u59cb\u5316\u56fe\u5f62", "match": 0}
{"groundtruth": "animationEffecter.onViewSizeChanged(vWidth, vHeight);", "prediction": " animationEffecter.onViewAttachedToWindow();\n        }\n    }\n\n    @Override\n    public void onViewAttachedToWindow() {\n        super.onViewAttachedToWindow();\n        if (null != animationEffecter) {\n            animationEffecter.onViewAttachedToWindow();\n        }\n    }\n\n    @Override\n    public void onViewDetachedFromWindow() {\n        super.onViewDetachedFromWindow();\n        if (null != animationEffecter) {\n            animationEffecter.onViewDetachedFromWindow();\n        }\n    }\n\n    @Override\n    public void onViewSizeChanged(int vWidth, int vHeight) {", "first_line_groundtruth": "animationEffecter.onViewSizeChanged(vWidth, vHeight);", "first_line_prediction": " animationEffecter.onViewAttachedToWindow();", "match": 0}
{"groundtruth": "int i = mRetrofitUrlManager.getPathSize();", "prediction": "int i = 0; i < mRetrofitUrlManager.getPathSize(); i++) {\n                    newPathSegments.add(encodedPathSegments.get(i));\n                }\n            }\n\n            builder.encodedPathSegments(newPathSegments);\n\n            if (listeners != null) {\n                for (int i = 0; i < listeners.length; i++) {\n                    ((onUrlChangeListener) listeners[i]).onUrlChanged(builder.build(), url); // \u901a\u77e5\u76d1\u542c\u5668\u6b64 Url \u7684 BaseUrl \u5df2\u88ab\u5207\u6362\n                }\n            }\n\n            return builder.build();\n        }\n\n        return url;\n    }", "first_line_groundtruth": "int i = mRetrofitUrlManager.getPathSize();", "first_line_prediction": "int i = 0; i < mRetrofitUrlManager.getPathSize(); i++) {", "match": 0}
{"groundtruth": "(readAnimView.getPreviousBitmap(), -leftOffset, 0, paint);", "prediction": "(readAnimView.getPreviousBitmap(), leftOffset, 0, paint);\n            canvas.restore();\n            canvas.save();\n            canvas.clipPath(getPathB());\n            canvas.drawBitmap(readAnimView.getCurrentBitmap(), 0, 0, paint);\n            canvas.restore();\n            drawShadow((int) leftOffset, canvas);\n        }\n    }\n\n    private void drawShadow(int offset, Canvas canvas) {\n        if (offset > 0) {\n            canvas.save();\n            canvas.clipPath(getPathAToLeft());\n            canvas.drawBitmap(readAnimView.getPreviousBitmap", "first_line_groundtruth": "(readAnimView.getPreviousBitmap(), -leftOffset, 0, paint);", "first_line_prediction": "(readAnimView.getPreviousBitmap(), leftOffset, 0, paint);", "match": 0}
{"groundtruth": "+ mRetrofitUrlManager.getPathSize();", "prediction": " + url.query();\n    }\n\n    private String getKey(HttpUrl domainUrl, HttpUrl url, int pathSize) {\n        return domainUrl.encodedPath() + url.encodedPath()\n                 + url.query()\n                 + pathSize;\n    }", "first_line_groundtruth": "+ mRetrofitUrlManager.getPathSize();", "first_line_prediction": " + url.query();", "match": 0}
{"groundtruth": "(slideDirection == AnimHelper.SLID_DIRECTION_LEFT && (null != readAnimView.getNextBitmap() && null != readAnimView.getCurrentBitmap())) {", "prediction": " (slideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n            return readAnimView.getCurrentBitmap() != null && readAnimView.getNextBitmap() != null;\n        } else if (slideDirection == AnimHelper.SLID_DIRECTION_RIGHT) {\n            return readAnimView.getPreviousBitmap() != null;\n        }\n        return false;\n    }", "first_line_groundtruth": "(slideDirection == AnimHelper.SLID_DIRECTION_LEFT && (null != readAnimView.getNextBitmap() && null != readAnimView.getCurrentBitmap())) {", "first_line_prediction": " (slideDirection == AnimHelper.SLID_DIRECTION_LEFT) {", "match": 0}
{"groundtruth": "+ mRetrofitUrlManager.getBaseUrl().host()\n                                + mRetrofitUrlManager.getBaseUrl().encodedPath()));", "prediction": " + mRetrofitUrlManager.getBaseUrl().host() + mRetrofitUrlManager.getBaseUrl().encodedPath()));\n            }\n\n            builder.encodedPathSegments(newPathSegments);\n\n            if (listeners != null) {\n                for (int i = 0; i < listeners.length; i++) {\n                    ((onUrlChangeListener) listeners[i]).onUrlChanged(url, url); // \u901a\u77e5\u76d1\u542c\u5668\u6b64 Url \u7684 BaseUrl \u5df2\u88ab\u5207\u6362\n                }\n            }\n\n            return builder.build();\n        }\n\n        return url;\n    }\n\n    private String getKey(HttpUrl domainUrl, HttpUrl url)", "first_line_groundtruth": "+ mRetrofitUrlManager.getBaseUrl().host()", "first_line_prediction": " + mRetrofitUrlManager.getBaseUrl().host() + mRetrofitUrlManager.getBaseUrl().encodedPath()));", "match": 0}
{"groundtruth": "() > mRetrofitUrlManager.getPathSize()) {", "prediction": "() > 0) {\n                newPathSegments.addAll(url.encodedPathSegments());\n            }\n\n            for (String PathSegment : newPathSegments) {\n                builder.addEncodedPathSegment(PathSegment);\n            }\n        } else {\n            builder.encodedPath(mCache.get(getKey(domainUrl, url)));\n        }\n\n        HttpUrl httpUrl = builder.build();\n\n        return httpUrl;\n    }\n\n    private String getKey(HttpUrl domainUrl, HttpUrl url) {\n        return getKey(domainUrl, url, url.pathSize());\n    }\n\n    private String getKey(HttpUrl domainUrl,", "first_line_groundtruth": "() > mRetrofitUrlManager.getPathSize()) {", "first_line_prediction": "() > 0) {", "match": 0}
{"groundtruth": "drawable = readAnimView.getAnimHelper().getCoverGradientDrawable();", "prediction": " drawable = new GradientDrawable();\n        drawable.setShape(GradientDrawable.RECTANGLE);\n        drawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        drawable.setGradientRadius(10);\n        drawable.setGradientColors(new int[]{Color.parseColor(\"#000000\"), Color.parseColor(\"#000000\")});\n        drawable.setGradientCenter(0, 0);\n        drawable.setGradientAngle(90);\n        drawable.setGradientCenter(0, 0);\n        drawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n       ", "first_line_groundtruth": "drawable = readAnimView.getAnimHelper().getCoverGradientDrawable();", "first_line_prediction": " drawable = new GradientDrawable();", "match": 0}
{"groundtruth": "DLog.log(\"touchUp coverAnimationRunning=%s\", coverAnimationRunning);", "prediction": " if (lastFingerLeftSlop) {\n             if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                 readAnimView.onPreviousPage();\n             } else {\n                 readAnimView.onNextPage();\n             }\n         } else {\n             if (coverSlideDirection == AnimHelper.SLID_DIRECTION_LEFT) {\n                 readAnimView.onPreviousPage();\n             } else {\n                 readAnimView.onNextPage();\n             }\n         }\n         coverAnimationRunning = false;\n         isCancelFlip = false;\n         isTouching = false;\n         currentX = -1;\n         down", "first_line_groundtruth": "DLog.log(\"touchUp coverAnimationRunning=%s\", coverAnimationRunning);", "first_line_prediction": " if (lastFingerLeftSlop) {", "match": 0}
{"groundtruth": "readLayoutManger.getBookFlipMode();", "prediction": " readLayoutManger.getBookFlipMode();\n    }\n\n    @Override\n    public void onForceLayoutCompleted(int position) {\n        currentPosition = position;\n        if (null != onPositionChangedListener) {\n            onPositionChangedListener.onPositionChanged(position);\n        }\n    }\n\n    @Override\n    public void onScrollStop() {\n        if (null != onPositionChangedListener) {\n            onPositionChangedListener.onPositionChanged(currentPosition);\n        }\n    }\n\n    @Override\n    public void onScrollStart() {\n\n    }\n\n    @Override\n    public void onScrollEnd() {\n\n    }\n\n    @Override", "first_line_groundtruth": "readLayoutManger.getBookFlipMode();", "first_line_prediction": " readLayoutManger.getBookFlipMode();", "match": 0}
{"groundtruth": "readLayoutManger.setonStopScroller(new ItemOnScrollStop());", "prediction": " /*\n            \u5173\u95ed\u786c\u4ef6\u52a0\u901f \u5361\u5230", "first_line_groundtruth": "readLayoutManger.setonStopScroller(new ItemOnScrollStop());", "first_line_prediction": " /*", "match": 0}
{"groundtruth": "readLayoutManger.setAutoLeftScroll(finallyMoveX < 10);", "prediction": " boolean lastFingerLeftSlop = finallyMoveX < 10;\n                         touchUp(lastFingerLeftSlop);\n                    } else if (lastMoveX - downX > 0) {//\u53f3\u6ed1\n                        touchUp(false);\n                    }\n                    moveSampling.clear();\n                } else {\n                    touchUp(false);\n                }\n                break;\n        }\n        return true;\n    }\n\n    private void touchUp(boolean isLeft) {\n        if (null != eventProxyWeakReference) {\n            EventProxy ic = eventProxyWeakReference.get();\n            if (null != ic) {\n                ic.on", "first_line_groundtruth": "readLayoutManger.setAutoLeftScroll(finallyMoveX < 10);", "first_line_prediction": " boolean lastFingerLeftSlop = finallyMoveX < 10;", "match": 0}
{"groundtruth": "readLayoutManger.onRecyclerViewSizeChange();", "prediction": " readLayoutManger.onSizeChanged(w, h, oldw, oldh);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (allowInterceptTouchEvent) {\n            return super.onInterceptTouchEvent(ev);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (allowInterceptTouchEvent) {\n            return super.onTouchEvent(ev);\n        }\n        return false;\n    }\n\n    @Override\n    public void onScrollStateChanged(int state) {\n        super.onScrollStateChanged(", "first_line_groundtruth": "readLayoutManger.onRecyclerViewSizeChange();", "first_line_prediction": " readLayoutManger.onSizeChanged(w, h, oldw, oldh);", "match": 0}
{"groundtruth": "readLayoutManger.setAutoLeftScroll(finallyMoveX < 0);", "prediction": " readLayoutManger.setAutoLeftScroll(false);\n                    }\n                    moveSampling.clear();\n                }\n                break;\n        }\n        return super.onTouchEvent(e);\n    }\n\n    @Override\n    public void onInterceptTouchEvent(boolean intercept) {\n        allowInterceptTouchEvent = intercept;\n    }\n\n    @Override\n    public void onScrollStateChanged(int state) {\n        super.onScrollStateChanged(state);\n        if (state == SCROLL_STATE_IDLE) {\n            if (null != eventProxyWeakReference) {\n                eventProxyWeakReference.get().onStopScroll();\n            }\n        }\n    }", "first_line_groundtruth": "readLayoutManger.setAutoLeftScroll(finallyMoveX < 0);", "first_line_prediction": " readLayoutManger.setAutoLeftScroll(false);", "match": 0}
{"groundtruth": "readLayoutManger.setBookFlipMode(flipMode);", "prediction": " readLayoutManger.setFlipMode(flipMode);\n    }\n\n    @Override\n    public void onItemClick(View view, int position) {\n        if (null != onPositionChangedListener) {\n            onPositionChangedListener.onPositionChanged(position);\n        }\n    }\n\n    @Override\n    public void onItemLongClick(View view, int position) {\n\n    }\n\n    @Override\n    public void onItemForceLayoutCompleted(View view, int position) {\n        if (null != onPositionChangedListener) {\n            onPositionChangedListener.onPositionChanged(position);\n        }\n    }\n\n    @Override\n   ", "first_line_groundtruth": "readLayoutManger.setBookFlipMode(flipMode);", "first_line_prediction": " readLayoutManger.setFlipMode(flipMode);", "match": 0}
{"groundtruth": "Food americanFoodA = AmericanFoodFactory.produce(\"A\");", "prediction": " Food AmericanFoodA = AmericanFoodFactory.produce(\"A\");\n         AmericanFoodA.food();\n         //\u751f\u4ea7\u7f8e\u56fdB\u7c7b\u98df\u7269\n         Food AmericanFoodB = AmericanFoodFactory.produce(\"B\");\n         AmericanFoodB.food();\n    }", "first_line_groundtruth": "Food americanFoodA = AmericanFoodFactory.produce(\"A\");", "first_line_prediction": " Food AmericanFoodA = AmericanFoodFactory.produce(\"A\");", "match": 0}
{"groundtruth": "DLog.log(\"coverAnimationRunning coverAnimationRunning=%s \u7ed3\u675f\uff0c\u5ef6\u65f6\u5f00\u542f \u72b6\u6001\u91cd\u7f6e\", coverAnimationRunning);", "prediction": " readAnimView.postDelayed(scrollRunnable, 100);\n            }\n            currentX = x;\n            invalidate();\n        }\n    }\n\n    @Override\n    public void onFling() {\n        if (scroller.computeScrollOffset()) {\n            int x = scroller.getCurrX();\n            int y = scroller.getCurrY();\n            if (x == scroller.getFinalX() && y == scroller.getFinalY()) {\n                scroller.forceFinished(true);\n                readAnimView.postDelayed(scrollRunnable, 100);\n            }\n            currentX =", "first_line_groundtruth": "DLog.log(\"coverAnimationRunning coverAnimationRunning=%s \u7ed3\u675f\uff0c\u5ef6\u65f6\u5f00\u542f \u72b6\u6001\u91cd\u7f6e\", coverAnimationRunning);", "first_line_prediction": " readAnimView.postDelayed(scrollRunnable, 100);", "match": 0}
{"groundtruth": "readLayoutManger.forceScrollToPosition(position);", "prediction": " readLayoutManger.scrollToPosition(position);\n    }\n\n    @Override\n    public void smoothScrollToPosition(int position) {\n        readLayoutManger.smoothScrollToPosition(position);\n    }\n\n    @Override\n    public void setAdapter(RecyclerView.Adapter adapter) {\n        readLayoutManger.setAdapter(adapter);\n    }\n\n    @Override\n    public void setItemViewBackgroundColor(int itemViewBackgroundColor) {\n        readLayoutManger.setItemViewBackgroundColor(itemViewBackgroundColor);\n    }\n\n    @Override\n    public void setOnScrollListener(OnScrollListener listener) {\n        readLayoutManger.setOnScrollListener(", "first_line_groundtruth": "readLayoutManger.forceScrollToPosition(position);", "first_line_prediction": " readLayoutManger.scrollToPosition(position);", "match": 0}
{"groundtruth": "readLayoutManger.setOnForceLayoutCompleted(new ItemOnForceLayoutCompleted());", "prediction": " /*\n            \u5173\u95ed\u786c\u4ef6\u52a0\u901f \u5361\u5230", "first_line_groundtruth": "readLayoutManger.setOnForceLayoutCompleted(new ItemOnForceLayoutCompleted());", "first_line_prediction": " /*", "match": 0}
{"groundtruth": "= AmericanFoodFactory.produce(\"A\");", "prediction": " = AmericanFoodFactory.produce(\"B\");\n        americanFoodB.food();\n    }", "first_line_groundtruth": "= AmericanFoodFactory.produce(\"A\");", "first_line_prediction": " = AmericanFoodFactory.produce(\"B\");", "match": 0}
{"groundtruth": ").animRunning();", "prediction": " ).animRunning();\n        }\n        return false;\n    }\n\n    @Override\n    public void onItemViewTouchEvent(MotionEvent event, int position) {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().onItemViewTouchEvent(event, position);\n        }\n    }\n\n    @Override\n    public void onItemViewTouchEvent(MotionEvent event, int position, View view) {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().onItemView", "first_line_groundtruth": ").animRunning();", "first_line_prediction": " ).animRunning();", "match": 0}
{"groundtruth": "animParentView.onClickMenuArea();", "prediction": " if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().onClickMenu();\n         }\n    }\n\n    @Override\n    public void onItemViewClick(View view, int position) {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {\n            eventProxyWeakReference.get().onItemViewClick(view, position);\n        }\n    }\n\n    @Override\n    public void onItemViewLongClick(View view, int position) {\n        if (null != eventProxyWeakReference && null != eventProxyWeakReference", "first_line_groundtruth": "animParentView.onClickMenuArea();", "first_line_prediction": " if (null != eventProxyWeakReference && null != eventProxyWeakReference.get()) {", "match": 0}
{"groundtruth": "PlayingSessionInformation.isOnNetwork()) {", "prediction": "PlayingSessionInformation.isOnNetwork()) return;\n        if(keybinding.isPressed()) {\n            client.execute(() -> {\n                client.execute(() -> {\n                    client.execute(() -> {\n                        client.execute(() -> {\n                            client.execute(() -> {\n                                client.execute(() -> {\n                                    client.execute(() -> {\n                                        client.execute(() -> {\n                                            client.execute(() -> {\n                                                client.execute(() -> {\n                                                    client.execute(() -> {\n                                                        client.execute(() -> {\n                                                            client.execute(() -> {\n                                                                client.execute(() -> {\n                                                                    client.execute(() -> {\n                                                                        client.", "first_line_groundtruth": "PlayingSessionInformation.isOnNetwork()) {", "first_line_prediction": "PlayingSessionInformation.isOnNetwork()) return;", "match": 0}
{"groundtruth": "!XenyriaConfigManager.getConfig().improvedShootingDetectionForPaintSquad) {", "prediction": "XenyriaConfigManager.getConfig().swimFormCameraForPaintSquad) {\n                    // Check if the player is in a swimming pool\n                    if(MinecraftClient.getInstance().world != null) {\n                        if(MinecraftClient.getInstance().world.getGameRules().getBoolean(\"doSwimming\")) {\n                            // Check if the player is shooting\n                            if(MinecraftClient.getInstance().player != null) {\n                                if(MinecraftClient.getInstance().player.isUsingItem()) {\n                                    if(MinecraftClient.getInstance().player.getMainHandStack().getItem().getName().equals(\"paint_squad", "first_line_groundtruth": "!XenyriaConfigManager.getConfig().improvedShootingDetectionForPaintSquad) {", "first_line_prediction": "XenyriaConfigManager.getConfig().swimFormCameraForPaintSquad) {", "match": 0}
{"groundtruth": "DLog.log(\"CoverAnimationEffect draw 1\");", "prediction": " return;\n        }\n        if (coverAnimationRunning) {\n            scroller.computeScrollOffset();\n            if (scroller.computeScrollOffset()) {\n                int x = scroller.getCurrX();\n                int y = scroller.getCurrY();\n                readAnimView.buildBitmap(coverSlideDirection);\n                readAnimView.drawBitmap(canvas, x, y);\n                invalidate();\n            } else {\n                coverAnimationRunning = false;\n                readAnimView.buildBitmap(coverSlideDirection);\n                readAnimView.drawBitmap(canvas, 0, 0);\n                invalidate();\n            }\n        }", "first_line_groundtruth": "DLog.log(\"CoverAnimationEffect draw 1\");", "first_line_prediction": " return;", "match": 0}
{"groundtruth": "configData = config.toJSON().toString(4);", "prediction": " jsonContent = config.save();\n        try(FileWriter fileWriter = new FileWriter(configFile)) {\n            fileWriter.write(jsonContent);\n        }\n    }\n\n    public static void setupConfigScreen(ConfigBuilder builder) {\n        builder.setParentScreen(null);\n        builder.setTitle(Text.of(\"Xenyria EEM\"));\n        builder.setSavingRunnable(() -> {\n            try {\n                saveConfig();\n            } catch (IOException | IllegalStateException exception) {\n                LOGGER.error(\"Couldn't save the config file for Xenyria EEM: \" + exception.getMessage());\n            }\n        });\n\n        ConfigCategory category", "first_line_groundtruth": "configData = config.toJSON().toString(4);", "first_line_prediction": " jsonContent = config.save();", "match": 0}
{"groundtruth": "discordActivityAccess.start(applicationId);", "prediction": " // Initialize the core\n                        discordActivityAccess.start(applicationId);\n                    }\n\n                    // Update the activity\n                    discordActivityAccess.updateRichPresence(applicationId,\n                            richPresenceData.getString(\"details\"),\n                            richPresenceData.getString(\"state\"),\n                            richPresenceData.getLong(\"activityStart\"),\n                            richPresenceData.getLong(\"activityEnd\"),\n                            richPresenceData.getString(\"smallImageId\"),\n                            richPresenceData.getString(\"smallImageText\"),\n                            richPresenceData.getString(\"largeImageId\"),\n                            richPresenceData.getString(\"largeImageText\")\n                    );\n                }\n            } catch (Exception e) {\n               ", "first_line_groundtruth": "discordActivityAccess.start(applicationId);", "first_line_prediction": " // Initialize the core", "match": 0}
{"groundtruth": "!XenyriaConfigManager.getConfig().shareServerActivity) {", "prediction": "XenyriaConfigManager.getConfig().enableDiscordRichPresence) {\n                        richPresenceData = loadDefaultRichPresenceData();\n                    }\n\n                    // Update the activity\n                    if (lastApplicationID != XenyriaConfigManager.getConfig().discordApplicationID) {\n                        lastApplicationID = XenyriaConfigManager.getConfig().discordApplicationID;\n                        discordActivityAccess.updateActivity(lastApplicationID, richPresenceData);\n                    } else {\n                        discordActivityAccess.updateActivity(richPresenceData);\n                    }\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to update rich presence: \" + e.", "first_line_groundtruth": "!XenyriaConfigManager.getConfig().shareServerActivity) {", "first_line_prediction": "XenyriaConfigManager.getConfig().enableDiscordRichPresence) {", "match": 0}
{"groundtruth": "PlayingSessionInformation.setOnNetwork(true);", "prediction": " // If the server is a dedicated server we send a mod packet to the server\n                         // to enable the PS shooting detection\n                         if(EXenyriaServerType.isDedicatedServer()) {\n                             JSONObject payload = new JSONObject();\n                             payload.put(\"shooting\", XenyriaConfigManager.getConfig().enablePSShootingDetection);\n                             XenyriaServerPacket packet = new XenyriaServerPacket(\n                                     XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE, payload);\n                             packet.sendToServer();\n                         }\n                    } else if (packet.getPacketType() == XenyriaServer", "first_line_groundtruth": "PlayingSessionInformation.setOnNetwork(true);", "first_line_prediction": " // If the server is a dedicated server we send a mod packet to the server", "match": 0}
{"groundtruth": "discordActivityAccess.stop();", "prediction": " // Destroy the existing core\n                        if(discordActivityAccess != null) discordActivityAccess.stop();\n                        // Initialize the core\n                        discordActivityAccess.initialize();\n                    }\n\n                    // Update the activity\n                    discordActivityAccess.updateRichPresence(applicationId,\n                            richPresenceData.getString(\"details\"),\n                            richPresenceData.getString(\"state\"),\n                            richPresenceData.getLong(\"activityStart\"),\n                            richPresenceData.getLong(\"activityEnd\"),\n                            richPresenceData.getString(\"smallImageId\"),\n                            richPresenceData.getString(\"smallImageText\"),\n                            richPresenceData.getString(\"largeImageId\"),\n                            richPresenceData.getString", "first_line_groundtruth": "discordActivityAccess.stop();", "first_line_prediction": " // Destroy the existing core", "match": 0}
{"groundtruth": "String instanceId = packet.getData().getString(\"server_id\");", "prediction": " // We store this ID in the PlayingSessionInformation class\n                         // so we can use it later to send the correct mod packets\n                         PlayingSessionInformation.setServerId(packet.getData().getString(\"serverId\"));\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {\n                        // PS sends a packet with the shooting state\n                        // We store this state in the PlayingSessionInformation class\n                        // so we can use it later to send the correct mod packets\n                        PlayingSessionInformation.setShootingState(packet.getData", "first_line_groundtruth": "String instanceId = packet.getData().getString(\"server_id\");", "first_line_prediction": " // We store this ID in the PlayingSessionInformation class", "match": 0}
{"groundtruth": "EXenyriaServerType.determineServerType(instanceId)\n                        );", "prediction": " EXenyriaServerType.fromServerId(instanceId));\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.SETTINGS_CHANGED) {\n                        // Orion sends one mod handshake packet on login\n                        // This packet contains the current server ID\n                        PlayingSessionInformation.setServerInstanceId(packet.getData().getString(\"server_id\"));\n                        PlayingSessionInformation.setOnNetwork(true);\n                        PlayingSessionInformation.setCurrentServerType(\n                                 EXenyriaServerType.fromServerId(packet.getData().getString(\"server_id\")));\n                    } else if (packet.", "first_line_groundtruth": "EXenyriaServerType.determineServerType(instanceId)", "first_line_prediction": " EXenyriaServerType.fromServerId(instanceId));", "match": 0}
{"groundtruth": "setLastReceivedRichPresence(packet.getData());", "prediction": "setLastReceivedRichPresence(packet.getData());\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {\n                        // If the shooting state is disabled in the settings we ignore this packet\n                        if (!XenyriaConfigManager.getConfig().enablePaintSquadShootingState) {\n                            return;\n                        }\n                        PlayingSessionInformation.setShootingState(packet.getData().getBoolean(\"shooting\"));\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SETTINGS_", "first_line_groundtruth": "setLastReceivedRichPresence(packet.getData());", "first_line_prediction": "setLastReceivedRichPresence(packet.getData());", "match": 1}
{"groundtruth": "\"Current server id: \" + PlayingSessionInformation.getServerInstanceId());", "prediction": "packet.getData().toString());\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.SETTINGS_CHANGED) {\n                        // Orion sends a packet when the settings are changed\n                        // This packet contains the new settings\n                        XenyriaConfigManager.getConfig().loadConfig();\n                    } else {\n                        LOGGER.warning(\"Unknown packet type: \" + packet.getPacketType());\n                    }\n                }\n        );\n    }", "first_line_groundtruth": "\"Current server id: \" + PlayingSessionInformation.getServerInstanceId());", "first_line_prediction": "packet.getData().toString());", "match": 0}
{"groundtruth": "responsePacket.sendToServer();", "prediction": " responsePacket.sendToServer();\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.SETTINGS_CHANGED) {\n                        // If the settings have changed we send a mod packet to the server\n                        // to reset the shooting detection\n                        JSONObject payload = new JSONObject();\n                        payload.put(\"shooting\", false);\n                        XenyriaServerPacket packet = new XenyriaServerPacket(\n                                XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE, payload);\n                        packet.sendToServer();\n                    } else if (packet.getPacketType() == X", "first_line_groundtruth": "responsePacket.sendToServer();", "first_line_prediction": " responsePacket.sendToServer();", "match": 0}
{"groundtruth": "XenyriaServerPacket packet = XenyriaServerPacket.parsePacket(rawJsonText);", "prediction": " XenyriaServerPacket packet = XenyriaServerPacket.parsePacket(rawJsonText);\n                     if(packet == null) {\n                         LOGGER.severe(\"Failed to parse packet from raw JSON: \" + rawJsonText);\n                         return;\n                     }\n\n                     // Handle the packet\n                     switch(packet.packetType) {\n                         case PS_SHOOTING_STATE:\n                             // If the packet is a PS_SHOOTING_STATE packet, we handle it\n                             // by updating the shooting state in the PlayingSessionInformation\n                             // object and sending a PS_SHOOTING_STATE packet to the client\n                            ", "first_line_groundtruth": "XenyriaServerPacket packet = XenyriaServerPacket.parsePacket(rawJsonText);", "first_line_prediction": " XenyriaServerPacket packet = XenyriaServerPacket.parsePacket(rawJsonText);", "match": 0}
{"groundtruth": "(\"Current network state: \" + PlayingSessionInformation.isOnNetwork());", "prediction": "(\"Received debug packet: \" + packet.getData().toString());\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {\n                        // PS sends a packet every 10 seconds with the shooting state\n                        // We use this to detect when the shooting state has changed\n                        PlayingSessionInformation.setShooting(packet.getData().getBoolean(\"shooting\"));\n                    }\n                }\n        );\n    }\n\n    public static XenyriaServerPacket parsePacket(String rawJsonText) {\n        try {\n            JSONObject jsonData = new JSONObject", "first_line_groundtruth": "(\"Current network state: \" + PlayingSessionInformation.isOnNetwork());", "first_line_prediction": "(\"Received debug packet: \" + packet.getData().toString());", "match": 0}
{"groundtruth": "XenyriaConfigManager.getConfig().enableDiscordRichPresence) {", "prediction": "XenyriaConfigManager.getInstance().isRichPresenceEnabled()) {\n                            return;\n                        }\n                        // If the server is not a Xenyria server we ignore this packet\n                        if (EXenyriaServerType.get() != EXenyriaServerType.XENYRIA) {\n                            return;\n                        }\n                        // If the server is a Xenyria server and rich presence is enabled we send the packet to the Discord Rich Presence integration\n                        DiscordRichPresenceIntegration.sendRichPresencePacket(packet.getData());\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType", "first_line_groundtruth": "XenyriaConfigManager.getConfig().enableDiscordRichPresence) {", "first_line_prediction": "XenyriaConfigManager.getInstance().isRichPresenceEnabled()) {", "match": 0}
{"groundtruth": "PlayingSessionInformation.setServerInstanceId(instanceId);", "prediction": " // If the server ID is not the same as the one we're currently connected to\n                         // we disconnect the player and reconnect to the new server\n                        if (!instanceId.equals(PlayingSessionInformation.getInstance().getServerId())) {\n                            LOGGER.info(\"Server ID changed from \" + PlayingSessionInformation.getInstance().getServerId() + \" to \" + instanceId + \". Disconnecting player and reconnecting to new server...\");\n                            PlayingSessionInformation.getInstance().disconnect();\n                            PlayingSessionInformation.getInstance().connectToServer(instanceId);\n                        }\n                    } else if (packet.getPacketType() == XenyriaServerPacket", "first_line_groundtruth": "PlayingSessionInformation.setServerInstanceId(instanceId);", "first_line_prediction": " // If the server ID is not the same as the one we're currently connected to", "match": 0}
{"groundtruth": "else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.DEBUG) {", "prediction": " else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {\n                        // PS sends a packet every 10 seconds with the shooting state\n                        // We use this to detect when the shooting state has changed\n                        boolean isShooting = packet.getData().getBoolean(\"shooting\");\n                        PlayingSessionInformation.setShooting(isShooting);\n                    } else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.DEBUG) {\n                        // Debugging packets are sent by the client to the server\n                        //", "first_line_groundtruth": "else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.DEBUG) {", "first_line_prediction": " else if (packet.getPacketType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {", "match": 0}
{"groundtruth": "(packet.getPacketType() == XenyriaServerPacket.EPacketType.RP) {", "prediction": " (packet.getType() == XenyriaServerPacket.EPacketType.SETTINGS_CHANGED) {\n                        XenyriaConfigManager.getInstance().reset();\n                        DiscordRichPresenceIntegration.updatePresence();\n                        PlayingSessionInformation.getInstance().reset();\n                    } else if (packet.getType() == XenyriaServerPacket.EPacketType.PS_SHOOTING_STATE) {\n                        PlayingSessionInformation.getInstance().setShooting(packet.getShooting());\n                    } else if (packet.getType() == XenyriaServerPacket.EPacketType.SERVER_TYPE) {\n                        EXenyriaServer", "first_line_groundtruth": "(packet.getPacketType() == XenyriaServerPacket.EPacketType.RP) {", "first_line_prediction": " (packet.getType() == XenyriaServerPacket.EPacketType.SETTINGS_CHANGED) {", "match": 0}
{"groundtruth": ".lexer.lex(markdown)).visit(compiler);", "prediction": ".lexer.lex(markdown));\n        var root = this.parser.root();\n\n        compiler.visitStart(root);\n        root.visit(compiler);\n        compiler.visitEnd(root);\n\n        return compiler.compile();\n    }\n\n    public R process(Text text) {\n        var compiler = this.compilerFactory.get();\n\n        this.parser.parse(this.lexer.lex(text));\n        var root = this.parser.root();\n\n        compiler.visitStart(root);\n        root.visit(compiler);\n        compiler.visitEnd(root);\n\n        return compiler.compile();\n    }\n\n    public static Markdown", "first_line_groundtruth": ".lexer.lex(markdown)).visit(compiler);", "first_line_prediction": ".lexer.lex(markdown));", "match": 0}
{"groundtruth": "+ feature.name() + \"' is incompatible with compiler '\" + testCompiler.name() + \"'\");", "prediction": " + feature.name() + \"' does not support compiler '\" + testCompiler.name() + \"'\");\n            }\n        }\n\n        this.lexer = new Lexer(this.features);\n        this.parser = new Parser(this.features);\n    }\n\n    /**\n     * @return A copy of this processor with the given {@code compilerFactory}\n     */\n    public MarkdownProcessor<R> copyWith(Supplier<MarkdownCompiler<R>> compilerFactory) {\n        return new MarkdownProcessor<>(compilerFactory, this.features);\n    }\n\n    /**\n     * @return A copy of this processor with the given {@code features}\n     */", "first_line_groundtruth": "+ feature.name() + \"' is incompatible with compiler '\" + testCompiler.name() + \"'\");", "first_line_prediction": " + feature.name() + \"' does not support compiler '\" + testCompiler.name() + \"'\");", "match": 0}
{"groundtruth": "builder.pushStyle(style -> style.withColor(Formatting.GRAY).withItalic(true));", "prediction": "builder.pushStyle(style -> style.withFormatting(Formatting.GRAY));\n        var quotation = Containers.verticalFlow(Sizing.content(), Sizing.content());\n        quotation.padding(Insets.of(5, 5, 7, 5)).surface((context, component) -> {\n            context.fill(component.x(), component.y() + 3, component.x() + 2, component.y() + component.height() - 3, 0xFF777777);\n        });\n        this.push(quotation);\n    }\n\n    @Override", "first_line_groundtruth": "builder.pushStyle(style -> style.withColor(Formatting.GRAY).withItalic(true));", "first_line_prediction": "builder.pushStyle(style -> style.withFormatting(Formatting.GRAY));", "match": 0}
{"groundtruth": "this.builder.popStyle();", "prediction": " this.quoteDepth--;\n         this.builder.popStyle();\n         this.builder.append(this.quoteMarker());\n     }", "first_line_groundtruth": "this.builder.popStyle();", "first_line_prediction": " this.quoteDepth--;", "match": 0}
{"groundtruth": "return RealCameraCore.isRenderingWorld && config.shouldDisableRender(modelPartName) && RealCameraCore.isActive();", "prediction": " return config.shouldDisableRender(modelPartName);\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinPlayerEntityRenderer#onSetModelPoseRETURN\n     * MixinPlayerEntityRenderer.onSetModelPoseRETURN\n     */\n    public static boolean allowRenderingHandWhen(MinecraftClient client) {\n        return config.allowRenderingHandWhen(client);\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinPlayerEntityRenderer#onSetModelPoseRETURN\n     * MixinPlayerEntityRenderer.onSetModelPoseRETURN\n     */\n    public static boolean", "first_line_groundtruth": "return RealCameraCore.isRenderingWorld && config.shouldDisableRender(modelPartName) && RealCameraCore.isActive();", "first_line_prediction": " return config.shouldDisableRender(modelPartName);", "match": 0}
{"groundtruth": "modConfig.set(new ModConfig());", "prediction": " GSON.toJson(new ModConfig(), writer);\n        } catch (Exception exception) {\n            RealCamera.LOGGER.warn(\"Failed to reset \" + FILE_NAME, exception);\n        }\n    }", "first_line_groundtruth": "modConfig.set(new ModConfig());", "first_line_prediction": " GSON.toJson(new ModConfig(), writer);", "match": 0}
{"groundtruth": "get(config.getModelModID()).test(tickDelta, matrixStack);", "prediction": "get(getModelPartName()).test(tickDelta, matrixStack);\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinLivingEntityRenderer#onRenderHandRETURN\n     * MixinLivingEntityRenderer.onRenderHandRETURN\n     */\n    public static boolean allowRenderingHandWhen(MinecraftClient client) {\n        return RealCameraCore.isRenderingWorld && config.allowRenderingHandWhen(client) && RealCameraCore.isActive();\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinLivingEntityRenderer#onRenderHandRETURN\n     * Mixin", "first_line_groundtruth": "get(config.getModelModID()).test(tickDelta, matrixStack);", "first_line_prediction": "get(getModelPartName()).test(tickDelta, matrixStack);", "match": 0}
{"groundtruth": "else config.setAdjustOffset(!config.isAdjustingOffset());", "prediction": " else config.cycleAdjustMode();\n        }\n        while (TOGGLE_CAMERA_MODE.wasPressed()) {\n            if (config.isClassic()) config.cycleClassicCameraMode();\n             else config.cycleCameraMode();\n        }\n        while (ADJUST_UP.wasPressed()) {\n            if (config.isClassic()) config.adjustUp();\n             else config.adjustUp(client);\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            if (config.isClassic()) config.adjustDown();\n             else config.adjustDown(client);\n        }\n        while (ADJUST_FRONT.", "first_line_groundtruth": "else config.setAdjustOffset(!config.isAdjustingOffset());", "first_line_prediction": " else config.cycleAdjustMode();", "match": 0}
{"groundtruth": "(config.isClassic()) config.adjustClassicZ(true);", "prediction": " (config.isClassic()) config.adjustClassicLeft();\n            else config.adjustOffsetLeft();\n            ConfigFile.save();\n        }\n        while (ADJUST_RIGHT.wasPressed()) {\n            if  (config.isClassic()) config.adjustClassicRight();\n            else config.adjustOffsetRight();\n            ConfigFile.save();\n        }\n        while (ADJUST_UP.wasPressed()) {\n            if  (config.isClassic()) config.adjustClassicUp();\n            else config.adjustOffsetUp();\n            ConfigFile.save();\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            if", "first_line_groundtruth": "(config.isClassic()) config.adjustClassicZ(true);", "first_line_prediction": " (config.isClassic()) config.adjustClassicLeft();", "match": 0}
{"groundtruth": "(config.isClassic()) config.cycleClassicAdjustMode();", "prediction": " (config.isClassic()) {\n                config.setClassic(false);\n            } else {\n                config.setClassic(true);\n            }\n        }\n        while (TOGGLE_CAMERA_MODE.wasPressed()) {\n            if  (config.isClassic()) {\n                config.setClassic(false);\n            } else {\n                config.setClassic(true);\n            }\n        }\n        while (ADJUST_UP.wasPressed()) {\n            config.adjust(0.05f);\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            config.adjust(-0.05f);\n       ", "first_line_groundtruth": "(config.isClassic()) config.cycleClassicAdjustMode();", "first_line_prediction": " (config.isClassic()) {", "match": 0}
{"groundtruth": "!config.isClassic());", "prediction": "config.isClassic() ? false : true);\n            ConfigFile.save();\n        }\n        while (ADJUST_UP.wasPressed()) {\n            config.adjustOffset(0.01F);\n            ConfigFile.save();\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            config.adjustOffset(-0.01F);\n            ConfigFile.save();\n        }\n        while (ADJUST_FRONT.wasPressed()) {\n            config.adjustOffset(0.01F, 0.0F, 1.0F);\n            ConfigFile.save();\n        }\n        while", "first_line_groundtruth": "!config.isClassic());", "first_line_prediction": "config.isClassic() ? false : true);", "match": 0}
{"groundtruth": "RealCameraCore.isActive();", "prediction": " functionProvider.get(getModelPartName()).test(0.0f, new MatrixStack());\n    }\n\n    /**\n     * @see com.xtracr.realcamera.mixins.MixinPlayerEntityRenderer#onSetModelPoseRETURN\n     * MixinPlayerEntityRenderer.onSetModelPoseRETURN\n     */\n    public static boolean shouldDisable(MinecraftClient client, String modelPartName) {\n        ModConfig.Disable.optionalParts.add(modelPartName);\n        return RealCameraCore.isRenderingWorld && config.shouldDisableRender(modelPartName) &&  functionProvider.get(getModelPartName()).test", "first_line_groundtruth": "RealCameraCore.isActive();", "first_line_prediction": " functionProvider.get(getModelPartName()).test(0.0f, new MatrixStack());", "match": 0}
{"groundtruth": "config.isEnabled();", "prediction": " config.isPerspectiveEnabled();\n            config.setPerspectiveEnabled(!enabled);\n            RealCamera.LOGGER.info(\"Perspective mode is now \" + (enabled ? \"enabled\" : \"disabled\"));\n        }\n\n        while (TOGGLE_ADJUST_MODE.wasPressed()) {\n            boolean enabled =  config.isAdjustModeEnabled();\n            config.setAdjustModeEnabled(!enabled);\n            RealCamera.LOGGER.info(\"Adjust mode is now \" + (enabled ? \"enabled\" : \"disabled\"));\n        }\n\n        while (TOGGLE_CAMERA_MODE.wasPressed()) {\n            boolean enabled =  config.isCameraMode", "first_line_groundtruth": "config.isEnabled();", "first_line_prediction": " config.isPerspectiveEnabled();", "match": 0}
{"groundtruth": "config.isClassic()) config.cycleClassicAdjustMode();", "prediction": "config.isClassic()) {\n                config.setClassic(false);\n            } else {\n                config.setClassic(true);\n            }\n        }\n        while (TOGGLE_CAMERA_MODE.wasPressed()) {\n            if (config.isClassic()) {\n                config.setClassic(false);\n            } else {\n                config.setClassic(true);\n            }\n        }\n        while (ADJUST_UP.wasPressed()) {\n            config.adjust(0.05f);\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            config.adjust(-0.05f);\n        }\n       ", "first_line_groundtruth": "config.isClassic()) config.cycleClassicAdjustMode();", "first_line_prediction": "config.isClassic()) {", "match": 0}
{"groundtruth": ")) config.adjustClassicZ(true);", "prediction": "client)) config.adjustClassicOffset(-1);\n            else config.adjustOffset(-1);\n            ConfigFile.save();\n        }\n        while (ADJUST_RIGHT.wasPressed()) {\n            if (config.isClassic(client)) config.adjustClassicOffset(1);\n            else config.adjustOffset(1);\n            ConfigFile.save();\n        }\n        while (ADJUST_UP.wasPressed()) {\n            if (config.isClassic(client)) config.adjustClassicOffset(0, 1);\n            else config.adjustOffset(0, 1);\n            ConfigFile.save();\n        }\n       ", "first_line_groundtruth": ")) config.adjustClassicZ(true);", "first_line_prediction": "client)) config.adjustClassicOffset(-1);", "match": 0}
{"groundtruth": "config.adjustBindingZ(true);", "prediction": " config.adjustOffsetX(true);\n            ConfigFile.save();\n        }\n        while (ADJUST_RIGHT.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicZ(false);\n            else  config.adjustOffsetX(false);\n            ConfigFile.save();\n        }\n        while (ADJUST_UP.wasPressed()) {\n            if (config.isClassic()) config.adjustClassicX(true);\n            else  config.adjustOffsetY(true);\n            ConfigFile.save();\n        }\n        while (ADJUST_DOWN.wasPressed()) {\n            if (config.is", "first_line_groundtruth": "config.adjustBindingZ(true);", "first_line_prediction": " config.adjustOffsetX(true);", "match": 0}
{"groundtruth": "TableFieldUtil.getFieldMap(r.getClass());", "prediction": " TableFieldUtil.getFieldMap(r.getClass());\n        for (CanalEntry.Column column : columnList) {\n            String fieldName = columnNames.get(column.getName());\n            if (StringUtils.isNotEmpty(fieldName)) {\n                TableFieldUtil.setFieldValue(r, fieldName, column.getValue());\n            }\n        }\n        return r;\n    }", "first_line_groundtruth": "TableFieldUtil.getFieldMap(r.getClass());", "first_line_prediction": " TableFieldUtil.getFieldMap(r.getClass());", "match": 0}
{"groundtruth": "return config.getModModelPartName();", "prediction": " return config.compats.modModelPart;\n    }\n\n    /**\n     * @param tickDelta   or partialTick(s) (official mapping)\n     * @param matrixStack or poseStack (official mapping)\n     * @return {@code true} if the result of {@code matrixStack} after processing is identical to the actual rendering.\n     * @see CompatExample#virtualRender\n     */\n    public static boolean virtualRender(float tickDelta, MatrixStack matrixStack) {\n        try {\n            final String modid = RealCameraCore.getInstance().getModID();\n            final BiPredicate<Float, MatrixStack> function", "first_line_groundtruth": "return config.getModModelPartName();", "first_line_prediction": " return config.compats.modModelPart;", "match": 0}
{"groundtruth": "Object result = StringConvertUtil.convertType(type, value);", "prediction": " if (type == String.class) {\n             field.set(object, value);\n         } else if (type == Integer.class) {\n             field.set(object, Integer.valueOf(value));\n         } else if (type == Long.class) {\n             field.set(object, Long.valueOf(value));\n         } else if (type == Boolean.class) {\n             field.set(object, Boolean.valueOf(value));\n         } else if (type == Double.class) {\n             field.set(object, Double.valueOf(value));\n         } else if (type == Float.class", "first_line_groundtruth": "Object result = StringConvertUtil.convertType(type, value);", "first_line_prediction": " if (type == String.class) {", "match": 0}
{"groundtruth": "= canalProperties.getRabbitMq();", "prediction": " = canalProperties.getMq();\n        return RabbitMqCanalClient.builder()\n                .hostname(mqProperties.getHost())\n                .port(mqProperties.getPort())\n                .username(mqProperties.getUsername())\n                .password(<PASSWORD>())\n                .virtualHost(mqProperties.getVirtualHost())\n                .exchange(mqProperties.getExchange())\n                .routingKey(mqProperties.getRoutingKey())\n                .messageHandler(messageHandler)\n                .build();\n    }", "first_line_groundtruth": "= canalProperties.getRabbitMq();", "first_line_prediction": " = canalProperties.getMq();", "match": 0}
{"groundtruth": ") config.adjustClassicX(false);", "prediction": " && config.isAdjustingOffset()) config.adjustClassicX(false);\n            else config.adjustBindingX(false);\n            ConfigFile.save();\n        }\n    }", "first_line_groundtruth": ") config.adjustClassicX(false);", "first_line_prediction": " && config.isAdjustingOffset()) config.adjustClassicX(false);", "match": 0}
{"groundtruth": "(VirtualRenderer.shouldDisableRender(\"jacket\")) model.jacket.visible = false;", "prediction": " (VirtualRenderer.shouldDisableRender(\"jacket\")) model.jacket.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"cloak\")) model.cloak.visible = false;\n    }", "first_line_groundtruth": "(VirtualRenderer.shouldDisableRender(\"jacket\")) model.jacket.visible = false;", "first_line_prediction": " (VirtualRenderer.shouldDisableRender(\"jacket\")) model.jacket.visible = false;", "match": 0}
{"groundtruth": "() && DoABarrelRollCompat.modEnabled() && RealCameraCore.isActive()) {", "prediction": "() && RealCameraCore.isActive()) {\n            DoABarrelRollCompat.onBeforeCameraUpdate(tickDelta, limitTime, matrixStack);\n        }\n    }", "first_line_groundtruth": "() && DoABarrelRollCompat.modEnabled() && RealCameraCore.isActive()) {", "first_line_prediction": "() && RealCameraCore.isActive()) {", "match": 0}
{"groundtruth": ".modEnabled() && RealCameraCore.isActive()) {", "prediction": ".isActive()) {\n            DoABarrelRollCompat.onBeforeCameraUpdate(tickDelta, limitTime, matrixStack);\n        }\n    }", "first_line_groundtruth": ".modEnabled() && RealCameraCore.isActive()) {", "first_line_prediction": ".isActive()) {", "match": 0}
{"groundtruth": ").OnMessageReceive(m_baseObject, code, msg);", "prediction": ").OnMessageReceive(fragment, code, msg);\n            }\n        } else {\n            printErrorLog(\"sendMessageToFragment -> fragment:\" + fragment + \" is not bind listener\");\n        }\n    }\n\n    public void sendMessageToContainerView(int containerViewId, int code, Object msg) {\n        if (containerViewId != 0) {\n            FragmentManager fragmentManager = m_containerViewMap.get(containerViewId);\n            if (fragmentManager != null) {\n                fragmentManager.executePendingTransactions();\n                Fragment fragment = fragmentManager.findFragmentByTag(m_metaphorMessage.getTag());", "first_line_groundtruth": ").OnMessageReceive(m_baseObject, code, msg);", "first_line_prediction": ").OnMessageReceive(fragment, code, msg);", "match": 0}
{"groundtruth": "if (VirtualRenderer.shouldDisableRender(\"leftPants\")) model.leftPants.visible = false;", "prediction": " if (VirtualRenderer.shouldDisableRender(\"rightPants\")) model.rightPants.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftPants\")) model.leftPants.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightBoots\")) model.rightBoots.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"leftBoots\")) model.leftBoots.visible = false;\n        if (VirtualRenderer.shouldDisableRender(\"rightHelmet\")) model.rightHelmet.visible = false;\n        if (VirtualRenderer.shouldDisableRender", "first_line_groundtruth": "if (VirtualRenderer.shouldDisableRender(\"leftPants\")) model.leftPants.visible = false;", "first_line_prediction": " if (VirtualRenderer.shouldDisableRender(\"rightPants\")) model.rightPants.visible = false;", "match": 0}
{"groundtruth": "&& camera.isThirdPerson() && RealCameraCore.isActive() &&\n                !ConfigFile.modConfig.allowRenderingHandWhen(client)) {", "prediction": " && RealCameraCore.isActive()) {\n            toggled = !toggled;\n            if (toggled) {\n                DoABarrelRollCompat.setThirdPerson(true);\n            } else {\n                DoABarrelRollCompat.setThirdPerson(false);\n            }\n        }\n    }", "first_line_groundtruth": "&& camera.isThirdPerson() && RealCameraCore.isActive() &&", "first_line_prediction": " && RealCameraCore.isActive()) {", "match": 0}
{"groundtruth": "m_metaphorManager.showFragment(strTag);", "prediction": " m_metaphorManager.showFragment(strTag);\n         return this;\n    }\n\n    @Override\n    public IMetaphorSubFragmentManager hideFragment(@NonNull String strTag) {\n        m_metaphorManager.hideFragment(strTag);\n        return this;\n    }\n\n    @Override\n    public boolean isTagExist(@NonNull String strTag) {\n        return m_metaphorManager.isTagExist(strTag);\n    }", "first_line_groundtruth": "m_metaphorManager.showFragment(strTag);", "first_line_prediction": " m_metaphorManager.showFragment(strTag);", "match": 0}
{"groundtruth": "settings.setTemperature(getMaxTemperatureValue(form.getTemperature()));", "prediction": " settings.setTemperature(getTemperatureValue(form.getTemperature()));\n    }\n  }\n\n  @Override\n  public void reset() {\n    if (form != null) {\n      form.setApiKey(settings.getApiKey());\n      form.setModel(settings.getModel());\n      form.setMaxTokens(String.valueOf(settings.getMaxTokens()));\n      form.setTemperature(String.valueOf(settings.getTemperature()));\n    }\n  }\n\n  @Override\n  public void disposeUIResources() {\n    form = null;\n  }\n\n  private int getMaxTokensValue(String maxTokens) {\n    try {\n      return Integer.parseInt(", "first_line_groundtruth": "settings.setTemperature(getMaxTemperatureValue(form.getTemperature()));", "first_line_prediction": " settings.setTemperature(getTemperatureValue(form.getTemperature()));", "match": 0}
{"groundtruth": "m_fx1 = FragmentX1.newInstance();", "prediction": " m_fx1 = new FragmentX1();\n         m_fx2 = new FragmentX2();\n         m_fx3 = new FragmentX3();\n         m_fa = new FragmentA();\n         m_fb = new FragmentB();\n         m_fc = new FragmentC();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Metaphor.with(MainActivity.this).init();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Metaphor.with(MainActivity.this).destroy();\n    }\n\n    @Override\n    protected", "first_line_groundtruth": "m_fx1 = FragmentX1.newInstance();", "first_line_prediction": " m_fx1 = new FragmentX1();", "match": 0}
{"groundtruth": "!form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "prediction": " !form.getTemperature().equals(String.valueOf(settings.getTemperature()));\n    }\n    return false;\n  }\n\n  @Override\n  public void apply() {\n    settings.setApiKey(form.getApiKey());\n    settings.setModel(form.getModel());\n    settings.setMaxTokens(Integer.parseInt(form.getMaxTokens()));\n    settings.setTemperature(Double.parseDouble(form.getTemperature()));\n  }\n\n  @Override\n  public void reset() {\n    form.setApiKey(settings.getApiKey());\n    form.setModel(settings.getModel());\n    form.setMaxTokens(String.valueOf(settings.getMax", "first_line_groundtruth": "!form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "first_line_prediction": " !form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "match": 0}
{"groundtruth": "return form.getMainPanel();", "prediction": " return form.getPanel();\n  }\n\n  @Override\n  public boolean isModified() {\n    return settings.getApiKey() != form.getApiKey() || settings.getModel() != form.getModel();\n  }\n\n  @Override\n  public void apply() {\n    settings.setApiKey(form.getApiKey());\n    settings.setModel(form.getModel());\n  }\n\n  @Override\n  public void reset() {\n    form.setApiKey(settings.getApiKey());\n    form.setModel(settings.getModel());\n  }\n\n  @Override\n  public void disposeUIResources() {\n    form = null;\n  }", "first_line_groundtruth": "return form.getMainPanel();", "first_line_prediction": " return form.getPanel();", "match": 0}
{"groundtruth": "form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "prediction": "form.getTemperature().equals(String.valueOf(settings.getTemperature()));\n    }\n    return false;\n  }\n\n  @Override\n  public void apply() {\n    settings.setApiKey(form.getApiKey());\n    settings.setModel(form.getModel());\n    settings.setMaxTokens(Integer.parseInt(form.getMaxTokens()));\n    settings.setTemperature(Double.parseDouble(form.getTemperature()));\n  }\n\n  @Override\n  public void reset() {\n    form.setApiKey(settings.getApiKey());\n    form.setModel(settings.getModel());\n    form.setMaxTokens(String.valueOf(settings.getMaxTokens", "first_line_groundtruth": "form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "first_line_prediction": "form.getTemperature().equals(String.valueOf(settings.getTemperature()));", "match": 1}
{"groundtruth": "(testRun.getTestRunOutcome() == null) {", "prediction": " (testRun.getOutcome() == null) {\n                    continue;\n                }\n\n                //do not show items without git repository\n                GitRepository gitRepository = GitService.getGitRepository(project, testRun.getGitRemote());\n                if (gitRepository == null) {\n                    continue;\n                }\n\n                //do not show items without git remote\n                GitRemote gitRemote = gitRepository.getRemote();\n                if (gitRemote == null) {\n                    continue;\n                }\n\n                //do not show items without git branch\n                String gitBranch = gitRemote.getName();\n                if (gitBranch == null) {\n                    continue;\n               ", "first_line_groundtruth": "(testRun.getTestRunOutcome() == null) {", "first_line_prediction": " (testRun.getOutcome() == null) {", "match": 0}
{"groundtruth": "apiResponse.getMessage(),\n              String.format(\"%d ExceptionAI Error\", apiResponse.getCode()),\n              Messages.getErrorIcon());", "prediction": " \"ExceptionAI Suggestions\\n\\n\" + apiResponse.getMessage(),\n              \"ExceptionAI Suggestions\",\n              Messages.getInformationIcon());\n        }\n      });\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }", "first_line_groundtruth": "apiResponse.getMessage(),", "first_line_prediction": " \"ExceptionAI Suggestions\\n\\n\" + apiResponse.getMessage(),", "match": 0}
{"groundtruth": "\"\\n\" + apiResponse.getMessage(),\n              \"ExceptionAI Suggestions\",\n              Messages.getInformationIcon());", "prediction": " \"Suggestions: \" + apiResponse.getSuggestions(),\n               \"Suggestions\",\n               Messages.getInformationIcon()\n          );\n        } else {\n          Messages.showMessageDialog(\n              project,\n              \"Suggestions: \" + apiResponse.getMessage(),\n              \"Suggestions\",\n              Messages.getInformationIcon()\n          );\n        }\n      });\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }", "first_line_groundtruth": "\"\\n\" + apiResponse.getMessage(),", "first_line_prediction": " \"Suggestions: \" + apiResponse.getSuggestions(),", "match": 0}
{"groundtruth": "= testRun.getDateTime();", "prediction": " = testRun.getDateTime();\n                String timeString = dateTimeString.substring(11, dateTimeString.length() - 3);\n                String dateString = dateTimeString.substring(0, 10);\n                String time = timeString.substring(0, 2) + \":\" + timeString.substring(2, 4);\n                String date = dateString.substring(0, 4) + \"-\" + dateString.substring(4, 6) + \"-\" + dateString.substring(6, 8);\n                JBLabel timeLabel = new JBLabel(time, Swing", "first_line_groundtruth": "= testRun.getDateTime();", "first_line_prediction": " = testRun.getDateTime();", "match": 0}
{"groundtruth": "switch (testRun.getTestRunOutcome()) {", "prediction": " //If the test run outcome is PASSED make the circle green\n                 if (testRun.getTestRunOutcome() == TestRunOutcome.PASSED) {\n                     circleColor = ButtonColors.TEST_PASSED_COLOR;\n                 }\n\n                 //If the test run outcome is FAILED make the circle red\n                 if (testRun.getTestRunOutcome() == TestRunOutcome.FAILED) {\n                     circleColor = ButtonColors.TEST_FAILED_COLOR;\n                 }\n\n                 //If the test run outcome is NOT_EXECUTED make the circle yellow\n                 if (testRun.getTestRunOutcome() == TestRunOutcome.NOT_EXECUT", "first_line_groundtruth": "switch (testRun.getTestRunOutcome()) {", "first_line_prediction": " //If the test run outcome is PASSED make the circle green", "match": 0}
{"groundtruth": "14, testRun.getCommit());", "prediction": "14);\n                historyContent.add(exampleGreenCirclePanel, historyGbc);\n\n                // prediction\n                historyGbc.gridy = i;\n                historyGbc.gridx = 2;\n\n                JBLabel predictionLabel = new JBLabel(testRun.getPrediction().toString());\n                historyContent.add(predictionLabel, historyGbc);\n\n                // link to test\n                historyGbc.gridy = i;\n                historyGbc.gridx = 3;\n\n                JBLabel testLinkLabel = new JBLabel(testRun.getTestName());\n                historyContent.add(testLinkLabel, historyG", "first_line_groundtruth": "14, testRun.getCommit());", "first_line_prediction": "14);", "match": 0}
{"groundtruth": "apiResponse.getCode() == 200) {", "prediction": "apiResponse.isSuccess()) {\n          String suggestion = apiResponse.getSuggestion();\n          String message = \"Suggestion: \" + suggestion;\n          String title = \"ExceptionAI Suggestion\";\n          int messageType = JOptionPane.INFORMATION_MESSAGE;\n          JOptionPane.showMessageDialog(null, message, title, messageType);\n        } else {\n          String message = \"Error: \" + apiResponse.getMessage();\n          String title = \"ExceptionAI Suggestion\";\n          int messageType = JOptionPane.ERROR_MESSAGE;\n          JOptionPane.showMessageDialog(null, message, title, messageType);\n        }\n      });\n    } catch (Exception e) {", "first_line_groundtruth": "apiResponse.getCode() == 200) {", "first_line_prediction": "apiResponse.isSuccess()) {", "match": 0}
{"groundtruth": "= testRun.getPrediction() == Prediction.CORRECT ? AllIcons.RunConfigurations.TestPassed : AllIcons.RunConfigurations.TestFailed;", "prediction": " = null;\n                switch (testRun.getTestRunOutcome()) {\n                    case PASSED:\n                        icon = AllIcons.RunConfigurations.TestPassed;\n                        break;\n                    case FAILED:\n                        icon = AllIcons.RunConfigurations.TestFailed;\n                        break;\n                    case NOT_EXECUTED:\n                        icon = AllIcons.RunConfigurations.TestIgnored;\n                        break;\n                }\n\n                JBLabel iconLabel = new JBLabel(icon);\n                historyContent.add(iconLabel, historyGbc);\n\n                // commit\n                historyGbc.gridx = 3;\n                historyGbc.gridy = i;\n\n                J", "first_line_groundtruth": "= testRun.getPrediction() == Prediction.CORRECT ? AllIcons.RunConfigurations.TestPassed : AllIcons.RunConfigurations.TestFailed;", "first_line_prediction": " = null;", "match": 0}
{"groundtruth": "<Class<?>, List<ISubscriber>> registeredSubs = SubscriberFinder.find(subscriber);", "prediction": "<Class<?>, List<ISubscriber>> subscriberMap = SubscriberFinder.find(subscriber);\n        // \u904d\u5386\u8ba2\u9605\u8005\u6620\u5c04\uff0c\u5c06\u8ba2\u9605\u8005\u6dfb\u52a0\u5230\u8ba2\u9605\u8005\u6620\u5c04\u4e2d\n        subscriberMap.forEach((eventClass, subscribers) -> {\n            subscribers.forEach(subscriber1 -> {\n                if(subscriberStatusMap.get(subscriber1.getClass()) != null) {\n                    logger.warn(String.format(\"Subscriber %s has already been registered\",subscriber1.getClass()));\n                    return;\n                }\n                subscriberStatusMap.put(subscriber1.getClass(), true);\n                executor.execute(new Subscription", "first_line_groundtruth": "<Class<?>, List<ISubscriber>> registeredSubs = SubscriberFinder.find(subscriber);", "first_line_prediction": "<Class<?>, List<ISubscriber>> subscriberMap = SubscriberFinder.find(subscriber);", "match": 0}
{"groundtruth": "subscriber.getThreadType() == ThreadType.ASYNC) {", "prediction": "subscriber.getThreadType() == ThreadType.MAIN) {\n                executor.execute(() -> {\n                    try {\n                        subscriber.invoke(event);\n                    } catch (Exception e) {\n                        logger.error(String.format(\"Subscriber %s threw an exception\",subscriber.getClass()),e);\n                    }\n                });\n            }else {\n                executor.execute(() -> {\n                    try {\n                        subscriber.invoke(event);\n                    } catch (Exception e) {\n                        logger.error(String.format(\"Subscriber %s threw an exception\",subscriber.getClass()),e);\n                    }\n                });\n            }\n        }\n    }", "first_line_groundtruth": "subscriber.getThreadType() == ThreadType.ASYNC) {", "first_line_prediction": "subscriber.getThreadType() == ThreadType.MAIN) {", "match": 0}
{"groundtruth": "(sub -> sub.getSubscriber() == subscriber);", "prediction": "(subscriber1 -> subscriber1.getSubscriber() == subscriber);\n                if(subscribers.isEmpty()) {\n                    subscriberStatusMap.remove(subscriberClass);\n                    logger.info(String.format(\"Unregistered: %s\",subscriber.getClass()));\n                }\n            });\n        }\n    }\n\n    public void post(IEvent event) {\n        Objects.requireNonNull(event);\n        if(subscriberMap != null && !subscriberMap.isEmpty()) {\n            subscriberMap.forEach((subscriberClass, subscribers) -> {\n                if(subscribers == null || subscribers.isEmpty()) {\n                    logger.warn(String.format(\"Subscriber %s was", "first_line_groundtruth": "(sub -> sub.getSubscriber() == subscriber);", "first_line_prediction": "(subscriber1 -> subscriber1.getSubscriber() == subscriber);", "match": 0}
{"groundtruth": "DataSourceContext.get();", "prediction": " DataSourceContext.get();\n        if (dataSourceKey == null) {\n            return defaultDataSource;\n        }\n        return dataSources.get(dataSourceKey);\n    }\n\n    private Connection wrapConnection(DataSource dataSource, Connection connection) {\n        TxConnectionContext.set(dataSource);\n        TxConnectionContext.set(connection);\n        return new TxConnectionWrapper(connection);\n    }", "first_line_groundtruth": "DataSourceContext.get();", "first_line_prediction": " DataSourceContext.get();", "match": 0}
{"groundtruth": "return TransactionContext.get() != null;", "prediction": " return TransactionContext.get() != null;\n    }\n\n    private SuspendedTx suspend() {\n        SuspendedTx suspended = new SuspendedTx();\n        suspended.setTransaction(TransactionContext.get());\n        suspended.setTxConnection(TxConnectionContext.get());\n        return suspended;\n    }\n\n    private void resume(SuspendedTx suspended) {\n        if (suspended != null) {\n            TransactionContext.set(suspended.getTransaction());\n            TxConnectionContext.set(suspended.getTxConnection());\n        }\n    }\n\n    private Object doExecute(Transaction transaction) throws Throwable", "first_line_groundtruth": "return TransactionContext.get() != null;", "first_line_prediction": " return TransactionContext.get() != null;", "match": 0}
{"groundtruth": "= transaction.getNoRollbackFor();", "prediction": " = transaction.getNoRollbackFor();\n        for (Class<? extends Throwable> noRollback : noRollbacks) {\n            if (noRollback.isInstance(t)) {\n                return false;\n            }\n        }\n        Class<? extends Throwable>[] rollbacks = transaction.getRollbackFor();\n        for (Class<? extends Throwable> rollback : rollbacks) {\n            if (rollback.isInstance(t)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void resume(SuspendedTx suspended) {\n        if (suspended != null) {\n            TransactionContext.set(suspended.", "first_line_groundtruth": "= transaction.getNoRollbackFor();", "first_line_prediction": " = transaction.getNoRollbackFor();", "match": 0}
{"groundtruth": "TransactionContext.remove();", "prediction": " return TxConnectionContext.suspend(tid);\n    }\n\n    private void resume(SuspendedTx suspended) {\n        if (suspended != null) {\n            suspended.resume();\n        }\n    }\n\n    private Object doExecute(Transaction transaction) throws Throwable {\n        TxId tid = TransactionContext.get();\n        if (tid == null) {\n            return transaction.proceed();\n        }\n        TxConnectionWrapper txConnection = TxConnectionContext.get(tid, transaction.getDataSource());\n        if (txConnection == null) {\n            return transaction.proceed();\n        }\n        return txConnection.execute(transaction);\n    }", "first_line_groundtruth": "TransactionContext.remove();", "first_line_prediction": " return TxConnectionContext.suspend(tid);", "match": 0}
{"groundtruth": "= transaction.proceed();", "prediction": " = transaction.proceed();\n            rollback = false;\n        } catch (Throwable e) {\n            rollback = true;\n            throw e;\n        } finally {\n            if (rollback) {\n                this.rollback(tid);\n            } else {\n                this.commit(tid);\n            }\n        }\n        return result;\n    }\n\n    private void rollback(TxId tid) {\n        TxConnectionContext.remove(tid);\n        TransactionContext.remove();\n    }\n\n    private void commit(TxId tid) {\n        TxConnectionContext.remove(tid);\n        TransactionContext.remove();\n    }\n\n    private void resume(SuspendedTx sus", "first_line_groundtruth": "= transaction.proceed();", "first_line_prediction": " = transaction.proceed();", "match": 0}
{"groundtruth": "callback.onCompletion(content);", "prediction": " success = true;\n                }\n            } catch (Exception e) {\n                log.error(\"gpt-3.5-turbo chat error:{}\", ExceptionUtils.getStackTrace(e));\n                retryCount++;\n                Thread.sleep(1000);\n            }\n        }\n        if (!success) {\n            throw new ChatException(\"\u6211", "first_line_groundtruth": "callback.onCompletion(content);", "first_line_prediction": " success = true;", "match": 0}
{"groundtruth": "BotUtil.resetAll();", "prediction": " BotUtil.resetPrompt(chatBO.getSessionId());\n             event.getSubject().sendMessage(\"\u91cd\u7f6e\u6210\u529f\");\n             return;\n        }\n        if (RESET_WORD.equals(prompt)) {\n             ///\u68c0\u6d4b\u5230\u91cd\u7f6e\u4f1a\u8bdd\u6307\u4ee4\n             BotUtil.resetPrompt(chatBO.getSessionId());\n             event.getSubject().sendMessage(\"\u91cd\u7f6e\u6210\u529f\");\n             return;\n        }\n        if (prompt.startsWith(GET_WORD)) {\n            String uniquePrompt = interactService.getUniquePrompt(chatBO.getSessionId());\n            if (StringUtils.isEmpty(uniquePrompt)) {\n                MessageChain messages = new", "first_line_groundtruth": "BotUtil.resetAll();", "first_line_prediction": " BotUtil.resetPrompt(chatBO.getSessionId());", "match": 0}
{"groundtruth": "Extractor.warning(\"Warning: Did not match as a member: \" + line);", "prediction": " warning(\"Could not parse method: \" + line);\n                    continue;\n                }\n                String modifiers = matcher.group(1);\n                String returnType = matcher.group(2);\n                String methodName = matcher.group(3);\n                String parameters = matcher.group(4);\n                String body = matcher.group(5);\n                String signature = returnType + \" \" + methodName + parameters;\n                String containingClass = currentClass;\n                if (containingClass == null) {\n                    warning(\"Could not find class for \" + signature);\n                }\n                String containingPackage = currentPackage;\n                if (containingPackage == null) {\n                   ", "first_line_groundtruth": "Extractor.warning(\"Warning: Did not match as a member: \" + line);", "first_line_prediction": " warning(\"Could not parse method: \" + line);", "match": 0}
{"groundtruth": "rateLimiter.setPrompt(sessionId, prompt);", "prediction": " rateLimiter.setPrompt(sessionId, prompt);\n    }\n\n    @Override\n    public void setPrompt(String sessionId, String prompt){\n        rateLimiter.setPrompt(sessionId, prompt);\n    }\n\n    @Override\n    public void resetPrompt(String sessionId){\n        rateLimiter.resetPrompt(sessionId);\n    }\n\n    @Override\n    public void setPrompt(String sessionId, String prompt, String model){\n        rateLimiter.setPrompt(sessionId, prompt, model);\n    }\n\n    @Override\n    public void setPrompt(String sessionId, String prompt, String model, String key){\n        rateLimiter.setPrompt(sessionId, prompt,", "first_line_groundtruth": "rateLimiter.setPrompt(sessionId, prompt);", "first_line_prediction": " rateLimiter.setPrompt(sessionId, prompt);", "match": 0}
{"groundtruth": "Extractor.warning(\"Warning: Did not match as a class/interface: \" + line);", "prediction": " Extractor.warning(\"Warning: Did not match as a class: \" + line);\n                } else {\n                    currentClass = matcher.group(3);\n                    classSet.add(currentClass);\n                    String superType = matcher.group(5);\n                    if (superType != null) {\n                        superType = stripTypeArgs(superType);\n                        classSet.add(superType);\n                    }\n                    String interfaces = matcher.group(7);\n                    if (interfaces != null) {\n                        for (String interfaceType : interfaces.split(\",\")) {\n                            interfaceType = stripTypeArgs(interfaceType);\n                            classSet", "first_line_groundtruth": "Extractor.warning(\"Warning: Did not match as a class/interface: \" + line);", "first_line_prediction": " Extractor.warning(\"Warning: Did not match as a class: \" + line);", "match": 0}
{"groundtruth": "FixProtocolVersion.fix();", "prediction": " //ChatGPTPlus\n        model = \"gpt-3-plus\";\n        maxToken = 1024;\n        temperature = 0.8;\n        basicPrompt = \"\u7b80", "first_line_groundtruth": "FixProtocolVersion.fix();", "first_line_prediction": " //ChatGPTPlus", "match": 0}
{"groundtruth": "action.deleteCache();", "prediction": " action.clearCache();\n    }\n\n    @Override\n    public boolean startInWriteAction() {\n        return false;\n    }", "first_line_groundtruth": "action.deleteCache();", "first_line_prediction": " action.clearCache();", "match": 0}
{"groundtruth": "HttpContextUtil.setAttributeToSession(\"verifyCode\", code);", "prediction": " return \"\u53d1\u9001\u6210\u529f\";\n    }\n\n    @PostMapping(\"/login\")\n    public String login(@Valid @RequestBody LoginVO loginVO) {\n        String verifyCode = (String) HttpContextUtil.getAttributeFromInSession(\"verifyCode\");\n        if (!verifyCode.equals(loginVO.getVerifyCode())) {\n            return \"\u9a8c\u8bc1\u7801\u4e0d\u6b63\u786e\uff0c\u767b\u5f55\u5931\u8d25\";\n        }\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.eq(\"email\", loginVO.getEmail());\n        User user = userService.getOne(queryWrapper);\n        if (user == null) {\n            return \"\u8be5\u90ae\u7bb1\u672a\u6ce8\u518c\";", "first_line_groundtruth": "HttpContextUtil.setAttributeToSession(\"verifyCode\", code);", "first_line_prediction": " return \"\u53d1\u9001\u6210\u529f\";", "match": 0}
{"groundtruth": "request.getName())\n                .createdBy(userId)\n                .build();", "prediction": "request.getName())\n                 .status(OrgStatus.EFFECTIVE)\n                 .build();\n\n        orgHandler.addOrg(org, userId);\n\n        return org.toResponse();\n    }\n\n    public OrgResponse updateOrgBasic(Long id, UpdateOrgBasicRequest request, Long userId) {\n        Optional<Org> org = orgRepository.findById(id);\n        if (org.isEmpty()) {\n            throw new BusinessException(\"Org not found\");\n        }\n\n        org.get().update(request.getName(), request.getLeaderId());\n\n        orgHandler.updateOrg(org.get(), userId);\n\n        return org.get", "first_line_groundtruth": "request.getName())", "first_line_prediction": "request.getName())", "match": 1}
{"groundtruth": "this.code = code.getValue();", "prediction": " this.code = code.getValue();\n         this.msg = code.getMsg();\n         this.data = data;\n    }\n\n    public Result(ResultCodeEnum code, String msg, T data) {\n         this.code = code.getValue();\n         this.msg = msg;\n         this.data = data;\n    }\n\n    public Result(ResultCodeEnum code) {\n         this.code = code.getValue();\n         this.msg = code.getMsg();\n    }\n\n    public Result(ResultCodeEnum code, String msg) {\n         this.code = code.getValue();\n         this.msg = msg;\n    }\n\n   ", "first_line_groundtruth": "this.code = code.getValue();", "first_line_prediction": " this.code = code.getValue();", "match": 0}
{"groundtruth": "(request.getTenantId(), id)\n                .orElseThrow(() -> {", "prediction": "(request.getTenantId(), id)\n                .orElseThrow(() -> new BusinessException(\"Org not found\"));\n\n        orgHandler.updateOrgBasic(org, request, userId);\n\n        return buildOrgDto(org);\n    }\n\n    @Transactional\n    public OrgResponse updateOrgStatus(Long id, UpdateOrgStatusRequest request, Long userId) {\n        Org org = orgRepository.findById(request.getTenantId(), id)\n                .orElseThrow(() -> new BusinessException(\"Org not found\"));\n\n        orgHandler.updateOrgStatus(org, request, userId);\n\n        return buildOrgDto(org);\n    }\n\n    @Transactional\n   ", "first_line_groundtruth": "(request.getTenantId(), id)", "first_line_prediction": "(request.getTenantId(), id)", "match": 1}
{"groundtruth": "= status.code();", "prediction": " = status.code();\n        }\n        return params;\n    }\n\n    private static String buildSqlExistsByIdAndStatus(int statusesLength) {\n        StringBuilder sql = new StringBuilder(\"SELECT COUNT(*) FROM emp WHERE tenant_id = ? AND id = ?\");\n        for(int i = 0; i < statusesLength; i++) {\n            sql.append(\" AND status_code = ?\");\n        }\n        return sql.toString();\n    }", "first_line_groundtruth": "= status.code();", "first_line_prediction": " = status.code();", "match": 0}
{"groundtruth": "assertOrgName.shouldNotEmpty(newName);", "prediction": " assertOrgName.shouldNotEmpty(newName);\n             assertOrgName.shouldNotDuplicatedInSameSuperior(org.getTenantId(), org.getSuperiorId(), newName);\n             org.setName(newName);\n        }\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        org.setLastUpdateBy(userId);\n        org.setLastUpdateDate(LocalDateTime.now());\n    }", "first_line_groundtruth": "assertOrgName.shouldNotEmpty(newName);", "first_line_prediction": " assertOrgName.shouldNotEmpty(newName);", "match": 0}
{"groundtruth": "(request.getSuperiorId())\n                .name(request.getName())\n                .createdBy(userId)\n                .build();", "prediction": "(request.getSuperiorId())\n                 .name(request.getName())\n                 .status(OrgStatus.EFFECTIVE)\n                 .build();\n\n        orgHandler.addOrg(org, userId);\n\n        return org.toResponse();\n    }\n\n    public OrgResponse updateOrgBasic(Long id, UpdateOrgBasicRequest request, Long userId) {\n        Optional<Org> org = orgRepository.findById(id);\n        if (org.isEmpty()) {\n            throw new BusinessException(\"Org not found\");\n        }\n\n        org.get().update(request.getName(), request.getLeaderId());\n\n        orgHandler.updateOrg", "first_line_groundtruth": "(request.getSuperiorId())", "first_line_prediction": "(request.getSuperiorId())", "match": 1}
{"groundtruth": "org, request.getName() , request.getLeaderId(), userId);", "prediction": "org, request, userId);\n\n        return buildOrgDto(org);\n    }\n\n    @Transactional\n    public OrgResponse updateOrgStatus(Long id, UpdateOrgStatusRequest request, Long userId) {\n        Org org = orgRepository.findById(request.getTenantId(), id)\n                 .orElseThrow(() -> {\n                     throw new BusinessException(\"\u8981\u4fee\u6539\u7684\u7ec4\u7ec7(id =\" + id + \"  )\u4e0d\u5b58\u5728\uff01\");\n                 });\n\n        orgHandler.updateStatus(org, request, userId);\n\n        return buildOrgDto(org);\n    }\n\n    @Transactional\n    public OrgResponse updateOrgPosition(Long id, UpdateOrgPositionRequest", "first_line_groundtruth": "org, request.getName() , request.getLeaderId(), userId);", "first_line_prediction": "org, request, userId);", "match": 0}
{"groundtruth": "return orgService.cancelOrg(tenant, id, userId);", "prediction": " return orgService.cancelOrg(tenant, id, userId);\n    }", "first_line_groundtruth": "return orgService.cancelOrg(tenant, id, userId);", "first_line_prediction": " return orgService.cancelOrg(tenant, id, userId);", "match": 0}
{"groundtruth": "orgHandler.updateBasic(org, request.getName() , request.getLeaderId(), userId);", "prediction": " org = orgHandler.updateOrgBasic(org, request, userId);\n\n        return buildOrgDto(org);\n    }\n\n    @Transactional\n    public OrgResponse updateOrgStatus(Long id, UpdateOrgStatusRequest request, Long userId) {\n        Org org = orgRepository.findById(request.getTenantId(), id)\n                 .orElseThrow(() -> {\n                    throw new BusinessException(\"\u8981\u4fee\u6539\u7684\u7ec4\u7ec7(id =\" + id + \"  )\u4e0d\u5b58\u5728\uff01\");\n                 });", "first_line_groundtruth": "orgHandler.updateBasic(org, request.getName() , request.getLeaderId(), userId);", "first_line_prediction": " org = orgHandler.updateOrgBasic(org, request, userId);", "match": 0}
{"groundtruth": "if (newLeader != null && !newLeader.equals(org.getLeaderId())) {", "prediction": " assertOrgLeader.shouldNotHasEmp(org.getTenantId(), org.getId());\n         org.setLeaderId(newLeader);\n    }\n\n    private void updateName(Org org, String newName) {\n        assertOrgName.shouldNotHasEmp(org.getTenantId(), org.getId());\n        org.setName(newName);\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        org.setLastUpdateBy(userId);\n        org.setLastUpdateDate(LocalDateTime.now());\n    }", "first_line_groundtruth": "if (newLeader != null && !newLeader.equals(org.getLeaderId())) {", "first_line_prediction": " assertOrgLeader.shouldNotHasEmp(org.getTenantId(), org.getId());", "match": 0}
{"groundtruth": "org.cancel();", "prediction": " updateAuditInfo(org, userId);\n    }\n\n    private void updateName(Org org, String newName) {\n        assertOrgName.shouldNotHasEmp(org.getTenantId(), org.getId());\n        assertOrgName.shouldNotHasEmp(org.getTenantId(), newName);\n        org.setName(newName);\n    }\n\n    private void updateLeader(Org org, Long newLeader) {\n        assertOrgLeader.shouldNotHasEmp(org.getTenantId(), org.getId());\n        assertOrgLeader.shouldNotHasEmp(org.getTenantId(), newLeader);\n        org.setLeaderId(new", "first_line_groundtruth": "org.cancel();", "first_line_prediction": " updateAuditInfo(org, userId);", "match": 0}
{"groundtruth": "OrgStatus.ofCode(statusCode));", "prediction": "OrgStatus.valueOf(this.statusCode));\n        org.setLastUpdatedAt(lastUpdatedAt);\n        org.setLastUpdatedBy(lastUpdatedBy);\n        return org;\n    }", "first_line_groundtruth": "OrgStatus.ofCode(statusCode));", "first_line_prediction": "OrgStatus.valueOf(this.statusCode));", "match": 0}
{"groundtruth": "assertOrgType.shouldEffective(tenantId, orgTypeCode);", "prediction": " assertOrgType.shouldEffective(tenantId, orgTypeCode);\n    }", "first_line_groundtruth": "assertOrgType.shouldEffective(tenantId, orgTypeCode);", "first_line_prediction": " assertOrgType.shouldEffective(tenantId, orgTypeCode);", "match": 0}
{"groundtruth": "= assertSuperior.shouldEffective(tenantId, superiorId);", "prediction": " = assertSuperior.shouldEffective(tenantId, superiorId);\n        assertOrgType.shouldEffective(tenantId, superiorOrg.getOrgTypeCode());\n    }\n\n    private void validateOrgType() {\n        assertOrgType.shouldEffective(tenantId, orgTypeCode);\n    }", "first_line_groundtruth": "= assertSuperior.shouldEffective(tenantId, superiorId);", "first_line_prediction": " = assertSuperior.shouldEffective(tenantId, superiorId);", "match": 0}
{"groundtruth": "assertOrgLeader.shouldEffective(org.getTenantId(), newLeader);", "prediction": " assertOrgLeader.shouldNotHasEmp(org.getTenantId(), newLeader);\n             org.setLeaderId(newLeader);\n        }\n    }\n\n    private void updateName(Org org, String newName) {\n        if (newName != null && !newName.equals(org.getName())) {\n            assertOrgName.shouldNotHasEmp(org.getTenantId(), newName);\n            org.setName(newName);\n        }\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        org.setLastUpdateBy(userId);\n        org.setLastUpdateDate(LocalDateTime.now());", "first_line_groundtruth": "assertOrgLeader.shouldEffective(org.getTenantId(), newLeader);", "first_line_prediction": " assertOrgLeader.shouldNotHasEmp(org.getTenantId(), newLeader);", "match": 0}
{"groundtruth": "assertOrgName.shouldNotEmpty(name);", "prediction": " assertOrgName.shouldNotEmpty(name);\n         assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);\n    }\n\n    private void validateOrgType() {\n        assertOrgType.shouldEffective(orgTypeCode);\n    }\n\n    private void validateSuperior() {\n        assertSuperior.shouldEffective(tenantId, superiorId);\n    }", "first_line_groundtruth": "assertOrgName.shouldNotEmpty(name);", "first_line_prediction": " assertOrgName.shouldNotEmpty(name);", "match": 0}
{"groundtruth": "), org.getSuperiorId(), newName);", "prediction": " ), org.getSuperiorId(), newName);\n            org.setName(newName);\n        }\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        org.setLastUpdatedBy(userId);\n        org.setLastUpdatedAt(LocalDateTime.now());\n    }", "first_line_groundtruth": "), org.getSuperiorId(), newName);", "first_line_prediction": " ), org.getSuperiorId(), newName);", "match": 0}
{"groundtruth": "shouldNotDuplicatedInSameSuperior(org.getTenantId(), org.getSuperiorId(), newName);", "prediction": "shouldNotDuplicatedInSameSuperior(org.getTenantId(), org.getSuperiorId(), newName);\n            org.setName(newName);\n        }\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        org.setLastUpdatedBy(userId);\n        org.setLastUpdatedAt(LocalDateTime.now());\n    }", "first_line_groundtruth": "shouldNotDuplicatedInSameSuperior(org.getTenantId(), org.getSuperiorId(), newName);", "first_line_prediction": "shouldNotDuplicatedInSameSuperior(org.getTenantId(), org.getSuperiorId(), newName);", "match": 1}
{"groundtruth": "assertOrgLeader.shouldEffective(tenantId, leaderId);", "prediction": " assertOrgLeader.shouldEffective(tenantId, leaderId);\n    }\n\n    private void validateOrgTenant() {\n        assertOrgTenant.shouldEffective(tenantId);\n    }\n\n    private void validateOrgType() {\n        assertOrgType.shouldEffective(tenantId, orgTypeCode);\n    }\n\n    private void validateSuperior() {\n        assertSuperior.shouldEffective(tenantId, superiorId);\n    }\n\n    private void validateOrgName() {\n        assertOrgName.shouldNotEmpty(name);\n        assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);\n    }", "first_line_groundtruth": "assertOrgLeader.shouldEffective(tenantId, leaderId);", "first_line_prediction": " assertOrgLeader.shouldEffective(tenantId, leaderId);", "match": 0}
{"groundtruth": "assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);", "prediction": " assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);\n    }\n\n    private void validateOrgType() {\n        assertOrgType.shouldEffective(orgTypeCode);\n    }\n\n    private void validateSuperior() {\n        assertSuperior.shouldEffective(tenantId, superiorId);\n    }", "first_line_groundtruth": "assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);", "first_line_prediction": " assertOrgName.shouldNotDuplicatedInSameSuperior(tenantId, superiorId, name);", "match": 0}
{"groundtruth": "assertOrgType.shouldNotEntp(orgTypeCode);", "prediction": " // \u5f00\u53d1\u4e2d\u5fc3\u548c\u76f4\u5c5e\u90e8\u95e8\u7684\u4e0a\u7ea7\u53ea\u80fd\u662f\u4f01\u4e1a\n        assertOrgType.ofDevCenterAndDirectDeptMustEntp(tenantId, orgTypeCode);\n    }", "first_line_groundtruth": "assertOrgType.shouldNotEntp(orgTypeCode);", "first_line_prediction": " // \u5f00\u53d1\u4e2d\u5fc3\u548c\u76f4\u5c5e\u90e8\u95e8\u7684\u4e0a\u7ea7\u53ea\u80fd\u662f\u4f01\u4e1a", "match": 0}
{"groundtruth": "+ \"' \u7684\u7ec4\u7ec7\u7684\u7ec4\u7ec7\u7c7b\u578b\u4ee3\u7801 '\" + superiorOrg.getOrgTypeCode() + \"' \u65e0\u6548!\"));", "prediction": " + \"' \u7684\u4e0a\u7ea7\u7ec4\u7ec7\u7c7b\u522b '\" + superiorOrg.getOrgTypeCode() + \"' \u4e0d\u5b58\u5728\uff01\"));\n    }\n\n    public void ofDevGroupMustDevCenter(Long superior, String orgTypeCode, OrgType superiorOrgType) {\n        if (superiorOrgType.isDevGroup()) {\n            throw new DirtyDataException(\"id \u4e3a '\" + superior + \"' \u7684\u4e0a\u7ea7\u7ec4\u7ec7\u7c7b\u522b '\" + superiorOrgType.getOrgTypeCode() + \"' \u4e0d\u80fd\u662f\u5f00\u53d1\u7ec4\uff01\");\n        }\n    }\n\n    public void ofDevCenterAndDirectDeptMustEntp(Long superior, String orgTypeCode, OrgType superior", "first_line_groundtruth": "+ \"' \u7684\u7ec4\u7ec7\u7684\u7ec4\u7ec7\u7c7b\u578b\u4ee3\u7801 '\" + superiorOrg.getOrgTypeCode() + \"' \u65e0\u6548!\"));", "first_line_prediction": " + \"' \u7684\u4e0a\u7ea7\u7ec4\u7ec7\u7c7b\u522b '\" + superiorOrg.getOrgTypeCode() + \"' \u4e0d\u5b58\u5728\uff01\"));", "match": 0}
{"groundtruth": "assertOrgType.shouldNotEmpty(orgTypeCode);", "prediction": " assertOrgType.shouldEffective(tenantId, orgTypeCode);\n    }", "first_line_groundtruth": "assertOrgType.shouldNotEmpty(orgTypeCode);", "first_line_prediction": " assertOrgType.shouldEffective(tenantId, orgTypeCode);", "match": 0}
{"groundtruth": "waitPoint.reset();", "prediction": " try {\n            waitPoint.await(interval, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException e) {\n            log.error(\"Interrupted\", e);\n         }", "first_line_groundtruth": "waitPoint.reset();", "first_line_prediction": " try {", "match": 0}
{"groundtruth": "metrics.start();", "prediction": " metrics.start();\n        try {\n            return service.execute(input);\n        } finally {\n            metrics.stop();\n        }\n    }\n\n    @Override\n    public void after() {\n        service.after();\n    }\n\n    @Override\n    public void exception(Throwable e) {\n        service.exception(e);\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public String getFlowType() {\n        return flowType;\n    }\n\n    @Override\n    public boolean isFinalTask() {\n        return finalTask;\n    }\n\n    @Override\n    public Metrics getMetrics() {\n        return", "first_line_groundtruth": "metrics.start();", "first_line_prediction": " metrics.start();", "match": 0}
{"groundtruth": "null, flow.getServiceContext());", "prediction": "service.getInput(), flow.getServiceContext());\n                    service.after();\n                } catch (Exception e) {\n                    log.error(\"\u6267\u884c\u670d\u52a1\u5931\u8d25\", e);\n                }\n            }\n        }\n        log.info(getServiceName() + \" stop\");\n    }\n\n    @Override\n    public void onStop() {\n        stopped = true;\n    }\n\n    @Override\n    public void onDestroy() {\n        queue.clear();\n    }\n\n    @Override\n    public void run() {\n        onStart();\n    }\n\n    public void addService(Service<?> service) {\n        queue.offer(service);\n    }", "first_line_groundtruth": "null, flow.getServiceContext());", "first_line_prediction": "service.getInput(), flow.getServiceContext());", "match": 0}
{"groundtruth": "process(input, getFlow().getServiceContext());", "prediction": "process(input, flow.getServiceContext());\n        metrics.stop();\n        return TaskResult.builder().executionId(executionId).status(TaskStatusEnum.SUCCESS).output(output).build();\n    }\n\n    @Override\n    public TaskResult exception(Throwable e) {\n        String executionId = IdUtil.fastUUID();\n        log.info(\"\u6267\u884c id\uff1a{}\", executionId);\n        metrics.start();\n        service.exception(e);\n        metrics.stop();\n        return TaskResult.builder().executionId(executionId).status(TaskStatusEnum.FAIL).build();\n    }\n\n    @Override\n    public String getId", "first_line_groundtruth": "process(input, getFlow().getServiceContext());", "first_line_prediction": "process(input, flow.getServiceContext());", "match": 0}
{"groundtruth": "if (StringUtils.hasText(groovyCode) && HadesCache.diff(instanceName, groovyCode)) {", "prediction": " // \u89e3\u6790groovy\n                Class groovyClass = GroovyUtils.parseClass(instanceName, groovyCode);\n                // \u6ce8\u518cbean\n                registerBeanService.registerBean(instanceName, groovyClass);\n            }\n        } catch (Exception e) {\n            log.error(\"HadesConfigService#bootstrap fail:{}\", Throwables.getStackTraceAsString(e));\n        }\n    }\n\n    /**\n     * \u6ce8\u518c\u76d1\u542c\u5668\n     */\n    public void addListener() {\n        try {\n            registerBeanService.addConfigListener(configProperties.getConfigName());\n        } catch (Exception e) {\n            log.error", "first_line_groundtruth": "if (StringUtils.hasText(groovyCode) && HadesCache.diff(instanceName, groovyCode)) {", "first_line_prediction": " // \u89e3\u6790groovy", "match": 0}
{"groundtruth": "= GroovyUtils.parseClass(instanceName, groovyCode);", "prediction": " = GroovyUtils.parseClass(instanceName, groovyCode);\n        registerBeanService.registerBean(instanceName, clazz);\n    }\n\n    /**\n     * \u6ce8\u518c\u76d1\u542c\u5668\n     */\n    public void addListener() {\n        registerBeanService.registerBean(configProperties.getConfigName(), this);\n    }\n\n    /**\n     * \u6ce8\u518c\u76d1\u542c\u5668\n     */\n    public void addOrUpdateProperty(String key, String value) {\n        registerBeanService.addOrUpdateProperty(key, value);\n    }\n\n    /**\n     * \u83b7\u53d6\u914d\u7f6e\u503c\n     *\n     * @param key\n     * @return\n     */\n    public String getConfig", "first_line_groundtruth": "= GroovyUtils.parseClass(instanceName, groovyCode);", "first_line_prediction": " = GroovyUtils.parseClass(instanceName, groovyCode);", "match": 0}
{"groundtruth": "Object bean = registerBeanService.registerBean(instanceName, clazz);", "prediction": " registerBeanService.registerBean(instanceName, clazz);\n        }\n    }\n\n    /**\n     * \u6ce8\u518c\u76d1\u542c\u5668\n     */\n    public void addListener() {\n        registerBeanService.registerBean(configProperties.getConfigName(), this);\n    }", "first_line_groundtruth": "Object bean = registerBeanService.registerBean(instanceName, clazz);", "first_line_prediction": " registerBeanService.registerBean(instanceName, clazz);", "match": 0}
