var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
  get: (a7, b5) => (typeof require !== "undefined" ? require : a7)[b5]
}) : x4)(function(x4) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x4 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/esbuild-plugin-polyfill-node/polyfills/global.js
var global;
var init_global = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/global.js"() {
    global = globalThis;
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
var init_dirname = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js
var init_filename = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js"() {
  }
});

// node_modules/@jspm/core/nodelibs/browser/process.js
var process_exports = {};
__export(process_exports, {
  _debugEnd: () => _debugEnd,
  _debugProcess: () => _debugProcess,
  _events: () => _events,
  _eventsCount: () => _eventsCount,
  _exiting: () => _exiting,
  _fatalExceptions: () => _fatalExceptions,
  _getActiveHandles: () => _getActiveHandles,
  _getActiveRequests: () => _getActiveRequests,
  _kill: () => _kill,
  _linkedBinding: () => _linkedBinding,
  _maxListeners: () => _maxListeners,
  _preload_modules: () => _preload_modules,
  _rawDebug: () => _rawDebug,
  _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
  _tickCallback: () => _tickCallback,
  abort: () => abort,
  addListener: () => addListener,
  allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
  arch: () => arch,
  argv: () => argv,
  argv0: () => argv0,
  assert: () => assert,
  binding: () => binding,
  chdir: () => chdir,
  config: () => config,
  cpuUsage: () => cpuUsage,
  cwd: () => cwd,
  debugPort: () => debugPort,
  default: () => process,
  dlopen: () => dlopen,
  domain: () => domain,
  emit: () => emit,
  emitWarning: () => emitWarning,
  env: () => env,
  execArgv: () => execArgv,
  execPath: () => execPath,
  exit: () => exit,
  features: () => features,
  hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
  hrtime: () => hrtime,
  kill: () => kill,
  listeners: () => listeners,
  memoryUsage: () => memoryUsage,
  moduleLoadList: () => moduleLoadList,
  nextTick: () => nextTick,
  off: () => off,
  on: () => on,
  once: () => once,
  openStdin: () => openStdin,
  pid: () => pid,
  platform: () => platform,
  ppid: () => ppid,
  prependListener: () => prependListener,
  prependOnceListener: () => prependOnceListener,
  reallyExit: () => reallyExit,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  resourceUsage: () => resourceUsage,
  setSourceMapsEnabled: () => setSourceMapsEnabled,
  setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
  stderr: () => stderr,
  stdin: () => stdin,
  stdout: () => stdout,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function unimplemented(name2) {
  throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
}
function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length)
    drainQueue();
}
function drainQueue() {
  if (draining)
    return;
  var timeout = setTimeout(cleanUpNextTick, 0);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue)
        currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  clearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i7 = 1; i7 < arguments.length; i7++)
      args[i7 - 1] = arguments[i7];
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining)
    setTimeout(drainQueue, 0);
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function _linkedBinding(name2) {
  unimplemented("_linkedBinding");
}
function dlopen(name2) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
function assert(condition, message) {
  if (!condition)
    throw new Error(message || "assertion error");
}
function hasUncaughtExceptionCaptureCallback() {
  return false;
}
function uptime() {
  return _performance.now() / 1e3;
}
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
function on() {
  return process;
}
function listeners(name2) {
  return [];
}
var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
var init_process = __esm({
  "node_modules/@jspm/core/nodelibs/browser/process.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    arch = "x64";
    platform = "browser";
    env = {
      PATH: "/usr/bin",
      LANG: navigator.language + ".UTF-8",
      PWD: "/",
      HOME: "/home",
      TMP: "/tmp"
    };
    argv = ["/usr/bin/node"];
    execArgv = [];
    version = "v16.8.0";
    versions = {};
    emitWarning = function(message, type2) {
      console.warn((type2 ? type2 + ": " : "") + message);
    };
    binding = function(name2) {
      unimplemented("binding");
    };
    umask = function(mask) {
      return 0;
    };
    cwd = function() {
      return "/";
    };
    chdir = function(dir) {
    };
    release = {
      name: "node",
      sourceUrl: "",
      headersUrl: "",
      libUrl: ""
    };
    _rawDebug = noop;
    moduleLoadList = [];
    domain = {};
    _exiting = false;
    config = {};
    reallyExit = noop;
    _kill = noop;
    cpuUsage = function() {
      return {};
    };
    resourceUsage = cpuUsage;
    memoryUsage = cpuUsage;
    kill = noop;
    exit = noop;
    openStdin = noop;
    allowedNodeEnvironmentFlags = {};
    features = {
      inspector: false,
      debug: false,
      uv: false,
      ipv6: false,
      tls_alpn: false,
      tls_sni: false,
      tls_ocsp: false,
      tls: false,
      cached_builtins: true
    };
    _fatalExceptions = noop;
    setUncaughtExceptionCaptureCallback = noop;
    _tickCallback = noop;
    _debugProcess = noop;
    _debugEnd = noop;
    _startProfilerIdleNotifier = noop;
    _stopProfilerIdleNotifier = noop;
    stdout = void 0;
    stderr = void 0;
    stdin = void 0;
    abort = noop;
    pid = 2;
    ppid = 1;
    execPath = "/bin/usr/node";
    debugPort = 9229;
    argv0 = "node";
    _preload_modules = [];
    setSourceMapsEnabled = noop;
    _performance = {
      now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
      timing: typeof performance !== "undefined" ? performance.timing : void 0
    };
    if (_performance.now === void 0) {
      nowOffset = Date.now();
      if (_performance.timing && _performance.timing.navigationStart) {
        nowOffset = _performance.timing.navigationStart;
      }
      _performance.now = () => Date.now() - nowOffset;
    }
    nanoPerSec = 1e9;
    hrtime.bigint = function(time) {
      var diff = hrtime(time);
      if (typeof BigInt === "undefined") {
        return diff[0] * nanoPerSec + diff[1];
      }
      return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
    };
    _maxListeners = 10;
    _events = {};
    _eventsCount = 0;
    addListener = on;
    once = on;
    off = on;
    removeListener = on;
    removeAllListeners = on;
    emit = noop;
    prependListener = on;
    prependOnceListener = on;
    process = {
      version,
      versions,
      arch,
      platform,
      release,
      _rawDebug,
      moduleLoadList,
      binding,
      _linkedBinding,
      _events,
      _eventsCount,
      _maxListeners,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      prependListener,
      prependOnceListener,
      listeners,
      domain,
      _exiting,
      config,
      dlopen,
      uptime,
      _getActiveRequests,
      _getActiveHandles,
      reallyExit,
      _kill,
      cpuUsage,
      resourceUsage,
      memoryUsage,
      kill,
      exit,
      openStdin,
      allowedNodeEnvironmentFlags,
      assert,
      features,
      _fatalExceptions,
      setUncaughtExceptionCaptureCallback,
      hasUncaughtExceptionCaptureCallback,
      emitWarning,
      nextTick,
      _tickCallback,
      _debugProcess,
      _debugEnd,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      stdout,
      stdin,
      stderr,
      abort,
      umask,
      chdir,
      cwd,
      env,
      title,
      argv,
      execArgv,
      pid,
      ppid,
      execPath,
      debugPort,
      hrtime,
      argv0,
      _preload_modules,
      setSourceMapsEnabled
    };
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
var init_process2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
    init_process();
  }
});

// node_modules/@jspm/core/nodelibs/browser/buffer.js
function dew$2() {
  if (_dewExec$2)
    return exports$3;
  _dewExec$2 = true;
  exports$3.byteLength = byteLength;
  exports$3.toByteArray = toByteArray;
  exports$3.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$3;
}
function dew$1() {
  if (_dewExec$1)
    return exports$2;
  _dewExec$1 = true;
  exports$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e9, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e9 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e9 & (1 << -nBits) - 1;
    e9 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e9 === 0) {
      e9 = 1 - eBias;
    } else if (e9 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e9 = e9 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
  };
  exports$2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e9, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e9 = eMax;
    } else {
      e9 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e9)) < 1) {
        e9--;
        c7 *= 2;
      }
      if (e9 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e9++;
        c7 /= 2;
      }
      if (e9 + eBias >= eMax) {
        m6 = 0;
        e9 = eMax;
      } else if (e9 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e9 = e9 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e9 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e9 = e9 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$2;
}
function dew() {
  if (_dewExec)
    return exports$1;
  _dewExec = true;
  const base642 = dew$2();
  const ieee754 = dew$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer3;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e9) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer4(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
    if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b5, n8, m6) {
    const i7 = b5[n8];
    b5[n8] = b5[m6];
    b5[m6] = i7;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b5) {
    if (!Buffer3.isBuffer(b5))
      throw new TypeError("Argument must be a Buffer");
    if (this === b5)
      return true;
    return Buffer3.compare(this, b5) === 0;
  };
  Buffer3.prototype.inspect = function inspect3() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === "number") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i7 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = `_${val.slice(i7 - 3, i7)}${res}`;
    }
    return `${val.slice(0, i7)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n8 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
        } else {
          range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
        }
      } else {
        range = `>= ${min}${n8} and <= ${max}${n8}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
var init_buffer = __esm({
  "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$1 = {};
    _dewExec = false;
    exports = dew();
    exports["Buffer"];
    exports["SlowBuffer"];
    exports["INSPECT_MAX_BYTES"];
    exports["kMaxLength"];
    Buffer2 = exports.Buffer;
    INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
    kMaxLength = exports.kMaxLength;
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
var init_buffer2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
    init_buffer();
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o8) {
        var ctor = o8.constructor;
        return ctor && ctor.prototype === o8;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k4 in window) {
          try {
            if (!excludedKeys["$" + k4] && has.call(window, k4) && window[k4] !== null && typeof window[k4] === "object") {
              try {
                equalsConstructorPrototype(window[k4]);
              } catch (e9) {
                return true;
              }
            }
          } catch (e9) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o8) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o8);
        }
        try {
          return equalsConstructorPrototype(o8);
        } catch (e9) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject4 = object !== null && typeof object === "object";
        var isFunction4 = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString5 = isObject4 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject4 && !isFunction4 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction4;
        if (isString5 && object.length > 0 && !has.call(object, 0)) {
          for (var i7 = 0; i7 < object.length; ++i7) {
            theKeys.push(String(i7));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j4 = 0; j4 < object.length; ++j4) {
            theKeys.push(String(j4));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k4 = 0; k4 < dontEnums.length; ++k4) {
            if (!(skipConstructor && dontEnums[k4] === "constructor") && has.call(object, dontEnums[k4])) {
              theKeys.push(dontEnums[k4]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o8) {
      return origKeys(o8);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i7 = 0; i7 < boundLength; i7++) {
        boundArgs.push("$" + i7);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var bind2 = require_function_bind();
    module.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e9) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e9) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x4) {
      return x4.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e9) {
        errorProto = getProto(getProto(e9));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var $exec = bind2.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i7 = 1, isOwn = true; i7 < parts.length; i7 += 1) {
        var part = parts[i7];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i7 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e9) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e9) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction4 = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name2, value, predicate) {
      if (name2 in object) {
        if (predicate === true) {
          if (object[name2] === value) {
            return;
          }
        } else if (!isFunction4(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name2, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name2] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates2 = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i7 = 0; i7 < props.length; i7 += 1) {
        defineProperty(object, props[i7], map[props[i7]], predicates2[props[i7]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var bind2 = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e9) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind2, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object.assign/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object.assign/implementation.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module.exports = function assign(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = toObject(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s6 = 1; s6 < arguments.length; ++s6) {
        var from = toObject(arguments[s6]);
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j4 = 0; j4 < syms.length; ++j4) {
            var key = syms[j4];
            if ($propIsEnumerable(from, key)) {
              $push(keys, key);
            }
          }
        }
        for (var i7 = 0; i7 < keys.length; ++i7) {
          var nextKey = keys[i7];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// node_modules/object.assign/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.assign/polyfill.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation3();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map = {};
      for (var i7 = 0; i7 < letters.length; ++i7) {
        map[letters[i7]] = letters[i7];
      }
      var obj = Object.assign({}, map);
      var actual = "";
      for (var k4 in obj) {
        actual += k4;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e9) {
        return thrower[1] === "y";
      }
      return false;
    };
    module.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// node_modules/object.assign/shim.js
var require_shim = __commonJS({
  "node_modules/object.assign/shim.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module.exports = function shimAssign() {
      var polyfill = getPolyfill();
      define2(
        Object,
        { assign: polyfill },
        { assign: function() {
          return Object.assign !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/object.assign/index.js
var require_object = __commonJS({
  "node_modules/object.assign/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var defineProperties = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind.apply(getPolyfill());
    var bound = function assign(target, source1) {
      return polyfill(Object, arguments);
    };
    defineProperties(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f7() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e9) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f7() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.unicodeSets) {
        result += "v";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module.exports, "name", { value: "get flags" });
    }
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o8 = {};
          Object.defineProperty(o8, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o8, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O5) {
      return O5.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol3(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray4(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect3(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp4(obj)) {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect3);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol3(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s6 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i7 = 0; i7 < attrs.length; i7++) {
          s6 += " " + attrs[i7].name + "=" + wrapQuotes(quote(attrs[i7].value), "double", opts);
        }
        s6 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s6 += "...";
        }
        s6 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s6;
      }
      if (isArray4(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect3);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError3(obj)) {
        var parts = arrObjKeys(obj, inspect3);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect3(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect3(key, obj, true) + " => " + inspect3(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect3(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber4(obj)) {
        return markBoxed(inspect3(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect3(bigIntValueOf.call(obj)));
      }
      if (isBoolean4(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString5(obj)) {
        return markBoxed(inspect3(String(obj)));
      }
      if (!isDate4(obj) && !isRegExp4(obj)) {
        var ys = arrObjKeys(obj, inspect3);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s6, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s6 + quoteChar;
    }
    function quote(s6) {
      return $replace.call(String(s6), /"/g, "&quot;");
    }
    function isArray4(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate4(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp4(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError3(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString5(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber4(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean4(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol3(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e9) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e9) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f7) {
      if (f7.name) {
        return f7.name;
      }
      var m6 = $match.call(functionToString.call(f7), /^function\s*([\w$]+)/);
      if (m6) {
        return m6[1];
      }
      return null;
    }
    function indexOf(xs, x4) {
      if (xs.indexOf) {
        return xs.indexOf(x4);
      }
      for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
        if (xs[i7] === x4) {
          return i7;
        }
      }
      return -1;
    }
    function isMap(x4) {
      if (!mapSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        mapSize.call(x4);
        try {
          setSize.call(x4);
        } catch (s6) {
          return true;
        }
        return x4 instanceof Map;
      } catch (e9) {
      }
      return false;
    }
    function isWeakMap(x4) {
      if (!weakMapHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x4, weakMapHas);
        try {
          weakSetHas.call(x4, weakSetHas);
        } catch (s6) {
          return true;
        }
        return x4 instanceof WeakMap;
      } catch (e9) {
      }
      return false;
    }
    function isWeakRef(x4) {
      if (!weakRefDeref || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x4);
        return true;
      } catch (e9) {
      }
      return false;
    }
    function isSet(x4) {
      if (!setSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        setSize.call(x4);
        try {
          mapSize.call(x4);
        } catch (m6) {
          return true;
        }
        return x4 instanceof Set;
      } catch (e9) {
      }
      return false;
    }
    function isWeakSet(x4) {
      if (!weakSetHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x4, weakSetHas);
        try {
          weakMapHas.call(x4, weakMapHas);
        } catch (s6) {
          return true;
        }
        return x4 instanceof WeakSet;
      } catch (e9) {
      }
      return false;
    }
    function isElement(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x4 instanceof HTMLElement) {
        return true;
      }
      return typeof x4.nodeName === "string" && typeof x4.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s6 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s6, "single", opts);
    }
    function lowbyte(c7) {
      var n8 = c7.charCodeAt(0);
      var x4 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n8];
      if (x4) {
        return "\\" + x4;
      }
      return "\\x" + (n8 < 16 ? "0" : "") + $toUpperCase.call(n8.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i7 = 0; i7 < xs.length; i7++) {
        if (indexOf(xs[i7], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect3) {
      var isArr = isArray4(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i7 = 0; i7 < obj.length; i7++) {
          xs[i7] = has(obj, i7) ? inspect3(obj[i7], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k4 = 0; k4 < syms.length; k4++) {
          symMap["$" + syms[k4]] = syms[k4];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect3(key, obj) + ": " + inspect3(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect3(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j4 = 0; j4 < syms.length; j4++) {
          if (isEnumerable.call(obj, syms[j4])) {
            xs.push("[" + inspect3(syms[j4]) + "]: " + inspect3(obj[syms[j4]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect3 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect3(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "node_modules/internal-slot/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O5);
        if (!SLOT.has(O5, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        return slots && slots["$" + slot];
      },
      has: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        return !!slots && has(slots, "$" + slot);
      },
      set: function(O5, slot, V3) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        if (!slots) {
          slots = {};
          channel.set(O5, slots);
        }
        slots["$" + slot] = V3;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module.exports = SLOT;
  }
});

// node_modules/stop-iteration-iterator/index.js
var require_stop_iteration_iterator = __commonJS({
  "node_modules/stop-iteration-iterator/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var SLOT = require_internal_slot();
    var $SyntaxError = SyntaxError;
    var $StopIteration = typeof StopIteration === "object" ? StopIteration : null;
    module.exports = function getStopIterationIterator(origIterator) {
      if (!$StopIteration) {
        throw new $SyntaxError("this environment lacks StopIteration");
      }
      SLOT.set(origIterator, "[[Done]]", false);
      var siIterator = {
        next: function next() {
          var iterator = SLOT.get(this, "[[Iterator]]");
          var done = SLOT.get(iterator, "[[Done]]");
          try {
            return {
              done,
              value: done ? void 0 : iterator.next()
            };
          } catch (e9) {
            SLOT.set(iterator, "[[Done]]", true);
            if (e9 !== $StopIteration) {
              throw e9;
            }
            return {
              done: true,
              value: void 0
            };
          }
        }
      };
      SLOT.set(siIterator, "[[Iterator]]", origIterator);
      return siIterator;
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toString3 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString3.call(arr) == "[object Array]";
    };
  }
});

// node_modules/is-string/index.js
var require_is_string = __commonJS({
  "node_modules/is-string/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e9) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module.exports = function isString5(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// node_modules/is-map/index.js
var require_is_map = __commonJS({
  "node_modules/is-map/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap(x4) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap(x4) {
        return false;
      };
    }
    module.exports = exported || function isMap(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x4);
        if ($setHas) {
          try {
            $setHas.call(x4);
          } catch (e9) {
            return true;
          }
        }
        return x4 instanceof $Map;
      } catch (e9) {
      }
      return false;
    };
  }
});

// node_modules/is-set/index.js
var require_is_set = __commonJS({
  "node_modules/is-set/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet(x4) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet(x4) {
        return false;
      };
    }
    module.exports = exported || function isSet(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $setHas.call(x4);
        if ($mapHas) {
          try {
            $mapHas.call(x4);
          } catch (e9) {
            return true;
          }
        }
        return x4 instanceof $Set;
      } catch (e9) {
      }
      return false;
    };
  }
});

// node_modules/es-get-iterator/index.js
var require_es_get_iterator = __commonJS({
  "node_modules/es-get-iterator/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isArguments = require_is_arguments();
    var getStopIterationIterator = require_stop_iteration_iterator();
    if (require_has_symbols()() || require_shams()()) {
      $iterator = Symbol.iterator;
      module.exports = function getIterator(iterable) {
        if (iterable != null && typeof iterable[$iterator] !== "undefined") {
          return iterable[$iterator]();
        }
        if (isArguments(iterable)) {
          return Array.prototype[$iterator].call(iterable);
        }
      };
    } else {
      isArray4 = require_isarray();
      isString5 = require_is_string();
      GetIntrinsic = require_get_intrinsic();
      $Map = GetIntrinsic("%Map%", true);
      $Set = GetIntrinsic("%Set%", true);
      callBound = require_callBound();
      $arrayPush = callBound("Array.prototype.push");
      $charCodeAt = callBound("String.prototype.charCodeAt");
      $stringSlice = callBound("String.prototype.slice");
      advanceStringIndex = function advanceStringIndex2(S4, index) {
        var length = S4.length;
        if (index + 1 >= length) {
          return index + 1;
        }
        var first = $charCodeAt(S4, index);
        if (first < 55296 || first > 56319) {
          return index + 1;
        }
        var second = $charCodeAt(S4, index + 1);
        if (second < 56320 || second > 57343) {
          return index + 1;
        }
        return index + 2;
      };
      getArrayIterator = function getArrayIterator2(arraylike) {
        var i7 = 0;
        return {
          next: function next() {
            var done = i7 >= arraylike.length;
            var value;
            if (!done) {
              value = arraylike[i7];
              i7 += 1;
            }
            return {
              done,
              value
            };
          }
        };
      };
      getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
        if (isArray4(iterable) || isArguments(iterable)) {
          return getArrayIterator(iterable);
        }
        if (isString5(iterable)) {
          var i7 = 0;
          return {
            next: function next() {
              var nextIndex = advanceStringIndex(iterable, i7);
              var value = $stringSlice(iterable, i7, nextIndex);
              i7 = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        }
        if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
          return iterable["_es6-shim iterator_"]();
        }
      };
      if (!$Map && !$Set) {
        module.exports = function getIterator(iterable) {
          if (iterable != null) {
            return getNonCollectionIterator(iterable, true);
          }
        };
      } else {
        isMap = require_is_map();
        isSet = require_is_set();
        $mapForEach = callBound("Map.prototype.forEach", true);
        $setForEach = callBound("Set.prototype.forEach", true);
        if (typeof process_exports === "undefined" || !process_exports.versions || !process_exports.versions.node) {
          $mapIterator = callBound("Map.prototype.iterator", true);
          $setIterator = callBound("Set.prototype.iterator", true);
        }
        $mapAtAtIterator = callBound("Map.prototype.@@iterator", true) || callBound("Map.prototype._es6-shim iterator_", true);
        $setAtAtIterator = callBound("Set.prototype.@@iterator", true) || callBound("Set.prototype._es6-shim iterator_", true);
        getCollectionIterator = function getCollectionIterator2(iterable) {
          if (isMap(iterable)) {
            if ($mapIterator) {
              return getStopIterationIterator($mapIterator(iterable));
            }
            if ($mapAtAtIterator) {
              return $mapAtAtIterator(iterable);
            }
            if ($mapForEach) {
              var entries = [];
              $mapForEach(iterable, function(v7, k4) {
                $arrayPush(entries, [k4, v7]);
              });
              return getArrayIterator(entries);
            }
          }
          if (isSet(iterable)) {
            if ($setIterator) {
              return getStopIterationIterator($setIterator(iterable));
            }
            if ($setAtAtIterator) {
              return $setAtAtIterator(iterable);
            }
            if ($setForEach) {
              var values = [];
              $setForEach(iterable, function(v7) {
                $arrayPush(values, v7);
              });
              return getArrayIterator(values);
            }
          }
        };
        module.exports = function getIterator(iterable) {
          return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
        };
      }
    }
    var $iterator;
    var isArray4;
    var isString5;
    var GetIntrinsic;
    var $Map;
    var $Set;
    var callBound;
    var $arrayPush;
    var $charCodeAt;
    var $stringSlice;
    var advanceStringIndex;
    var getArrayIterator;
    var getNonCollectionIterator;
    var isMap;
    var isSet;
    var $mapForEach;
    var $setForEach;
    var $mapIterator;
    var $setIterator;
    var $mapAtAtIterator;
    var $setAtAtIterator;
    var getCollectionIterator;
  }
});

// node_modules/object-is/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/object-is/implementation.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a7, b5) {
      if (a7 === 0 && b5 === 0) {
        return 1 / a7 === 1 / b5;
      }
      if (a7 === b5) {
        return true;
      }
      if (numberIsNaN(a7) && numberIsNaN(b5)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/object-is/polyfill.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation5();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim3 = __commonJS({
  "node_modules/object-is/shim.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var getPolyfill = require_polyfill3();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_4) {
        if (_4 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e9) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e9) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all3 = document.all;
      if (toStr.call(all3) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e9) {
            }
          }
          return false;
        };
      }
    }
    var all3;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e9) {
        if (e9 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i7 = 0, len = array.length; i7 < len; i7++) {
        if (hasOwnProperty2.call(array, i7)) {
          if (receiver == null) {
            iterator(array[i7], i7, array);
          } else {
            iterator.call(receiver, array[i7], i7, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i7 = 0, len = string.length; i7 < len; i7++) {
        if (receiver == null) {
          iterator(string.charAt(i7), i7, string);
        } else {
          iterator.call(receiver, string.charAt(i7), i7, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k4 in object) {
        if (hasOwnProperty2.call(object, k4)) {
          if (receiver == null) {
            iterator(object[k4], k4, object);
          } else {
            iterator.call(receiver, object[k4], k4, object);
          }
        }
      }
    };
    var forEach2 = function forEach3(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach2;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i7 = 0; i7 < possibleNames.length; i7++) {
        if (typeof g5[possibleNames[i7]] === "function") {
          out[out.length] = possibleNames[i7];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e9) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i7 = 0; i7 < array.length; i7 += 1) {
        if (array[i7] === value) {
          return i7;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf2) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g5[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf2(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf2(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach2(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e9) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-array-buffer/index.js
var require_is_array_buffer = __commonJS({
  "node_modules/is-array-buffer/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var GetIntrinsic = require_get_intrinsic();
    var isTypedArray2 = require_is_typed_array();
    var $ArrayBuffer = GetIntrinsic("ArrayBuffer", true);
    var $Float32Array = GetIntrinsic("Float32Array", true);
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;
    var $abSlice = abSlice && callBind(abSlice);
    module.exports = $byteLength || $abSlice ? function isArrayBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        if ($byteLength) {
          $byteLength(obj);
        } else {
          $abSlice(obj, 0);
        }
        return true;
      } catch (e9) {
        return false;
      }
    } : $Float32Array ? function IsArrayBuffer(obj) {
      try {
        return new $Float32Array(obj).buffer === obj && !isTypedArray2(obj);
      } catch (e9) {
        return typeof obj === "object" && e9.name === "RangeError";
      }
    } : function isArrayBuffer2(obj) {
      return false;
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e9) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e9) {
        return e9 === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/is-shared-array-buffer/index.js
var require_is_shared_array_buffer = __commonJS({
  "node_modules/is-shared-array-buffer/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $byteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    module.exports = $byteLength ? function isSharedArrayBuffer(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        $byteLength(obj);
        return true;
      } catch (e9) {
        return false;
      }
    } : function isSharedArrayBuffer(obj) {
      return false;
    };
  }
});

// node_modules/is-number-object/index.js
var require_is_number_object = __commonJS({
  "node_modules/is-number-object/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var numToStr = Number.prototype.toString;
    var tryNumberObject = function tryNumberObject2(value) {
      try {
        numToStr.call(value);
        return true;
      } catch (e9) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var numClass = "[object Number]";
    var hasToStringTag = require_shams2()();
    module.exports = function isNumberObject(value) {
      if (typeof value === "number") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
    };
  }
});

// node_modules/is-boolean-object/index.js
var require_is_boolean_object = __commonJS({
  "node_modules/is-boolean-object/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
      try {
        $boolToStr(value);
        return true;
      } catch (e9) {
        return false;
      }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = require_shams2()();
    module.exports = function isBoolean4(value) {
      if (typeof value === "boolean") {
        return true;
      }
      if (value === null || typeof value !== "object") {
        return false;
      }
      return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module.exports = function isSymbol3(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e9) {
          return false;
        }
      };
    } else {
      module.exports = function isSymbol3(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/has-bigints/index.js
var require_has_bigints = __commonJS({
  "node_modules/has-bigints/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    module.exports = function hasNativeBigInts() {
      return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
  }
});

// node_modules/is-bigint/index.js
var require_is_bigint = __commonJS({
  "node_modules/is-bigint/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasBigInts = require_has_bigints()();
    if (hasBigInts) {
      bigIntValueOf = BigInt.prototype.valueOf;
      tryBigInt = function tryBigIntObject(value) {
        try {
          bigIntValueOf.call(value);
          return true;
        } catch (e9) {
        }
        return false;
      };
      module.exports = function isBigInt(value) {
        if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
          return false;
        }
        if (typeof value === "bigint") {
          return true;
        }
        return tryBigInt(value);
      };
    } else {
      module.exports = function isBigInt(value) {
        return false;
      };
    }
    var bigIntValueOf;
    var tryBigInt;
  }
});

// node_modules/which-boxed-primitive/index.js
var require_which_boxed_primitive = __commonJS({
  "node_modules/which-boxed-primitive/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isString5 = require_is_string();
    var isNumber4 = require_is_number_object();
    var isBoolean4 = require_is_boolean_object();
    var isSymbol3 = require_is_symbol();
    var isBigInt = require_is_bigint();
    module.exports = function whichBoxedPrimitive(value) {
      if (value == null || typeof value !== "object" && typeof value !== "function") {
        return null;
      }
      if (isString5(value)) {
        return "String";
      }
      if (isNumber4(value)) {
        return "Number";
      }
      if (isBoolean4(value)) {
        return "Boolean";
      }
      if (isSymbol3(value)) {
        return "Symbol";
      }
      if (isBigInt(value)) {
        return "BigInt";
      }
    };
  }
});

// node_modules/is-weakmap/index.js
var require_is_weakmap = __commonJS({
  "node_modules/is-weakmap/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
      exported = function isWeakMap(x4) {
        return false;
      };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isWeakMap(x4) {
        return false;
      };
    }
    module.exports = exported || function isWeakMap(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x4, $mapHas);
        if ($setHas) {
          try {
            $setHas.call(x4, $setHas);
          } catch (e9) {
            return true;
          }
        }
        return x4 instanceof $WeakMap;
      } catch (e9) {
      }
      return false;
    };
  }
});

// node_modules/is-weakset/index.js
var require_is_weakset = __commonJS({
  "node_modules/is-weakset/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound("WeakSet.prototype.has", true);
    if ($setHas) {
      $mapHas = callBound("WeakMap.prototype.has", true);
      module.exports = function isWeakSet(x4) {
        if (!x4 || typeof x4 !== "object") {
          return false;
        }
        try {
          $setHas(x4, $setHas);
          if ($mapHas) {
            try {
              $mapHas(x4, $mapHas);
            } catch (e9) {
              return true;
            }
          }
          return x4 instanceof $WeakSet;
        } catch (e9) {
        }
        return false;
      };
    } else {
      module.exports = function isWeakSet(x4) {
        return false;
      };
    }
    var $mapHas;
  }
});

// node_modules/which-collection/index.js
var require_which_collection = __commonJS({
  "node_modules/which-collection/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isMap = require_is_map();
    var isSet = require_is_set();
    var isWeakMap = require_is_weakmap();
    var isWeakSet = require_is_weakset();
    module.exports = function whichCollection(value) {
      if (value && typeof value === "object") {
        if (isMap(value)) {
          return "Map";
        }
        if (isSet(value)) {
          return "Set";
        }
        if (isWeakMap(value)) {
          return "WeakMap";
        }
        if (isWeakSet(value)) {
          return "WeakSet";
        }
      }
      return false;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf2) {
      forEach2(typedArrays, function(typedArray) {
        if (typeof g5[typedArray] === "function") {
          var arr = new g5[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf2(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf2(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach2(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name2 = getter.call(value);
            if (name2 === typedArray) {
              foundName = name2;
            }
          } catch (e9) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray2(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/array-buffer-byte-length/index.js
var require_array_buffer_byte_length = __commonJS({
  "node_modules/array-buffer-byte-length/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var isArrayBuffer2 = require_is_array_buffer();
    module.exports = function byteLength(ab) {
      if (!isArrayBuffer2(ab)) {
        return NaN;
      }
      return $byteLength ? $byteLength(ab) : ab.byteLength;
    };
  }
});

// node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "node_modules/deep-equal/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var assign = require_object();
    var callBound = require_callBound();
    var flags = require_regexp_prototype();
    var GetIntrinsic = require_get_intrinsic();
    var getIterator = require_es_get_iterator();
    var getSideChannel = require_side_channel();
    var is = require_object_is();
    var isArguments = require_is_arguments();
    var isArray4 = require_isarray();
    var isArrayBuffer2 = require_is_array_buffer();
    var isDate4 = require_is_date_object();
    var isRegex = require_is_regex();
    var isSharedArrayBuffer = require_is_shared_array_buffer();
    var objectKeys = require_object_keys();
    var whichBoxedPrimitive = require_which_boxed_primitive();
    var whichCollection = require_which_collection();
    var whichTypedArray = require_which_typed_array();
    var byteLength = require_array_buffer_byte_length();
    var sabByteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    var $getTime = callBound("Date.prototype.getTime");
    var gPO = Object.getPrototypeOf;
    var $objToString = callBound("Object.prototype.toString");
    var $Set = GetIntrinsic("%Set%", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSize = callBound("Map.prototype.size", true);
    var $setAdd = callBound("Set.prototype.add", true);
    var $setDelete = callBound("Set.prototype.delete", true);
    var $setHas = callBound("Set.prototype.has", true);
    var $setSize = callBound("Set.prototype.size", true);
    function setHasEqualElement(set, val1, opts, channel) {
      var i7 = getIterator(set);
      var result;
      while ((result = i7.next()) && !result.done) {
        if (internalDeepEqual(val1, result.value, opts, channel)) {
          $setDelete(set, result.value);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      if (typeof prim === "undefined") {
        return null;
      }
      if (typeof prim === "object") {
        return void 0;
      }
      if (typeof prim === "symbol") {
        return false;
      }
      if (typeof prim === "string" || typeof prim === "number") {
        return +prim === +prim;
      }
      return true;
    }
    function mapMightHaveLoosePrim(a7, b5, prim, item, opts, channel) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = $mapGet(b5, altValue);
      var looseOpts = assign({}, opts, { strict: false });
      if (typeof curB === "undefined" && !$mapHas(b5, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
        return false;
      }
      return !$mapHas(a7, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    function setMightHaveLoosePrim(a7, b5, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      return $setHas(b5, altValue) && !$setHas(a7, altValue);
    }
    function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
      var i7 = getIterator(set);
      var result;
      var key2;
      while ((result = i7.next()) && !result.done) {
        key2 = result.value;
        if (
          // eslint-disable-next-line no-use-before-define
          internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)
        ) {
          $setDelete(set, key2);
          return true;
        }
      }
      return false;
    }
    function internalDeepEqual(actual, expected, options, channel) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      var actualBoxed = whichBoxedPrimitive(actual);
      var expectedBoxed = whichBoxedPrimitive(expected);
      if (actualBoxed !== expectedBoxed) {
        return false;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      var hasActual = channel.has(actual);
      var hasExpected = channel.has(expected);
      var sentinel;
      if (hasActual && hasExpected) {
        if (channel.get(actual) === channel.get(expected)) {
          return true;
        }
      } else {
        sentinel = {};
      }
      if (!hasActual) {
        channel.set(actual, sentinel);
      }
      if (!hasExpected) {
        channel.set(expected, sentinel);
      }
      return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer4(x4) {
      if (!x4 || typeof x4 !== "object" || typeof x4.length !== "number") {
        return false;
      }
      if (typeof x4.copy !== "function" || typeof x4.slice !== "function") {
        return false;
      }
      if (x4.length > 0 && typeof x4[0] !== "number") {
        return false;
      }
      return !!(x4.constructor && x4.constructor.isBuffer && x4.constructor.isBuffer(x4));
    }
    function setEquiv(a7, b5, opts, channel) {
      if ($setSize(a7) !== $setSize(b5)) {
        return false;
      }
      var iA = getIterator(a7);
      var iB = getIterator(b5);
      var resultA;
      var resultB;
      var set;
      while ((resultA = iA.next()) && !resultA.done) {
        if (resultA.value && typeof resultA.value === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        } else if (!$setHas(b5, resultA.value)) {
          if (opts.strict) {
            return false;
          }
          if (!setMightHaveLoosePrim(a7, b5, resultA.value)) {
            return false;
          }
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          if (resultB.value && typeof resultB.value === "object") {
            if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
              return false;
            }
          } else if (!opts.strict && !$setHas(a7, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function mapEquiv(a7, b5, opts, channel) {
      if ($mapSize(a7) !== $mapSize(b5)) {
        return false;
      }
      var iA = getIterator(a7);
      var iB = getIterator(b5);
      var resultA;
      var resultB;
      var set;
      var key;
      var item1;
      var item2;
      while ((resultA = iA.next()) && !resultA.done) {
        key = resultA.value[0];
        item1 = resultA.value[1];
        if (key && typeof key === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, key);
        } else {
          item2 = $mapGet(b5, key);
          if (typeof item2 === "undefined" && !$mapHas(b5, key) || !internalDeepEqual(item1, item2, opts, channel)) {
            if (opts.strict) {
              return false;
            }
            if (!mapMightHaveLoosePrim(a7, b5, key, item1, opts, channel)) {
              return false;
            }
            if (!set) {
              set = new $Set();
            }
            $setAdd(set, key);
          }
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          key = resultB.value[0];
          item2 = resultB.value[1];
          if (key && typeof key === "object") {
            if (!mapHasEqualEntry(set, a7, key, item2, opts, channel)) {
              return false;
            }
          } else if (!opts.strict && (!a7.has(key) || !internalDeepEqual($mapGet(a7, key), item2, opts, channel)) && !mapHasEqualEntry(set, a7, key, item2, assign({}, opts, { strict: false }), channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function objEquiv(a7, b5, opts, channel) {
      var i7, key;
      if (typeof a7 !== typeof b5) {
        return false;
      }
      if (a7 == null || b5 == null) {
        return false;
      }
      if ($objToString(a7) !== $objToString(b5)) {
        return false;
      }
      if (isArguments(a7) !== isArguments(b5)) {
        return false;
      }
      var aIsArray = isArray4(a7);
      var bIsArray = isArray4(b5);
      if (aIsArray !== bIsArray) {
        return false;
      }
      var aIsError = a7 instanceof Error;
      var bIsError = b5 instanceof Error;
      if (aIsError !== bIsError) {
        return false;
      }
      if (aIsError || bIsError) {
        if (a7.name !== b5.name || a7.message !== b5.message) {
          return false;
        }
      }
      var aIsRegex = isRegex(a7);
      var bIsRegex = isRegex(b5);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if ((aIsRegex || bIsRegex) && (a7.source !== b5.source || flags(a7) !== flags(b5))) {
        return false;
      }
      var aIsDate = isDate4(a7);
      var bIsDate = isDate4(b5);
      if (aIsDate !== bIsDate) {
        return false;
      }
      if (aIsDate || bIsDate) {
        if ($getTime(a7) !== $getTime(b5)) {
          return false;
        }
      }
      if (opts.strict && gPO && gPO(a7) !== gPO(b5)) {
        return false;
      }
      var aWhich = whichTypedArray(a7);
      var bWhich = whichTypedArray(b5);
      if ((aWhich || bWhich) && aWhich !== bWhich) {
        return false;
      }
      var aIsBuffer = isBuffer4(a7);
      var bIsBuffer = isBuffer4(b5);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a7.length !== b5.length) {
          return false;
        }
        for (i7 = 0; i7 < a7.length; i7++) {
          if (a7[i7] !== b5[i7]) {
            return false;
          }
        }
        return true;
      }
      var aIsArrayBuffer = isArrayBuffer2(a7);
      var bIsArrayBuffer = isArrayBuffer2(b5);
      if (aIsArrayBuffer !== bIsArrayBuffer) {
        return false;
      }
      if (aIsArrayBuffer || bIsArrayBuffer) {
        if (byteLength(a7) !== byteLength(b5)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a7), new Uint8Array(b5), opts, channel);
      }
      var aIsSAB = isSharedArrayBuffer(a7);
      var bIsSAB = isSharedArrayBuffer(b5);
      if (aIsSAB !== bIsSAB) {
        return false;
      }
      if (aIsSAB || bIsSAB) {
        if (sabByteLength(a7) !== sabByteLength(b5)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a7), new Uint8Array(b5), opts, channel);
      }
      if (typeof a7 !== typeof b5) {
        return false;
      }
      var ka = objectKeys(a7);
      var kb = objectKeys(b5);
      if (ka.length !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (i7 = ka.length - 1; i7 >= 0; i7--) {
        if (ka[i7] != kb[i7]) {
          return false;
        }
      }
      for (i7 = ka.length - 1; i7 >= 0; i7--) {
        key = ka[i7];
        if (!internalDeepEqual(a7[key], b5[key], opts, channel)) {
          return false;
        }
      }
      var aCollection = whichCollection(a7);
      var bCollection = whichCollection(b5);
      if (aCollection !== bCollection) {
        return false;
      }
      if (aCollection === "Set" || bCollection === "Set") {
        return setEquiv(a7, b5, opts, channel);
      }
      if (aCollection === "Map") {
        return mapEquiv(a7, b5, opts, channel);
      }
      return true;
    }
    module.exports = function deepEqual3(a7, b5, opts) {
      return internalDeepEqual(a7, b5, opts, getSideChannel());
    };
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_4) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    !function(e9) {
      var t8;
      "object" == typeof exports10 ? module.exports = e9() : "function" == typeof define && define.amd ? define(e9) : ("undefined" != typeof window ? t8 = window : "undefined" != typeof global ? t8 = global : "undefined" != typeof self && (t8 = self), t8.objectHash = e9());
    }(function() {
      return function r9(o8, i7, u7) {
        function s6(n8, e10) {
          if (!i7[n8]) {
            if (!o8[n8]) {
              var t8 = "function" == typeof __require && __require;
              if (!e10 && t8)
                return t8(n8, true);
              if (a7)
                return a7(n8, true);
              throw new Error("Cannot find module '" + n8 + "'");
            }
            e10 = i7[n8] = { exports: {} };
            o8[n8][0].call(e10.exports, function(e11) {
              var t9 = o8[n8][1][e11];
              return s6(t9 || e11);
            }, e10, e10.exports, r9, o8, i7, u7);
          }
          return i7[n8].exports;
        }
        for (var a7 = "function" == typeof __require && __require, e9 = 0; e9 < u7.length; e9++)
          s6(u7[e9]);
        return s6;
      }({ 1: [function(w4, b5, m6) {
        !function(e9, n8, s6, c7, d6, h8, p7, g5, y6) {
          "use strict";
          var r9 = w4("crypto");
          function t8(e10, t9) {
            t9 = u7(e10, t9);
            var n9;
            return void 0 === (n9 = "passthrough" !== t9.algorithm ? r9.createHash(t9.algorithm) : new l7()).write && (n9.write = n9.update, n9.end = n9.update), f7(t9, n9).dispatch(e10), n9.update || n9.end(""), n9.digest ? n9.digest("buffer" === t9.encoding ? void 0 : t9.encoding) : (e10 = n9.read(), "buffer" !== t9.encoding ? e10.toString(t9.encoding) : e10);
          }
          (m6 = b5.exports = t8).sha1 = function(e10) {
            return t8(e10);
          }, m6.keys = function(e10) {
            return t8(e10, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m6.MD5 = function(e10) {
            return t8(e10, { algorithm: "md5", encoding: "hex" });
          }, m6.keysMD5 = function(e10) {
            return t8(e10, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o8 = r9.getHashes ? r9.getHashes().slice() : ["sha1", "md5"], i7 = (o8.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u7(e10, t9) {
            var n9 = {};
            if (n9.algorithm = (t9 = t9 || {}).algorithm || "sha1", n9.encoding = t9.encoding || "hex", n9.excludeValues = !!t9.excludeValues, n9.algorithm = n9.algorithm.toLowerCase(), n9.encoding = n9.encoding.toLowerCase(), n9.ignoreUnknown = true === t9.ignoreUnknown, n9.respectType = false !== t9.respectType, n9.respectFunctionNames = false !== t9.respectFunctionNames, n9.respectFunctionProperties = false !== t9.respectFunctionProperties, n9.unorderedArrays = true === t9.unorderedArrays, n9.unorderedSets = false !== t9.unorderedSets, n9.unorderedObjects = false !== t9.unorderedObjects, n9.replacer = t9.replacer || void 0, n9.excludeKeys = t9.excludeKeys || void 0, void 0 === e10)
              throw new Error("Object argument required.");
            for (var r10 = 0; r10 < o8.length; ++r10)
              o8[r10].toLowerCase() === n9.algorithm.toLowerCase() && (n9.algorithm = o8[r10]);
            if (-1 === o8.indexOf(n9.algorithm))
              throw new Error('Algorithm "' + n9.algorithm + '"  not supported. supported values: ' + o8.join(", "));
            if (-1 === i7.indexOf(n9.encoding) && "passthrough" !== n9.algorithm)
              throw new Error('Encoding "' + n9.encoding + '"  not supported. supported values: ' + i7.join(", "));
            return n9;
          }
          function a7(e10) {
            if ("function" == typeof e10)
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e10));
          }
          function f7(o9, t9, i8) {
            i8 = i8 || [];
            function u8(e10) {
              return t9.update ? t9.update(e10, "utf8") : t9.write(e10, "utf8");
            }
            return { dispatch: function(e10) {
              return this["_" + (null === (e10 = o9.replacer ? o9.replacer(e10) : e10) ? "null" : typeof e10)](e10);
            }, _object: function(t10) {
              var n9, e10 = Object.prototype.toString.call(t10), r10 = /\[object (.*)\]/i.exec(e10);
              r10 = (r10 = r10 ? r10[1] : "unknown:[" + e10 + "]").toLowerCase();
              if (0 <= (e10 = i8.indexOf(t10)))
                return this.dispatch("[CIRCULAR:" + e10 + "]");
              if (i8.push(t10), void 0 !== s6 && s6.isBuffer && s6.isBuffer(t10))
                return u8("buffer:"), u8(t10);
              if ("object" === r10 || "function" === r10 || "asyncfunction" === r10)
                return e10 = Object.keys(t10), o9.unorderedObjects && (e10 = e10.sort()), false === o9.respectType || a7(t10) || e10.splice(0, 0, "prototype", "__proto__", "constructor"), o9.excludeKeys && (e10 = e10.filter(function(e11) {
                  return !o9.excludeKeys(e11);
                })), u8("object:" + e10.length + ":"), n9 = this, e10.forEach(function(e11) {
                  n9.dispatch(e11), u8(":"), o9.excludeValues || n9.dispatch(t10[e11]), u8(",");
                });
              if (!this["_" + r10]) {
                if (o9.ignoreUnknown)
                  return u8("[" + r10 + "]");
                throw new Error('Unknown object type "' + r10 + '"');
              }
              this["_" + r10](t10);
            }, _array: function(e10, t10) {
              t10 = void 0 !== t10 ? t10 : false !== o9.unorderedArrays;
              var n9 = this;
              if (u8("array:" + e10.length + ":"), !t10 || e10.length <= 1)
                return e10.forEach(function(e11) {
                  return n9.dispatch(e11);
                });
              var r10 = [], t10 = e10.map(function(e11) {
                var t11 = new l7(), n10 = i8.slice();
                return f7(o9, t11, n10).dispatch(e11), r10 = r10.concat(n10.slice(i8.length)), t11.read().toString();
              });
              return i8 = i8.concat(r10), t10.sort(), this._array(t10, false);
            }, _date: function(e10) {
              return u8("date:" + e10.toJSON());
            }, _symbol: function(e10) {
              return u8("symbol:" + e10.toString());
            }, _error: function(e10) {
              return u8("error:" + e10.toString());
            }, _boolean: function(e10) {
              return u8("bool:" + e10.toString());
            }, _string: function(e10) {
              u8("string:" + e10.length + ":"), u8(e10.toString());
            }, _function: function(e10) {
              u8("fn:"), a7(e10) ? this.dispatch("[native]") : this.dispatch(e10.toString()), false !== o9.respectFunctionNames && this.dispatch("function-name:" + String(e10.name)), o9.respectFunctionProperties && this._object(e10);
            }, _number: function(e10) {
              return u8("number:" + e10.toString());
            }, _xml: function(e10) {
              return u8("xml:" + e10.toString());
            }, _null: function() {
              return u8("Null");
            }, _undefined: function() {
              return u8("Undefined");
            }, _regexp: function(e10) {
              return u8("regex:" + e10.toString());
            }, _uint8array: function(e10) {
              return u8("uint8array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _uint8clampedarray: function(e10) {
              return u8("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _int8array: function(e10) {
              return u8("int8array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _uint16array: function(e10) {
              return u8("uint16array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _int16array: function(e10) {
              return u8("int16array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _uint32array: function(e10) {
              return u8("uint32array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _int32array: function(e10) {
              return u8("int32array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _float32array: function(e10) {
              return u8("float32array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _float64array: function(e10) {
              return u8("float64array:"), this.dispatch(Array.prototype.slice.call(e10));
            }, _arraybuffer: function(e10) {
              return u8("arraybuffer:"), this.dispatch(new Uint8Array(e10));
            }, _url: function(e10) {
              return u8("url:" + e10.toString());
            }, _map: function(e10) {
              u8("map:");
              e10 = Array.from(e10);
              return this._array(e10, false !== o9.unorderedSets);
            }, _set: function(e10) {
              u8("set:");
              e10 = Array.from(e10);
              return this._array(e10, false !== o9.unorderedSets);
            }, _file: function(e10) {
              return u8("file:"), this.dispatch([e10.name, e10.size, e10.type, e10.lastModfied]);
            }, _blob: function() {
              if (o9.ignoreUnknown)
                return u8("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u8("domwindow");
            }, _bigint: function(e10) {
              return u8("bigint:" + e10.toString());
            }, _process: function() {
              return u8("process");
            }, _timer: function() {
              return u8("timer");
            }, _pipe: function() {
              return u8("pipe");
            }, _tcp: function() {
              return u8("tcp");
            }, _udp: function() {
              return u8("udp");
            }, _tty: function() {
              return u8("tty");
            }, _statwatcher: function() {
              return u8("statwatcher");
            }, _securecontext: function() {
              return u8("securecontext");
            }, _connection: function() {
              return u8("connection");
            }, _zlib: function() {
              return u8("zlib");
            }, _context: function() {
              return u8("context");
            }, _nodescript: function() {
              return u8("nodescript");
            }, _httpparser: function() {
              return u8("httpparser");
            }, _dataview: function() {
              return u8("dataview");
            }, _signal: function() {
              return u8("signal");
            }, _fsevent: function() {
              return u8("fsevent");
            }, _tlswrap: function() {
              return u8("tlswrap");
            } };
          }
          function l7() {
            return { buf: "", write: function(e10) {
              this.buf += e10;
            }, end: function(e10) {
              this.buf += e10;
            }, read: function() {
              return this.buf;
            } };
          }
          m6.writeToStream = function(e10, t9, n9) {
            return void 0 === n9 && (n9 = t9, t9 = {}), f7(t9 = u7(e10, t9), n9).dispatch(e10);
          };
        }.call(this, w4("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e9, t8, f7) {
        !function(e10, t9, n8, r9, o8, i7, u7, s6, a7) {
          !function(e11) {
            "use strict";
            var a8 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t10 = "+".charCodeAt(0), n9 = "/".charCodeAt(0), r10 = "0".charCodeAt(0), o9 = "a".charCodeAt(0), i8 = "A".charCodeAt(0), u8 = "-".charCodeAt(0), s7 = "_".charCodeAt(0);
            function f8(e12) {
              e12 = e12.charCodeAt(0);
              return e12 === t10 || e12 === u8 ? 62 : e12 === n9 || e12 === s7 ? 63 : e12 < r10 ? -1 : e12 < r10 + 10 ? e12 - r10 + 26 + 26 : e12 < i8 + 26 ? e12 - i8 : e12 < o9 + 26 ? e12 - o9 + 26 : void 0;
            }
            e11.toByteArray = function(e12) {
              var t11, n10;
              if (0 < e12.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r11 = e12.length, r11 = "=" === e12.charAt(r11 - 2) ? 2 : "=" === e12.charAt(r11 - 1) ? 1 : 0, o10 = new a8(3 * e12.length / 4 - r11), i9 = 0 < r11 ? e12.length - 4 : e12.length, u9 = 0;
              function s8(e13) {
                o10[u9++] = e13;
              }
              for (t11 = 0; t11 < i9; t11 += 4, 0)
                s8((16711680 & (n10 = f8(e12.charAt(t11)) << 18 | f8(e12.charAt(t11 + 1)) << 12 | f8(e12.charAt(t11 + 2)) << 6 | f8(e12.charAt(t11 + 3)))) >> 16), s8((65280 & n10) >> 8), s8(255 & n10);
              return 2 == r11 ? s8(255 & (n10 = f8(e12.charAt(t11)) << 2 | f8(e12.charAt(t11 + 1)) >> 4)) : 1 == r11 && (s8((n10 = f8(e12.charAt(t11)) << 10 | f8(e12.charAt(t11 + 1)) << 4 | f8(e12.charAt(t11 + 2)) >> 2) >> 8 & 255), s8(255 & n10)), o10;
            }, e11.fromByteArray = function(e12) {
              var t11, n10, r11, o10, i9 = e12.length % 3, u9 = "";
              function s8(e13) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e13);
              }
              for (t11 = 0, r11 = e12.length - i9; t11 < r11; t11 += 3)
                n10 = (e12[t11] << 16) + (e12[t11 + 1] << 8) + e12[t11 + 2], u9 += s8((o10 = n10) >> 18 & 63) + s8(o10 >> 12 & 63) + s8(o10 >> 6 & 63) + s8(63 & o10);
              switch (i9) {
                case 1:
                  u9 = (u9 += s8((n10 = e12[e12.length - 1]) >> 2)) + s8(n10 << 4 & 63) + "==";
                  break;
                case 2:
                  u9 = (u9 = (u9 += s8((n10 = (e12[e12.length - 2] << 8) + e12[e12.length - 1]) >> 10)) + s8(n10 >> 4 & 63)) + s8(n10 << 2 & 63) + "=";
              }
              return u9;
            };
          }(void 0 === f7 ? this.base64js = {} : f7);
        }.call(this, e9("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e9("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O5, e9, H3) {
        !function(e10, n8, f7, r9, h8, p7, g5, y6, w4) {
          var a7 = O5("base64-js"), i7 = O5("ieee754");
          function f7(e11, t9, n9) {
            if (!(this instanceof f7))
              return new f7(e11, t9, n9);
            var r10, o9, i8, u8, s7 = typeof e11;
            if ("base64" === t9 && "string" == s7)
              for (e11 = (u8 = e11).trim ? u8.trim() : u8.replace(/^\s+|\s+$/g, ""); e11.length % 4 != 0; )
                e11 += "=";
            if ("number" == s7)
              r10 = j4(e11);
            else if ("string" == s7)
              r10 = f7.byteLength(e11, t9);
            else {
              if ("object" != s7)
                throw new Error("First argument needs to be a number, array or string.");
              r10 = j4(e11.length);
            }
            if (f7._useTypedArrays ? o9 = f7._augment(new Uint8Array(r10)) : ((o9 = this).length = r10, o9._isBuffer = true), f7._useTypedArrays && "number" == typeof e11.byteLength)
              o9._set(e11);
            else if (C4(u8 = e11) || f7.isBuffer(u8) || u8 && "object" == typeof u8 && "number" == typeof u8.length)
              for (i8 = 0; i8 < r10; i8++)
                f7.isBuffer(e11) ? o9[i8] = e11.readUInt8(i8) : o9[i8] = e11[i8];
            else if ("string" == s7)
              o9.write(e11, 0, t9);
            else if ("number" == s7 && !f7._useTypedArrays && !n9)
              for (i8 = 0; i8 < r10; i8++)
                o9[i8] = 0;
            return o9;
          }
          function b5(e11, t9, n9, r10) {
            return f7._charsWritten = c7(function(e12) {
              for (var t10 = [], n10 = 0; n10 < e12.length; n10++)
                t10.push(255 & e12.charCodeAt(n10));
              return t10;
            }(t9), e11, n9, r10);
          }
          function m6(e11, t9, n9, r10) {
            return f7._charsWritten = c7(function(e12) {
              for (var t10, n10, r11 = [], o9 = 0; o9 < e12.length; o9++)
                n10 = e12.charCodeAt(o9), t10 = n10 >> 8, n10 = n10 % 256, r11.push(n10), r11.push(t10);
              return r11;
            }(t9), e11, n9, r10);
          }
          function v7(e11, t9, n9) {
            var r10 = "";
            n9 = Math.min(e11.length, n9);
            for (var o9 = t9; o9 < n9; o9++)
              r10 += String.fromCharCode(e11[o9]);
            return r10;
          }
          function o8(e11, t9, n9, r10) {
            r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(null != t9, "missing offset"), d6(t9 + 1 < e11.length, "Trying to read beyond buffer length"));
            var o9, r10 = e11.length;
            if (!(r10 <= t9))
              return n9 ? (o9 = e11[t9], t9 + 1 < r10 && (o9 |= e11[t9 + 1] << 8)) : (o9 = e11[t9] << 8, t9 + 1 < r10 && (o9 |= e11[t9 + 1])), o9;
          }
          function u7(e11, t9, n9, r10) {
            r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(null != t9, "missing offset"), d6(t9 + 3 < e11.length, "Trying to read beyond buffer length"));
            var o9, r10 = e11.length;
            if (!(r10 <= t9))
              return n9 ? (t9 + 2 < r10 && (o9 = e11[t9 + 2] << 16), t9 + 1 < r10 && (o9 |= e11[t9 + 1] << 8), o9 |= e11[t9], t9 + 3 < r10 && (o9 += e11[t9 + 3] << 24 >>> 0)) : (t9 + 1 < r10 && (o9 = e11[t9 + 1] << 16), t9 + 2 < r10 && (o9 |= e11[t9 + 2] << 8), t9 + 3 < r10 && (o9 |= e11[t9 + 3]), o9 += e11[t9] << 24 >>> 0), o9;
          }
          function _4(e11, t9, n9, r10) {
            if (r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(null != t9, "missing offset"), d6(t9 + 1 < e11.length, "Trying to read beyond buffer length")), !(e11.length <= t9))
              return r10 = o8(e11, t9, n9, true), 32768 & r10 ? -1 * (65535 - r10 + 1) : r10;
          }
          function E4(e11, t9, n9, r10) {
            if (r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(null != t9, "missing offset"), d6(t9 + 3 < e11.length, "Trying to read beyond buffer length")), !(e11.length <= t9))
              return r10 = u7(e11, t9, n9, true), 2147483648 & r10 ? -1 * (4294967295 - r10 + 1) : r10;
          }
          function I4(e11, t9, n9, r10) {
            return r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(t9 + 3 < e11.length, "Trying to read beyond buffer length")), i7.read(e11, t9, n9, 23, 4);
          }
          function A4(e11, t9, n9, r10) {
            return r10 || (d6("boolean" == typeof n9, "missing or invalid endian"), d6(t9 + 7 < e11.length, "Trying to read beyond buffer length")), i7.read(e11, t9, n9, 52, 8);
          }
          function s6(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 1 < e11.length, "trying to write beyond buffer length"), Y4(t9, 65535));
            o9 = e11.length;
            if (!(o9 <= n9))
              for (var i8 = 0, u8 = Math.min(o9 - n9, 2); i8 < u8; i8++)
                e11[n9 + i8] = (t9 & 255 << 8 * (r10 ? i8 : 1 - i8)) >>> 8 * (r10 ? i8 : 1 - i8);
          }
          function l7(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 3 < e11.length, "trying to write beyond buffer length"), Y4(t9, 4294967295));
            o9 = e11.length;
            if (!(o9 <= n9))
              for (var i8 = 0, u8 = Math.min(o9 - n9, 4); i8 < u8; i8++)
                e11[n9 + i8] = t9 >>> 8 * (r10 ? i8 : 3 - i8) & 255;
          }
          function B4(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 1 < e11.length, "Trying to write beyond buffer length"), F4(t9, 32767, -32768)), e11.length <= n9 || s6(e11, 0 <= t9 ? t9 : 65535 + t9 + 1, n9, r10, o9);
          }
          function L4(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 3 < e11.length, "Trying to write beyond buffer length"), F4(t9, 2147483647, -2147483648)), e11.length <= n9 || l7(e11, 0 <= t9 ? t9 : 4294967295 + t9 + 1, n9, r10, o9);
          }
          function U4(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 3 < e11.length, "Trying to write beyond buffer length"), D4(t9, 34028234663852886e22, -34028234663852886e22)), e11.length <= n9 || i7.write(e11, t9, n9, r10, 23, 4);
          }
          function x4(e11, t9, n9, r10, o9) {
            o9 || (d6(null != t9, "missing value"), d6("boolean" == typeof r10, "missing or invalid endian"), d6(null != n9, "missing offset"), d6(n9 + 7 < e11.length, "Trying to write beyond buffer length"), D4(t9, 17976931348623157e292, -17976931348623157e292)), e11.length <= n9 || i7.write(e11, t9, n9, r10, 52, 8);
          }
          H3.Buffer = f7, H3.SlowBuffer = f7, H3.INSPECT_MAX_BYTES = 50, f7.poolSize = 8192, f7._useTypedArrays = function() {
            try {
              var e11 = new ArrayBuffer(0), t9 = new Uint8Array(e11);
              return t9.foo = function() {
                return 42;
              }, 42 === t9.foo() && "function" == typeof t9.subarray;
            } catch (e12) {
              return false;
            }
          }(), f7.isEncoding = function(e11) {
            switch (String(e11).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f7.isBuffer = function(e11) {
            return !(null == e11 || !e11._isBuffer);
          }, f7.byteLength = function(e11, t9) {
            var n9;
            switch (e11 += "", t9 || "utf8") {
              case "hex":
                n9 = e11.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n9 = T5(e11).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n9 = e11.length;
                break;
              case "base64":
                n9 = M4(e11).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n9 = 2 * e11.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n9;
          }, f7.concat = function(e11, t9) {
            if (d6(C4(e11), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e11.length)
              return new f7(0);
            if (1 === e11.length)
              return e11[0];
            if ("number" != typeof t9)
              for (o9 = t9 = 0; o9 < e11.length; o9++)
                t9 += e11[o9].length;
            for (var n9 = new f7(t9), r10 = 0, o9 = 0; o9 < e11.length; o9++) {
              var i8 = e11[o9];
              i8.copy(n9, r10), r10 += i8.length;
            }
            return n9;
          }, f7.prototype.write = function(e11, t9, n9, r10) {
            isFinite(t9) ? isFinite(n9) || (r10 = n9, n9 = void 0) : (a8 = r10, r10 = t9, t9 = n9, n9 = a8), t9 = Number(t9) || 0;
            var o9, i8, u8, s7, a8 = this.length - t9;
            switch ((!n9 || a8 < (n9 = Number(n9))) && (n9 = a8), r10 = String(r10 || "utf8").toLowerCase()) {
              case "hex":
                o9 = function(e12, t10, n10, r11) {
                  n10 = Number(n10) || 0;
                  var o10 = e12.length - n10;
                  (!r11 || o10 < (r11 = Number(r11))) && (r11 = o10), d6((o10 = t10.length) % 2 == 0, "Invalid hex string"), o10 / 2 < r11 && (r11 = o10 / 2);
                  for (var i9 = 0; i9 < r11; i9++) {
                    var u9 = parseInt(t10.substr(2 * i9, 2), 16);
                    d6(!isNaN(u9), "Invalid hex string"), e12[n10 + i9] = u9;
                  }
                  return f7._charsWritten = 2 * i9, i9;
                }(this, e11, t9, n9);
                break;
              case "utf8":
              case "utf-8":
                i8 = this, u8 = t9, s7 = n9, o9 = f7._charsWritten = c7(T5(e11), i8, u8, s7);
                break;
              case "ascii":
              case "binary":
                o9 = b5(this, e11, t9, n9);
                break;
              case "base64":
                i8 = this, u8 = t9, s7 = n9, o9 = f7._charsWritten = c7(M4(e11), i8, u8, s7);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o9 = m6(this, e11, t9, n9);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o9;
          }, f7.prototype.toString = function(e11, t9, n9) {
            var r10, o9, i8, u8, s7 = this;
            if (e11 = String(e11 || "utf8").toLowerCase(), t9 = Number(t9) || 0, (n9 = void 0 !== n9 ? Number(n9) : s7.length) === t9)
              return "";
            switch (e11) {
              case "hex":
                r10 = function(e12, t10, n10) {
                  var r11 = e12.length;
                  (!t10 || t10 < 0) && (t10 = 0);
                  (!n10 || n10 < 0 || r11 < n10) && (n10 = r11);
                  for (var o10 = "", i9 = t10; i9 < n10; i9++)
                    o10 += k4(e12[i9]);
                  return o10;
                }(s7, t9, n9);
                break;
              case "utf8":
              case "utf-8":
                r10 = function(e12, t10, n10) {
                  var r11 = "", o10 = "";
                  n10 = Math.min(e12.length, n10);
                  for (var i9 = t10; i9 < n10; i9++)
                    e12[i9] <= 127 ? (r11 += N4(o10) + String.fromCharCode(e12[i9]), o10 = "") : o10 += "%" + e12[i9].toString(16);
                  return r11 + N4(o10);
                }(s7, t9, n9);
                break;
              case "ascii":
              case "binary":
                r10 = v7(s7, t9, n9);
                break;
              case "base64":
                o9 = s7, u8 = n9, r10 = 0 === (i8 = t9) && u8 === o9.length ? a7.fromByteArray(o9) : a7.fromByteArray(o9.slice(i8, u8));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r10 = function(e12, t10, n10) {
                  for (var r11 = e12.slice(t10, n10), o10 = "", i9 = 0; i9 < r11.length; i9 += 2)
                    o10 += String.fromCharCode(r11[i9] + 256 * r11[i9 + 1]);
                  return o10;
                }(s7, t9, n9);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r10;
          }, f7.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f7.prototype.copy = function(e11, t9, n9, r10) {
            if (t9 = t9 || 0, (r10 = r10 || 0 === r10 ? r10 : this.length) !== (n9 = n9 || 0) && 0 !== e11.length && 0 !== this.length) {
              d6(n9 <= r10, "sourceEnd < sourceStart"), d6(0 <= t9 && t9 < e11.length, "targetStart out of bounds"), d6(0 <= n9 && n9 < this.length, "sourceStart out of bounds"), d6(0 <= r10 && r10 <= this.length, "sourceEnd out of bounds"), r10 > this.length && (r10 = this.length);
              var o9 = (r10 = e11.length - t9 < r10 - n9 ? e11.length - t9 + n9 : r10) - n9;
              if (o9 < 100 || !f7._useTypedArrays)
                for (var i8 = 0; i8 < o9; i8++)
                  e11[i8 + t9] = this[i8 + n9];
              else
                e11._set(this.subarray(n9, n9 + o9), t9);
            }
          }, f7.prototype.slice = function(e11, t9) {
            var n9 = this.length;
            if (e11 = S4(e11, n9, 0), t9 = S4(t9, n9, n9), f7._useTypedArrays)
              return f7._augment(this.subarray(e11, t9));
            for (var r10 = t9 - e11, o9 = new f7(r10, void 0, true), i8 = 0; i8 < r10; i8++)
              o9[i8] = this[i8 + e11];
            return o9;
          }, f7.prototype.get = function(e11) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e11);
          }, f7.prototype.set = function(e11, t9) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e11, t9);
          }, f7.prototype.readUInt8 = function(e11, t9) {
            if (t9 || (d6(null != e11, "missing offset"), d6(e11 < this.length, "Trying to read beyond buffer length")), !(e11 >= this.length))
              return this[e11];
          }, f7.prototype.readUInt16LE = function(e11, t9) {
            return o8(this, e11, true, t9);
          }, f7.prototype.readUInt16BE = function(e11, t9) {
            return o8(this, e11, false, t9);
          }, f7.prototype.readUInt32LE = function(e11, t9) {
            return u7(this, e11, true, t9);
          }, f7.prototype.readUInt32BE = function(e11, t9) {
            return u7(this, e11, false, t9);
          }, f7.prototype.readInt8 = function(e11, t9) {
            if (t9 || (d6(null != e11, "missing offset"), d6(e11 < this.length, "Trying to read beyond buffer length")), !(e11 >= this.length))
              return 128 & this[e11] ? -1 * (255 - this[e11] + 1) : this[e11];
          }, f7.prototype.readInt16LE = function(e11, t9) {
            return _4(this, e11, true, t9);
          }, f7.prototype.readInt16BE = function(e11, t9) {
            return _4(this, e11, false, t9);
          }, f7.prototype.readInt32LE = function(e11, t9) {
            return E4(this, e11, true, t9);
          }, f7.prototype.readInt32BE = function(e11, t9) {
            return E4(this, e11, false, t9);
          }, f7.prototype.readFloatLE = function(e11, t9) {
            return I4(this, e11, true, t9);
          }, f7.prototype.readFloatBE = function(e11, t9) {
            return I4(this, e11, false, t9);
          }, f7.prototype.readDoubleLE = function(e11, t9) {
            return A4(this, e11, true, t9);
          }, f7.prototype.readDoubleBE = function(e11, t9) {
            return A4(this, e11, false, t9);
          }, f7.prototype.writeUInt8 = function(e11, t9, n9) {
            n9 || (d6(null != e11, "missing value"), d6(null != t9, "missing offset"), d6(t9 < this.length, "trying to write beyond buffer length"), Y4(e11, 255)), t9 >= this.length || (this[t9] = e11);
          }, f7.prototype.writeUInt16LE = function(e11, t9, n9) {
            s6(this, e11, t9, true, n9);
          }, f7.prototype.writeUInt16BE = function(e11, t9, n9) {
            s6(this, e11, t9, false, n9);
          }, f7.prototype.writeUInt32LE = function(e11, t9, n9) {
            l7(this, e11, t9, true, n9);
          }, f7.prototype.writeUInt32BE = function(e11, t9, n9) {
            l7(this, e11, t9, false, n9);
          }, f7.prototype.writeInt8 = function(e11, t9, n9) {
            n9 || (d6(null != e11, "missing value"), d6(null != t9, "missing offset"), d6(t9 < this.length, "Trying to write beyond buffer length"), F4(e11, 127, -128)), t9 >= this.length || (0 <= e11 ? this.writeUInt8(e11, t9, n9) : this.writeUInt8(255 + e11 + 1, t9, n9));
          }, f7.prototype.writeInt16LE = function(e11, t9, n9) {
            B4(this, e11, t9, true, n9);
          }, f7.prototype.writeInt16BE = function(e11, t9, n9) {
            B4(this, e11, t9, false, n9);
          }, f7.prototype.writeInt32LE = function(e11, t9, n9) {
            L4(this, e11, t9, true, n9);
          }, f7.prototype.writeInt32BE = function(e11, t9, n9) {
            L4(this, e11, t9, false, n9);
          }, f7.prototype.writeFloatLE = function(e11, t9, n9) {
            U4(this, e11, t9, true, n9);
          }, f7.prototype.writeFloatBE = function(e11, t9, n9) {
            U4(this, e11, t9, false, n9);
          }, f7.prototype.writeDoubleLE = function(e11, t9, n9) {
            x4(this, e11, t9, true, n9);
          }, f7.prototype.writeDoubleBE = function(e11, t9, n9) {
            x4(this, e11, t9, false, n9);
          }, f7.prototype.fill = function(e11, t9, n9) {
            if (t9 = t9 || 0, n9 = n9 || this.length, d6("number" == typeof (e11 = "string" == typeof (e11 = e11 || 0) ? e11.charCodeAt(0) : e11) && !isNaN(e11), "value is not a number"), d6(t9 <= n9, "end < start"), n9 !== t9 && 0 !== this.length) {
              d6(0 <= t9 && t9 < this.length, "start out of bounds"), d6(0 <= n9 && n9 <= this.length, "end out of bounds");
              for (var r10 = t9; r10 < n9; r10++)
                this[r10] = e11;
            }
          }, f7.prototype.inspect = function() {
            for (var e11 = [], t9 = this.length, n9 = 0; n9 < t9; n9++)
              if (e11[n9] = k4(this[n9]), n9 === H3.INSPECT_MAX_BYTES) {
                e11[n9 + 1] = "...";
                break;
              }
            return "<Buffer " + e11.join(" ") + ">";
          }, f7.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f7._useTypedArrays)
              return new f7(this).buffer;
            for (var e11 = new Uint8Array(this.length), t9 = 0, n9 = e11.length; t9 < n9; t9 += 1)
              e11[t9] = this[t9];
            return e11.buffer;
          };
          var t8 = f7.prototype;
          function S4(e11, t9, n9) {
            return "number" != typeof e11 ? n9 : t9 <= (e11 = ~~e11) ? t9 : 0 <= e11 || 0 <= (e11 += t9) ? e11 : 0;
          }
          function j4(e11) {
            return (e11 = ~~Math.ceil(+e11)) < 0 ? 0 : e11;
          }
          function C4(e11) {
            return (Array.isArray || function(e12) {
              return "[object Array]" === Object.prototype.toString.call(e12);
            })(e11);
          }
          function k4(e11) {
            return e11 < 16 ? "0" + e11.toString(16) : e11.toString(16);
          }
          function T5(e11) {
            for (var t9 = [], n9 = 0; n9 < e11.length; n9++) {
              var r10 = e11.charCodeAt(n9);
              if (r10 <= 127)
                t9.push(e11.charCodeAt(n9));
              else
                for (var o9 = n9, i8 = (55296 <= r10 && r10 <= 57343 && n9++, encodeURIComponent(e11.slice(o9, n9 + 1)).substr(1).split("%")), u8 = 0; u8 < i8.length; u8++)
                  t9.push(parseInt(i8[u8], 16));
            }
            return t9;
          }
          function M4(e11) {
            return a7.toByteArray(e11);
          }
          function c7(e11, t9, n9, r10) {
            for (var o9 = 0; o9 < r10 && !(o9 + n9 >= t9.length || o9 >= e11.length); o9++)
              t9[o9 + n9] = e11[o9];
            return o9;
          }
          function N4(e11) {
            try {
              return decodeURIComponent(e11);
            } catch (e12) {
              return String.fromCharCode(65533);
            }
          }
          function Y4(e11, t9) {
            d6("number" == typeof e11, "cannot write a non-number as a number"), d6(0 <= e11, "specified a negative value for writing an unsigned value"), d6(e11 <= t9, "value is larger than maximum value for type"), d6(Math.floor(e11) === e11, "value has a fractional component");
          }
          function F4(e11, t9, n9) {
            d6("number" == typeof e11, "cannot write a non-number as a number"), d6(e11 <= t9, "value larger than maximum allowed value"), d6(n9 <= e11, "value smaller than minimum allowed value"), d6(Math.floor(e11) === e11, "value has a fractional component");
          }
          function D4(e11, t9, n9) {
            d6("number" == typeof e11, "cannot write a non-number as a number"), d6(e11 <= t9, "value larger than maximum allowed value"), d6(n9 <= e11, "value smaller than minimum allowed value");
          }
          function d6(e11, t9) {
            if (!e11)
              throw new Error(t9 || "Failed assertion");
          }
          f7._augment = function(e11) {
            return e11._isBuffer = true, e11._get = e11.get, e11._set = e11.set, e11.get = t8.get, e11.set = t8.set, e11.write = t8.write, e11.toString = t8.toString, e11.toLocaleString = t8.toString, e11.toJSON = t8.toJSON, e11.copy = t8.copy, e11.slice = t8.slice, e11.readUInt8 = t8.readUInt8, e11.readUInt16LE = t8.readUInt16LE, e11.readUInt16BE = t8.readUInt16BE, e11.readUInt32LE = t8.readUInt32LE, e11.readUInt32BE = t8.readUInt32BE, e11.readInt8 = t8.readInt8, e11.readInt16LE = t8.readInt16LE, e11.readInt16BE = t8.readInt16BE, e11.readInt32LE = t8.readInt32LE, e11.readInt32BE = t8.readInt32BE, e11.readFloatLE = t8.readFloatLE, e11.readFloatBE = t8.readFloatBE, e11.readDoubleLE = t8.readDoubleLE, e11.readDoubleBE = t8.readDoubleBE, e11.writeUInt8 = t8.writeUInt8, e11.writeUInt16LE = t8.writeUInt16LE, e11.writeUInt16BE = t8.writeUInt16BE, e11.writeUInt32LE = t8.writeUInt32LE, e11.writeUInt32BE = t8.writeUInt32BE, e11.writeInt8 = t8.writeInt8, e11.writeInt16LE = t8.writeInt16LE, e11.writeInt16BE = t8.writeInt16BE, e11.writeInt32LE = t8.writeInt32LE, e11.writeInt32BE = t8.writeInt32BE, e11.writeFloatLE = t8.writeFloatLE, e11.writeFloatBE = t8.writeFloatBE, e11.writeDoubleLE = t8.writeDoubleLE, e11.writeDoubleBE = t8.writeDoubleBE, e11.fill = t8.fill, e11.inspect = t8.inspect, e11.toArrayBuffer = t8.toArrayBuffer, e11;
          };
        }.call(this, O5("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O5("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c7, d6, e9) {
        !function(e10, t8, a7, n8, r9, o8, i7, u7, s6) {
          var a7 = c7("buffer").Buffer, f7 = 4, l7 = new a7(f7);
          l7.fill(0);
          d6.exports = { hash: function(e11, t9, n9, r10) {
            for (var o9 = t9(function(e12, t10) {
              e12.length % f7 != 0 && (n10 = e12.length + (f7 - e12.length % f7), e12 = a7.concat([e12, l7], n10));
              for (var n10, r11 = [], o10 = t10 ? e12.readInt32BE : e12.readInt32LE, i9 = 0; i9 < e12.length; i9 += f7)
                r11.push(o10.call(e12, i9));
              return r11;
            }(e11 = a7.isBuffer(e11) ? e11 : new a7(e11), r10), 8 * e11.length), t9 = r10, i8 = new a7(n9), u8 = t9 ? i8.writeInt32BE : i8.writeInt32LE, s7 = 0; s7 < o9.length; s7++)
              u8.call(i8, o9[s7], 4 * s7, true);
            return i8;
          } };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v7, e9, _4) {
        !function(l7, c7, u7, d6, h8, p7, g5, y6, w4) {
          var u7 = v7("buffer").Buffer, e10 = v7("./sha"), t8 = v7("./sha256"), n8 = v7("./rng"), b5 = { sha1: e10, sha256: t8, md5: v7("./md5") }, s6 = 64, a7 = new u7(s6);
          function r9(e11, n9) {
            var r10 = b5[e11 = e11 || "sha1"], o9 = [];
            return r10 || i7("algorithm:", e11, "is not yet supported"), { update: function(e12) {
              return u7.isBuffer(e12) || (e12 = new u7(e12)), o9.push(e12), e12.length, this;
            }, digest: function(e12) {
              var t9 = u7.concat(o9), t9 = n9 ? function(e13, t10, n10) {
                u7.isBuffer(t10) || (t10 = new u7(t10)), u7.isBuffer(n10) || (n10 = new u7(n10)), t10.length > s6 ? t10 = e13(t10) : t10.length < s6 && (t10 = u7.concat([t10, a7], s6));
                for (var r11 = new u7(s6), o10 = new u7(s6), i8 = 0; i8 < s6; i8++)
                  r11[i8] = 54 ^ t10[i8], o10[i8] = 92 ^ t10[i8];
                return n10 = e13(u7.concat([r11, n10])), e13(u7.concat([o10, n10]));
              }(r10, n9, t9) : r10(t9);
              return o9 = null, e12 ? t9.toString(e12) : t9;
            } };
          }
          function i7() {
            var e11 = [].slice.call(arguments).join(" ");
            throw new Error([e11, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a7.fill(0), _4.createHash = function(e11) {
            return r9(e11);
          }, _4.createHmac = r9, _4.randomBytes = function(e11, t9) {
            if (!t9 || !t9.call)
              return new u7(n8(e11));
            try {
              t9.call(this, void 0, new u7(n8(e11)));
            } catch (e12) {
              t9(e12);
            }
          };
          var o8, f7 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m6 = function(e11) {
            _4[e11] = function() {
              i7("sorry,", e11, "is not implemented yet");
            };
          };
          for (o8 in f7)
            m6(f7[o8], o8);
        }.call(this, v7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w4, b5, e9) {
        !function(e10, r9, o8, i7, u7, a7, f7, l7, y6) {
          var t8 = w4("./helpers");
          function n8(e11, t9) {
            e11[t9 >> 5] |= 128 << t9 % 32, e11[14 + (t9 + 64 >>> 9 << 4)] = t9;
            for (var n9 = 1732584193, r10 = -271733879, o9 = -1732584194, i8 = 271733878, u8 = 0; u8 < e11.length; u8 += 16) {
              var s7 = n9, a8 = r10, f8 = o9, l8 = i8, n9 = c7(n9, r10, o9, i8, e11[u8 + 0], 7, -680876936), i8 = c7(i8, n9, r10, o9, e11[u8 + 1], 12, -389564586), o9 = c7(o9, i8, n9, r10, e11[u8 + 2], 17, 606105819), r10 = c7(r10, o9, i8, n9, e11[u8 + 3], 22, -1044525330);
              n9 = c7(n9, r10, o9, i8, e11[u8 + 4], 7, -176418897), i8 = c7(i8, n9, r10, o9, e11[u8 + 5], 12, 1200080426), o9 = c7(o9, i8, n9, r10, e11[u8 + 6], 17, -1473231341), r10 = c7(r10, o9, i8, n9, e11[u8 + 7], 22, -45705983), n9 = c7(n9, r10, o9, i8, e11[u8 + 8], 7, 1770035416), i8 = c7(i8, n9, r10, o9, e11[u8 + 9], 12, -1958414417), o9 = c7(o9, i8, n9, r10, e11[u8 + 10], 17, -42063), r10 = c7(r10, o9, i8, n9, e11[u8 + 11], 22, -1990404162), n9 = c7(n9, r10, o9, i8, e11[u8 + 12], 7, 1804603682), i8 = c7(i8, n9, r10, o9, e11[u8 + 13], 12, -40341101), o9 = c7(o9, i8, n9, r10, e11[u8 + 14], 17, -1502002290), n9 = d6(n9, r10 = c7(r10, o9, i8, n9, e11[u8 + 15], 22, 1236535329), o9, i8, e11[u8 + 1], 5, -165796510), i8 = d6(i8, n9, r10, o9, e11[u8 + 6], 9, -1069501632), o9 = d6(o9, i8, n9, r10, e11[u8 + 11], 14, 643717713), r10 = d6(r10, o9, i8, n9, e11[u8 + 0], 20, -373897302), n9 = d6(n9, r10, o9, i8, e11[u8 + 5], 5, -701558691), i8 = d6(i8, n9, r10, o9, e11[u8 + 10], 9, 38016083), o9 = d6(o9, i8, n9, r10, e11[u8 + 15], 14, -660478335), r10 = d6(r10, o9, i8, n9, e11[u8 + 4], 20, -405537848), n9 = d6(n9, r10, o9, i8, e11[u8 + 9], 5, 568446438), i8 = d6(i8, n9, r10, o9, e11[u8 + 14], 9, -1019803690), o9 = d6(o9, i8, n9, r10, e11[u8 + 3], 14, -187363961), r10 = d6(r10, o9, i8, n9, e11[u8 + 8], 20, 1163531501), n9 = d6(n9, r10, o9, i8, e11[u8 + 13], 5, -1444681467), i8 = d6(i8, n9, r10, o9, e11[u8 + 2], 9, -51403784), o9 = d6(o9, i8, n9, r10, e11[u8 + 7], 14, 1735328473), n9 = h8(n9, r10 = d6(r10, o9, i8, n9, e11[u8 + 12], 20, -1926607734), o9, i8, e11[u8 + 5], 4, -378558), i8 = h8(i8, n9, r10, o9, e11[u8 + 8], 11, -2022574463), o9 = h8(o9, i8, n9, r10, e11[u8 + 11], 16, 1839030562), r10 = h8(r10, o9, i8, n9, e11[u8 + 14], 23, -35309556), n9 = h8(n9, r10, o9, i8, e11[u8 + 1], 4, -1530992060), i8 = h8(i8, n9, r10, o9, e11[u8 + 4], 11, 1272893353), o9 = h8(o9, i8, n9, r10, e11[u8 + 7], 16, -155497632), r10 = h8(r10, o9, i8, n9, e11[u8 + 10], 23, -1094730640), n9 = h8(n9, r10, o9, i8, e11[u8 + 13], 4, 681279174), i8 = h8(i8, n9, r10, o9, e11[u8 + 0], 11, -358537222), o9 = h8(o9, i8, n9, r10, e11[u8 + 3], 16, -722521979), r10 = h8(r10, o9, i8, n9, e11[u8 + 6], 23, 76029189), n9 = h8(n9, r10, o9, i8, e11[u8 + 9], 4, -640364487), i8 = h8(i8, n9, r10, o9, e11[u8 + 12], 11, -421815835), o9 = h8(o9, i8, n9, r10, e11[u8 + 15], 16, 530742520), n9 = p7(n9, r10 = h8(r10, o9, i8, n9, e11[u8 + 2], 23, -995338651), o9, i8, e11[u8 + 0], 6, -198630844), i8 = p7(i8, n9, r10, o9, e11[u8 + 7], 10, 1126891415), o9 = p7(o9, i8, n9, r10, e11[u8 + 14], 15, -1416354905), r10 = p7(r10, o9, i8, n9, e11[u8 + 5], 21, -57434055), n9 = p7(n9, r10, o9, i8, e11[u8 + 12], 6, 1700485571), i8 = p7(i8, n9, r10, o9, e11[u8 + 3], 10, -1894986606), o9 = p7(o9, i8, n9, r10, e11[u8 + 10], 15, -1051523), r10 = p7(r10, o9, i8, n9, e11[u8 + 1], 21, -2054922799), n9 = p7(n9, r10, o9, i8, e11[u8 + 8], 6, 1873313359), i8 = p7(i8, n9, r10, o9, e11[u8 + 15], 10, -30611744), o9 = p7(o9, i8, n9, r10, e11[u8 + 6], 15, -1560198380), r10 = p7(r10, o9, i8, n9, e11[u8 + 13], 21, 1309151649), n9 = p7(n9, r10, o9, i8, e11[u8 + 4], 6, -145523070), i8 = p7(i8, n9, r10, o9, e11[u8 + 11], 10, -1120210379), o9 = p7(o9, i8, n9, r10, e11[u8 + 2], 15, 718787259), r10 = p7(r10, o9, i8, n9, e11[u8 + 9], 21, -343485551), n9 = g5(n9, s7), r10 = g5(r10, a8), o9 = g5(o9, f8), i8 = g5(i8, l8);
            }
            return Array(n9, r10, o9, i8);
          }
          function s6(e11, t9, n9, r10, o9, i8) {
            return g5((t9 = g5(g5(t9, e11), g5(r10, i8))) << o9 | t9 >>> 32 - o9, n9);
          }
          function c7(e11, t9, n9, r10, o9, i8, u8) {
            return s6(t9 & n9 | ~t9 & r10, e11, t9, o9, i8, u8);
          }
          function d6(e11, t9, n9, r10, o9, i8, u8) {
            return s6(t9 & r10 | n9 & ~r10, e11, t9, o9, i8, u8);
          }
          function h8(e11, t9, n9, r10, o9, i8, u8) {
            return s6(t9 ^ n9 ^ r10, e11, t9, o9, i8, u8);
          }
          function p7(e11, t9, n9, r10, o9, i8, u8) {
            return s6(n9 ^ (t9 | ~r10), e11, t9, o9, i8, u8);
          }
          function g5(e11, t9) {
            var n9 = (65535 & e11) + (65535 & t9);
            return (e11 >> 16) + (t9 >> 16) + (n9 >> 16) << 16 | 65535 & n9;
          }
          b5.exports = function(e11) {
            return t8.hash(e11, n8, 16);
          };
        }.call(this, w4("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e9, l7, t8) {
        !function(e10, t9, n8, r9, o8, i7, u7, s6, f7) {
          var a7;
          l7.exports = a7 || function(e11) {
            for (var t10, n9 = new Array(e11), r10 = 0; r10 < e11; r10++)
              0 == (3 & r10) && (t10 = 4294967296 * Math.random()), n9[r10] = t10 >>> ((3 & r10) << 3) & 255;
            return n9;
          };
        }.call(this, e9("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e9("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c7, d6, e9) {
        !function(e10, t8, n8, r9, o8, s6, a7, f7, l7) {
          var i7 = c7("./helpers");
          function u7(l8, c8) {
            l8[c8 >> 5] |= 128 << 24 - c8 % 32, l8[15 + (c8 + 64 >> 9 << 4)] = c8;
            for (var e11, t9, n9, r10 = Array(80), o9 = 1732584193, i8 = -271733879, u8 = -1732584194, s7 = 271733878, d7 = -1009589776, h8 = 0; h8 < l8.length; h8 += 16) {
              for (var p7 = o9, g5 = i8, y6 = u8, w4 = s7, b5 = d7, a8 = 0; a8 < 80; a8++) {
                r10[a8] = a8 < 16 ? l8[h8 + a8] : v7(r10[a8 - 3] ^ r10[a8 - 8] ^ r10[a8 - 14] ^ r10[a8 - 16], 1);
                var f8 = m6(m6(v7(o9, 5), (f8 = i8, t9 = u8, n9 = s7, (e11 = a8) < 20 ? f8 & t9 | ~f8 & n9 : !(e11 < 40) && e11 < 60 ? f8 & t9 | f8 & n9 | t9 & n9 : f8 ^ t9 ^ n9)), m6(m6(d7, r10[a8]), (e11 = a8) < 20 ? 1518500249 : e11 < 40 ? 1859775393 : e11 < 60 ? -1894007588 : -899497514)), d7 = s7, s7 = u8, u8 = v7(i8, 30), i8 = o9, o9 = f8;
              }
              o9 = m6(o9, p7), i8 = m6(i8, g5), u8 = m6(u8, y6), s7 = m6(s7, w4), d7 = m6(d7, b5);
            }
            return Array(o9, i8, u8, s7, d7);
          }
          function m6(e11, t9) {
            var n9 = (65535 & e11) + (65535 & t9);
            return (e11 >> 16) + (t9 >> 16) + (n9 >> 16) << 16 | 65535 & n9;
          }
          function v7(e11, t9) {
            return e11 << t9 | e11 >>> 32 - t9;
          }
          d6.exports = function(e11) {
            return i7.hash(e11, u7, 20, true);
          };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c7, d6, e9) {
        !function(e10, t8, n8, r9, u7, s6, a7, f7, l7) {
          function b5(e11, t9) {
            var n9 = (65535 & e11) + (65535 & t9);
            return (e11 >> 16) + (t9 >> 16) + (n9 >> 16) << 16 | 65535 & n9;
          }
          function o8(e11, l8) {
            var c8, d7 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t9 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n9 = new Array(64);
            e11[l8 >> 5] |= 128 << 24 - l8 % 32, e11[15 + (l8 + 64 >> 9 << 4)] = l8;
            for (var r10, o9, h8 = 0; h8 < e11.length; h8 += 16) {
              for (var i8 = t9[0], u8 = t9[1], s7 = t9[2], p7 = t9[3], a8 = t9[4], g5 = t9[5], y6 = t9[6], w4 = t9[7], f8 = 0; f8 < 64; f8++)
                n9[f8] = f8 < 16 ? e11[f8 + h8] : b5(b5(b5((o9 = n9[f8 - 2], m6(o9, 17) ^ m6(o9, 19) ^ v7(o9, 10)), n9[f8 - 7]), (o9 = n9[f8 - 15], m6(o9, 7) ^ m6(o9, 18) ^ v7(o9, 3))), n9[f8 - 16]), c8 = b5(b5(b5(b5(w4, m6(o9 = a8, 6) ^ m6(o9, 11) ^ m6(o9, 25)), a8 & g5 ^ ~a8 & y6), d7[f8]), n9[f8]), r10 = b5(m6(r10 = i8, 2) ^ m6(r10, 13) ^ m6(r10, 22), i8 & u8 ^ i8 & s7 ^ u8 & s7), w4 = y6, y6 = g5, g5 = a8, a8 = b5(p7, c8), p7 = s7, s7 = u8, u8 = i8, i8 = b5(c8, r10);
              t9[0] = b5(i8, t9[0]), t9[1] = b5(u8, t9[1]), t9[2] = b5(s7, t9[2]), t9[3] = b5(p7, t9[3]), t9[4] = b5(a8, t9[4]), t9[5] = b5(g5, t9[5]), t9[6] = b5(y6, t9[6]), t9[7] = b5(w4, t9[7]);
            }
            return t9;
          }
          var i7 = c7("./helpers"), m6 = function(e11, t9) {
            return e11 >>> t9 | e11 << 32 - t9;
          }, v7 = function(e11, t9) {
            return e11 >>> t9;
          };
          d6.exports = function(e11) {
            return i7.hash(e11, o8, 32, true);
          };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e9, t8, f7) {
        !function(e10, t9, n8, r9, o8, i7, u7, s6, a7) {
          f7.read = function(e11, t10, n9, r10, o9) {
            var i8, u8, l7 = 8 * o9 - r10 - 1, c7 = (1 << l7) - 1, d6 = c7 >> 1, s7 = -7, a8 = n9 ? o9 - 1 : 0, f8 = n9 ? -1 : 1, o9 = e11[t10 + a8];
            for (a8 += f8, i8 = o9 & (1 << -s7) - 1, o9 >>= -s7, s7 += l7; 0 < s7; i8 = 256 * i8 + e11[t10 + a8], a8 += f8, s7 -= 8)
              ;
            for (u8 = i8 & (1 << -s7) - 1, i8 >>= -s7, s7 += r10; 0 < s7; u8 = 256 * u8 + e11[t10 + a8], a8 += f8, s7 -= 8)
              ;
            if (0 === i8)
              i8 = 1 - d6;
            else {
              if (i8 === c7)
                return u8 ? NaN : 1 / 0 * (o9 ? -1 : 1);
              u8 += Math.pow(2, r10), i8 -= d6;
            }
            return (o9 ? -1 : 1) * u8 * Math.pow(2, i8 - r10);
          }, f7.write = function(e11, t10, l7, n9, r10, c7) {
            var o9, i8, u8 = 8 * c7 - r10 - 1, s7 = (1 << u8) - 1, a8 = s7 >> 1, d6 = 23 === r10 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f8 = n9 ? 0 : c7 - 1, h8 = n9 ? 1 : -1, c7 = t10 < 0 || 0 === t10 && 1 / t10 < 0 ? 1 : 0;
            for (t10 = Math.abs(t10), isNaN(t10) || t10 === 1 / 0 ? (i8 = isNaN(t10) ? 1 : 0, o9 = s7) : (o9 = Math.floor(Math.log(t10) / Math.LN2), t10 * (n9 = Math.pow(2, -o9)) < 1 && (o9--, n9 *= 2), 2 <= (t10 += 1 <= o9 + a8 ? d6 / n9 : d6 * Math.pow(2, 1 - a8)) * n9 && (o9++, n9 /= 2), s7 <= o9 + a8 ? (i8 = 0, o9 = s7) : 1 <= o9 + a8 ? (i8 = (t10 * n9 - 1) * Math.pow(2, r10), o9 += a8) : (i8 = t10 * Math.pow(2, a8 - 1) * Math.pow(2, r10), o9 = 0)); 8 <= r10; e11[l7 + f8] = 255 & i8, f8 += h8, i8 /= 256, r10 -= 8)
              ;
            for (o9 = o9 << r10 | i8, u8 += r10; 0 < u8; e11[l7 + f8] = 255 & o9, f8 += h8, o9 /= 256, u8 -= 8)
              ;
            e11[l7 + f8 - h8] |= 128 * c7;
          };
        }.call(this, e9("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e9("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e9, h8, t8) {
        !function(e10, t9, n8, r9, o8, f7, l7, c7, d6) {
          var i7, u7, s6;
          function a7() {
          }
          (e10 = h8.exports = {}).nextTick = (u7 = "undefined" != typeof window && window.setImmediate, s6 = "undefined" != typeof window && window.postMessage && window.addEventListener, u7 ? function(e11) {
            return window.setImmediate(e11);
          } : s6 ? (i7 = [], window.addEventListener("message", function(e11) {
            var t10 = e11.source;
            t10 !== window && null !== t10 || "process-tick" !== e11.data || (e11.stopPropagation(), 0 < i7.length && i7.shift()());
          }, true), function(e11) {
            i7.push(e11), window.postMessage("process-tick", "*");
          }) : function(e11) {
            setTimeout(e11, 0);
          }), e10.title = "browser", e10.browser = true, e10.env = {}, e10.argv = [], e10.on = a7, e10.addListener = a7, e10.once = a7, e10.off = a7, e10.removeListener = a7, e10.removeAllListeners = a7, e10.emit = a7, e10.binding = function(e11) {
            throw new Error("process.binding is not supported");
          }, e10.cwd = function() {
            return "/";
          }, e10.chdir = function(e11) {
            throw new Error("process.chdir is not supported");
          };
        }.call(this, e9("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e9("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/object-sizeof/byte_size.js
var require_byte_size = __commonJS({
  "node_modules/object-sizeof/byte_size.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = {
      STRING: 2,
      BOOLEAN: 4,
      BYTES: 4,
      NUMBER: 8,
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports10) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.byteLength = byteLength;
    exports10.toByteArray = toByteArray;
    exports10.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    var i7;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer2[offset + i7];
      i7 += d6;
      e9 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports10.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d6] |= s6 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports10) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports10.Buffer = Buffer3;
    exports10.SlowBuffer = SlowBuffer;
    exports10.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports10.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b5 = fromObject(value);
      if (b5)
        return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer4(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a7, b5) {
      if (isInstance(a7, Uint8Array))
        a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array))
        b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
      if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a7 === b5)
        return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b5, n8, m6) {
      const i7 = b5[n8];
      b5[n8] = b5[m6];
      b5[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString3() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b5) {
      if (!Buffer3.isBuffer(b5))
        throw new TypeError("Argument must be a Buffer");
      if (this === b5)
        return true;
      return Buffer3.compare(this, b5) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports10.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read2(arr, i7 + j4) !== read2(val, j4)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E4(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E4(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet[i7] + alphabet[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/object-sizeof/indexv2.js
var require_indexv2 = __commonJS({
  "node_modules/object-sizeof/indexv2.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var ECMA_SIZES = require_byte_size();
    var Buffer3 = require_buffer().Buffer;
    function preciseStringSizeNode(str) {
      return 12 + 4 * Math.ceil(str.length / 4);
    }
    function isNodeEnvironment() {
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        return false;
      }
      return true;
    }
    function objectSizeComplex(obj) {
      let totalSize = 0;
      const errorIndication = -1;
      try {
        let potentialConversion = obj;
        if (obj instanceof Map) {
          potentialConversion = Object.fromEntries(obj);
        } else if (obj instanceof Set) {
          potentialConversion = Array.from(obj);
        }
        if (obj instanceof Int8Array) {
          return obj.length * ECMA_SIZES.Int8Array;
        } else if (obj instanceof Uint8Array || obj instanceof Uint8ClampedArray) {
          return obj.length * ECMA_SIZES.Uint8Array;
        } else if (obj instanceof Int16Array) {
          return obj.length * ECMA_SIZES.Int16Array;
        } else if (obj instanceof Uint16Array) {
          return obj.length * ECMA_SIZES.Uint16Array;
        } else if (obj instanceof Int32Array) {
          return obj.length * ECMA_SIZES.Int32Array;
        } else if (obj instanceof Uint32Array) {
          return obj.length * ECMA_SIZES.Uint32Array;
        } else if (obj instanceof Float32Array) {
          return obj.length * ECMA_SIZES.Float32Array;
        } else if (obj instanceof Float64Array) {
          return obj.length * ECMA_SIZES.Float64Array;
        }
        const objectToString = JSON.stringify(potentialConversion);
        const buffer2 = new Buffer3.from(objectToString);
        totalSize = buffer2.byteLength;
      } catch (ex) {
        console.error("Error detected, return " + errorIndication, ex);
        return errorIndication;
      }
      return totalSize;
    }
    function objectSizeSimple(obj) {
      const objectList = [];
      const stack = [obj];
      let bytes = 0;
      while (stack.length) {
        const value = stack.pop();
        if (typeof value === "boolean") {
          bytes += ECMA_SIZES.BYTES;
        } else if (typeof value === "string") {
          if (isNodeEnvironment()) {
            bytes += preciseStringSizeNode(value);
          } else {
            bytes += value.length * ECMA_SIZES.STRING;
          }
        } else if (typeof value === "number") {
          bytes += ECMA_SIZES.NUMBER;
        } else if (typeof value === "symbol") {
          const isGlobalSymbol = Symbol.keyFor && Symbol.keyFor(obj);
          if (isGlobalSymbol) {
            bytes += Symbol.keyFor(obj).length * ECMA_SIZES.STRING;
          } else {
            bytes += (obj.toString().length - 8) * ECMA_SIZES.STRING;
          }
        } else if (typeof value === "bigint") {
          bytes += Buffer3.from(value.toString()).byteLength;
        } else if (typeof value === "function") {
          bytes += value.toString().length;
        } else if (typeof value === "object" && objectList.indexOf(value) === -1) {
          objectList.push(value);
          for (const i7 in value) {
            stack.push(value[i7]);
          }
        }
      }
      return bytes;
    }
    module.exports = function(obj) {
      let totalSize = 0;
      if (obj !== null && typeof obj === "object") {
        totalSize = objectSizeComplex(obj);
      } else {
        totalSize = objectSizeSimple(obj);
      }
      return totalSize;
    };
  }
});

// node_modules/browser-or-node/lib/index.js
var require_lib = __commonJS({
  "node_modules/browser-or-node/lib/index.js"(exports10) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    Object.defineProperty(exports10, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isNode = typeof process_exports !== "undefined" && process_exports.versions != null && process_exports.versions.node != null;
    var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    var isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
    var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    exports10.isBrowser = isBrowser2;
    exports10.isWebWorker = isWebWorker;
    exports10.isNode = isNode;
    exports10.isJsDom = isJsDom;
    exports10.isDeno = isDeno;
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    function tryStringify(o8) {
      try {
        return JSON.stringify(o8);
      } catch (e9) {
        return '"[Circular]"';
      }
    }
    module.exports = format5;
    function format5(f7, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f7 === "object" && f7 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f7;
        var objects = new Array(len);
        objects[0] = ss(f7);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f7 !== "string") {
        return f7;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f7;
      var str = "";
      var a7 = 1 - offset;
      var lastPos = -1;
      var flen = f7 && f7.length || 0;
      for (var i7 = 0; i7 < flen; ) {
        if (f7.charCodeAt(i7) === 37 && i7 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f7.charCodeAt(i7 + 1)) {
            case 100:
            case 102:
              if (a7 >= argLen)
                break;
              if (args[a7] == null)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += Number(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 105:
              if (a7 >= argLen)
                break;
              if (args[a7] == null)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += Math.floor(Number(args[a7]));
              lastPos = i7 + 2;
              i7++;
              break;
            case 79:
            case 111:
            case 106:
              if (a7 >= argLen)
                break;
              if (args[a7] === void 0)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              var type2 = typeof args[a7];
              if (type2 === "string") {
                str += "'" + args[a7] + "'";
                lastPos = i7 + 2;
                i7++;
                break;
              }
              if (type2 === "function") {
                str += args[a7].name || "<anonymous>";
                lastPos = i7 + 2;
                i7++;
                break;
              }
              str += ss(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 115:
              if (a7 >= argLen)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += String(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 37:
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += "%";
              lastPos = i7 + 2;
              i7++;
              a7--;
              break;
          }
          ++a7;
        }
        ++i7;
      }
      if (lastPos === -1)
        return f7;
      else if (lastPos < flen) {
        str += f7.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports10, module) {
    "use strict";
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var format5 = require_quick_format_unescaped();
    module.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k4) {
          return k4 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto === "function") {
        levels.forEach(function(level2) {
          proto[level2] = proto;
        });
      }
      if (opts.enabled === false || opts.browser.disabled)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log)
        logger.log = noop3;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = getLevels(opts);
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop3;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2)
        logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(setOpts, logger, "error", "log");
        set(setOpts, logger, "fatal", "error");
        set(setOpts, logger, "warn", "error");
        set(setOpts, logger, "info", "log");
        set(setOpts, logger, "debug", "log");
        set(setOpts, logger, "trace", "log");
        customLevels.forEach(function(level3) {
          set(setOpts, logger, level3, "log");
        });
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind2(parent, bindings, "error");
          this.fatal = bind2(parent, bindings, "fatal");
          this.warn = bind2(parent, bindings, "warn");
          this.info = bind2(parent, bindings, "info");
          this.debug = bind2(parent, bindings, "debug");
          this.trace = bind2(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set(opts, logger, level, fallback) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop3 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop3;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop3)
        return;
      logger[level] = function(write2) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i7 = 0; i7 < args.length; i7++)
            args[i7] = arguments[i7];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write2.call(proto, asObject(this, level, args, ts));
          else
            write2.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = logger.levels.values[transmitLevel];
            const methodValue = logger.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: logger.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts) {
      if (logger._serialize)
        applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o8 = {};
      if (ts) {
        o8.time = ts;
      }
      o8.level = logger.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o8, argsCloned.shift());
        }
        msg = argsCloned.length ? format5(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format5(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o8.msg = msg;
      return o8;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i7 in args) {
        if (stdErrSerialize && args[i7] instanceof Error) {
          args[i7] = pino2.stdSerializers.err(args[i7]);
        } else if (typeof args[i7] === "object" && !Array.isArray(args[i7])) {
          for (const k4 in args[i7]) {
            if (serialize && serialize.indexOf(k4) > -1 && k4 in serializers) {
              args[i7][k4] = serializers[k4](args[i7][k4]);
            }
          }
        }
      }
    }
    function bind2(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i7 = 1; i7 < args.length; i7++) {
          args[i7] = arguments[i7 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a7) {
      return a7;
    }
    function noop3() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o8) {
        return typeof o8 !== "undefined" && o8;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e9) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// src/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/TabbyAgent.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/axios.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/utils.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/bind.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i7;
  let l7;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i7 = 0, l7 = obj.length; i7 < l7; i7++) {
      fn.call(null, obj[i7], i7, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i7 = 0; i7 < len; i7++) {
      key = keys[i7];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i7 = keys.length;
  let _key;
  while (i7-- > 0) {
    _key = keys[i7];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i7 = 0, l7 = arguments.length; i7 < l7; i7++) {
    arguments[i7] && forEach(arguments[i7], assignValue);
  }
  return result;
}
var extend = (a7, b5, thisArg, { allOwnKeys } = {}) => {
  forEach(b5, (val, key) => {
    if (thisArg && isFunction(val)) {
      a7[key] = bind(val, thisArg);
    } else {
      a7[key] = val;
    }
  }, { allOwnKeys });
  return a7;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i7;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i7 = props.length;
    while (i7-- > 0) {
      prop = props[i7];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i7 = thing.length;
  if (!isNumber(i7))
    return null;
  const arr = new Array(i7);
  while (i7-- > 0) {
    arr[i7] = thing[i7];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m6, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i7) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i7] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i7 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i7] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/Axios.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/buildURL.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/toFormData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/AxiosError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function AxiosError(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i7) {
    token = removeBrackets(token);
    return !dots && i7 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer2.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h8) {
      if (h8 !== null) {
        fn(h8);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/core/dispatchRequest.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/transformData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/defaults/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/defaults/transitional.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/browser/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i7;
  const len = keys.length;
  let key;
  for (i7 = 0; i7 < len; i7++) {
    key = keys[i7];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name2 = path2[index++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path2.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path2, value, target[name2], index);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e9) {
      if (e9.name !== "SyntaxError") {
        throw e9;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default.isFormData(data);
    if (isFormData3) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e9) {
        if (strictJSONParsing) {
          if (e9.name === "SyntaxError") {
            throw AxiosError_default.from(e9, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e9;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/core/AxiosHeaders.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/parseHeaders.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i7;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i7 = line.indexOf(":");
    key = line.substring(0, i7).trim().toLowerCase();
    val = line.substring(i7 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w4, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i7 = keys.length;
    let deleted = false;
    while (i7--) {
      const key = keys[i7];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format5) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format5 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function CanceledError(message, config2, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/adapters/adapters.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/adapters/xhr.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/settle.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function settle(resolve4, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve4(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var cookies_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name2, value, expires, path2, domain2, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils_default.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// node_modules/axios/lib/core/buildFullPath.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/parseProtocol.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i7 = tail;
    let bytesCount = 0;
    while (i7 !== head) {
      bytesCount += bytes[i7++];
      i7 = i7 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e9) => {
    const loaded = e9.loaded;
    const total = e9.lengthComputable ? e9.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e9
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve4, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders_default.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData)) {
      if (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve2(value) {
        resolve4(value);
        done();
      }, function _reject2(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitional_default;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin_default(fullPath)) && config2.xsrfCookieName && cookies_default.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e9) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i7 = 0; i7 < length; i7++) {
      nameOrAdapter = adapters[i7];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a7, b5, caseless) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(a7, b5, caseless);
    } else if (!utils_default.isUndefined(a7)) {
      return getMergedValue(void 0, a7, caseless);
    }
  }
  function valueFromConfig2(a7, b5) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(void 0, b5);
    }
  }
  function defaultToConfig2(a7, b5) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(void 0, b5);
    } else if (!utils_default.isUndefined(a7)) {
      return getMergedValue(void 0, a7);
    }
  }
  function mergeDirectKeys(a7, b5, prop) {
    if (prop in config2) {
      return getMergedValue(a7, b5);
    } else if (prop in config1) {
      return getMergedValue(void 0, a7);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a7, b5) => mergeDeepProperties(headersToObject(a7), headersToObject(b5), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/validator.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/env/data.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var VERSION = "1.4.0";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i7) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i7 < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version3, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version3 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i7 = keys.length;
  while (i7-- > 0) {
    const opt = keys[i7];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i7 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i7 < len) {
        promise = promise.then(chain[i7++], chain[i7++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i7 = 0;
    while (i7 < len) {
      const onFulfilled = requestInterceptorChain[i7++];
      const onRejected = requestInterceptorChain[i7++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i7 = 0;
    len = responseInterceptorChain.length;
    while (i7 < len) {
      promise = promise.then(responseInterceptorChain[i7++], responseInterceptorChain[i7++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve4) {
      resolvePromise = resolve4;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i7 = token._listeners.length;
      while (i7-- > 0) {
        token._listeners[i7](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve2;
      const promise = new Promise((resolve4) => {
        token.subscribe(resolve4);
        _resolve2 = resolve4;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve2);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c7) {
      cancel = c7;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises3) {
  return Promise.all(promises3);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@jspm/core/nodelibs/browser/events.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var e;
var t;
var n = "object" == typeof Reflect ? Reflect : null;
var r = n && "function" == typeof n.apply ? n.apply : function(e9, t8, n8) {
  return Function.prototype.apply.call(e9, t8, n8);
};
t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e9) {
  return Object.getOwnPropertyNames(e9).concat(Object.getOwnPropertySymbols(e9));
} : function(e9) {
  return Object.getOwnPropertyNames(e9);
};
var i = Number.isNaN || function(e9) {
  return e9 != e9;
};
function o() {
  o.init.call(this);
}
e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var s = 10;
function u(e9) {
  if ("function" != typeof e9)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e9);
}
function f(e9) {
  return void 0 === e9._maxListeners ? o.defaultMaxListeners : e9._maxListeners;
}
function v(e9, t8, n8, r9) {
  var i7, o8, s6, v7;
  if (u(n8), void 0 === (o8 = e9._events) ? (o8 = e9._events = /* @__PURE__ */ Object.create(null), e9._eventsCount = 0) : (void 0 !== o8.newListener && (e9.emit("newListener", t8, n8.listener ? n8.listener : n8), o8 = e9._events), s6 = o8[t8]), void 0 === s6)
    s6 = o8[t8] = n8, ++e9._eventsCount;
  else if ("function" == typeof s6 ? s6 = o8[t8] = r9 ? [n8, s6] : [s6, n8] : r9 ? s6.unshift(n8) : s6.push(n8), (i7 = f(e9)) > 0 && s6.length > i7 && !s6.warned) {
    s6.warned = true;
    var a7 = new Error("Possible EventEmitter memory leak detected. " + s6.length + " " + String(t8) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a7.name = "MaxListenersExceededWarning", a7.emitter = e9, a7.type = t8, a7.count = s6.length, v7 = a7, console && console.warn && console.warn(v7);
  }
  return e9;
}
function a() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e9, t8, n8) {
  var r9 = { fired: false, wrapFn: void 0, target: e9, type: t8, listener: n8 }, i7 = a.bind(r9);
  return i7.listener = n8, r9.wrapFn = i7, i7;
}
function h(e9, t8, n8) {
  var r9 = e9._events;
  if (void 0 === r9)
    return [];
  var i7 = r9[t8];
  return void 0 === i7 ? [] : "function" == typeof i7 ? n8 ? [i7.listener || i7] : [i7] : n8 ? function(e10) {
    for (var t9 = new Array(e10.length), n9 = 0; n9 < t9.length; ++n9)
      t9[n9] = e10[n9].listener || e10[n9];
    return t9;
  }(i7) : c(i7, i7.length);
}
function p(e9) {
  var t8 = this._events;
  if (void 0 !== t8) {
    var n8 = t8[e9];
    if ("function" == typeof n8)
      return 1;
    if (void 0 !== n8)
      return n8.length;
  }
  return 0;
}
function c(e9, t8) {
  for (var n8 = new Array(t8), r9 = 0; r9 < t8; ++r9)
    n8[r9] = e9[r9];
  return n8;
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return s;
}, set: function(e9) {
  if ("number" != typeof e9 || e9 < 0 || i(e9))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e9 + ".");
  s = e9;
} }), o.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(e9) {
  if ("number" != typeof e9 || e9 < 0 || i(e9))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e9 + ".");
  return this._maxListeners = e9, this;
}, o.prototype.getMaxListeners = function() {
  return f(this);
}, o.prototype.emit = function(e9) {
  for (var t8 = [], n8 = 1; n8 < arguments.length; n8++)
    t8.push(arguments[n8]);
  var i7 = "error" === e9, o8 = this._events;
  if (void 0 !== o8)
    i7 = i7 && void 0 === o8.error;
  else if (!i7)
    return false;
  if (i7) {
    var s6;
    if (t8.length > 0 && (s6 = t8[0]), s6 instanceof Error)
      throw s6;
    var u7 = new Error("Unhandled error." + (s6 ? " (" + s6.message + ")" : ""));
    throw u7.context = s6, u7;
  }
  var f7 = o8[e9];
  if (void 0 === f7)
    return false;
  if ("function" == typeof f7)
    r(f7, this, t8);
  else {
    var v7 = f7.length, a7 = c(f7, v7);
    for (n8 = 0; n8 < v7; ++n8)
      r(a7[n8], this, t8);
  }
  return true;
}, o.prototype.addListener = function(e9, t8) {
  return v(this, e9, t8, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e9, t8) {
  return v(this, e9, t8, true);
}, o.prototype.once = function(e9, t8) {
  return u(t8), this.on(e9, l(this, e9, t8)), this;
}, o.prototype.prependOnceListener = function(e9, t8) {
  return u(t8), this.prependListener(e9, l(this, e9, t8)), this;
}, o.prototype.removeListener = function(e9, t8) {
  var n8, r9, i7, o8, s6;
  if (u(t8), void 0 === (r9 = this._events))
    return this;
  if (void 0 === (n8 = r9[e9]))
    return this;
  if (n8 === t8 || n8.listener === t8)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r9[e9], r9.removeListener && this.emit("removeListener", e9, n8.listener || t8));
  else if ("function" != typeof n8) {
    for (i7 = -1, o8 = n8.length - 1; o8 >= 0; o8--)
      if (n8[o8] === t8 || n8[o8].listener === t8) {
        s6 = n8[o8].listener, i7 = o8;
        break;
      }
    if (i7 < 0)
      return this;
    0 === i7 ? n8.shift() : !function(e10, t9) {
      for (; t9 + 1 < e10.length; t9++)
        e10[t9] = e10[t9 + 1];
      e10.pop();
    }(n8, i7), 1 === n8.length && (r9[e9] = n8[0]), void 0 !== r9.removeListener && this.emit("removeListener", e9, s6 || t8);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e9) {
  var t8, n8, r9;
  if (void 0 === (n8 = this._events))
    return this;
  if (void 0 === n8.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n8[e9] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n8[e9]), this;
  if (0 === arguments.length) {
    var i7, o8 = Object.keys(n8);
    for (r9 = 0; r9 < o8.length; ++r9)
      "removeListener" !== (i7 = o8[r9]) && this.removeAllListeners(i7);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t8 = n8[e9]))
    this.removeListener(e9, t8);
  else if (void 0 !== t8)
    for (r9 = t8.length - 1; r9 >= 0; r9--)
      this.removeListener(e9, t8[r9]);
  return this;
}, o.prototype.listeners = function(e9) {
  return h(this, e9, true);
}, o.prototype.rawListeners = function(e9) {
  return h(this, e9, false);
}, o.listenerCount = function(e9, t8) {
  return "function" == typeof e9.listenerCount ? e9.listenerCount(t8) : p.call(e9, t8);
}, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? t(this._events) : [];
};
var y = e;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;

// node_modules/@jspm/core/nodelibs/browser/events.js
y.once = function(emitter, event) {
  return new Promise((resolve4, reject) => {
    function eventListener(...args) {
      if (errorListener !== void 0) {
        emitter.removeListener("error", errorListener);
      }
      resolve4(args);
    }
    let errorListener;
    if (event !== "error") {
      errorListener = (err) => {
        emitter.removeListener(name, eventListener);
        reject(err);
      };
      emitter.once("error", errorListener);
    }
    emitter.once(event, eventListener);
  });
};
y.on = function(emitter, event) {
  const unconsumedEventValues = [];
  const unconsumedPromises = [];
  let error = null;
  let finished2 = false;
  const iterator = {
    async next() {
      const value = unconsumedEventValues.shift();
      if (value) {
        return createIterResult(value, false);
      }
      if (error) {
        const p7 = Promise.reject(error);
        error = null;
        return p7;
      }
      if (finished2) {
        return createIterResult(void 0, true);
      }
      return new Promise((resolve4, reject) => unconsumedPromises.push({ resolve: resolve4, reject }));
    },
    async return() {
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return createIterResult(void 0, true);
    },
    throw(err) {
      error = err;
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  emitter.on(event, eventHandler);
  emitter.on("error", errorHandler);
  return iterator;
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEventValues.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
};
var {
  EventEmitter,
  defaultMaxListeners,
  init,
  listenerCount,
  on: on2,
  once: once2
} = y;

// node_modules/uuid/dist/esm-browser/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/rng.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var byteToHex = [];
for (let i7 = 0; i7 < 256; ++i7) {
  byteToHex.push((i7 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/v4.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/native.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i7 = 0; i7 < 16; ++i7) {
      buf[offset + i7] = rnds[i7];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/TabbyAgent.ts
var import_deep_equal = __toESM(require_deep_equal());
var import_deepmerge = __toESM(require_cjs());

// src/generated/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/TabbyApi.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/core/AxiosHttpRequest.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/core/BaseHttpRequest.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var BaseHttpRequest = class {
  constructor(config2) {
    this.config = config2;
  }
};

// src/generated/core/request.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var import_form_data = __toESM(require_browser());

// src/generated/core/ApiError.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var ApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request2;
  }
};

// src/generated/core/CancelablePromise.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var _isResolved, _isRejected, _isCancelled, _cancelHandlers, _promise, _resolve, _reject;
var CancelablePromise = class {
  constructor(executor) {
    __privateAdd(this, _isResolved, void 0);
    __privateAdd(this, _isRejected, void 0);
    __privateAdd(this, _isCancelled, void 0);
    __privateAdd(this, _cancelHandlers, void 0);
    __privateAdd(this, _promise, void 0);
    __privateAdd(this, _resolve, void 0);
    __privateAdd(this, _reject, void 0);
    __privateSet(this, _isResolved, false);
    __privateSet(this, _isRejected, false);
    __privateSet(this, _isCancelled, false);
    __privateSet(this, _cancelHandlers, []);
    __privateSet(this, _promise, new Promise((resolve4, reject) => {
      __privateSet(this, _resolve, resolve4);
      __privateSet(this, _reject, reject);
      const onResolve = (value) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isResolved, true);
        (_a = __privateGet(this, _resolve)) == null ? void 0 : _a.call(this, value);
      };
      const onReject = (reason) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isRejected, true);
        (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, reason);
      };
      const onCancel = (cancelHandler) => {
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateGet(this, _cancelHandlers).push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => __privateGet(this, _isResolved)
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => __privateGet(this, _isRejected)
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => __privateGet(this, _isCancelled)
      });
      return executor(onResolve, onReject, onCancel);
    }));
  }
  get [Symbol.toStringTag]() {
    return "Cancellable Promise";
  }
  then(onFulfilled, onRejected) {
    return __privateGet(this, _promise).then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return __privateGet(this, _promise).catch(onRejected);
  }
  finally(onFinally) {
    return __privateGet(this, _promise).finally(onFinally);
  }
  cancel() {
    var _a;
    if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
      return;
    }
    __privateSet(this, _isCancelled, true);
    if (__privateGet(this, _cancelHandlers).length) {
      try {
        for (const cancelHandler of __privateGet(this, _cancelHandlers)) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    __privateGet(this, _cancelHandlers).length = 0;
    (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, new CancelError("Request aborted"));
  }
  get isCancelled() {
    return __privateGet(this, _isCancelled);
  }
};
_isResolved = new WeakMap();
_isRejected = new WeakMap();
_isCancelled = new WeakMap();
_cancelHandlers = new WeakMap();
_promise = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();

// src/generated/core/request.ts
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString2 = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString2(value) && value !== "";
};
var isBlob2 = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData2 = (value) => {
  return value instanceof import_form_data.default;
};
var isSuccess = (status) => {
  return status >= 200 && status < 300;
};
var base64 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer2.from(str).toString("base64");
  }
};
var getQueryString = (params) => {
  const qs = [];
  const append2 = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process3 = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v7) => {
          process3(key, v7);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k4, v7]) => {
          process3(`${key}[${k4}]`, v7);
        });
      } else {
        append2(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process3(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config2, options) => {
  const encoder = config2.ENCODE_PATH || encodeURI;
  const path2 = options.url.replace("{api-version}", config2.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config2.BASE}${path2}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new import_form_data.default();
    const process3 = (key, value) => {
      if (isString2(value) || isBlob2(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_4, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v7) => process3(key, v7));
      } else {
        process3(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config2, options, formData) => {
  const token = await resolve(options, config2.TOKEN);
  const username = await resolve(options, config2.USERNAME);
  const password = await resolve(options, config2.PASSWORD);
  const additionalHeaders = await resolve(options, config2.HEADERS);
  const formHeaders = typeof formData?.getHeaders === "function" && formData?.getHeaders() || {};
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers,
    ...formHeaders
  }).filter(([_4, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob2(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString2(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData2(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return headers;
};
var getRequestBody = (options) => {
  if (options.body) {
    return options.body;
  }
  return void 0;
};
var sendRequest = async (config2, options, url, body, formData, headers, onCancel) => {
  const source = axios_default.CancelToken.source();
  const requestConfig = {
    url,
    headers,
    data: body ?? formData,
    method: options.method,
    withCredentials: config2.WITH_CREDENTIALS,
    cancelToken: source.token
  };
  onCancel(() => source.cancel("The user aborted a request."));
  try {
    return await axios_default.request(requestConfig);
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers[responseHeader];
    if (isString2(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = (response) => {
  if (response.status !== 204) {
    return response.data;
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config2, options) => {
  return new CancelablePromise(async (resolve4, reject, onCancel) => {
    try {
      const url = getUrl(config2, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config2, options, formData);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config2, options, url, body, formData, headers, onCancel);
        const responseBody = getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: isSuccess(response.status),
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes(options, result);
        resolve4(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// src/generated/core/AxiosHttpRequest.ts
var AxiosHttpRequest = class extends BaseHttpRequest {
  constructor(config2) {
    super(config2);
  }
  /**
   * Request method
   * @param options The request options from the service
   * @returns CancelablePromise<T>
   * @throws ApiError
   */
  request(options) {
    return request(this.config, options);
  }
};

// src/generated/services/DefaultService.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var DefaultService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Completions
   * @param requestBody
   * @returns CompletionResponse Successful Response
   * @throws ApiError
   */
  completionsV1CompletionsPost(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/v1/completions",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        422: `Validation Error`
      }
    });
  }
  /**
   * Events
   * @param requestBody
   * @returns any Successful Response
   * @throws ApiError
   */
  eventsV1EventsPost(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/v1/events",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        422: `Validation Error`
      }
    });
  }
};

// src/generated/TabbyApi.ts
var TabbyApi = class {
  constructor(config2, HttpRequest = AxiosHttpRequest) {
    this.request = new HttpRequest({
      BASE: config2?.BASE ?? "",
      VERSION: config2?.VERSION ?? "0.1.0",
      WITH_CREDENTIALS: config2?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config2?.CREDENTIALS ?? "include",
      TOKEN: config2?.TOKEN,
      USERNAME: config2?.USERNAME,
      PASSWORD: config2?.PASSWORD,
      HEADERS: config2?.HEADERS,
      ENCODE_PATH: config2?.ENCODE_PATH
    });
    this.default = new DefaultService(this.request);
  }
};

// src/generated/core/OpenAPI.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/models/EventType.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["COMPLETION"] = "completion";
  EventType2["VIEW"] = "view";
  EventType2["SELECT"] = "select";
  return EventType2;
})(EventType || {});

// src/utils.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function sleep(milliseconds) {
  return new Promise((r9) => setTimeout(r9, milliseconds));
}
function splitLines(input) {
  return input.match(/.*(?:$|\r?\n)/g).filter(Boolean);
}
function splitWords(input) {
  return input.match(/\w+|\W+/g).filter(Boolean);
}
function isBlank(input) {
  return input.trim().length === 0;
}
function cancelable(promise, cancel) {
  return new CancelablePromise((resolve4, reject, onCancel) => {
    promise.then((resp) => {
      resolve4(resp);
    }).catch((err) => {
      reject(err);
    });
    onCancel(() => {
      cancel();
    });
  });
}

// src/AgentConfig.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var defaultAgentConfig = {
  server: {
    endpoint: "http://localhost:8080"
  },
  logs: {
    level: "error"
  },
  anonymousUsageTracking: {
    disable: false
  }
};

// src/CompletionCache.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/lru-cache/dist/mjs/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process_exports === "object" && !!process_exports ? process_exports : {};
var emitWarning2 = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_4, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning2("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n8) => n8 && n8 === Math.floor(n8) && n8 > 0 && isFinite(n8);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s6 = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s6;
  }
  push(n8) {
    this.heap[this.length++] = n8;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var Stack = _Stack;
_constructing = new WeakMap();
// private constructor
__privateAdd(Stack, _constructing, false);
var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
var _LRUCache = class {
  constructor(options) {
    __privateAdd(this, _initializeTTLTracking);
    __privateAdd(this, _initializeSizeTracking);
    __privateAdd(this, _indexes);
    __privateAdd(this, _rindexes);
    __privateAdd(this, _isValidIndex);
    __privateAdd(this, _evict);
    __privateAdd(this, _backgroundFetch);
    __privateAdd(this, _isBackgroundFetch);
    __privateAdd(this, _connect);
    __privateAdd(this, _moveToTail);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _dispose, void 0);
    __privateAdd(this, _disposeAfter, void 0);
    __privateAdd(this, _fetchMethod, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _calculatedSize, void 0);
    __privateAdd(this, _keyMap, void 0);
    __privateAdd(this, _keyList, void 0);
    __privateAdd(this, _valList, void 0);
    __privateAdd(this, _next, void 0);
    __privateAdd(this, _prev, void 0);
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _free, void 0);
    __privateAdd(this, _disposed, void 0);
    __privateAdd(this, _sizes, void 0);
    __privateAdd(this, _starts, void 0);
    __privateAdd(this, _ttls, void 0);
    __privateAdd(this, _hasDispose, void 0);
    __privateAdd(this, _hasFetchMethod, void 0);
    __privateAdd(this, _hasDisposeAfter, void 0);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning2(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c7) {
    return {
      // properties
      starts: __privateGet(c7, _starts),
      ttls: __privateGet(c7, _ttls),
      sizes: __privateGet(c7, _sizes),
      keyMap: __privateGet(c7, _keyMap),
      keyList: __privateGet(c7, _keyList),
      valList: __privateGet(c7, _valList),
      next: __privateGet(c7, _next),
      prev: __privateGet(c7, _prev),
      get head() {
        return __privateGet(c7, _head);
      },
      get tail() {
        return __privateGet(c7, _tail);
      },
      free: __privateGet(c7, _free),
      // methods
      isBackgroundFetch: (p7) => {
        var _a;
        return __privateMethod(_a = c7, _isBackgroundFetch, isBackgroundFetch_fn).call(_a, p7);
      },
      backgroundFetch: (k4, index, options, context) => {
        var _a;
        return __privateMethod(_a = c7, _backgroundFetch, backgroundFetch_fn).call(_a, k4, index, options, context);
      },
      moveToTail: (index) => {
        var _a;
        return __privateMethod(_a = c7, _moveToTail, moveToTail_fn).call(_a, index);
      },
      indexes: (options) => {
        var _a;
        return __privateMethod(_a = c7, _indexes, indexes_fn).call(_a, options);
      },
      rindexes: (options) => {
        var _a;
        return __privateMethod(_a = c7, _rindexes, rindexes_fn).call(_a, options);
      },
      isStale: (index) => {
        var _a;
        return __privateGet(_a = c7, _isStale).call(_a, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i7] !== void 0 && __privateGet(this, _keyList)[i7] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield [__privateGet(this, _keyList)[i7], __privateGet(this, _valList)[i7]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i7] !== void 0 && __privateGet(this, _keyList)[i7] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield [__privateGet(this, _keyList)[i7], __privateGet(this, _valList)[i7]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i7];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield k4;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i7];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield k4;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      if (v7 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield __privateGet(this, _valList)[i7];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      if (v7 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield __privateGet(this, _valList)[i7];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i7], this)) {
        return this.get(__privateGet(this, _keyList)[i7], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i7], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i7], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i7)) {
        this.delete(__privateGet(this, _keyList)[i7]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i7];
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i7];
        const age = perf.now() - __privateGet(this, _starts)[i7];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i7];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k4, v7, setOptions = {}) {
    var _a, _b;
    if (v7 === void 0) {
      this.delete(k4);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k4, v7, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k4);
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k4);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k4;
      __privateGet(this, _valList)[index] = v7;
      __privateGet(this, _keyMap).set(k4, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v7 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, oldVal, k4, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            __privateGet(this, _disposed)?.push([oldVal, k4, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size, status);
        __privateGet(this, _valList)[index] = v7;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _evict, evict_fn).call(this, true);
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_a = __privateGet(this, _disposeAfter)) == null ? void 0 : _a.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k4, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0) {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) && v7.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k4, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index))) {
      const v7 = __privateGet(this, _valList)[index];
      return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
    }
  }
  async fetch(k4, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k4, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k4);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p7 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index, options, context);
      return p7.__returned = p7;
    } else {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
        const stale = allowStale && v7.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v7.__staleWhileFetching : v7.__returned = v7;
      }
      const isStale = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v7;
      }
      const p7 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index, options, context);
      const hasStale = p7.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p7.__staleWhileFetching : p7.__returned = p7;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k4, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k4);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k4) {
    var _a, _b;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index = __privateGet(this, _keyMap).get(k4);
      if (index !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index);
          const v7 = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
            v7.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              __privateGet(this, _disposed)?.push([v7, k4, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k4);
          __privateGet(this, _keyList)[index] = void 0;
          __privateGet(this, _valList)[index] = void 0;
          if (index === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index]);
          } else if (index === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index]);
          } else {
            __privateGet(this, _next)[__privateGet(this, _prev)[index]] = __privateGet(this, _next)[index];
            __privateGet(this, _prev)[__privateGet(this, _next)[index]] = __privateGet(this, _prev)[index];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a, _b;
    for (const index of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
        v7.__abortController.abort(new Error("deleted"));
      } else {
        const k4 = __privateGet(this, _keyList)[index];
        if (__privateGet(this, _hasDispose)) {
          (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v7, k4, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
  }
};
var LRUCache = _LRUCache;
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_initializeTTLTracking = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t8 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          this.delete(__privateGet(this, _keyList)[index]);
        }
      }, ttl + 1);
      if (t8.unref) {
        t8.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n8 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n8;
      const t8 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t8.unref) {
        t8.unref();
      }
    }
    return n8;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (ttl === 0 || start === 0) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index) => {
    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
_initializeSizeTracking = new WeakSet();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k4, v7, size, sizeCalculation) => {
    if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v7, k4);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index, size, status) => {
    sizes[index] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _evict, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
_indexes = new WeakSet();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i7 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i7)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i7)) {
        yield i7;
      }
      if (i7 === __privateGet(this, _head)) {
        break;
      } else {
        i7 = __privateGet(this, _prev)[i7];
      }
    }
  }
};
_rindexes = new WeakSet();
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i7 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i7)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i7)) {
        yield i7;
      }
      if (i7 === __privateGet(this, _tail)) {
        break;
      } else {
        i7 = __privateGet(this, _next)[i7];
      }
    }
  }
};
_isValidIndex = new WeakSet();
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
_evict = new WeakSet();
evict_fn = function(free) {
  var _a;
  const head = __privateGet(this, _head);
  const k4 = __privateGet(this, _keyList)[head];
  const v7 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
    v7.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      __privateGet(this, _disposed)?.push([v7, k4, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k4);
  __privateWrapper(this, _size)._--;
  return head;
};
_backgroundFetch = new WeakSet();
backgroundFetch_fn = function(k4, index, options, context) {
  const v7 = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
    return v7;
  }
  const ac = new AC();
  const { signal } = options;
  signal?.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v8, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v8 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p7;
    if (__privateGet(this, _valList)[index] === p7) {
      if (v8 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          this.delete(k4);
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k4, v8, fetchOpts.options);
      }
    }
    return v8;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p7;
    if (__privateGet(this, _valList)[index] === p7) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        this.delete(k4);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a;
    const fmp = (_a = __privateGet(this, _fetchMethod)) == null ? void 0 : _a.call(this, k4, v7, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v8) => res(v8), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res();
        if (options.allowStaleOnFetchAbort) {
          res = (v8) => cb(v8, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p7 = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p7, {
    __abortController: ac,
    __staleWhileFetching: v7,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k4, bf, { ...fetchOpts.options, status: void 0 });
    index = __privateGet(this, _keyMap).get(k4);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
_isBackgroundFetch = new WeakSet();
isBackgroundFetch_fn = function(p7) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b5 = p7;
  return !!b5 && b5 instanceof Promise && b5.hasOwnProperty("__staleWhileFetching") && b5.__abortController instanceof AC;
};
_connect = new WeakSet();
connect_fn = function(p7, n8) {
  __privateGet(this, _prev)[n8] = p7;
  __privateGet(this, _next)[p7] = n8;
};
_moveToTail = new WeakSet();
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};

// src/CompletionCache.ts
var import_object_hash = __toESM(require_object_hash());
var import_object_sizeof = __toESM(require_indexv2());

// src/logger.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/os.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_process();
init_process();
var exports$12 = {};
var _dewExec2 = false;
function dew2() {
  if (_dewExec2)
    return exports$12;
  _dewExec2 = true;
  exports$12.endianness = function() {
    return "LE";
  };
  exports$12.hostname = function() {
    if (typeof location !== "undefined") {
      return location.hostname;
    } else
      return "";
  };
  exports$12.loadavg = function() {
    return [];
  };
  exports$12.uptime = function() {
    return 0;
  };
  exports$12.freemem = function() {
    return Number.MAX_VALUE;
  };
  exports$12.totalmem = function() {
    return Number.MAX_VALUE;
  };
  exports$12.cpus = function() {
    return [];
  };
  exports$12.type = function() {
    return "Browser";
  };
  exports$12.release = function() {
    if (typeof navigator !== "undefined") {
      return navigator.appVersion;
    }
    return "";
  };
  exports$12.networkInterfaces = exports$12.getNetworkInterfaces = function() {
    return {};
  };
  exports$12.arch = function() {
    return "javascript";
  };
  exports$12.platform = function() {
    return "browser";
  };
  exports$12.tmpdir = exports$12.tmpDir = function() {
    return "/tmp";
  };
  exports$12.EOL = "\n";
  exports$12.homedir = function() {
    return "/";
  };
  return exports$12;
}
var exports2 = dew2();
exports2["endianness"];
exports2["hostname"];
exports2["loadavg"];
exports2["uptime"];
exports2["freemem"];
exports2["totalmem"];
exports2["cpus"];
exports2["type"];
exports2["release"];
exports2["networkInterfaces"];
exports2["getNetworkInterfaces"];
exports2["arch"];
exports2["platform"];
exports2["tmpdir"];
exports2["tmpDir"];
exports2["EOL"];
exports2["homedir"];
var _endianness = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1 ? "LE" : "BE";
exports2.endianness = function() {
  return _endianness;
};
exports2.homedir = function() {
  return "/home";
};
exports2.version = function() {
  return "";
};
exports2.arch = function() {
  return "x64";
};
exports2.totalmem = function() {
  return navigator.deviceMemory !== void 0 ? navigator.deviceMemory * (1 << 30) : 2 * (1 << 30);
};
exports2.cpus = function() {
  return Array(navigator.hardwareConcurrency || 0).fill({ model: "", times: {} });
};
exports2.uptime = uptime;
exports2.constants = {};
var version2 = exports2.version;
var constants = exports2.constants;
var EOL = exports2.EOL;
var arch2 = exports2.arch;
var cpus = exports2.cpus;
var endianness = exports2.endianness;
var freemem = exports2.freemem;
var getNetworkInterfaces = exports2.getNetworkInterfaces;
var homedir = exports2.homedir;
var hostname = exports2.hostname;
var loadavg = exports2.loadavg;
var networkInterfaces = exports2.networkInterfaces;
var platform2 = exports2.platform;
var release2 = exports2.release;
var tmpDir = exports2.tmpDir;
var tmpdir = exports2.tmpdir;
var totalmem = exports2.totalmem;
var type = exports2.type;

// node_modules/@jspm/core/nodelibs/browser/path.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var exports3 = {};
var _dewExec3 = false;
var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew3() {
  if (_dewExec3)
    return exports3;
  _dewExec3 = true;
  var process3 = exports3 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e9) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e9) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e9) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e10) {
        return cachedSetTimeout.call(this || _global2, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e9) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e10) {
        return cachedClearTimeout.call(this || _global2, marker);
      }
    }
  }
  var queue2 = [];
  var draining2 = false;
  var currentQueue2;
  var queueIndex2 = -1;
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout(timeout);
  }
  process3.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        args[i7 - 1] = arguments[i7];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout(drainQueue2);
    }
  };
  function Item2(fun, array) {
    (this || _global2).fun = fun;
    (this || _global2).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global2).fun.apply(null, (this || _global2).array);
  };
  process3.title = "browser";
  process3.browser = true;
  process3.env = {};
  process3.argv = [];
  process3.version = "";
  process3.versions = {};
  function noop3() {
  }
  process3.on = noop3;
  process3.addListener = noop3;
  process3.once = noop3;
  process3.off = noop3;
  process3.removeListener = noop3;
  process3.removeAllListeners = noop3;
  process3.emit = noop3;
  process3.prependListener = noop3;
  process3.prependOnceListener = noop3;
  process3.listeners = function(name2) {
    return [];
  };
  process3.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process3.cwd = function() {
    return "/";
  };
  process3.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process3.umask = function() {
    return 0;
  };
  return exports3;
}
var process2 = dew3();
process2.platform = "browser";
process2.addListener;
process2.argv;
process2.binding;
process2.browser;
process2.chdir;
process2.cwd;
process2.emit;
process2.env;
process2.listeners;
process2.nextTick;
process2.off;
process2.on;
process2.once;
process2.prependListener;
process2.prependOnceListener;
process2.removeAllListeners;
process2.removeListener;
process2.title;
process2.umask;
process2.version;
process2.versions;

// node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
var exports$13 = {};
var _dewExec4 = false;
function dew4() {
  if (_dewExec4)
    return exports$13;
  _dewExec4 = true;
  var process$1 = process2;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve4() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd2 === void 0)
            cwd2 = process$1.cwd();
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute2)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = "";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$13 = posix2;
  return exports$13;
}
var exports4 = dew4();

// node_modules/@jspm/core/nodelibs/browser/path.js
var _makeLong = exports4._makeLong;
var basename = exports4.basename;
var delimiter = exports4.delimiter;
var dirname = exports4.dirname;
var extname = exports4.extname;
var format = exports4.format;
var isAbsolute = exports4.isAbsolute;
var join = exports4.join;
var normalize = exports4.normalize;
var parse = exports4.parse;
var posix = exports4.posix;
var relative = exports4.relative;
var resolve2 = exports4.resolve;
var sep = exports4.sep;
var win32 = exports4.win32;

// src/logger.ts
var import_browser_or_node = __toESM(require_lib());

// node_modules/rotating-file-stream/dist/es/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/child_process.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function unimplemented2() {
  throw new Error("Node.js child_process is not supported by JSPM core in the browser");
}

// node_modules/@jspm/core/nodelibs/browser/zlib.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var e2;
var t2;
var n2;
var r2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var o2 = e2 = {};
function i2() {
  throw new Error("setTimeout has not been defined");
}
function u2() {
  throw new Error("clearTimeout has not been defined");
}
function c2(e9) {
  if (t2 === setTimeout)
    return setTimeout(e9, 0);
  if ((t2 === i2 || !t2) && setTimeout)
    return t2 = setTimeout, setTimeout(e9, 0);
  try {
    return t2(e9, 0);
  } catch (n8) {
    try {
      return t2.call(null, e9, 0);
    } catch (n9) {
      return t2.call(this || r2, e9, 0);
    }
  }
}
!function() {
  try {
    t2 = "function" == typeof setTimeout ? setTimeout : i2;
  } catch (e9) {
    t2 = i2;
  }
  try {
    n2 = "function" == typeof clearTimeout ? clearTimeout : u2;
  } catch (e9) {
    n2 = u2;
  }
}();
var l2;
var s2 = [];
var f2 = false;
var a2 = -1;
function h2() {
  f2 && l2 && (f2 = false, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
}
function d() {
  if (!f2) {
    var e9 = c2(h2);
    f2 = true;
    for (var t8 = s2.length; t8; ) {
      for (l2 = s2, s2 = []; ++a2 < t8; )
        l2 && l2[a2].run();
      a2 = -1, t8 = s2.length;
    }
    l2 = null, f2 = false, function(e10) {
      if (n2 === clearTimeout)
        return clearTimeout(e10);
      if ((n2 === u2 || !n2) && clearTimeout)
        return n2 = clearTimeout, clearTimeout(e10);
      try {
        n2(e10);
      } catch (t9) {
        try {
          return n2.call(null, e10);
        } catch (t10) {
          return n2.call(this || r2, e10);
        }
      }
    }(e9);
  }
}
function m(e9, t8) {
  (this || r2).fun = e9, (this || r2).array = t8;
}
function p2() {
}
o2.nextTick = function(e9) {
  var t8 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n8 = 1; n8 < arguments.length; n8++)
      t8[n8 - 1] = arguments[n8];
  s2.push(new m(e9, t8)), 1 !== s2.length || f2 || c2(d);
}, m.prototype.run = function() {
  (this || r2).fun.apply(null, (this || r2).array);
}, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = p2, o2.addListener = p2, o2.once = p2, o2.off = p2, o2.removeListener = p2, o2.removeAllListeners = p2, o2.emit = p2, o2.prependListener = p2, o2.prependOnceListener = p2, o2.listeners = function(e9) {
  return [];
}, o2.binding = function(e9) {
  throw new Error("process.binding is not supported");
}, o2.cwd = function() {
  return "/";
}, o2.chdir = function(e9) {
  throw new Error("process.chdir is not supported");
}, o2.umask = function() {
  return 0;
};
var T = e2;
T.addListener;
T.argv;
T.binding;
T.browser;
T.chdir;
T.cwd;
T.emit;
T.env;
T.listeners;
T.nextTick;
T.off;
T.on;
T.once;
T.prependListener;
T.prependOnceListener;
T.removeAllListeners;
T.removeListener;
T.title;
T.umask;
T.version;
T.versions;

// node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
var t3 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var e3 = Object.prototype.toString;
var o3 = function(o8) {
  return !(t3 && o8 && "object" == typeof o8 && Symbol.toStringTag in o8) && "[object Arguments]" === e3.call(o8);
};
var n3 = function(t8) {
  return !!o3(t8) || null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Array]" !== e3.call(t8) && "[object Function]" === e3.call(t8.callee);
};
var r3 = function() {
  return o3(arguments);
}();
o3.isLegacyArguments = n3;
var l3 = r3 ? o3 : n3;
var t$1 = Object.prototype.toString;
var o$1 = Function.prototype.toString;
var n$1 = /^\s*(?:function)?\*/;
var e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var r$1 = Object.getPrototypeOf;
var c3 = function() {
  if (!e$1)
    return false;
  try {
    return Function("return function*() {}")();
  } catch (t8) {
  }
}();
var u3 = c3 ? r$1(c3) : {};
var i3 = function(c7) {
  return "function" == typeof c7 && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u3 : "[object GeneratorFunction]" === t$1.call(c7)));
};
var t$2 = "function" == typeof Object.create ? function(t8, e9) {
  e9 && (t8.super_ = e9, t8.prototype = Object.create(e9.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }));
} : function(t8, e9) {
  if (e9) {
    t8.super_ = e9;
    var o8 = function() {
    };
    o8.prototype = e9.prototype, t8.prototype = new o8(), t8.prototype.constructor = t8;
  }
};
var i$1 = function(e9) {
  return e9 && "object" == typeof e9 && "function" == typeof e9.copy && "function" == typeof e9.fill && "function" == typeof e9.readUInt8;
};
var o$2 = {};
var u$1 = i$1;
var f3 = l3;
var a3 = i3;
function c$1(e9) {
  return e9.call.bind(e9);
}
var s3 = "undefined" != typeof BigInt;
var p3 = "undefined" != typeof Symbol;
var y2 = p3 && void 0 !== Symbol.toStringTag;
var l$1 = "undefined" != typeof Uint8Array;
var d2 = "undefined" != typeof ArrayBuffer;
if (l$1 && y2)
  var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
var m2 = c$1(Object.prototype.toString);
var h3 = c$1(Number.prototype.valueOf);
var j = c$1(String.prototype.valueOf);
var A = c$1(Boolean.prototype.valueOf);
if (s3)
  var w = c$1(BigInt.prototype.valueOf);
if (p3)
  var v2 = c$1(Symbol.prototype.valueOf);
function O(e9, t8) {
  if ("object" != typeof e9)
    return false;
  try {
    return t8(e9), true;
  } catch (e10) {
    return false;
  }
}
function S(e9) {
  return l$1 && y2 ? void 0 !== b(e9) : B(e9) || k(e9) || E(e9) || D(e9) || U(e9) || P(e9) || x(e9) || I(e9) || M(e9) || z(e9) || F(e9);
}
function B(e9) {
  return l$1 && y2 ? "Uint8Array" === b(e9) : "[object Uint8Array]" === m2(e9) || u$1(e9) && void 0 !== e9.buffer;
}
function k(e9) {
  return l$1 && y2 ? "Uint8ClampedArray" === b(e9) : "[object Uint8ClampedArray]" === m2(e9);
}
function E(e9) {
  return l$1 && y2 ? "Uint16Array" === b(e9) : "[object Uint16Array]" === m2(e9);
}
function D(e9) {
  return l$1 && y2 ? "Uint32Array" === b(e9) : "[object Uint32Array]" === m2(e9);
}
function U(e9) {
  return l$1 && y2 ? "Int8Array" === b(e9) : "[object Int8Array]" === m2(e9);
}
function P(e9) {
  return l$1 && y2 ? "Int16Array" === b(e9) : "[object Int16Array]" === m2(e9);
}
function x(e9) {
  return l$1 && y2 ? "Int32Array" === b(e9) : "[object Int32Array]" === m2(e9);
}
function I(e9) {
  return l$1 && y2 ? "Float32Array" === b(e9) : "[object Float32Array]" === m2(e9);
}
function M(e9) {
  return l$1 && y2 ? "Float64Array" === b(e9) : "[object Float64Array]" === m2(e9);
}
function z(e9) {
  return l$1 && y2 ? "BigInt64Array" === b(e9) : "[object BigInt64Array]" === m2(e9);
}
function F(e9) {
  return l$1 && y2 ? "BigUint64Array" === b(e9) : "[object BigUint64Array]" === m2(e9);
}
function T2(e9) {
  return "[object Map]" === m2(e9);
}
function N(e9) {
  return "[object Set]" === m2(e9);
}
function W(e9) {
  return "[object WeakMap]" === m2(e9);
}
function $(e9) {
  return "[object WeakSet]" === m2(e9);
}
function C(e9) {
  return "[object ArrayBuffer]" === m2(e9);
}
function V(e9) {
  return "undefined" != typeof ArrayBuffer && (C.working ? C(e9) : e9 instanceof ArrayBuffer);
}
function G(e9) {
  return "[object DataView]" === m2(e9);
}
function R(e9) {
  return "undefined" != typeof DataView && (G.working ? G(e9) : e9 instanceof DataView);
}
function J(e9) {
  return "[object SharedArrayBuffer]" === m2(e9);
}
function _(e9) {
  return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e9) : e9 instanceof SharedArrayBuffer);
}
function H(e9) {
  return O(e9, h3);
}
function Z(e9) {
  return O(e9, j);
}
function q(e9) {
  return O(e9, A);
}
function K(e9) {
  return s3 && O(e9, w);
}
function L(e9) {
  return p3 && O(e9, v2);
}
o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(e9) {
  return "undefined" != typeof Promise && e9 instanceof Promise || null !== e9 && "object" == typeof e9 && "function" == typeof e9.then && "function" == typeof e9.catch;
}, o$2.isArrayBufferView = function(e9) {
  return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : S(e9) || R(e9);
}, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e9) {
  return "undefined" != typeof Map && (T2.working ? T2(e9) : e9 instanceof Map);
}, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e9) {
  return "undefined" != typeof Set && (N.working ? N(e9) : e9 instanceof Set);
}, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e9) {
  return "undefined" != typeof WeakMap && (W.working ? W(e9) : e9 instanceof WeakMap);
}, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e9) {
  return $(e9);
}, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e9) {
  return "[object AsyncFunction]" === m2(e9);
}, o$2.isMapIterator = function(e9) {
  return "[object Map Iterator]" === m2(e9);
}, o$2.isSetIterator = function(e9) {
  return "[object Set Iterator]" === m2(e9);
}, o$2.isGeneratorObject = function(e9) {
  return "[object Generator]" === m2(e9);
}, o$2.isWebAssemblyCompiledModule = function(e9) {
  return "[object WebAssembly.Module]" === m2(e9);
}, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e9) {
  return H(e9) || Z(e9) || q(e9) || K(e9) || L(e9);
}, o$2.isAnyArrayBuffer = function(e9) {
  return l$1 && (V(e9) || _(e9));
}, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e9) {
  Object.defineProperty(o$2, e9, { enumerable: false, value: function() {
    throw new Error(e9 + " is not supported in userland");
  } });
});
var Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var X = {};
var Y = T;
var ee = Object.getOwnPropertyDescriptors || function(e9) {
  for (var t8 = Object.keys(e9), r9 = {}, n8 = 0; n8 < t8.length; n8++)
    r9[t8[n8]] = Object.getOwnPropertyDescriptor(e9, t8[n8]);
  return r9;
};
var te = /%[sdj%]/g;
X.format = function(e9) {
  if (!ge(e9)) {
    for (var t8 = [], r9 = 0; r9 < arguments.length; r9++)
      t8.push(oe(arguments[r9]));
    return t8.join(" ");
  }
  r9 = 1;
  for (var n8 = arguments, i7 = n8.length, o8 = String(e9).replace(te, function(e10) {
    if ("%%" === e10)
      return "%";
    if (r9 >= i7)
      return e10;
    switch (e10) {
      case "%s":
        return String(n8[r9++]);
      case "%d":
        return Number(n8[r9++]);
      case "%j":
        try {
          return JSON.stringify(n8[r9++]);
        } catch (e11) {
          return "[Circular]";
        }
      default:
        return e10;
    }
  }), u7 = n8[r9]; r9 < i7; u7 = n8[++r9])
    le(u7) || !he(u7) ? o8 += " " + u7 : o8 += " " + oe(u7);
  return o8;
}, X.deprecate = function(e9, t8) {
  if (void 0 !== Y && true === Y.noDeprecation)
    return e9;
  if (void 0 === Y)
    return function() {
      return X.deprecate(e9, t8).apply(this || Q, arguments);
    };
  var r9 = false;
  return function() {
    if (!r9) {
      if (Y.throwDeprecation)
        throw new Error(t8);
      Y.traceDeprecation ? console.trace(t8) : console.error(t8), r9 = true;
    }
    return e9.apply(this || Q, arguments);
  };
};
var re = {};
var ne = /^$/;
if (Y.env.NODE_DEBUG) {
  ie = Y.env.NODE_DEBUG;
  ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
}
var ie;
function oe(e9, t8) {
  var r9 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r9.depth = arguments[2]), arguments.length >= 4 && (r9.colors = arguments[3]), ye(t8) ? r9.showHidden = t8 : t8 && X._extend(r9, t8), be(r9.showHidden) && (r9.showHidden = false), be(r9.depth) && (r9.depth = 2), be(r9.colors) && (r9.colors = false), be(r9.customInspect) && (r9.customInspect = true), r9.colors && (r9.stylize = ue), ae(r9, e9, r9.depth);
}
function ue(e9, t8) {
  var r9 = oe.styles[t8];
  return r9 ? "\x1B[" + oe.colors[r9][0] + "m" + e9 + "\x1B[" + oe.colors[r9][1] + "m" : e9;
}
function fe(e9, t8) {
  return e9;
}
function ae(e9, t8, r9) {
  if (e9.customInspect && t8 && we(t8.inspect) && t8.inspect !== X.inspect && (!t8.constructor || t8.constructor.prototype !== t8)) {
    var n8 = t8.inspect(r9, e9);
    return ge(n8) || (n8 = ae(e9, n8, r9)), n8;
  }
  var i7 = function(e10, t9) {
    if (be(t9))
      return e10.stylize("undefined", "undefined");
    if (ge(t9)) {
      var r10 = "'" + JSON.stringify(t9).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e10.stylize(r10, "string");
    }
    if (de(t9))
      return e10.stylize("" + t9, "number");
    if (ye(t9))
      return e10.stylize("" + t9, "boolean");
    if (le(t9))
      return e10.stylize("null", "null");
  }(e9, t8);
  if (i7)
    return i7;
  var o8 = Object.keys(t8), u7 = function(e10) {
    var t9 = {};
    return e10.forEach(function(e11, r10) {
      t9[e11] = true;
    }), t9;
  }(o8);
  if (e9.showHidden && (o8 = Object.getOwnPropertyNames(t8)), Ae(t8) && (o8.indexOf("message") >= 0 || o8.indexOf("description") >= 0))
    return ce(t8);
  if (0 === o8.length) {
    if (we(t8)) {
      var f7 = t8.name ? ": " + t8.name : "";
      return e9.stylize("[Function" + f7 + "]", "special");
    }
    if (me(t8))
      return e9.stylize(RegExp.prototype.toString.call(t8), "regexp");
    if (je(t8))
      return e9.stylize(Date.prototype.toString.call(t8), "date");
    if (Ae(t8))
      return ce(t8);
  }
  var a7, c7 = "", s6 = false, p7 = ["{", "}"];
  (pe(t8) && (s6 = true, p7 = ["[", "]"]), we(t8)) && (c7 = " [Function" + (t8.name ? ": " + t8.name : "") + "]");
  return me(t8) && (c7 = " " + RegExp.prototype.toString.call(t8)), je(t8) && (c7 = " " + Date.prototype.toUTCString.call(t8)), Ae(t8) && (c7 = " " + ce(t8)), 0 !== o8.length || s6 && 0 != t8.length ? r9 < 0 ? me(t8) ? e9.stylize(RegExp.prototype.toString.call(t8), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t8), a7 = s6 ? function(e10, t9, r10, n9, i8) {
    for (var o9 = [], u8 = 0, f8 = t9.length; u8 < f8; ++u8)
      ke(t9, String(u8)) ? o9.push(se(e10, t9, r10, n9, String(u8), true)) : o9.push("");
    return i8.forEach(function(i9) {
      i9.match(/^\d+$/) || o9.push(se(e10, t9, r10, n9, i9, true));
    }), o9;
  }(e9, t8, r9, u7, o8) : o8.map(function(n9) {
    return se(e9, t8, r9, u7, n9, s6);
  }), e9.seen.pop(), function(e10, t9, r10) {
    var n9 = 0;
    if (e10.reduce(function(e11, t10) {
      return n9++, t10.indexOf("\n") >= 0 && n9++, e11 + t10.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r10[0] + ("" === t9 ? "" : t9 + "\n ") + " " + e10.join(",\n  ") + " " + r10[1];
    return r10[0] + t9 + " " + e10.join(", ") + " " + r10[1];
  }(a7, c7, p7)) : p7[0] + c7 + p7[1];
}
function ce(e9) {
  return "[" + Error.prototype.toString.call(e9) + "]";
}
function se(e9, t8, r9, n8, i7, o8) {
  var u7, f7, a7;
  if ((a7 = Object.getOwnPropertyDescriptor(t8, i7) || { value: t8[i7] }).get ? f7 = a7.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : a7.set && (f7 = e9.stylize("[Setter]", "special")), ke(n8, i7) || (u7 = "[" + i7 + "]"), f7 || (e9.seen.indexOf(a7.value) < 0 ? (f7 = le(r9) ? ae(e9, a7.value, null) : ae(e9, a7.value, r9 - 1)).indexOf("\n") > -1 && (f7 = o8 ? f7.split("\n").map(function(e10) {
    return "  " + e10;
  }).join("\n").substr(2) : "\n" + f7.split("\n").map(function(e10) {
    return "   " + e10;
  }).join("\n")) : f7 = e9.stylize("[Circular]", "special")), be(u7)) {
    if (o8 && i7.match(/^\d+$/))
      return f7;
    (u7 = JSON.stringify("" + i7)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e9.stylize(u7, "name")) : (u7 = u7.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u7 = e9.stylize(u7, "string"));
  }
  return u7 + ": " + f7;
}
function pe(e9) {
  return Array.isArray(e9);
}
function ye(e9) {
  return "boolean" == typeof e9;
}
function le(e9) {
  return null === e9;
}
function de(e9) {
  return "number" == typeof e9;
}
function ge(e9) {
  return "string" == typeof e9;
}
function be(e9) {
  return void 0 === e9;
}
function me(e9) {
  return he(e9) && "[object RegExp]" === ve(e9);
}
function he(e9) {
  return "object" == typeof e9 && null !== e9;
}
function je(e9) {
  return he(e9) && "[object Date]" === ve(e9);
}
function Ae(e9) {
  return he(e9) && ("[object Error]" === ve(e9) || e9 instanceof Error);
}
function we(e9) {
  return "function" == typeof e9;
}
function ve(e9) {
  return Object.prototype.toString.call(e9);
}
function Oe(e9) {
  return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
}
X.debuglog = function(e9) {
  if (e9 = e9.toUpperCase(), !re[e9])
    if (ne.test(e9)) {
      var t8 = Y.pid;
      re[e9] = function() {
        var r9 = X.format.apply(X, arguments);
        console.error("%s %d: %s", e9, t8, r9);
      };
    } else
      re[e9] = function() {
      };
  return re[e9];
}, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e9) {
  return null == e9;
}, X.isNumber = de, X.isString = ge, X.isSymbol = function(e9) {
  return "symbol" == typeof e9;
}, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e9) {
  return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
}, X.isBuffer = i$1;
var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Be() {
  var e9 = /* @__PURE__ */ new Date(), t8 = [Oe(e9.getHours()), Oe(e9.getMinutes()), Oe(e9.getSeconds())].join(":");
  return [e9.getDate(), Se[e9.getMonth()], t8].join(" ");
}
function ke(e9, t8) {
  return Object.prototype.hasOwnProperty.call(e9, t8);
}
X.log = function() {
  console.log("%s - %s", Be(), X.format.apply(X, arguments));
}, X.inherits = t$2, X._extend = function(e9, t8) {
  if (!t8 || !he(t8))
    return e9;
  for (var r9 = Object.keys(t8), n8 = r9.length; n8--; )
    e9[r9[n8]] = t8[r9[n8]];
  return e9;
};
var Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function De(e9, t8) {
  if (!e9) {
    var r9 = new Error("Promise was rejected with a falsy value");
    r9.reason = e9, e9 = r9;
  }
  return t8(e9);
}
X.promisify = function(e9) {
  if ("function" != typeof e9)
    throw new TypeError('The "original" argument must be of type Function');
  if (Ee && e9[Ee]) {
    var t8;
    if ("function" != typeof (t8 = e9[Ee]))
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), t8;
  }
  function t8() {
    for (var t9, r9, n8 = new Promise(function(e10, n9) {
      t9 = e10, r9 = n9;
    }), i7 = [], o8 = 0; o8 < arguments.length; o8++)
      i7.push(arguments[o8]);
    i7.push(function(e10, n9) {
      e10 ? r9(e10) : t9(n9);
    });
    try {
      e9.apply(this || Q, i7);
    } catch (e10) {
      r9(e10);
    }
    return n8;
  }
  return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Ee && Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t8, ee(e9));
}, X.promisify.custom = Ee, X.callbackify = function(e9) {
  if ("function" != typeof e9)
    throw new TypeError('The "original" argument must be of type Function');
  function t8() {
    for (var t9 = [], r9 = 0; r9 < arguments.length; r9++)
      t9.push(arguments[r9]);
    var n8 = t9.pop();
    if ("function" != typeof n8)
      throw new TypeError("The last argument must be of type Function");
    var i7 = this || Q, o8 = function() {
      return n8.apply(i7, arguments);
    };
    e9.apply(this || Q, t9).then(function(e10) {
      Y.nextTick(o8.bind(null, null, e10));
    }, function(e10) {
      Y.nextTick(De.bind(null, e10, o8));
    });
  }
  return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Object.defineProperties(t8, ee(e9)), t8;
};

// node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
X.promisify;
var _extend = X._extend;
var callbackify = X.callbackify;
var debuglog = X.debuglog;
var deprecate = X.deprecate;
var format2 = X.format;
var inherits2 = X.inherits;
var inspect = X.inspect;
var isArray2 = X.isArray;
var isBoolean2 = X.isBoolean;
var isBuffer2 = X.isBuffer;
var isDate2 = X.isDate;
var isError = X.isError;
var isFunction2 = X.isFunction;
var isNull = X.isNull;
var isNullOrUndefined = X.isNullOrUndefined;
var isNumber2 = X.isNumber;
var isObject2 = X.isObject;
var isPrimitive = X.isPrimitive;
var isRegExp2 = X.isRegExp;
var isString3 = X.isString;
var isSymbol = X.isSymbol;
var isUndefined2 = X.isUndefined;
var log = X.log;
var promisify = X.promisify;
var types = X.types;
var TextEncoder = self.TextEncoder;
var TextDecoder2 = self.TextDecoder;

// node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
for (r$13 = { byteLength: function(r9) {
  var t8 = u$2(r9), e9 = t8[0], n8 = t8[1];
  return 3 * (e9 + n8) / 4 - n8;
}, toByteArray: function(r9) {
  var t8, o8, a7 = u$2(r9), h8 = a7[0], c7 = a7[1], d6 = new n$22(function(r10, t9, e9) {
    return 3 * (t9 + e9) / 4 - e9;
  }(0, h8, c7)), f7 = 0, A4 = c7 > 0 ? h8 - 4 : h8;
  for (o8 = 0; o8 < A4; o8 += 4)
    t8 = e$22[r9.charCodeAt(o8)] << 18 | e$22[r9.charCodeAt(o8 + 1)] << 12 | e$22[r9.charCodeAt(o8 + 2)] << 6 | e$22[r9.charCodeAt(o8 + 3)], d6[f7++] = t8 >> 16 & 255, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8;
  2 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 2 | e$22[r9.charCodeAt(o8 + 1)] >> 4, d6[f7++] = 255 & t8);
  1 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 10 | e$22[r9.charCodeAt(o8 + 1)] << 4 | e$22[r9.charCodeAt(o8 + 2)] >> 2, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8);
  return d6;
}, fromByteArray: function(r9) {
  for (var e9, n8 = r9.length, o8 = n8 % 3, a7 = [], h8 = 0, u7 = n8 - o8; h8 < u7; h8 += 16383)
    a7.push(c$12(r9, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
  1 === o8 ? (e9 = r9[n8 - 1], a7.push(t$13[e9 >> 2] + t$13[e9 << 4 & 63] + "==")) : 2 === o8 && (e9 = (r9[n8 - 2] << 8) + r9[n8 - 1], a7.push(t$13[e9 >> 10] + t$13[e9 >> 4 & 63] + t$13[e9 << 2 & 63] + "="));
  return a7.join("");
} }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
  t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
var r$13;
var t$13;
var e$22;
var n$22;
var o$23;
var a$12;
var h$12;
function u$2(r9) {
  var t8 = r9.length;
  if (t8 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e9 = r9.indexOf("=");
  return -1 === e9 && (e9 = t8), [e9, e9 === t8 ? 0 : 4 - e9 % 4];
}
function c$12(r9, e9, n8) {
  for (var o8, a7, h8 = [], u7 = e9; u7 < n8; u7 += 3)
    o8 = (r9[u7] << 16 & 16711680) + (r9[u7 + 1] << 8 & 65280) + (255 & r9[u7 + 2]), h8.push(t$13[(a7 = o8) >> 18 & 63] + t$13[a7 >> 12 & 63] + t$13[a7 >> 6 & 63] + t$13[63 & a7]);
  return h8.join("");
}
e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
var a$1$1 = { read: function(a7, t8, o8, r9, h8) {
  var M4, f7, p7 = 8 * h8 - r9 - 1, w4 = (1 << p7) - 1, e9 = w4 >> 1, i7 = -7, N4 = o8 ? h8 - 1 : 0, n8 = o8 ? -1 : 1, u7 = a7[t8 + N4];
  for (N4 += n8, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p7; i7 > 0; M4 = 256 * M4 + a7[t8 + N4], N4 += n8, i7 -= 8)
    ;
  for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r9; i7 > 0; f7 = 256 * f7 + a7[t8 + N4], N4 += n8, i7 -= 8)
    ;
  if (0 === M4)
    M4 = 1 - e9;
  else {
    if (M4 === w4)
      return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
    f7 += Math.pow(2, r9), M4 -= e9;
  }
  return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r9);
}, write: function(a7, t8, o8, r9, h8, M4) {
  var f7, p7, w4, e9 = 8 * M4 - h8 - 1, i7 = (1 << e9) - 1, N4 = i7 >> 1, n8 = 23 === h8 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r9 ? 0 : M4 - 1, l7 = r9 ? 1 : -1, s6 = t8 < 0 || 0 === t8 && 1 / t8 < 0 ? 1 : 0;
  for (t8 = Math.abs(t8), isNaN(t8) || t8 === 1 / 0 ? (p7 = isNaN(t8) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t8) / Math.LN2), t8 * (w4 = Math.pow(2, -f7)) < 1 && (f7--, w4 *= 2), (t8 += f7 + N4 >= 1 ? n8 / w4 : n8 * Math.pow(2, 1 - N4)) * w4 >= 2 && (f7++, w4 /= 2), f7 + N4 >= i7 ? (p7 = 0, f7 = i7) : f7 + N4 >= 1 ? (p7 = (t8 * w4 - 1) * Math.pow(2, h8), f7 += N4) : (p7 = t8 * Math.pow(2, N4 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a7[o8 + u7] = 255 & p7, u7 += l7, p7 /= 256, h8 -= 8)
    ;
  for (f7 = f7 << h8 | p7, e9 += h8; e9 > 0; a7[o8 + u7] = 255 & f7, u7 += l7, f7 /= 256, e9 -= 8)
    ;
  a7[o8 + u7 - l7] |= 128 * s6;
} };
var e$1$1 = {};
var n$1$1 = r$13;
var i$12 = a$1$1;
var o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t8) {
  +t8 != t8 && (t8 = 0);
  return u$1$1.alloc(+t8);
}, e$1$1.INSPECT_MAX_BYTES = 50;
function f$2(t8) {
  if (t8 > 2147483647)
    throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
  var r9 = new Uint8Array(t8);
  return Object.setPrototypeOf(r9, u$1$1.prototype), r9;
}
function u$1$1(t8, r9, e9) {
  if ("number" == typeof t8) {
    if ("string" == typeof r9)
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$2(t8);
  }
  return s$1(t8, r9, e9);
}
function s$1(t8, r9, e9) {
  if ("string" == typeof t8)
    return function(t9, r10) {
      "string" == typeof r10 && "" !== r10 || (r10 = "utf8");
      if (!u$1$1.isEncoding(r10))
        throw new TypeError("Unknown encoding: " + r10);
      var e10 = 0 | y3(t9, r10), n9 = f$2(e10), i8 = n9.write(t9, r10);
      i8 !== e10 && (n9 = n9.slice(0, i8));
      return n9;
    }(t8, r9);
  if (ArrayBuffer.isView(t8))
    return p4(t8);
  if (null == t8)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
  if (F2(t8, ArrayBuffer) || t8 && F2(t8.buffer, ArrayBuffer))
    return c$1$1(t8, r9, e9);
  if ("undefined" != typeof SharedArrayBuffer && (F2(t8, SharedArrayBuffer) || t8 && F2(t8.buffer, SharedArrayBuffer)))
    return c$1$1(t8, r9, e9);
  if ("number" == typeof t8)
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n8 = t8.valueOf && t8.valueOf();
  if (null != n8 && n8 !== t8)
    return u$1$1.from(n8, r9, e9);
  var i7 = function(t9) {
    if (u$1$1.isBuffer(t9)) {
      var r10 = 0 | l$12(t9.length), e10 = f$2(r10);
      return 0 === e10.length || t9.copy(e10, 0, 0, r10), e10;
    }
    if (void 0 !== t9.length)
      return "number" != typeof t9.length || N2(t9.length) ? f$2(0) : p4(t9);
    if ("Buffer" === t9.type && Array.isArray(t9.data))
      return p4(t9.data);
  }(t8);
  if (i7)
    return i7;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t8[Symbol.toPrimitive])
    return u$1$1.from(t8[Symbol.toPrimitive]("string"), r9, e9);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
}
function h$1$1(t8) {
  if ("number" != typeof t8)
    throw new TypeError('"size" argument must be of type number');
  if (t8 < 0)
    throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
}
function a$2(t8) {
  return h$1$1(t8), f$2(t8 < 0 ? 0 : 0 | l$12(t8));
}
function p4(t8) {
  for (var r9 = t8.length < 0 ? 0 : 0 | l$12(t8.length), e9 = f$2(r9), n8 = 0; n8 < r9; n8 += 1)
    e9[n8] = 255 & t8[n8];
  return e9;
}
function c$1$1(t8, r9, e9) {
  if (r9 < 0 || t8.byteLength < r9)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (t8.byteLength < r9 + (e9 || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var n8;
  return n8 = void 0 === r9 && void 0 === e9 ? new Uint8Array(t8) : void 0 === e9 ? new Uint8Array(t8, r9) : new Uint8Array(t8, r9, e9), Object.setPrototypeOf(n8, u$1$1.prototype), n8;
}
function l$12(t8) {
  if (t8 >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t8;
}
function y3(t8, r9) {
  if (u$1$1.isBuffer(t8))
    return t8.length;
  if (ArrayBuffer.isView(t8) || F2(t8, ArrayBuffer))
    return t8.byteLength;
  if ("string" != typeof t8)
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t8);
  var e9 = t8.length, n8 = arguments.length > 2 && true === arguments[2];
  if (!n8 && 0 === e9)
    return 0;
  for (var i7 = false; ; )
    switch (r9) {
      case "ascii":
      case "latin1":
      case "binary":
        return e9;
      case "utf8":
      case "utf-8":
        return _2(t8).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e9;
      case "hex":
        return e9 >>> 1;
      case "base64":
        return z2(t8).length;
      default:
        if (i7)
          return n8 ? -1 : _2(t8).length;
        r9 = ("" + r9).toLowerCase(), i7 = true;
    }
}
function g2(t8, r9, e9) {
  var n8 = false;
  if ((void 0 === r9 || r9 < 0) && (r9 = 0), r9 > this.length)
    return "";
  if ((void 0 === e9 || e9 > this.length) && (e9 = this.length), e9 <= 0)
    return "";
  if ((e9 >>>= 0) <= (r9 >>>= 0))
    return "";
  for (t8 || (t8 = "utf8"); ; )
    switch (t8) {
      case "hex":
        return O2(this, r9, e9);
      case "utf8":
      case "utf-8":
        return I2(this, r9, e9);
      case "ascii":
        return S2(this, r9, e9);
      case "latin1":
      case "binary":
        return R2(this, r9, e9);
      case "base64":
        return T3(this, r9, e9);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, r9, e9);
      default:
        if (n8)
          throw new TypeError("Unknown encoding: " + t8);
        t8 = (t8 + "").toLowerCase(), n8 = true;
    }
}
function w2(t8, r9, e9) {
  var n8 = t8[r9];
  t8[r9] = t8[e9], t8[e9] = n8;
}
function d3(t8, r9, e9, n8, i7) {
  if (0 === t8.length)
    return -1;
  if ("string" == typeof e9 ? (n8 = e9, e9 = 0) : e9 > 2147483647 ? e9 = 2147483647 : e9 < -2147483648 && (e9 = -2147483648), N2(e9 = +e9) && (e9 = i7 ? 0 : t8.length - 1), e9 < 0 && (e9 = t8.length + e9), e9 >= t8.length) {
    if (i7)
      return -1;
    e9 = t8.length - 1;
  } else if (e9 < 0) {
    if (!i7)
      return -1;
    e9 = 0;
  }
  if ("string" == typeof r9 && (r9 = u$1$1.from(r9, n8)), u$1$1.isBuffer(r9))
    return 0 === r9.length ? -1 : v3(t8, r9, e9, n8, i7);
  if ("number" == typeof r9)
    return r9 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i7 ? Uint8Array.prototype.indexOf.call(t8, r9, e9) : Uint8Array.prototype.lastIndexOf.call(t8, r9, e9) : v3(t8, [r9], e9, n8, i7);
  throw new TypeError("val must be string, number or Buffer");
}
function v3(t8, r9, e9, n8, i7) {
  var o8, f7 = 1, u7 = t8.length, s6 = r9.length;
  if (void 0 !== n8 && ("ucs2" === (n8 = String(n8).toLowerCase()) || "ucs-2" === n8 || "utf16le" === n8 || "utf-16le" === n8)) {
    if (t8.length < 2 || r9.length < 2)
      return -1;
    f7 = 2, u7 /= 2, s6 /= 2, e9 /= 2;
  }
  function h8(t9, r10) {
    return 1 === f7 ? t9[r10] : t9.readUInt16BE(r10 * f7);
  }
  if (i7) {
    var a7 = -1;
    for (o8 = e9; o8 < u7; o8++)
      if (h8(t8, o8) === h8(r9, -1 === a7 ? 0 : o8 - a7)) {
        if (-1 === a7 && (a7 = o8), o8 - a7 + 1 === s6)
          return a7 * f7;
      } else
        -1 !== a7 && (o8 -= o8 - a7), a7 = -1;
  } else
    for (e9 + s6 > u7 && (e9 = u7 - s6), o8 = e9; o8 >= 0; o8--) {
      for (var p7 = true, c7 = 0; c7 < s6; c7++)
        if (h8(t8, o8 + c7) !== h8(r9, c7)) {
          p7 = false;
          break;
        }
      if (p7)
        return o8;
    }
  return -1;
}
function b2(t8, r9, e9, n8) {
  e9 = Number(e9) || 0;
  var i7 = t8.length - e9;
  n8 ? (n8 = Number(n8)) > i7 && (n8 = i7) : n8 = i7;
  var o8 = r9.length;
  n8 > o8 / 2 && (n8 = o8 / 2);
  for (var f7 = 0; f7 < n8; ++f7) {
    var u7 = parseInt(r9.substr(2 * f7, 2), 16);
    if (N2(u7))
      return f7;
    t8[e9 + f7] = u7;
  }
  return f7;
}
function m3(t8, r9, e9, n8) {
  return D2(_2(r9, t8.length - e9), t8, e9, n8);
}
function E2(t8, r9, e9, n8) {
  return D2(function(t9) {
    for (var r10 = [], e10 = 0; e10 < t9.length; ++e10)
      r10.push(255 & t9.charCodeAt(e10));
    return r10;
  }(r9), t8, e9, n8);
}
function B2(t8, r9, e9, n8) {
  return E2(t8, r9, e9, n8);
}
function A2(t8, r9, e9, n8) {
  return D2(z2(r9), t8, e9, n8);
}
function U2(t8, r9, e9, n8) {
  return D2(function(t9, r10) {
    for (var e10, n9, i7, o8 = [], f7 = 0; f7 < t9.length && !((r10 -= 2) < 0); ++f7)
      e10 = t9.charCodeAt(f7), n9 = e10 >> 8, i7 = e10 % 256, o8.push(i7), o8.push(n9);
    return o8;
  }(r9, t8.length - e9), t8, e9, n8);
}
function T3(t8, r9, e9) {
  return 0 === r9 && e9 === t8.length ? n$1$1.fromByteArray(t8) : n$1$1.fromByteArray(t8.slice(r9, e9));
}
function I2(t8, r9, e9) {
  e9 = Math.min(t8.length, e9);
  for (var n8 = [], i7 = r9; i7 < e9; ) {
    var o8, f7, u7, s6, h8 = t8[i7], a7 = null, p7 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
    if (i7 + p7 <= e9)
      switch (p7) {
        case 1:
          h8 < 128 && (a7 = h8);
          break;
        case 2:
          128 == (192 & (o8 = t8[i7 + 1])) && (s6 = (31 & h8) << 6 | 63 & o8) > 127 && (a7 = s6);
          break;
        case 3:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], 128 == (192 & o8) && 128 == (192 & f7) && (s6 = (15 & h8) << 12 | (63 & o8) << 6 | 63 & f7) > 2047 && (s6 < 55296 || s6 > 57343) && (a7 = s6);
          break;
        case 4:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], u7 = t8[i7 + 3], 128 == (192 & o8) && 128 == (192 & f7) && 128 == (192 & u7) && (s6 = (15 & h8) << 18 | (63 & o8) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s6 < 1114112 && (a7 = s6);
      }
    null === a7 ? (a7 = 65533, p7 = 1) : a7 > 65535 && (a7 -= 65536, n8.push(a7 >>> 10 & 1023 | 55296), a7 = 56320 | 1023 & a7), n8.push(a7), i7 += p7;
  }
  return function(t9) {
    var r10 = t9.length;
    if (r10 <= 4096)
      return String.fromCharCode.apply(String, t9);
    var e10 = "", n9 = 0;
    for (; n9 < r10; )
      e10 += String.fromCharCode.apply(String, t9.slice(n9, n9 += 4096));
    return e10;
  }(n8);
}
e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
  try {
    var t8 = new Uint8Array(1), r9 = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(r9, Uint8Array.prototype), Object.setPrototypeOf(t8, r9), 42 === t8.foo();
  } catch (t9) {
    return false;
  }
}(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this))
    return this.buffer;
} }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this))
    return this.byteOffset;
} }), u$1$1.poolSize = 8192, u$1$1.from = function(t8, r9, e9) {
  return s$1(t8, r9, e9);
}, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t8, r9, e9) {
  return function(t9, r10, e10) {
    return h$1$1(t9), t9 <= 0 ? f$2(t9) : void 0 !== r10 ? "string" == typeof e10 ? f$2(t9).fill(r10, e10) : f$2(t9).fill(r10) : f$2(t9);
  }(t8, r9, e9);
}, u$1$1.allocUnsafe = function(t8) {
  return a$2(t8);
}, u$1$1.allocUnsafeSlow = function(t8) {
  return a$2(t8);
}, u$1$1.isBuffer = function(t8) {
  return null != t8 && true === t8._isBuffer && t8 !== u$1$1.prototype;
}, u$1$1.compare = function(t8, r9) {
  if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), F2(r9, Uint8Array) && (r9 = u$1$1.from(r9, r9.offset, r9.byteLength)), !u$1$1.isBuffer(t8) || !u$1$1.isBuffer(r9))
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  if (t8 === r9)
    return 0;
  for (var e9 = t8.length, n8 = r9.length, i7 = 0, o8 = Math.min(e9, n8); i7 < o8; ++i7)
    if (t8[i7] !== r9[i7]) {
      e9 = t8[i7], n8 = r9[i7];
      break;
    }
  return e9 < n8 ? -1 : n8 < e9 ? 1 : 0;
}, u$1$1.isEncoding = function(t8) {
  switch (String(t8).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, u$1$1.concat = function(t8, r9) {
  if (!Array.isArray(t8))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === t8.length)
    return u$1$1.alloc(0);
  var e9;
  if (void 0 === r9)
    for (r9 = 0, e9 = 0; e9 < t8.length; ++e9)
      r9 += t8[e9].length;
  var n8 = u$1$1.allocUnsafe(r9), i7 = 0;
  for (e9 = 0; e9 < t8.length; ++e9) {
    var o8 = t8[e9];
    if (F2(o8, Uint8Array) && (o8 = u$1$1.from(o8)), !u$1$1.isBuffer(o8))
      throw new TypeError('"list" argument must be an Array of Buffers');
    o8.copy(n8, i7), i7 += o8.length;
  }
  return n8;
}, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
  var t8 = this.length;
  if (t8 % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r9 = 0; r9 < t8; r9 += 2)
    w2(this, r9, r9 + 1);
  return this;
}, u$1$1.prototype.swap32 = function() {
  var t8 = this.length;
  if (t8 % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r9 = 0; r9 < t8; r9 += 4)
    w2(this, r9, r9 + 3), w2(this, r9 + 1, r9 + 2);
  return this;
}, u$1$1.prototype.swap64 = function() {
  var t8 = this.length;
  if (t8 % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r9 = 0; r9 < t8; r9 += 8)
    w2(this, r9, r9 + 7), w2(this, r9 + 1, r9 + 6), w2(this, r9 + 2, r9 + 5), w2(this, r9 + 3, r9 + 4);
  return this;
}, u$1$1.prototype.toString = function() {
  var t8 = this.length;
  return 0 === t8 ? "" : 0 === arguments.length ? I2(this, 0, t8) : g2.apply(this, arguments);
}, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError("Argument must be a Buffer");
  return this === t8 || 0 === u$1$1.compare(this, t8);
}, u$1$1.prototype.inspect = function() {
  var t8 = "", r9 = e$1$1.INSPECT_MAX_BYTES;
  return t8 = this.toString("hex", 0, r9).replace(/(.{2})/g, "$1 ").trim(), this.length > r9 && (t8 += " ... "), "<Buffer " + t8 + ">";
}, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t8, r9, e9, n8, i7) {
  if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), !u$1$1.isBuffer(t8))
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t8);
  if (void 0 === r9 && (r9 = 0), void 0 === e9 && (e9 = t8 ? t8.length : 0), void 0 === n8 && (n8 = 0), void 0 === i7 && (i7 = this.length), r9 < 0 || e9 > t8.length || n8 < 0 || i7 > this.length)
    throw new RangeError("out of range index");
  if (n8 >= i7 && r9 >= e9)
    return 0;
  if (n8 >= i7)
    return -1;
  if (r9 >= e9)
    return 1;
  if (this === t8)
    return 0;
  for (var o8 = (i7 >>>= 0) - (n8 >>>= 0), f7 = (e9 >>>= 0) - (r9 >>>= 0), s6 = Math.min(o8, f7), h8 = this.slice(n8, i7), a7 = t8.slice(r9, e9), p7 = 0; p7 < s6; ++p7)
    if (h8[p7] !== a7[p7]) {
      o8 = h8[p7], f7 = a7[p7];
      break;
    }
  return o8 < f7 ? -1 : f7 < o8 ? 1 : 0;
}, u$1$1.prototype.includes = function(t8, r9, e9) {
  return -1 !== this.indexOf(t8, r9, e9);
}, u$1$1.prototype.indexOf = function(t8, r9, e9) {
  return d3(this, t8, r9, e9, true);
}, u$1$1.prototype.lastIndexOf = function(t8, r9, e9) {
  return d3(this, t8, r9, e9, false);
}, u$1$1.prototype.write = function(t8, r9, e9, n8) {
  if (void 0 === r9)
    n8 = "utf8", e9 = this.length, r9 = 0;
  else if (void 0 === e9 && "string" == typeof r9)
    n8 = r9, e9 = this.length, r9 = 0;
  else {
    if (!isFinite(r9))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    r9 >>>= 0, isFinite(e9) ? (e9 >>>= 0, void 0 === n8 && (n8 = "utf8")) : (n8 = e9, e9 = void 0);
  }
  var i7 = this.length - r9;
  if ((void 0 === e9 || e9 > i7) && (e9 = i7), t8.length > 0 && (e9 < 0 || r9 < 0) || r9 > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  n8 || (n8 = "utf8");
  for (var o8 = false; ; )
    switch (n8) {
      case "hex":
        return b2(this, t8, r9, e9);
      case "utf8":
      case "utf-8":
        return m3(this, t8, r9, e9);
      case "ascii":
        return E2(this, t8, r9, e9);
      case "latin1":
      case "binary":
        return B2(this, t8, r9, e9);
      case "base64":
        return A2(this, t8, r9, e9);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return U2(this, t8, r9, e9);
      default:
        if (o8)
          throw new TypeError("Unknown encoding: " + n8);
        n8 = ("" + n8).toLowerCase(), o8 = true;
    }
}, u$1$1.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
function S2(t8, r9, e9) {
  var n8 = "";
  e9 = Math.min(t8.length, e9);
  for (var i7 = r9; i7 < e9; ++i7)
    n8 += String.fromCharCode(127 & t8[i7]);
  return n8;
}
function R2(t8, r9, e9) {
  var n8 = "";
  e9 = Math.min(t8.length, e9);
  for (var i7 = r9; i7 < e9; ++i7)
    n8 += String.fromCharCode(t8[i7]);
  return n8;
}
function O2(t8, r9, e9) {
  var n8 = t8.length;
  (!r9 || r9 < 0) && (r9 = 0), (!e9 || e9 < 0 || e9 > n8) && (e9 = n8);
  for (var i7 = "", o8 = r9; o8 < e9; ++o8)
    i7 += Y2[t8[o8]];
  return i7;
}
function L2(t8, r9, e9) {
  for (var n8 = t8.slice(r9, e9), i7 = "", o8 = 0; o8 < n8.length; o8 += 2)
    i7 += String.fromCharCode(n8[o8] + 256 * n8[o8 + 1]);
  return i7;
}
function x2(t8, r9, e9) {
  if (t8 % 1 != 0 || t8 < 0)
    throw new RangeError("offset is not uint");
  if (t8 + r9 > e9)
    throw new RangeError("Trying to access beyond buffer length");
}
function C2(t8, r9, e9, n8, i7, o8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r9 > i7 || r9 < o8)
    throw new RangeError('"value" argument is out of bounds');
  if (e9 + n8 > t8.length)
    throw new RangeError("Index out of range");
}
function P2(t8, r9, e9, n8, i7, o8) {
  if (e9 + n8 > t8.length)
    throw new RangeError("Index out of range");
  if (e9 < 0)
    throw new RangeError("Index out of range");
}
function k2(t8, r9, e9, n8, o8) {
  return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 4), i$12.write(t8, r9, e9, n8, 23, 4), e9 + 4;
}
function M2(t8, r9, e9, n8, o8) {
  return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 8), i$12.write(t8, r9, e9, n8, 52, 8), e9 + 8;
}
u$1$1.prototype.slice = function(t8, r9) {
  var e9 = this.length;
  (t8 = ~~t8) < 0 ? (t8 += e9) < 0 && (t8 = 0) : t8 > e9 && (t8 = e9), (r9 = void 0 === r9 ? e9 : ~~r9) < 0 ? (r9 += e9) < 0 && (r9 = 0) : r9 > e9 && (r9 = e9), r9 < t8 && (r9 = t8);
  var n8 = this.subarray(t8, r9);
  return Object.setPrototypeOf(n8, u$1$1.prototype), n8;
}, u$1$1.prototype.readUIntLE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
    n8 += this[t8 + o8] * i7;
  return n8;
}, u$1$1.prototype.readUIntBE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8 + --r9], i7 = 1; r9 > 0 && (i7 *= 256); )
    n8 += this[t8 + --r9] * i7;
  return n8;
}, u$1$1.prototype.readUInt8 = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 1, this.length), this[t8];
}, u$1$1.prototype.readUInt16LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] | this[t8 + 1] << 8;
}, u$1$1.prototype.readUInt16BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] << 8 | this[t8 + 1];
}, u$1$1.prototype.readUInt32LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), (this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16) + 16777216 * this[t8 + 3];
}, u$1$1.prototype.readUInt32BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), 16777216 * this[t8] + (this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3]);
}, u$1$1.prototype.readIntLE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
    n8 += this[t8 + o8] * i7;
  return n8 >= (i7 *= 128) && (n8 -= Math.pow(2, 8 * r9)), n8;
}, u$1$1.prototype.readIntBE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = r9, i7 = 1, o8 = this[t8 + --n8]; n8 > 0 && (i7 *= 256); )
    o8 += this[t8 + --n8] * i7;
  return o8 >= (i7 *= 128) && (o8 -= Math.pow(2, 8 * r9)), o8;
}, u$1$1.prototype.readInt8 = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 1, this.length), 128 & this[t8] ? -1 * (255 - this[t8] + 1) : this[t8];
}, u$1$1.prototype.readInt16LE = function(t8, r9) {
  t8 >>>= 0, r9 || x2(t8, 2, this.length);
  var e9 = this[t8] | this[t8 + 1] << 8;
  return 32768 & e9 ? 4294901760 | e9 : e9;
}, u$1$1.prototype.readInt16BE = function(t8, r9) {
  t8 >>>= 0, r9 || x2(t8, 2, this.length);
  var e9 = this[t8 + 1] | this[t8] << 8;
  return 32768 & e9 ? 4294901760 | e9 : e9;
}, u$1$1.prototype.readInt32LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16 | this[t8 + 3] << 24;
}, u$1$1.prototype.readInt32BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] << 24 | this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3];
}, u$1$1.prototype.readFloatLE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, true, 23, 4);
}, u$1$1.prototype.readFloatBE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, false, 23, 4);
}, u$1$1.prototype.readDoubleLE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, true, 52, 8);
}, u$1$1.prototype.readDoubleBE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, false, 52, 8);
}, u$1$1.prototype.writeUIntLE = function(t8, r9, e9, n8) {
  (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
  var i7 = 1, o8 = 0;
  for (this[r9] = 255 & t8; ++o8 < e9 && (i7 *= 256); )
    this[r9 + o8] = t8 / i7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeUIntBE = function(t8, r9, e9, n8) {
  (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
  var i7 = e9 - 1, o8 = 1;
  for (this[r9 + i7] = 255 & t8; --i7 >= 0 && (o8 *= 256); )
    this[r9 + i7] = t8 / o8 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeUInt8 = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 255, 0), this[r9] = 255 & t8, r9 + 1;
}, u$1$1.prototype.writeUInt16LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
}, u$1$1.prototype.writeUInt16BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
}, u$1$1.prototype.writeUInt32LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9 + 3] = t8 >>> 24, this[r9 + 2] = t8 >>> 16, this[r9 + 1] = t8 >>> 8, this[r9] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeUInt32BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeIntLE = function(t8, r9, e9, n8) {
  if (t8 = +t8, r9 >>>= 0, !n8) {
    var i7 = Math.pow(2, 8 * e9 - 1);
    C2(this, t8, r9, e9, i7 - 1, -i7);
  }
  var o8 = 0, f7 = 1, u7 = 0;
  for (this[r9] = 255 & t8; ++o8 < e9 && (f7 *= 256); )
    t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 - 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeIntBE = function(t8, r9, e9, n8) {
  if (t8 = +t8, r9 >>>= 0, !n8) {
    var i7 = Math.pow(2, 8 * e9 - 1);
    C2(this, t8, r9, e9, i7 - 1, -i7);
  }
  var o8 = e9 - 1, f7 = 1, u7 = 0;
  for (this[r9 + o8] = 255 & t8; --o8 >= 0 && (f7 *= 256); )
    t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 + 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeInt8 = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 127, -128), t8 < 0 && (t8 = 255 + t8 + 1), this[r9] = 255 & t8, r9 + 1;
}, u$1$1.prototype.writeInt16LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
}, u$1$1.prototype.writeInt16BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
}, u$1$1.prototype.writeInt32LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, this[r9 + 2] = t8 >>> 16, this[r9 + 3] = t8 >>> 24, r9 + 4;
}, u$1$1.prototype.writeInt32BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), t8 < 0 && (t8 = 4294967295 + t8 + 1), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeFloatLE = function(t8, r9, e9) {
  return k2(this, t8, r9, true, e9);
}, u$1$1.prototype.writeFloatBE = function(t8, r9, e9) {
  return k2(this, t8, r9, false, e9);
}, u$1$1.prototype.writeDoubleLE = function(t8, r9, e9) {
  return M2(this, t8, r9, true, e9);
}, u$1$1.prototype.writeDoubleBE = function(t8, r9, e9) {
  return M2(this, t8, r9, false, e9);
}, u$1$1.prototype.copy = function(t8, r9, e9, n8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError("argument should be a Buffer");
  if (e9 || (e9 = 0), n8 || 0 === n8 || (n8 = this.length), r9 >= t8.length && (r9 = t8.length), r9 || (r9 = 0), n8 > 0 && n8 < e9 && (n8 = e9), n8 === e9)
    return 0;
  if (0 === t8.length || 0 === this.length)
    return 0;
  if (r9 < 0)
    throw new RangeError("targetStart out of bounds");
  if (e9 < 0 || e9 >= this.length)
    throw new RangeError("Index out of range");
  if (n8 < 0)
    throw new RangeError("sourceEnd out of bounds");
  n8 > this.length && (n8 = this.length), t8.length - r9 < n8 - e9 && (n8 = t8.length - r9 + e9);
  var i7 = n8 - e9;
  if (this === t8 && "function" == typeof Uint8Array.prototype.copyWithin)
    this.copyWithin(r9, e9, n8);
  else if (this === t8 && e9 < r9 && r9 < n8)
    for (var o8 = i7 - 1; o8 >= 0; --o8)
      t8[o8 + r9] = this[o8 + e9];
  else
    Uint8Array.prototype.set.call(t8, this.subarray(e9, n8), r9);
  return i7;
}, u$1$1.prototype.fill = function(t8, r9, e9, n8) {
  if ("string" == typeof t8) {
    if ("string" == typeof r9 ? (n8 = r9, r9 = 0, e9 = this.length) : "string" == typeof e9 && (n8 = e9, e9 = this.length), void 0 !== n8 && "string" != typeof n8)
      throw new TypeError("encoding must be a string");
    if ("string" == typeof n8 && !u$1$1.isEncoding(n8))
      throw new TypeError("Unknown encoding: " + n8);
    if (1 === t8.length) {
      var i7 = t8.charCodeAt(0);
      ("utf8" === n8 && i7 < 128 || "latin1" === n8) && (t8 = i7);
    }
  } else
    "number" == typeof t8 ? t8 &= 255 : "boolean" == typeof t8 && (t8 = Number(t8));
  if (r9 < 0 || this.length < r9 || this.length < e9)
    throw new RangeError("Out of range index");
  if (e9 <= r9)
    return this;
  var o8;
  if (r9 >>>= 0, e9 = void 0 === e9 ? this.length : e9 >>> 0, t8 || (t8 = 0), "number" == typeof t8)
    for (o8 = r9; o8 < e9; ++o8)
      this[o8] = t8;
  else {
    var f7 = u$1$1.isBuffer(t8) ? t8 : u$1$1.from(t8, n8), s6 = f7.length;
    if (0 === s6)
      throw new TypeError('The value "' + t8 + '" is invalid for argument "value"');
    for (o8 = 0; o8 < e9 - r9; ++o8)
      this[o8 + r9] = f7[o8 % s6];
  }
  return this;
};
var j2 = /[^+/0-9A-Za-z-_]/g;
function _2(t8, r9) {
  var e9;
  r9 = r9 || 1 / 0;
  for (var n8 = t8.length, i7 = null, o8 = [], f7 = 0; f7 < n8; ++f7) {
    if ((e9 = t8.charCodeAt(f7)) > 55295 && e9 < 57344) {
      if (!i7) {
        if (e9 > 56319) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189);
          continue;
        }
        if (f7 + 1 === n8) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189);
          continue;
        }
        i7 = e9;
        continue;
      }
      if (e9 < 56320) {
        (r9 -= 3) > -1 && o8.push(239, 191, 189), i7 = e9;
        continue;
      }
      e9 = 65536 + (i7 - 55296 << 10 | e9 - 56320);
    } else
      i7 && (r9 -= 3) > -1 && o8.push(239, 191, 189);
    if (i7 = null, e9 < 128) {
      if ((r9 -= 1) < 0)
        break;
      o8.push(e9);
    } else if (e9 < 2048) {
      if ((r9 -= 2) < 0)
        break;
      o8.push(e9 >> 6 | 192, 63 & e9 | 128);
    } else if (e9 < 65536) {
      if ((r9 -= 3) < 0)
        break;
      o8.push(e9 >> 12 | 224, e9 >> 6 & 63 | 128, 63 & e9 | 128);
    } else {
      if (!(e9 < 1114112))
        throw new Error("Invalid code point");
      if ((r9 -= 4) < 0)
        break;
      o8.push(e9 >> 18 | 240, e9 >> 12 & 63 | 128, e9 >> 6 & 63 | 128, 63 & e9 | 128);
    }
  }
  return o8;
}
function z2(t8) {
  return n$1$1.toByteArray(function(t9) {
    if ((t9 = (t9 = t9.split("=")[0]).trim().replace(j2, "")).length < 2)
      return "";
    for (; t9.length % 4 != 0; )
      t9 += "=";
    return t9;
  }(t8));
}
function D2(t8, r9, e9, n8) {
  for (var i7 = 0; i7 < n8 && !(i7 + e9 >= r9.length || i7 >= t8.length); ++i7)
    r9[i7 + e9] = t8[i7];
  return i7;
}
function F2(t8, r9) {
  return t8 instanceof r9 || null != t8 && null != t8.constructor && null != t8.constructor.name && t8.constructor.name === r9.name;
}
function N2(t8) {
  return t8 != t8;
}
var Y2 = function() {
  for (var t8 = new Array(256), r9 = 0; r9 < 16; ++r9)
    for (var e9 = 16 * r9, n8 = 0; n8 < 16; ++n8)
      t8[e9 + n8] = "0123456789abcdef"[r9] + "0123456789abcdef"[n8];
  return t8;
}();
e$1$1.Buffer;
e$1$1.INSPECT_MAX_BYTES;
e$1$1.kMaxLength;
var e4 = {};
var n4 = e$1$1;
var o4 = n4.Buffer;
function t4(r9, e9) {
  for (var n8 in r9)
    e9[n8] = r9[n8];
}
function f4(r9, e9, n8) {
  return o4(r9, e9, n8);
}
o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r9, e9, n8) {
  if ("number" == typeof r9)
    throw new TypeError("Argument must not be a number");
  return o4(r9, e9, n8);
}, f4.alloc = function(r9, e9, n8) {
  if ("number" != typeof r9)
    throw new TypeError("Argument must be a number");
  var t8 = o4(r9);
  return void 0 !== e9 ? "string" == typeof n8 ? t8.fill(e9, n8) : t8.fill(e9) : t8.fill(0), t8;
}, f4.allocUnsafe = function(r9) {
  if ("number" != typeof r9)
    throw new TypeError("Argument must be a number");
  return o4(r9);
}, f4.allocUnsafeSlow = function(r9) {
  if ("number" != typeof r9)
    throw new TypeError("Argument must be a number");
  return n4.SlowBuffer(r9);
};
var u4 = e4;
var e$12 = {};
var s4 = u4.Buffer;
var i4 = s4.isEncoding || function(t8) {
  switch ((t8 = "" + t8) && t8.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function a4(t8) {
  var e9;
  switch (this.encoding = function(t9) {
    var e10 = function(t10) {
      if (!t10)
        return "utf8";
      for (var e11; ; )
        switch (t10) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t10;
          default:
            if (e11)
              return;
            t10 = ("" + t10).toLowerCase(), e11 = true;
        }
    }(t9);
    if ("string" != typeof e10 && (s4.isEncoding === i4 || !i4(t9)))
      throw new Error("Unknown encoding: " + t9);
    return e10 || t9;
  }(t8), this.encoding) {
    case "utf16le":
      this.text = h4, this.end = l4, e9 = 4;
      break;
    case "utf8":
      this.fillLast = n$12, e9 = 4;
      break;
    case "base64":
      this.text = u$12, this.end = o$12, e9 = 3;
      break;
    default:
      return this.write = f$1, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e9);
}
function r4(t8) {
  return t8 <= 127 ? 0 : t8 >> 5 == 6 ? 2 : t8 >> 4 == 14 ? 3 : t8 >> 3 == 30 ? 4 : t8 >> 6 == 2 ? -1 : -2;
}
function n$12(t8) {
  var e9 = this.lastTotal - this.lastNeed, s6 = function(t9, e10, s7) {
    if (128 != (192 & e10[0]))
      return t9.lastNeed = 0, "\uFFFD";
    if (t9.lastNeed > 1 && e10.length > 1) {
      if (128 != (192 & e10[1]))
        return t9.lastNeed = 1, "\uFFFD";
      if (t9.lastNeed > 2 && e10.length > 2 && 128 != (192 & e10[2]))
        return t9.lastNeed = 2, "\uFFFD";
    }
  }(this, t8);
  return void 0 !== s6 ? s6 : this.lastNeed <= t8.length ? (t8.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t8.copy(this.lastChar, e9, 0, t8.length), this.lastNeed -= t8.length, void 0);
}
function h4(t8, e9) {
  if ((t8.length - e9) % 2 == 0) {
    var s6 = t8.toString("utf16le", e9);
    if (s6) {
      var i7 = s6.charCodeAt(s6.length - 1);
      if (i7 >= 55296 && i7 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1], s6.slice(0, -1);
    }
    return s6;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t8[t8.length - 1], t8.toString("utf16le", e9, t8.length - 1);
}
function l4(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : "";
  if (this.lastNeed) {
    var s6 = this.lastTotal - this.lastNeed;
    return e9 + this.lastChar.toString("utf16le", 0, s6);
  }
  return e9;
}
function u$12(t8, e9) {
  var s6 = (t8.length - e9) % 3;
  return 0 === s6 ? t8.toString("base64", e9) : (this.lastNeed = 3 - s6, this.lastTotal = 3, 1 === s6 ? this.lastChar[0] = t8[t8.length - 1] : (this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1]), t8.toString("base64", e9, t8.length - s6));
}
function o$12(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : "";
  return this.lastNeed ? e9 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e9;
}
function f$1(t8) {
  return t8.toString(this.encoding);
}
function c4(t8) {
  return t8 && t8.length ? this.write(t8) : "";
}
e$12.StringDecoder = a4, a4.prototype.write = function(t8) {
  if (0 === t8.length)
    return "";
  var e9, s6;
  if (this.lastNeed) {
    if (void 0 === (e9 = this.fillLast(t8)))
      return "";
    s6 = this.lastNeed, this.lastNeed = 0;
  } else
    s6 = 0;
  return s6 < t8.length ? e9 ? e9 + this.text(t8, s6) : this.text(t8, s6) : e9 || "";
}, a4.prototype.end = function(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : "";
  return this.lastNeed ? e9 + "\uFFFD" : e9;
}, a4.prototype.text = function(t8, e9) {
  var s6 = function(t9, e10, s7) {
    var i8 = e10.length - 1;
    if (i8 < s7)
      return 0;
    var a7 = r4(e10[i8]);
    if (a7 >= 0)
      return a7 > 0 && (t9.lastNeed = a7 - 1), a7;
    if (--i8 < s7 || -2 === a7)
      return 0;
    if ((a7 = r4(e10[i8])) >= 0)
      return a7 > 0 && (t9.lastNeed = a7 - 2), a7;
    if (--i8 < s7 || -2 === a7)
      return 0;
    if ((a7 = r4(e10[i8])) >= 0)
      return a7 > 0 && (2 === a7 ? a7 = 0 : t9.lastNeed = a7 - 3), a7;
    return 0;
  }(this, t8, e9);
  if (!this.lastNeed)
    return t8.toString("utf8", e9);
  this.lastTotal = s6;
  var i7 = t8.length - (s6 - this.lastNeed);
  return t8.copy(this.lastChar, 0, i7), t8.toString("utf8", e9, i7);
}, a4.prototype.fillLast = function(t8) {
  if (this.lastNeed <= t8.length)
    return t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t8.length), this.lastNeed -= t8.length;
};
e$12.StringDecoder;
e$12.StringDecoder;

// node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
var exports$2$1 = {};
var _dewExec$2$1 = false;
function dew$2$1() {
  if (_dewExec$2$1)
    return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$1;
}
var exports$1$1 = {};
var _dewExec$1$1 = false;
function dew$1$1() {
  if (_dewExec$1$1)
    return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e9, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e9 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e9 & (1 << -nBits) - 1;
    e9 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e9 === 0) {
      e9 = 1 - eBias;
    } else if (e9 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e9 = e9 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
  };
  exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e9, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e9 = eMax;
    } else {
      e9 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e9)) < 1) {
        e9--;
        c7 *= 2;
      }
      if (e9 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e9++;
        c7 /= 2;
      }
      if (e9 + eBias >= eMax) {
        m6 = 0;
        e9 = eMax;
      } else if (e9 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e9 = e9 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e9 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e9 = e9 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$1$1;
}
var exports$g = {};
var _dewExec$g = false;
function dew$g() {
  if (_dewExec$g)
    return exports$g;
  _dewExec$g = true;
  const base642 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Buffer3;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e9) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer4(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
    if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b5, n8, m6) {
    const i7 = b5[n8];
    b5[n8] = b5[m6];
    b5[m6] = i7;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b5) {
    if (!Buffer3.isBuffer(b5))
      throw new TypeError("Argument must be a Buffer");
    if (this === b5)
      return true;
    return Buffer3.compare(this, b5) === 0;
  };
  Buffer3.prototype.inspect = function inspect3() {
    let str = "";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === "number") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i7 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = `_${val.slice(i7 - 3, i7)}${res}`;
    }
    return `${val.slice(0, i7)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n8 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
        } else {
          range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
        }
      } else {
        range = `>= ${min}${n8} and <= ${max}${n8}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
var buffer = dew$g();
buffer.Buffer;
buffer.INSPECT_MAX_BYTES;
buffer.kMaxLength;
var exports$f = {};
var _dewExec$f = false;
function dew$f() {
  if (_dewExec$f)
    return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === "function") {
    exports$f = function inherits4(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits4(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
var exports$e = {};
var _dewExec$e = false;
function dew$e() {
  if (_dewExec$e)
    return exports$e;
  _dewExec$e = true;
  exports$e = y.EventEmitter;
  return exports$e;
}
var exports$d = {};
var _dewExec$d = false;
function dew$d() {
  if (_dewExec$d)
    return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i7 = 1; i7 < arguments.length; i7++) {
      var source = arguments[i7] != null ? arguments[i7] : {};
      if (i7 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i7 = 0; i7 < props.length; i7++) {
      var descriptor = props[i7];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer, Buffer3 = _require.Buffer;
  var _require2 = X, inspect3 = _require2.inspect;
  var custom = inspect3 && inspect3.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v7) {
        var entry = {
          data: v7,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v7) {
        var entry = {
          data: v7,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s6) {
        if (this.length === 0)
          return "";
        var p7 = this.head;
        var ret = "" + p7.data;
        while (p7 = p7.next) {
          ret += s6 + p7.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n8) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n8 >>> 0);
        var p7 = this.head;
        var i7 = 0;
        while (p7) {
          copyBuffer(p7.data, ret, i7);
          i7 += p7.data.length;
          p7 = p7.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n8, hasStrings) {
        var ret;
        if (n8 < this.head.data.length) {
          ret = this.head.data.slice(0, n8);
          this.head.data = this.head.data.slice(n8);
        } else if (n8 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n8) {
        var p7 = this.head;
        var c7 = 1;
        var ret = p7.data;
        n8 -= ret.length;
        while (p7 = p7.next) {
          var str = p7.data;
          var nb = n8 > str.length ? str.length : n8;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n8);
          n8 -= nb;
          if (n8 === 0) {
            if (nb === str.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = str.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n8) {
        var ret = Buffer3.allocUnsafe(n8);
        var p7 = this.head;
        var c7 = 1;
        p7.data.copy(ret);
        n8 -= p7.data.length;
        while (p7 = p7.next) {
          var buf = p7.data;
          var nb = n8 > buf.length ? buf.length : n8;
          buf.copy(ret, ret.length - n8, 0, nb);
          n8 -= nb;
          if (n8 === 0) {
            if (nb === buf.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = buf.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_4, options) {
        return inspect3(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
var exports$c = {};
var _dewExec$c = false;
function dew$c() {
  if (_dewExec$c)
    return exports$c;
  _dewExec$c = true;
  var process$1 = process2;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream2.destroy(err);
    else
      stream2.emit("error", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
var exports$b = {};
var _dewExec$b = false;
function dew$b() {
  if (_dewExec$b)
    return exports$b;
  _dewExec$b = true;
  const codes2 = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes2[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i7) => String(i7));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith2(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith2(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b.codes = codes2;
  return exports$b;
}
var exports$a = {};
var _dewExec$a = false;
function dew$a() {
  if (_dewExec$a)
    return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
var exports$9 = {};
var _dewExec$9 = false;
var _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$9() {
  if (_dewExec$9)
    return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate3;
  function deprecate3(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned2 = false;
    function deprecated() {
      if (!warned2) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned2 = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config2(name2) {
    try {
      if (!_global$2.localStorage)
        return false;
    } catch (_4) {
      return false;
    }
    var val = _global$2.localStorage[name2];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$9;
}
var exports$8 = {};
var _dewExec$8 = false;
var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$8() {
  if (_dewExec$8)
    return exports$8;
  _dewExec$8 = true;
  var process$1 = process2;
  exports$8 = Writable2;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex2;
  Writable2.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream2 = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_4) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable2(options) {
    Duplex2 = Duplex2 || dew$7();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable2, this))
      return new Writable2(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream2, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2)
      stream2._writev(chunk, state.onwrite);
    else
      stream2._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream2, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream2, state);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state = stream2._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream2, state, sync, er, cb);
    else {
      var finished2 = needFinish(state) || stream2.destroyed;
      if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream2, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream2, state, finished2, cb);
      } else {
        afterWrite(stream2, state, finished2, cb);
      }
    }
  }
  function afterWrite(stream2, state, finished2, cb) {
    if (!finished2)
      onwriteDrain(stream2, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream2, state);
  }
  function onwriteDrain(stream2, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l7 = state.bufferedRequestCount;
      var buffer2 = new Array(l7);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream2, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream2, state) {
    stream2._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream2, err);
      }
      state.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state);
    });
  }
  function prefinish(stream2, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream2._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream2, state);
      } else {
        state.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream2, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream2.emit("finish");
        if (state.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state, cb) {
    state.ending = true;
    finishMaybe(stream2, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
var exports$7 = {};
var _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7)
    return exports$7;
  _dewExec$7 = true;
  var process$1 = process2;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex2;
  var Readable2 = dew$3();
  var Writable2 = dew$8();
  dew$f()(Duplex2, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v7 = 0; v7 < keys.length; v7++) {
      var method = keys[v7];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
var exports$6 = {};
var _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6)
    return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop3() {
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos(stream2, opts, callback) {
    if (typeof opts === "function")
      return eos(stream2, null, opts);
    if (!opts)
      opts = {};
    callback = once3(callback || noop3);
    var readable = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable)
        onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream2);
    };
    var onerror = function onerror2(err) {
      callback.call(stream2, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req)
        onrequest();
      else
        stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false)
      stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req)
        stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
var exports$5 = {};
var _dewExec$5 = false;
function dew$5() {
  if (_dewExec$5)
    return exports$5;
  _dewExec$5 = true;
  var process$1 = process2;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished2 = dew$6();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve4 = iter[kLastResolve];
    if (resolve4 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve4(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve4, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve4(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve4, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve4, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve4(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve4, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve4(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve4, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve4(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve4;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished2(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve4 = iterator[kLastResolve];
      if (resolve4 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve4(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
var exports$4 = {};
var _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4)
    return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$4;
}
var exports$32 = {};
var _dewExec$3 = false;
var _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$3() {
  if (_dewExec$3)
    return exports$32;
  _dewExec$3 = true;
  var process$1 = process2;
  exports$32 = Readable2;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  y.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global3.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex2 = Duplex2 || dew$7();
    if (!(this instanceof Readable2))
      return new Readable2(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream2._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream2, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream2, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream2, state, chunk, false);
            else
              maybeReadMore(stream2, state);
          } else {
            addChunk(stream2, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream2, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream2, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$12.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p7 = this._readableState.buffer.head;
    var content = "";
    while (p7 !== null) {
      content += decoder.write(p7.data);
      p7 = p7.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n8) {
    if (n8 >= MAX_HWM) {
      n8 = MAX_HWM;
    } else {
      n8--;
      n8 |= n8 >>> 1;
      n8 |= n8 >>> 2;
      n8 |= n8 >>> 4;
      n8 |= n8 >>> 8;
      n8 |= n8 >>> 16;
      n8++;
    }
    return n8;
  }
  function howMuchToRead(n8, state) {
    if (n8 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n8 !== n8) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n8 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n8);
    if (n8 <= state.length)
      return n8;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n8) {
    debug("read", n8);
    n8 = parseInt(n8, 10);
    var state = this._readableState;
    var nOrig = n8;
    if (n8 !== 0)
      state.emittedReadable = false;
    if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n8 = howMuchToRead(n8, state);
    if (n8 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n8 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n8 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n8 > 0)
      ret = fromList(n8, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n8 = 0;
    } else {
      state.length -= n8;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n8 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream2);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state = stream2._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state = stream2._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream2.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream2, state);
    }
  }
  function maybeReadMore_(stream2, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n8) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i7 = 0; i7 < len; i7++) {
        dests[i7].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream2, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream2, state);
    }
  }
  function resume_(stream2, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream2.read(0);
    }
    state.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state.flowing && !state.reading)
      stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state = stream2._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i7 in stream2) {
      if (this[i7] === void 0 && typeof stream2[i7] === "function") {
        this[i7] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i7);
      }
    }
    for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
      stream2.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
    }
    this._read = function(n9) {
      debug("wrapped _read", n9);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n8, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n8 || n8 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n8, state.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state = stream2._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream2);
    }
  }
  function endReadableNT(state, stream2) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x4) {
    for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
      if (xs[i7] === x4)
        return i7;
    }
    return -1;
  }
  return exports$32;
}
var exports$22 = {};
var _dewExec$22 = false;
function dew$22() {
  if (_dewExec$22)
    return exports$22;
  _dewExec$22 = true;
  exports$22 = Transform2;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex2 = dew$7();
  dew$f()(Transform2, Duplex2);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex2.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex2.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n8) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex2.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream2, er, data) {
    if (er)
      return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return exports$22;
}
var exports$14 = {};
var _dewExec$12 = false;
function dew$12() {
  if (_dewExec$12)
    return exports$14;
  _dewExec$12 = true;
  exports$14 = PassThrough2;
  var Transform2 = dew$22();
  dew$f()(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2))
      return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$14;
}
var exports5 = {};
var _dewExec5 = false;
function dew5() {
  if (_dewExec5)
    return exports5;
  _dewExec5 = true;
  var eos;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop3(err) {
    if (err)
      throw err;
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$6();
    eos(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream2))
        return stream2.abort();
      if (typeof stream2.destroy === "function")
        return stream2.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop3;
    if (typeof streams[streams.length - 1] !== "function")
      return noop3;
    return streams.pop();
  }
  function pipeline2() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream2, i7) {
      var reading = i7 < streams.length - 1;
      var writing = i7 > 0;
      return destroyer(stream2, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports5 = pipeline2;
  return exports5;
}

// node_modules/@jspm/core/nodelibs/browser/stream.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var exports$15 = {};
var _dewExec6 = false;
var _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew6() {
  if (_dewExec6)
    return exports$15;
  _dewExec6 = true;
  exports$15 = Stream2;
  var EE = y.EventEmitter;
  var inherits4 = dew$f();
  inherits4(Stream2, EE);
  Stream2.Readable = dew$3();
  Stream2.Writable = dew$8();
  Stream2.Duplex = dew$7();
  Stream2.Transform = dew$22();
  Stream2.PassThrough = dew$12();
  Stream2.finished = dew$6();
  Stream2.pipeline = dew5();
  Stream2.Stream = Stream2;
  function Stream2() {
    EE.call(this || _global4);
  }
  Stream2.prototype.pipe = function(dest, options) {
    var source = this || _global4;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global4, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$15;
}
var exports6 = dew6();

// node_modules/@jspm/core/nodelibs/browser/util.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var _extend2 = X._extend;
var callbackify2 = X.callbackify;
var debuglog2 = X.debuglog;
var deprecate2 = X.deprecate;
var format3 = X.format;
var inherits3 = X.inherits;
var inspect2 = X.inspect;
var isArray3 = X.isArray;
var isBoolean3 = X.isBoolean;
var isBuffer3 = X.isBuffer;
var isDate3 = X.isDate;
var isError2 = X.isError;
var isFunction3 = X.isFunction;
var isNull2 = X.isNull;
var isNullOrUndefined2 = X.isNullOrUndefined;
var isNumber3 = X.isNumber;
var isObject3 = X.isObject;
var isPrimitive2 = X.isPrimitive;
var isRegExp3 = X.isRegExp;
var isString4 = X.isString;
var isSymbol2 = X.isSymbol;
var isUndefined3 = X.isUndefined;
var log2 = X.log;
var promisify2 = X.promisify;
var types2 = X.types;
var TextEncoder2 = X.TextEncoder = globalThis.TextEncoder;
var TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;

// node_modules/@jspm/core/nodelibs/browser/stream.js
var Readable = exports6.Readable;
Readable.wrap = function(src, options) {
  options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
  options.destroy = function(err, callback) {
    src.destroy(err);
    callback(err);
  };
  return new Readable(options).wrap(src);
};
var Writable = exports6.Writable;
var Duplex = exports6.Duplex;
var Transform = exports6.Transform;
var PassThrough = exports6.PassThrough;
var finished = exports6.finished;
var pipeline = exports6.pipeline;
var Stream = exports6.Stream;
var promises = {
  finished: promisify2(exports6.finished),
  pipeline: promisify2(exports6.pipeline)
};

// node_modules/@jspm/core/nodelibs/browser/assert.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function e5(e9, r9) {
  if (null == e9)
    throw new TypeError("Cannot convert first argument to object");
  for (var t8 = Object(e9), n8 = 1; n8 < arguments.length; n8++) {
    var o8 = arguments[n8];
    if (null != o8)
      for (var a7 = Object.keys(Object(o8)), l7 = 0, i7 = a7.length; l7 < i7; l7++) {
        var c7 = a7[l7], b5 = Object.getOwnPropertyDescriptor(o8, c7);
        void 0 !== b5 && b5.enumerable && (t8[c7] = o8[c7]);
      }
  }
  return t8;
}
var r5 = { assign: e5, polyfill: function() {
  Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e5 });
} };
var t5;
var e$13 = Object.prototype.toString;
var r$12 = function(t8) {
  var r9 = e$13.call(t8), n8 = "[object Arguments]" === r9;
  return n8 || (n8 = "[object Array]" !== r9 && null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Function]" === e$13.call(t8.callee)), n8;
};
if (!Object.keys) {
  n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a7 = l7.call(function() {
  }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t8) {
    var e9 = t8.constructor;
    return e9 && e9.prototype === t8;
  }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
    if ("undefined" == typeof window)
      return false;
    for (var t8 in window)
      try {
        if (!p7["$" + t8] && n8.call(window, t8) && null !== window[t8] && "object" == typeof window[t8])
          try {
            f7(window[t8]);
          } catch (t9) {
            return true;
          }
      } catch (t9) {
        return true;
      }
    return false;
  }();
  t5 = function(t8) {
    var e9 = null !== t8 && "object" == typeof t8, r9 = "[object Function]" === o8.call(t8), l8 = c7(t8), p8 = e9 && "[object String]" === o8.call(t8), y6 = [];
    if (!e9 && !r9 && !l8)
      throw new TypeError("Object.keys called on a non-object");
    var b5 = a7 && r9;
    if (p8 && t8.length > 0 && !n8.call(t8, 0))
      for (var g5 = 0; g5 < t8.length; ++g5)
        y6.push(String(g5));
    if (l8 && t8.length > 0)
      for (var h8 = 0; h8 < t8.length; ++h8)
        y6.push(String(h8));
    else
      for (var $3 in t8)
        b5 && "prototype" === $3 || !n8.call(t8, $3) || y6.push(String($3));
    if (i7)
      for (var j4 = function(t9) {
        if ("undefined" == typeof window || !s6)
          return f7(t9);
        try {
          return f7(t9);
        } catch (t10) {
          return false;
        }
      }(t8), w4 = 0; w4 < u7.length; ++w4)
        j4 && "constructor" === u7[w4] || !n8.call(t8, u7[w4]) || y6.push(u7[w4]);
    return y6;
  };
}
var n8;
var o8;
var c7;
var l7;
var i7;
var a7;
var u7;
var f7;
var p7;
var s6;
var y4 = t5;
var b3 = Array.prototype.slice;
var g3 = r$12;
var h5 = Object.keys;
var $2 = h5 ? function(t8) {
  return h5(t8);
} : y4;
var j3 = Object.keys;
$2.shim = function() {
  Object.keys ? function() {
    var t8 = Object.keys(arguments);
    return t8 && t8.length === arguments.length;
  }(1, 2) || (Object.keys = function(t8) {
    return g3(t8) ? j3(b3.call(t8)) : j3(t8);
  }) : Object.keys = $2;
  return Object.keys || $2;
};
var w3 = $2;
var r$2 = w3;
var e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
var o$13 = Object.prototype.toString;
var n$13 = Array.prototype.concat;
var a$1 = Object.defineProperty;
var c$13 = a$1 && function() {
  var t8 = {};
  try {
    for (var r9 in a$1(t8, "x", { enumerable: false, value: t8 }), t8)
      return false;
    return t8.x === t8;
  } catch (t9) {
    return false;
  }
}();
var l$13 = function(t8, r9, e9, n8) {
  var l7;
  (!(r9 in t8) || "function" == typeof (l7 = n8) && "[object Function]" === o$13.call(l7) && n8()) && (c$13 ? a$1(t8, r9, { configurable: true, enumerable: false, value: e9, writable: true }) : t8[r9] = e9);
};
var u$13 = function(t8, o8) {
  var a7 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o8);
  e$2 && (c7 = n$13.call(c7, Object.getOwnPropertySymbols(o8)));
  for (var u7 = 0; u7 < c7.length; u7 += 1)
    l$13(t8, c7[u7], o8[c7[u7]], a7[c7[u7]]);
};
u$13.supportsDescriptors = !!c$13;
var f$12 = u$13;
var t$12 = function() {
  if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
    return false;
  if ("symbol" == typeof Symbol.iterator)
    return true;
  var t8 = {}, e9 = Symbol("test"), r9 = Object(e9);
  if ("string" == typeof e9)
    return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(e9))
    return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(r9))
    return false;
  for (e9 in t8[e9] = 42, t8)
    return false;
  if ("function" == typeof Object.keys && 0 !== Object.keys(t8).length)
    return false;
  if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t8).length)
    return false;
  var o8 = Object.getOwnPropertySymbols(t8);
  if (1 !== o8.length || o8[0] !== e9)
    return false;
  if (!Object.prototype.propertyIsEnumerable.call(t8, e9))
    return false;
  if ("function" == typeof Object.getOwnPropertyDescriptor) {
    var n8 = Object.getOwnPropertyDescriptor(t8, e9);
    if (42 !== n8.value || true !== n8.enumerable)
      return false;
  }
  return true;
};
var f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
var e$3 = t$12;
var l$2 = function() {
  return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
};
var t$22 = "Function.prototype.bind called on incompatible ";
var n$2 = Array.prototype.slice;
var o$22 = Object.prototype.toString;
var r$3 = function(r9) {
  var e9 = this;
  if ("function" != typeof e9 || "[object Function]" !== o$22.call(e9))
    throw new TypeError(t$22 + e9);
  for (var p7, i7 = n$2.call(arguments, 1), c7 = function() {
    if (this instanceof p7) {
      var t8 = e9.apply(this, i7.concat(n$2.call(arguments)));
      return Object(t8) === t8 ? t8 : this;
    }
    return e9.apply(r9, i7.concat(n$2.call(arguments)));
  }, a7 = Math.max(0, e9.length - i7.length), l7 = [], u7 = 0; u7 < a7; u7++)
    l7.push("$" + u7);
  if (p7 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c7), e9.prototype) {
    var y6 = function() {
    };
    y6.prototype = e9.prototype, p7.prototype = new y6(), y6.prototype = null;
  }
  return p7;
};
var e$4 = Function.prototype.bind || r$3;
var o$3 = TypeError;
var t$3 = Object.getOwnPropertyDescriptor;
if (t$3)
  try {
    t$3({}, "");
  } catch (r9) {
    t$3 = null;
  }
var n$3 = function() {
  throw new o$3();
};
var y$1 = t$3 ? function() {
  try {
    return arguments.callee, n$3;
  } catch (r9) {
    try {
      return t$3(arguments, "callee").get;
    } catch (r10) {
      return n$3;
    }
  }
}() : n$3;
var a$22 = l$2();
var i$13 = Object.getPrototypeOf || function(r9) {
  return r9.__proto__;
};
var d4 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
var f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d4, "%TypedArrayPrototype%": d4 ? d4.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
var u$22 = e$4.call(Function.call, String.prototype.replace);
var A3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var l$3 = /\\(\\)?/g;
var v5 = function(r9) {
  var e9 = [];
  return u$22(r9, A3, function(r10, o8, t8, n8) {
    e9[e9.length] = t8 ? u$22(n8, l$3, "$1") : o8 || r10;
  }), e9;
};
var P3 = function(r9, e9) {
  if (!(r9 in f$3))
    throw new SyntaxError("intrinsic " + r9 + " does not exist!");
  if (void 0 === f$3[r9] && !e9)
    throw new o$3("intrinsic " + r9 + " exists, but is not available. Please file an issue!");
  return f$3[r9];
};
var c$2 = function(r9, e9) {
  if ("string" != typeof r9 || 0 === r9.length)
    throw new TypeError("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && "boolean" != typeof e9)
    throw new TypeError('"allowMissing" argument must be a boolean');
  for (var n8 = v5(r9), y6 = P3("%" + (n8.length > 0 ? n8[0] : "") + "%", e9), a7 = 1; a7 < n8.length; a7 += 1)
    if (null != y6)
      if (t$3 && a7 + 1 >= n8.length) {
        var i7 = t$3(y6, n8[a7]);
        if (!e9 && !(n8[a7] in y6))
          throw new o$3("base intrinsic for " + r9 + " exists, but the property is not available.");
        y6 = i7 ? i7.get || i7.value : y6[n8[a7]];
      } else
        y6 = y6[n8[a7]];
  return y6;
};
var t$4;
var p$1 = e$4;
var o$4 = c$2("%Function%");
var i$2 = o$4.apply;
var a$3 = o$4.call;
(t$4 = function() {
  return p$1.apply(a$3, arguments);
}).apply = function() {
  return p$1.apply(i$2, arguments);
};
var l$4 = t$4;
var r$4;
var n$4;
var i$3 = function(t8) {
  return t8 != t8;
};
var o$5 = (r$4 = function(t8, e9) {
  return 0 === t8 && 0 === e9 ? 1 / t8 == 1 / e9 : t8 === e9 || !(!i$3(t8) || !i$3(e9));
}, r$4);
var c$3 = (n$4 = function() {
  return "function" == typeof Object.is ? Object.is : o$5;
}, n$4);
var f$4 = f$12;
var u$3 = f$12;
var s$12 = r$4;
var a$4 = n$4;
var l$5 = function() {
  var t8 = c$3();
  return f$4(Object, { is: t8 }, { is: function() {
    return Object.is !== t8;
  } }), t8;
};
var p$2 = l$4(a$4(), Object);
u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
var m4 = p$2;
N3 = function(r9) {
  return r9 != r9;
};
var N3;
var e$5;
var i$4 = N3;
var n$5 = (e$5 = function() {
  return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
}, f$12);
var t$5 = e$5;
var u$4 = f$12;
var a$5 = N3;
var m$1 = e$5;
var o$6 = function() {
  var r9 = t$5();
  return n$5(Number, { isNaN: r9 }, { isNaN: function() {
    return Number.isNaN !== r9;
  } }), r9;
};
var s$2 = m$1();
u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
var f$5 = s$2;
var c$4 = {};
var a$6 = false;
function i$5() {
  if (a$6)
    return c$4;
  function e9(t8) {
    return (e9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  function n8(t8, n9) {
    return !n9 || "object" !== e9(n9) && "function" != typeof n9 ? function(t9) {
      if (void 0 === t9)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t9;
    }(t8) : n9;
  }
  function r9(t8) {
    return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
      return t9.__proto__ || Object.getPrototypeOf(t9);
    })(t8);
  }
  function o8(t8, e10) {
    return (o8 = Object.setPrototypeOf || function(t9, e11) {
      return t9.__proto__ = e11, t9;
    })(t8, e10);
  }
  a$6 = true;
  var i7, u7, l7 = {};
  function f7(t8, e10, c7) {
    c7 || (c7 = Error);
    var a7 = function(c8) {
      function a8(o9, c9, i8) {
        var u8;
        return !function(t9, e11) {
          if (!(t9 instanceof e11))
            throw new TypeError("Cannot call a class as a function");
        }(this, a8), (u8 = n8(this, r9(a8).call(this, function(t9, n9, r10) {
          return "string" == typeof e10 ? e10 : e10(t9, n9, r10);
        }(o9, c9, i8)))).code = t8, u8;
      }
      return !function(t9, e11) {
        if ("function" != typeof e11 && null !== e11)
          throw new TypeError("Super expression must either be null or a function");
        t9.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e11 && o8(t9, e11);
      }(a8, c8), a8;
    }(c7);
    l7[t8] = a7;
  }
  function s6(t8, e10) {
    if (Array.isArray(t8)) {
      var n9 = t8.length;
      return t8 = t8.map(function(t9) {
        return String(t9);
      }), n9 > 2 ? "one of ".concat(e10, " ").concat(t8.slice(0, n9 - 1).join(", "), ", or ") + t8[n9 - 1] : 2 === n9 ? "one of ".concat(e10, " ").concat(t8[0], " or ").concat(t8[1]) : "of ".concat(e10, " ").concat(t8[0]);
    }
    return "of ".concat(e10, " ").concat(String(t8));
  }
  return f7("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f7("ERR_INVALID_ARG_TYPE", function(t8, n9, r10) {
    var o9, c7, u8;
    if (void 0 === i7 && (i7 = tt()), i7("string" == typeof t8, "'name' must be a string"), "string" == typeof n9 && (c7 = "not ", n9.substr(0, c7.length) === c7) ? (o9 = "must not be", n9 = n9.replace(/^not /, "")) : o9 = "must be", function(t9, e10, n10) {
      return (void 0 === n10 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
    }(t8, " argument"))
      u8 = "The ".concat(t8, " ").concat(o9, " ").concat(s6(n9, "type"));
    else {
      var l8 = function(t9, e10, n10) {
        return "number" != typeof n10 && (n10 = 0), !(n10 + e10.length > t9.length) && -1 !== t9.indexOf(e10, n10);
      }(t8, ".") ? "property" : "argument";
      u8 = 'The "'.concat(t8, '" ').concat(l8, " ").concat(o9, " ").concat(s6(n9, "type"));
    }
    return u8 += ". Received type ".concat(e9(r10));
  }, TypeError), f7("ERR_INVALID_ARG_VALUE", function(e10, n9) {
    var r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u7 && (u7 = X);
    var o9 = u7.inspect(n9);
    return o9.length > 128 && (o9 = "".concat(o9.slice(0, 128), "...")), "The argument '".concat(e10, "' ").concat(r10, ". Received ").concat(o9);
  }, TypeError), f7("ERR_INVALID_RETURN_VALUE", function(t8, n9, r10) {
    var o9;
    return o9 = r10 && r10.constructor && r10.constructor.name ? "instance of ".concat(r10.constructor.name) : "type ".concat(e9(r10)), "Expected ".concat(t8, ' to be returned from the "').concat(n9, '"') + " function but got ".concat(o9, ".");
  }, TypeError), f7("ERR_MISSING_ARGS", function() {
    for (var t8 = arguments.length, e10 = new Array(t8), n9 = 0; n9 < t8; n9++)
      e10[n9] = arguments[n9];
    void 0 === i7 && (i7 = tt()), i7(e10.length > 0, "At least one arg needs to be specified");
    var r10 = "The ", o9 = e10.length;
    switch (e10 = e10.map(function(t9) {
      return '"'.concat(t9, '"');
    }), o9) {
      case 1:
        r10 += "".concat(e10[0], " argument");
        break;
      case 2:
        r10 += "".concat(e10[0], " and ").concat(e10[1], " arguments");
        break;
      default:
        r10 += e10.slice(0, o9 - 1).join(", "), r10 += ", and ".concat(e10[o9 - 1], " arguments");
    }
    return "".concat(r10, " must be specified");
  }, TypeError), c$4.codes = l7, c$4;
}
var u$5 = {};
var l$6 = false;
function f$6() {
  if (l$6)
    return u$5;
  l$6 = true;
  var n8 = T;
  function r9(t8, e9, n9) {
    return e9 in t8 ? Object.defineProperty(t8, e9, { value: n9, enumerable: true, configurable: true, writable: true }) : t8[e9] = n9, t8;
  }
  function o8(t8, e9) {
    for (var n9 = 0; n9 < e9.length; n9++) {
      var r10 = e9[n9];
      r10.enumerable = r10.enumerable || false, r10.configurable = true, "value" in r10 && (r10.writable = true), Object.defineProperty(t8, r10.key, r10);
    }
  }
  function c7(t8, e9) {
    return !e9 || "object" !== y6(e9) && "function" != typeof e9 ? a7(t8) : e9;
  }
  function a7(t8) {
    if (void 0 === t8)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t8;
  }
  function f7(t8) {
    var e9 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f7 = function(t9) {
      if (null === t9 || (n9 = t9, -1 === Function.toString.call(n9).indexOf("[native code]")))
        return t9;
      var n9;
      if ("function" != typeof t9)
        throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e9) {
        if (e9.has(t9))
          return e9.get(t9);
        e9.set(t9, r10);
      }
      function r10() {
        return p7(t9, arguments, h8(this).constructor);
      }
      return r10.prototype = Object.create(t9.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), g5(r10, t9);
    })(t8);
  }
  function s6() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t8) {
      return false;
    }
  }
  function p7(t8, e9, n9) {
    return (p7 = s6() ? Reflect.construct : function(t9, e10, n10) {
      var r10 = [null];
      r10.push.apply(r10, e10);
      var o9 = new (Function.bind.apply(t9, r10))();
      return n10 && g5(o9, n10.prototype), o9;
    }).apply(null, arguments);
  }
  function g5(t8, e9) {
    return (g5 = Object.setPrototypeOf || function(t9, e10) {
      return t9.__proto__ = e10, t9;
    })(t8, e9);
  }
  function h8(t8) {
    return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
      return t9.__proto__ || Object.getPrototypeOf(t9);
    })(t8);
  }
  function y6(t8) {
    return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  var b5 = X.inspect, v7 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d6(t8, e9, n9) {
    return (void 0 === n9 || n9 > t8.length) && (n9 = t8.length), t8.substring(n9 - e9.length, n9) === e9;
  }
  var m6 = "", E4 = "", w4 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O5(t8) {
    var e9 = Object.keys(t8), n9 = Object.create(Object.getPrototypeOf(t8));
    return e9.forEach(function(e10) {
      n9[e10] = t8[e10];
    }), Object.defineProperty(n9, "message", { value: t8.message }), n9;
  }
  function x4(t8) {
    return b5(t8, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q3(t8, e9, r10) {
    var o9 = "", c8 = "", a8 = 0, i7 = "", u7 = false, l7 = x4(t8), f8 = l7.split("\n"), s7 = x4(e9).split("\n"), p8 = 0, g6 = "";
    if ("strictEqual" === r10 && "object" === y6(t8) && "object" === y6(e9) && null !== t8 && null !== e9 && (r10 = "strictEqualObject"), 1 === f8.length && 1 === s7.length && f8[0] !== s7[0]) {
      var h9 = f8[0].length + s7[0].length;
      if (h9 <= 10) {
        if (!("object" === y6(t8) && null !== t8 || "object" === y6(e9) && null !== e9 || 0 === t8 && 0 === e9))
          return "".concat(j4[r10], "\n\n") + "".concat(f8[0], " !== ").concat(s7[0], "\n");
      } else if ("strictEqualObject" !== r10) {
        if (h9 < (n8.stderr && n8.stderr.isTTY ? n8.stderr.columns : 80)) {
          for (; f8[0][p8] === s7[0][p8]; )
            p8++;
          p8 > 2 && (g6 = "\n  ".concat(function(t9, e10) {
            if (e10 = Math.floor(e10), 0 == t9.length || 0 == e10)
              return "";
            var n9 = t9.length * e10;
            for (e10 = Math.floor(Math.log(e10) / Math.log(2)); e10; )
              t9 += t9, e10--;
            return t9 += t9.substring(0, n9 - t9.length);
          }(" ", p8), "^"), p8 = 0);
        }
      }
    }
    for (var b6 = f8[f8.length - 1], v8 = s7[s7.length - 1]; b6 === v8 && (p8++ < 2 ? i7 = "\n  ".concat(b6).concat(i7) : o9 = b6, f8.pop(), s7.pop(), 0 !== f8.length && 0 !== s7.length); )
      b6 = f8[f8.length - 1], v8 = s7[s7.length - 1];
    var O6 = Math.max(f8.length, s7.length);
    if (0 === O6) {
      var q4 = l7.split("\n");
      if (q4.length > 30)
        for (q4[26] = "".concat(m6, "...").concat(S4); q4.length > 27; )
          q4.pop();
      return "".concat(j4.notIdentical, "\n\n").concat(q4.join("\n"), "\n");
    }
    p8 > 3 && (i7 = "\n".concat(m6, "...").concat(S4).concat(i7), u7 = true), "" !== o9 && (i7 = "\n  ".concat(o9).concat(i7), o9 = "");
    var R5 = 0, A4 = j4[r10] + "\n".concat(E4, "+ actual").concat(S4, " ").concat(w4, "- expected").concat(S4), k4 = " ".concat(m6, "...").concat(S4, " Lines skipped");
    for (p8 = 0; p8 < O6; p8++) {
      var _4 = p8 - a8;
      if (f8.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(s7[p8 - 2]), R5++), c8 += "\n  ".concat(s7[p8 - 1]), R5++), a8 = p8, o9 += "\n".concat(w4, "-").concat(S4, " ").concat(s7[p8]), R5++;
      else if (s7.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(f8[p8]), R5++;
      else {
        var T5 = s7[p8], P4 = f8[p8], I4 = P4 !== T5 && (!d6(P4, ",") || P4.slice(0, -1) !== T5);
        I4 && d6(T5, ",") && T5.slice(0, -1) === P4 && (I4 = false, P4 += ","), I4 ? (_4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(P4), o9 += "\n".concat(w4, "-").concat(S4, " ").concat(T5), R5 += 2) : (c8 += o9, o9 = "", 1 !== _4 && 0 !== p8 || (c8 += "\n  ".concat(P4), R5++));
      }
      if (R5 > 20 && p8 < O6 - 2)
        return "".concat(A4).concat(k4, "\n").concat(c8, "\n").concat(m6, "...").concat(S4).concat(o9, "\n") + "".concat(m6, "...").concat(S4);
    }
    return "".concat(A4).concat(u7 ? k4 : "", "\n").concat(c8).concat(o9).concat(i7).concat(g6);
  }
  var R4 = function(t8) {
    function e9(t9) {
      var r10;
      if (!function(t10, e10) {
        if (!(t10 instanceof e10))
          throw new TypeError("Cannot call a class as a function");
      }(this, e9), "object" !== y6(t9) || null === t9)
        throw new v7("options", "Object", t9);
      var o9 = t9.message, i8 = t9.operator, u8 = t9.stackStartFn, l7 = t9.actual, f8 = t9.expected, s7 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o9)
        r10 = c7(this, h8(e9).call(this, String(o9)));
      else if (n8.stderr && n8.stderr.isTTY && (n8.stderr && n8.stderr.getColorDepth && 1 !== n8.stderr.getColorDepth() ? (m6 = "\x1B[34m", E4 = "\x1B[32m", S4 = "\x1B[39m", w4 = "\x1B[31m") : (m6 = "", E4 = "", S4 = "", w4 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f8) && null !== f8 && "stack" in l7 && l7 instanceof Error && "stack" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), "deepStrictEqual" === i8 || "strictEqual" === i8)
        r10 = c7(this, h8(e9).call(this, q3(l7, f8, i8)));
      else if ("notDeepStrictEqual" === i8 || "notStrictEqual" === i8) {
        var p8 = j4[i8], g6 = x4(l7).split("\n");
        if ("notStrictEqual" === i8 && "object" === y6(l7) && null !== l7 && (p8 = j4.notStrictEqualObject), g6.length > 30)
          for (g6[26] = "".concat(m6, "...").concat(S4); g6.length > 27; )
            g6.pop();
        r10 = 1 === g6.length ? c7(this, h8(e9).call(this, "".concat(p8, " ").concat(g6[0]))) : c7(this, h8(e9).call(this, "".concat(p8, "\n\n").concat(g6.join("\n"), "\n")));
      } else {
        var b6 = x4(l7), d7 = "", R5 = j4[i8];
        "notDeepEqual" === i8 || "notEqual" === i8 ? (b6 = "".concat(j4[i8], "\n\n").concat(b6)).length > 1024 && (b6 = "".concat(b6.slice(0, 1021), "...")) : (d7 = "".concat(x4(f8)), b6.length > 512 && (b6 = "".concat(b6.slice(0, 509), "...")), d7.length > 512 && (d7 = "".concat(d7.slice(0, 509), "...")), "deepEqual" === i8 || "equal" === i8 ? b6 = "".concat(R5, "\n\n").concat(b6, "\n\nshould equal\n\n") : d7 = " ".concat(i8, " ").concat(d7)), r10 = c7(this, h8(e9).call(this, "".concat(b6).concat(d7)));
      }
      return Error.stackTraceLimit = s7, r10.generatedMessage = !o9, Object.defineProperty(a7(r10), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r10.code = "ERR_ASSERTION", r10.actual = l7, r10.expected = f8, r10.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a7(r10), u8), r10.stack, r10.name = "AssertionError", c7(r10);
    }
    var i7, u7;
    return !function(t9, e10) {
      if ("function" != typeof e10 && null !== e10)
        throw new TypeError("Super expression must either be null or a function");
      t9.prototype = Object.create(e10 && e10.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e10 && g5(t9, e10);
    }(e9, t8), i7 = e9, (u7 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b5.custom, value: function(t9, e10) {
      return b5(this, function(t10) {
        for (var e11 = 1; e11 < arguments.length; e11++) {
          var n9 = null != arguments[e11] ? arguments[e11] : {}, o9 = Object.keys(n9);
          "function" == typeof Object.getOwnPropertySymbols && (o9 = o9.concat(Object.getOwnPropertySymbols(n9).filter(function(t11) {
            return Object.getOwnPropertyDescriptor(n9, t11).enumerable;
          }))), o9.forEach(function(e12) {
            r9(t10, e12, n9[e12]);
          });
        }
        return t10;
      }({}, e10, { customInspect: false, depth: 0 }));
    } }]) && o8(i7.prototype, u7), e9;
  }(f7(Error));
  return u$5 = R4;
}
function s$3(t8, e9) {
  return function(t9) {
    if (Array.isArray(t9))
      return t9;
  }(t8) || function(t9, e10) {
    var n8 = [], r9 = true, o8 = false, c7 = void 0;
    try {
      for (var a7, i7 = t9[Symbol.iterator](); !(r9 = (a7 = i7.next()).done) && (n8.push(a7.value), !e10 || n8.length !== e10); r9 = true)
        ;
    } catch (t10) {
      o8 = true, c7 = t10;
    } finally {
      try {
        r9 || null == i7.return || i7.return();
      } finally {
        if (o8)
          throw c7;
      }
    }
    return n8;
  }(t8, e9) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t8) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
    return typeof t9;
  } : function(t9) {
    return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
  })(t8);
}
var g$1 = void 0 !== /a/g.flags;
var h$1 = function(t8) {
  var e9 = [];
  return t8.forEach(function(t9) {
    return e9.push(t9);
  }), e9;
};
var y$2 = function(t8) {
  var e9 = [];
  return t8.forEach(function(t9, n8) {
    return e9.push([n8, t9]);
  }), e9;
};
var b$1 = Object.is ? Object.is : m4;
var v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var d$1 = Number.isNaN ? Number.isNaN : f$5;
function m$2(t8) {
  return t8.call.bind(t8);
}
var E3 = m$2(Object.prototype.hasOwnProperty);
var w$1 = m$2(Object.prototype.propertyIsEnumerable);
var S3 = m$2(Object.prototype.toString);
var j$1 = X.types;
var O3 = j$1.isAnyArrayBuffer;
var x3 = j$1.isArrayBufferView;
var q2 = j$1.isDate;
var R3 = j$1.isMap;
var A$1 = j$1.isRegExp;
var k3 = j$1.isSet;
var _3 = j$1.isNativeError;
var T4 = j$1.isBoxedPrimitive;
var P$1 = j$1.isNumberObject;
var I3 = j$1.isStringObject;
var D3 = j$1.isBooleanObject;
var F3 = j$1.isBigIntObject;
var N$1 = j$1.isSymbolObject;
var L3 = j$1.isFloat32Array;
var M3 = j$1.isFloat64Array;
function U3(t8) {
  if (0 === t8.length || t8.length > 10)
    return true;
  for (var e9 = 0; e9 < t8.length; e9++) {
    var n8 = t8.charCodeAt(e9);
    if (n8 < 48 || n8 > 57)
      return true;
  }
  return 10 === t8.length && t8 >= Math.pow(2, 32);
}
function G2(t8) {
  return Object.keys(t8).filter(U3).concat(v$1(t8).filter(Object.prototype.propertyIsEnumerable.bind(t8)));
}
function V2(t8, e9) {
  if (t8 === e9)
    return 0;
  for (var n8 = t8.length, r9 = e9.length, o8 = 0, c7 = Math.min(n8, r9); o8 < c7; ++o8)
    if (t8[o8] !== e9[o8]) {
      n8 = t8[o8], r9 = e9[o8];
      break;
    }
  return n8 < r9 ? -1 : r9 < n8 ? 1 : 0;
}
function B3(t8, e9, n8, r9) {
  if (t8 === e9)
    return 0 !== t8 || (!n8 || b$1(t8, e9));
  if (n8) {
    if ("object" !== p$3(t8))
      return "number" == typeof t8 && d$1(t8) && d$1(e9);
    if ("object" !== p$3(e9) || null === t8 || null === e9)
      return false;
    if (Object.getPrototypeOf(t8) !== Object.getPrototypeOf(e9))
      return false;
  } else {
    if (null === t8 || "object" !== p$3(t8))
      return (null === e9 || "object" !== p$3(e9)) && t8 == e9;
    if (null === e9 || "object" !== p$3(e9))
      return false;
  }
  var o8, c7, a7, i7, u7 = S3(t8);
  if (u7 !== S3(e9))
    return false;
  if (Array.isArray(t8)) {
    if (t8.length !== e9.length)
      return false;
    var l7 = G2(t8), f7 = G2(e9);
    return l7.length === f7.length && C3(t8, e9, n8, r9, 1, l7);
  }
  if ("[object Object]" === u7 && (!R3(t8) && R3(e9) || !k3(t8) && k3(e9)))
    return false;
  if (q2(t8)) {
    if (!q2(e9) || Date.prototype.getTime.call(t8) !== Date.prototype.getTime.call(e9))
      return false;
  } else if (A$1(t8)) {
    if (!A$1(e9) || (a7 = t8, i7 = e9, !(g$1 ? a7.source === i7.source && a7.flags === i7.flags : RegExp.prototype.toString.call(a7) === RegExp.prototype.toString.call(i7))))
      return false;
  } else if (_3(t8) || t8 instanceof Error) {
    if (t8.message !== e9.message || t8.name !== e9.name)
      return false;
  } else {
    if (x3(t8)) {
      if (n8 || !L3(t8) && !M3(t8)) {
        if (!function(t9, e10) {
          return t9.byteLength === e10.byteLength && 0 === V2(new Uint8Array(t9.buffer, t9.byteOffset, t9.byteLength), new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength));
        }(t8, e9))
          return false;
      } else if (!function(t9, e10) {
        if (t9.byteLength !== e10.byteLength)
          return false;
        for (var n9 = 0; n9 < t9.byteLength; n9++)
          if (t9[n9] !== e10[n9])
            return false;
        return true;
      }(t8, e9))
        return false;
      var s6 = G2(t8), h8 = G2(e9);
      return s6.length === h8.length && C3(t8, e9, n8, r9, 0, s6);
    }
    if (k3(t8))
      return !(!k3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 2);
    if (R3(t8))
      return !(!R3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 3);
    if (O3(t8)) {
      if (c7 = e9, (o8 = t8).byteLength !== c7.byteLength || 0 !== V2(new Uint8Array(o8), new Uint8Array(c7)))
        return false;
    } else if (T4(t8) && !function(t9, e10) {
      return P$1(t9) ? P$1(e10) && b$1(Number.prototype.valueOf.call(t9), Number.prototype.valueOf.call(e10)) : I3(t9) ? I3(e10) && String.prototype.valueOf.call(t9) === String.prototype.valueOf.call(e10) : D3(t9) ? D3(e10) && Boolean.prototype.valueOf.call(t9) === Boolean.prototype.valueOf.call(e10) : F3(t9) ? F3(e10) && BigInt.prototype.valueOf.call(t9) === BigInt.prototype.valueOf.call(e10) : N$1(e10) && Symbol.prototype.valueOf.call(t9) === Symbol.prototype.valueOf.call(e10);
    }(t8, e9))
      return false;
  }
  return C3(t8, e9, n8, r9, 0);
}
function z3(t8, e9) {
  return e9.filter(function(e10) {
    return w$1(t8, e10);
  });
}
function C3(t8, e9, n8, r9, o8, c7) {
  if (5 === arguments.length) {
    c7 = Object.keys(t8);
    var a7 = Object.keys(e9);
    if (c7.length !== a7.length)
      return false;
  }
  for (var i7 = 0; i7 < c7.length; i7++)
    if (!E3(e9, c7[i7]))
      return false;
  if (n8 && 5 === arguments.length) {
    var u7 = v$1(t8);
    if (0 !== u7.length) {
      var l7 = 0;
      for (i7 = 0; i7 < u7.length; i7++) {
        var f7 = u7[i7];
        if (w$1(t8, f7)) {
          if (!w$1(e9, f7))
            return false;
          c7.push(f7), l7++;
        } else if (w$1(e9, f7))
          return false;
      }
      var s6 = v$1(e9);
      if (u7.length !== s6.length && z3(e9, s6).length !== l7)
        return false;
    } else {
      var p7 = v$1(e9);
      if (0 !== p7.length && 0 !== z3(e9, p7).length)
        return false;
    }
  }
  if (0 === c7.length && (0 === o8 || 1 === o8 && 0 === t8.length || 0 === t8.size))
    return true;
  if (void 0 === r9)
    r9 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g5 = r9.val1.get(t8);
    if (void 0 !== g5) {
      var h8 = r9.val2.get(e9);
      if (void 0 !== h8)
        return g5 === h8;
    }
    r9.position++;
  }
  r9.val1.set(t8, r9.position), r9.val2.set(e9, r9.position);
  var y6 = Q2(t8, e9, n8, c7, r9, o8);
  return r9.val1.delete(t8), r9.val2.delete(e9), y6;
}
function Y3(t8, e9, n8, r9) {
  for (var o8 = h$1(t8), c7 = 0; c7 < o8.length; c7++) {
    var a7 = o8[c7];
    if (B3(e9, a7, n8, r9))
      return t8.delete(a7), true;
  }
  return false;
}
function W2(t8) {
  switch (p$3(t8)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t8 = +t8;
    case "number":
      if (d$1(t8))
        return false;
  }
  return true;
}
function H2(t8, e9, n8) {
  var r9 = W2(n8);
  return null != r9 ? r9 : e9.has(r9) && !t8.has(r9);
}
function J2(t8, e9, n8, r9, o8) {
  var c7 = W2(n8);
  if (null != c7)
    return c7;
  var a7 = e9.get(c7);
  return !(void 0 === a7 && !e9.has(c7) || !B3(r9, a7, false, o8)) && (!t8.has(c7) && B3(r9, a7, false, o8));
}
function K2(t8, e9, n8, r9, o8, c7) {
  for (var a7 = h$1(t8), i7 = 0; i7 < a7.length; i7++) {
    var u7 = a7[i7];
    if (B3(n8, u7, o8, c7) && B3(r9, e9.get(u7), o8, c7))
      return t8.delete(u7), true;
  }
  return false;
}
function Q2(t8, e9, n8, r9, o8, c7) {
  var a7 = 0;
  if (2 === c7) {
    if (!function(t9, e10, n9, r10) {
      for (var o9 = null, c8 = h$1(t9), a8 = 0; a8 < c8.length; a8++) {
        var i8 = c8[a8];
        if ("object" === p$3(i8) && null !== i8)
          null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
        else if (!e10.has(i8)) {
          if (n9)
            return false;
          if (!H2(t9, e10, i8))
            return false;
          null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
        }
      }
      if (null !== o9) {
        for (var u8 = h$1(e10), l8 = 0; l8 < u8.length; l8++) {
          var f7 = u8[l8];
          if ("object" === p$3(f7) && null !== f7) {
            if (!Y3(o9, f7, n9, r10))
              return false;
          } else if (!n9 && !t9.has(f7) && !Y3(o9, f7, n9, r10))
            return false;
        }
        return 0 === o9.size;
      }
      return true;
    }(t8, e9, n8, o8))
      return false;
  } else if (3 === c7) {
    if (!function(t9, e10, n9, r10) {
      for (var o9 = null, c8 = y$2(t9), a8 = 0; a8 < c8.length; a8++) {
        var i8 = s$3(c8[a8], 2), u8 = i8[0], l8 = i8[1];
        if ("object" === p$3(u8) && null !== u8)
          null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
        else {
          var f7 = e10.get(u8);
          if (void 0 === f7 && !e10.has(u8) || !B3(l8, f7, n9, r10)) {
            if (n9)
              return false;
            if (!J2(t9, e10, u8, l8, r10))
              return false;
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
          }
        }
      }
      if (null !== o9) {
        for (var g5 = y$2(e10), h8 = 0; h8 < g5.length; h8++) {
          var b5 = s$3(g5[h8], 2), v7 = (u8 = b5[0], b5[1]);
          if ("object" === p$3(u8) && null !== u8) {
            if (!K2(o9, t9, u8, v7, n9, r10))
              return false;
          } else if (!(n9 || t9.has(u8) && B3(t9.get(u8), v7, false, r10) || K2(o9, t9, u8, v7, false, r10)))
            return false;
        }
        return 0 === o9.size;
      }
      return true;
    }(t8, e9, n8, o8))
      return false;
  } else if (1 === c7)
    for (; a7 < t8.length; a7++) {
      if (!E3(t8, a7)) {
        if (E3(e9, a7))
          return false;
        for (var i7 = Object.keys(t8); a7 < i7.length; a7++) {
          var u7 = i7[a7];
          if (!E3(e9, u7) || !B3(t8[u7], e9[u7], n8, o8))
            return false;
        }
        return i7.length === Object.keys(e9).length;
      }
      if (!E3(e9, a7) || !B3(t8[a7], e9[a7], n8, o8))
        return false;
    }
  for (a7 = 0; a7 < r9.length; a7++) {
    var l7 = r9[a7];
    if (!B3(t8[l7], e9[l7], n8, o8))
      return false;
  }
  return true;
}
var X2 = { isDeepEqual: function(t8, e9) {
  return B3(t8, e9, false);
}, isDeepStrictEqual: function(t8, e9) {
  return B3(t8, e9, true);
} };
var Z2 = {};
var $$1 = false;
function tt() {
  if ($$1)
    return Z2;
  $$1 = true;
  var o8 = T;
  function c7(t8) {
    return (c7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  var a7, u7, l7 = i$5().codes, s6 = l7.ERR_AMBIGUOUS_ARGUMENT, p7 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b5 = f$6(), v7 = X.inspect, d6 = X.types, m$12 = d6.isPromise, E4 = d6.isRegExp, w4 = Object.assign ? Object.assign : r5.assign, S4 = Object.is ? Object.is : m4;
  function j4() {
    a7 = X2.isDeepEqual, u7 = X2.isDeepStrictEqual;
  }
  var O5 = false, x4 = Z2 = k4, q3 = {};
  function R4(t8) {
    if (t8.message instanceof Error)
      throw t8.message;
    throw new b5(t8);
  }
  function A4(t8, e9, n8, r9) {
    if (!n8) {
      var o9 = false;
      if (0 === e9)
        o9 = true, r9 = "No value argument passed to `assert.ok()`";
      else if (r9 instanceof Error)
        throw r9;
      var c8 = new b5({ actual: n8, expected: true, message: r9, operator: "==", stackStartFn: t8 });
      throw c8.generatedMessage = o9, c8;
    }
  }
  function k4() {
    for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
      e9[n8] = arguments[n8];
    A4.apply(void 0, [k4, e9.length].concat(e9));
  }
  x4.fail = function t8(e9, n8, r9, c8, a8) {
    var i7, u8 = arguments.length;
    if (0 === u8)
      i7 = "Failed";
    else if (1 === u8)
      r9 = e9, e9 = void 0;
    else {
      if (false === O5) {
        O5 = true;
        var l8 = o8.emitWarning ? o8.emitWarning : console.warn.bind(console);
        l8("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u8 && (c8 = "!=");
    }
    if (r9 instanceof Error)
      throw r9;
    var f7 = { actual: e9, expected: n8, operator: void 0 === c8 ? "fail" : c8, stackStartFn: a8 || t8 };
    void 0 !== r9 && (f7.message = r9);
    var s7 = new b5(f7);
    throw i7 && (s7.message = i7, s7.generatedMessage = true), s7;
  }, x4.AssertionError = b5, x4.ok = k4, x4.equal = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    e9 != n8 && R4({ actual: e9, expected: n8, message: r9, operator: "==", stackStartFn: t8 });
  }, x4.notEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    e9 == n8 && R4({ actual: e9, expected: n8, message: r9, operator: "!=", stackStartFn: t8 });
  }, x4.deepEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), a7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepEqual", stackStartFn: t8 });
  }, x4.notDeepEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), a7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepEqual", stackStartFn: t8 });
  }, x4.deepStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), u7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepStrictEqual", stackStartFn: t8 });
  }, x4.notDeepStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4();
    u7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepStrictEqual", stackStartFn: t8 });
  }, x4.strictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    S4(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "strictEqual", stackStartFn: t8 });
  }, x4.notStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    S4(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notStrictEqual", stackStartFn: t8 });
  };
  var _4 = function t8(e9, n8, r9) {
    var o9 = this;
    !function(t9, e10) {
      if (!(t9 instanceof e10))
        throw new TypeError("Cannot call a class as a function");
    }(this, t8), n8.forEach(function(t9) {
      t9 in e9 && (void 0 !== r9 && "string" == typeof r9[t9] && E4(e9[t9]) && e9[t9].test(r9[t9]) ? o9[t9] = r9[t9] : o9[t9] = e9[t9]);
    });
  };
  function T5(t8, e9, n8, r9, o9, c8) {
    if (!(n8 in t8) || !u7(t8[n8], e9[n8])) {
      if (!r9) {
        var a8 = new _4(t8, o9), i7 = new _4(e9, o9, t8), l8 = new b5({ actual: a8, expected: i7, operator: "deepStrictEqual", stackStartFn: c8 });
        throw l8.actual = t8, l8.expected = e9, l8.operator = c8.name, l8;
      }
      R4({ actual: t8, expected: e9, message: r9, operator: c8.name, stackStartFn: c8 });
    }
  }
  function P4(t8, e9, n8, r9) {
    if ("function" != typeof e9) {
      if (E4(e9))
        return e9.test(t8);
      if (2 === arguments.length)
        throw new p7("expected", ["Function", "RegExp"], e9);
      if ("object" !== c7(t8) || null === t8) {
        var o9 = new b5({ actual: t8, expected: e9, message: n8, operator: "deepStrictEqual", stackStartFn: r9 });
        throw o9.operator = r9.name, o9;
      }
      var i7 = Object.keys(e9);
      if (e9 instanceof Error)
        i7.push("name", "message");
      else if (0 === i7.length)
        throw new g5("error", e9, "may not be an empty object");
      return void 0 === a7 && j4(), i7.forEach(function(o10) {
        "string" == typeof t8[o10] && E4(e9[o10]) && e9[o10].test(t8[o10]) || T5(t8, e9, o10, n8, i7, r9);
      }), true;
    }
    return void 0 !== e9.prototype && t8 instanceof e9 || !Error.isPrototypeOf(e9) && true === e9.call({}, t8);
  }
  function I4(t8) {
    if ("function" != typeof t8)
      throw new p7("fn", "Function", t8);
    try {
      t8();
    } catch (t9) {
      return t9;
    }
    return q3;
  }
  function D4(t8) {
    return m$12(t8) || null !== t8 && "object" === c7(t8) && "function" == typeof t8.then && "function" == typeof t8.catch;
  }
  function F4(t8) {
    return Promise.resolve().then(function() {
      var e9;
      if ("function" == typeof t8) {
        if (!D4(e9 = t8()))
          throw new h8("instance of Promise", "promiseFn", e9);
      } else {
        if (!D4(t8))
          throw new p7("promiseFn", ["Function", "Promise"], t8);
        e9 = t8;
      }
      return Promise.resolve().then(function() {
        return e9;
      }).then(function() {
        return q3;
      }).catch(function(t9) {
        return t9;
      });
    });
  }
  function N4(t8, e9, n8, r9) {
    if ("string" == typeof n8) {
      if (4 === arguments.length)
        throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
      if ("object" === c7(e9) && null !== e9) {
        if (e9.message === n8)
          throw new s6("error/message", 'The error message "'.concat(e9.message, '" is identical to the message.'));
      } else if (e9 === n8)
        throw new s6("error/message", 'The error "'.concat(e9, '" is identical to the message.'));
      r9 = n8, n8 = void 0;
    } else if (null != n8 && "object" !== c7(n8) && "function" != typeof n8)
      throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
    if (e9 === q3) {
      var o9 = "";
      n8 && n8.name && (o9 += " (".concat(n8.name, ")")), o9 += r9 ? ": ".concat(r9) : ".";
      var a8 = "rejects" === t8.name ? "rejection" : "exception";
      R4({ actual: void 0, expected: n8, operator: t8.name, message: "Missing expected ".concat(a8).concat(o9), stackStartFn: t8 });
    }
    if (n8 && !P4(e9, n8, r9, t8))
      throw e9;
  }
  function L4(t8, e9, n8, r9) {
    if (e9 !== q3) {
      if ("string" == typeof n8 && (r9 = n8, n8 = void 0), !n8 || P4(e9, n8)) {
        var o9 = r9 ? ": ".concat(r9) : ".", c8 = "doesNotReject" === t8.name ? "rejection" : "exception";
        R4({ actual: e9, expected: n8, operator: t8.name, message: "Got unwanted ".concat(c8).concat(o9, "\n") + 'Actual message: "'.concat(e9 && e9.message, '"'), stackStartFn: t8 });
      }
      throw e9;
    }
  }
  function M4() {
    for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
      e9[n8] = arguments[n8];
    A4.apply(void 0, [M4, e9.length].concat(e9));
  }
  return x4.throws = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    N4.apply(void 0, [t8, I4(e9)].concat(r9));
  }, x4.rejects = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    return F4(e9).then(function(e10) {
      return N4.apply(void 0, [t8, e10].concat(r9));
    });
  }, x4.doesNotThrow = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    L4.apply(void 0, [t8, I4(e9)].concat(r9));
  }, x4.doesNotReject = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    return F4(e9).then(function(e10) {
      return L4.apply(void 0, [t8, e10].concat(r9));
    });
  }, x4.ifError = function t8(e9) {
    if (null != e9) {
      var n8 = "ifError got unwanted exception: ";
      "object" === c7(e9) && "string" == typeof e9.message ? 0 === e9.message.length && e9.constructor ? n8 += e9.constructor.name : n8 += e9.message : n8 += v7(e9);
      var r9 = new b5({ actual: e9, expected: null, operator: "ifError", message: n8, stackStartFn: t8 }), o9 = e9.stack;
      if ("string" == typeof o9) {
        var a8 = o9.split("\n");
        a8.shift();
        for (var i7 = r9.stack.split("\n"), u8 = 0; u8 < a8.length; u8++) {
          var l8 = i7.indexOf(a8[u8]);
          if (-1 !== l8) {
            i7 = i7.slice(0, l8);
            break;
          }
        }
        r9.stack = "".concat(i7.join("\n"), "\n").concat(a8.join("\n"));
      }
      throw r9;
    }
  }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
}
var et = tt();
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
var AssertionError = et.AssertionError;
var deepEqual = et.deepEqual;
var deepStrictEqual = et.deepStrictEqual;
var doesNotReject = et.doesNotReject;
var doesNotThrow = et.doesNotThrow;
var equal = et.equal;
var fail = et.fail;
var ifError = et.ifError;
var notDeepEqual = et.notDeepEqual;
var notDeepStrictEqual = et.notDeepStrictEqual;
var notEqual = et.notEqual;
var notStrictEqual = et.notStrictEqual;
var ok = et.ok;
var rejects = et.rejects;
var strict = et.strict;
var strictEqual = et.strictEqual;
var throws = et.throws;

// node_modules/@jspm/core/nodelibs/browser/zlib.js
var exports$d2 = {};
var _dewExec$c2 = false;
function dew$c2() {
  if (_dewExec$c2)
    return exports$d2;
  _dewExec$c2 = true;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  exports$d2 = ZStream;
  return exports$d2;
}
var exports$c2 = {};
var _dewExec$b2 = false;
function dew$b2() {
  if (_dewExec$b2)
    return exports$c2;
  _dewExec$b2 = true;
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports$c2.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p7 in source) {
        if (_has(source, p7)) {
          obj[p7] = source[p7];
        }
      }
    }
    return obj;
  };
  exports$c2.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i7 = 0; i7 < len; i7++) {
        dest[dest_offs + i7] = src[src_offs + i7];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i7, l7, len, pos, chunk, result;
      len = 0;
      for (i7 = 0, l7 = chunks.length; i7 < l7; i7++) {
        len += chunks[i7].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i7 = 0, l7 = chunks.length; i7 < l7; i7++) {
        chunk = chunks[i7];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i7 = 0; i7 < len; i7++) {
        dest[dest_offs + i7] = src[src_offs + i7];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$c2.setTyped = function(on3) {
    if (on3) {
      exports$c2.Buf8 = Uint8Array;
      exports$c2.Buf16 = Uint16Array;
      exports$c2.Buf32 = Int32Array;
      exports$c2.assign(exports$c2, fnTyped);
    } else {
      exports$c2.Buf8 = Array;
      exports$c2.Buf16 = Array;
      exports$c2.Buf32 = Array;
      exports$c2.assign(exports$c2, fnUntyped);
    }
  };
  exports$c2.setTyped(TYPED_OK);
  return exports$c2;
}
var exports$b2 = {};
var _dewExec$a2 = false;
function dew$a2() {
  if (_dewExec$a2)
    return exports$b2;
  _dewExec$a2 = true;
  var utils = dew$b2();
  var Z_FIXED2 = 4;
  var Z_BINARY2 = 0;
  var Z_TEXT2 = 1;
  var Z_UNKNOWN2 = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s6, w4) {
    s6.pending_buf[s6.pending++] = w4 & 255;
    s6.pending_buf[s6.pending++] = w4 >>> 8 & 255;
  }
  function send_bits(s6, value, length) {
    if (s6.bi_valid > Buf_size - length) {
      s6.bi_buf |= value << s6.bi_valid & 65535;
      put_short(s6, s6.bi_buf);
      s6.bi_buf = value >> Buf_size - s6.bi_valid;
      s6.bi_valid += length - Buf_size;
    } else {
      s6.bi_buf |= value << s6.bi_valid & 65535;
      s6.bi_valid += length;
    }
  }
  function send_code(s6, c7, tree) {
    send_bits(
      s6,
      tree[c7 * 2],
      tree[c7 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s6) {
    if (s6.bi_valid === 16) {
      put_short(s6, s6.bi_buf);
      s6.bi_buf = 0;
      s6.bi_valid = 0;
    } else if (s6.bi_valid >= 8) {
      s6.pending_buf[s6.pending++] = s6.bi_buf & 255;
      s6.bi_buf >>= 8;
      s6.bi_valid -= 8;
    }
  }
  function gen_bitlen(s6, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h8;
    var n8, m6;
    var bits;
    var xbits;
    var f7;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s6.bl_count[bits] = 0;
    }
    tree[s6.heap[s6.heap_max] * 2 + 1] = 0;
    for (h8 = s6.heap_max + 1; h8 < HEAP_SIZE; h8++) {
      n8 = s6.heap[h8];
      bits = tree[tree[n8 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n8 * 2 + 1] = bits;
      if (n8 > max_code) {
        continue;
      }
      s6.bl_count[bits]++;
      xbits = 0;
      if (n8 >= base) {
        xbits = extra[n8 - base];
      }
      f7 = tree[n8 * 2];
      s6.opt_len += f7 * (bits + xbits);
      if (has_stree) {
        s6.static_len += f7 * (stree[n8 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s6.bl_count[bits] === 0) {
        bits--;
      }
      s6.bl_count[bits]--;
      s6.bl_count[bits + 1] += 2;
      s6.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n8 = s6.bl_count[bits];
      while (n8 !== 0) {
        m6 = s6.heap[--h8];
        if (m6 > max_code) {
          continue;
        }
        if (tree[m6 * 2 + 1] !== bits) {
          s6.opt_len += (bits - tree[m6 * 2 + 1]) * tree[m6 * 2];
          tree[m6 * 2 + 1] = bits;
        }
        n8--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n8;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n8 = 0; n8 <= max_code; n8++) {
      var len = tree[n8 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n8 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n8;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n8 = 0; n8 < 1 << extra_lbits[code]; n8++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n8 = 0; n8 < 1 << extra_dbits[code]; n8++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n8 = 0; n8 < 1 << extra_dbits[code] - 7; n8++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n8 = 0;
    while (n8 <= 143) {
      static_ltree[n8 * 2 + 1] = 8;
      n8++;
      bl_count[8]++;
    }
    while (n8 <= 255) {
      static_ltree[n8 * 2 + 1] = 9;
      n8++;
      bl_count[9]++;
    }
    while (n8 <= 279) {
      static_ltree[n8 * 2 + 1] = 7;
      n8++;
      bl_count[7]++;
    }
    while (n8 <= 287) {
      static_ltree[n8 * 2 + 1] = 8;
      n8++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n8 = 0; n8 < D_CODES; n8++) {
      static_dtree[n8 * 2 + 1] = 5;
      static_dtree[n8 * 2] = bi_reverse(n8, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s6) {
    var n8;
    for (n8 = 0; n8 < L_CODES; n8++) {
      s6.dyn_ltree[n8 * 2] = 0;
    }
    for (n8 = 0; n8 < D_CODES; n8++) {
      s6.dyn_dtree[n8 * 2] = 0;
    }
    for (n8 = 0; n8 < BL_CODES; n8++) {
      s6.bl_tree[n8 * 2] = 0;
    }
    s6.dyn_ltree[END_BLOCK * 2] = 1;
    s6.opt_len = s6.static_len = 0;
    s6.last_lit = s6.matches = 0;
  }
  function bi_windup(s6) {
    if (s6.bi_valid > 8) {
      put_short(s6, s6.bi_buf);
    } else if (s6.bi_valid > 0) {
      s6.pending_buf[s6.pending++] = s6.bi_buf;
    }
    s6.bi_buf = 0;
    s6.bi_valid = 0;
  }
  function copy_block(s6, buf, len, header) {
    bi_windup(s6);
    if (header) {
      put_short(s6, len);
      put_short(s6, ~len);
    }
    utils.arraySet(s6.pending_buf, s6.window, buf, len, s6.pending);
    s6.pending += len;
  }
  function smaller(tree, n8, m6, depth) {
    var _n2 = n8 * 2;
    var _m2 = m6 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n8] <= depth[m6];
  }
  function pqdownheap(s6, tree, k4) {
    var v7 = s6.heap[k4];
    var j4 = k4 << 1;
    while (j4 <= s6.heap_len) {
      if (j4 < s6.heap_len && smaller(tree, s6.heap[j4 + 1], s6.heap[j4], s6.depth)) {
        j4++;
      }
      if (smaller(tree, v7, s6.heap[j4], s6.depth)) {
        break;
      }
      s6.heap[k4] = s6.heap[j4];
      k4 = j4;
      j4 <<= 1;
    }
    s6.heap[k4] = v7;
  }
  function compress_block(s6, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s6.last_lit !== 0) {
      do {
        dist = s6.pending_buf[s6.d_buf + lx * 2] << 8 | s6.pending_buf[s6.d_buf + lx * 2 + 1];
        lc = s6.pending_buf[s6.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s6, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s6, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s6, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s6, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s6, dist, extra);
          }
        }
      } while (lx < s6.last_lit);
    }
    send_code(s6, END_BLOCK, ltree);
  }
  function build_tree(s6, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n8, m6;
    var max_code = -1;
    var node;
    s6.heap_len = 0;
    s6.heap_max = HEAP_SIZE;
    for (n8 = 0; n8 < elems; n8++) {
      if (tree[n8 * 2] !== 0) {
        s6.heap[++s6.heap_len] = max_code = n8;
        s6.depth[n8] = 0;
      } else {
        tree[n8 * 2 + 1] = 0;
      }
    }
    while (s6.heap_len < 2) {
      node = s6.heap[++s6.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s6.depth[node] = 0;
      s6.opt_len--;
      if (has_stree) {
        s6.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n8 = s6.heap_len >> 1; n8 >= 1; n8--) {
      pqdownheap(s6, tree, n8);
    }
    node = elems;
    do {
      n8 = s6.heap[
        1
        /*SMALLEST*/
      ];
      s6.heap[
        1
        /*SMALLEST*/
      ] = s6.heap[s6.heap_len--];
      pqdownheap(
        s6,
        tree,
        1
        /*SMALLEST*/
      );
      m6 = s6.heap[
        1
        /*SMALLEST*/
      ];
      s6.heap[--s6.heap_max] = n8;
      s6.heap[--s6.heap_max] = m6;
      tree[node * 2] = tree[n8 * 2] + tree[m6 * 2];
      s6.depth[node] = (s6.depth[n8] >= s6.depth[m6] ? s6.depth[n8] : s6.depth[m6]) + 1;
      tree[n8 * 2 + 1] = tree[m6 * 2 + 1] = node;
      s6.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s6,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s6.heap_len >= 2);
    s6.heap[--s6.heap_max] = s6.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s6, desc);
    gen_codes(tree, max_code, s6.bl_count);
  }
  function scan_tree(s6, tree, max_code) {
    var n8;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n8 = 0; n8 <= max_code; n8++) {
      curlen = nextlen;
      nextlen = tree[(n8 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s6.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s6.bl_tree[curlen * 2]++;
        }
        s6.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s6.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s6.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s6, tree, max_code) {
    var n8;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n8 = 0; n8 <= max_code; n8++) {
      curlen = nextlen;
      nextlen = tree[(n8 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s6, curlen, s6.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s6, curlen, s6.bl_tree);
          count--;
        }
        send_code(s6, REP_3_6, s6.bl_tree);
        send_bits(s6, count - 3, 2);
      } else if (count <= 10) {
        send_code(s6, REPZ_3_10, s6.bl_tree);
        send_bits(s6, count - 3, 3);
      } else {
        send_code(s6, REPZ_11_138, s6.bl_tree);
        send_bits(s6, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s6) {
    var max_blindex;
    scan_tree(s6, s6.dyn_ltree, s6.l_desc.max_code);
    scan_tree(s6, s6.dyn_dtree, s6.d_desc.max_code);
    build_tree(s6, s6.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s6.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s6.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s6, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s6, lcodes - 257, 5);
    send_bits(s6, dcodes - 1, 5);
    send_bits(s6, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(
        s6,
        s6.bl_tree[bl_order[rank] * 2 + 1],
        3
      );
    }
    send_tree(s6, s6.dyn_ltree, lcodes - 1);
    send_tree(s6, s6.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s6) {
    var black_mask = 4093624447;
    var n8;
    for (n8 = 0; n8 <= 31; n8++, black_mask >>>= 1) {
      if (black_mask & 1 && s6.dyn_ltree[n8 * 2] !== 0) {
        return Z_BINARY2;
      }
    }
    if (s6.dyn_ltree[9 * 2] !== 0 || s6.dyn_ltree[10 * 2] !== 0 || s6.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT2;
    }
    for (n8 = 32; n8 < LITERALS; n8++) {
      if (s6.dyn_ltree[n8 * 2] !== 0) {
        return Z_TEXT2;
      }
    }
    return Z_BINARY2;
  }
  var static_init_done = false;
  function _tr_init(s6) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s6.l_desc = new TreeDesc(s6.dyn_ltree, static_l_desc);
    s6.d_desc = new TreeDesc(s6.dyn_dtree, static_d_desc);
    s6.bl_desc = new TreeDesc(s6.bl_tree, static_bl_desc);
    s6.bi_buf = 0;
    s6.bi_valid = 0;
    init_block(s6);
  }
  function _tr_stored_block(s6, buf, stored_len, last) {
    send_bits(s6, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s6, buf, stored_len, true);
  }
  function _tr_align(s6) {
    send_bits(s6, STATIC_TREES << 1, 3);
    send_code(s6, END_BLOCK, static_ltree);
    bi_flush(s6);
  }
  function _tr_flush_block(s6, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s6.level > 0) {
      if (s6.strm.data_type === Z_UNKNOWN2) {
        s6.strm.data_type = detect_data_type(s6);
      }
      build_tree(s6, s6.l_desc);
      build_tree(s6, s6.d_desc);
      max_blindex = build_bl_tree(s6);
      opt_lenb = s6.opt_len + 3 + 7 >>> 3;
      static_lenb = s6.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s6, buf, stored_len, last);
    } else if (s6.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
      send_bits(s6, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s6, static_ltree, static_dtree);
    } else {
      send_bits(s6, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s6, s6.l_desc.max_code + 1, s6.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s6, s6.dyn_ltree, s6.dyn_dtree);
    }
    init_block(s6);
    if (last) {
      bi_windup(s6);
    }
  }
  function _tr_tally(s6, dist, lc) {
    s6.pending_buf[s6.d_buf + s6.last_lit * 2] = dist >>> 8 & 255;
    s6.pending_buf[s6.d_buf + s6.last_lit * 2 + 1] = dist & 255;
    s6.pending_buf[s6.l_buf + s6.last_lit] = lc & 255;
    s6.last_lit++;
    if (dist === 0) {
      s6.dyn_ltree[lc * 2]++;
    } else {
      s6.matches++;
      dist--;
      s6.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s6.dyn_dtree[d_code(dist) * 2]++;
    }
    return s6.last_lit === s6.lit_bufsize - 1;
  }
  exports$b2._tr_init = _tr_init;
  exports$b2._tr_stored_block = _tr_stored_block;
  exports$b2._tr_flush_block = _tr_flush_block;
  exports$b2._tr_tally = _tr_tally;
  exports$b2._tr_align = _tr_align;
  return exports$b2;
}
var exports$a2 = {};
var _dewExec$92 = false;
function dew$92() {
  if (_dewExec$92)
    return exports$a2;
  _dewExec$92 = true;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n8 = 0;
    while (len !== 0) {
      n8 = len > 2e3 ? 2e3 : len;
      len -= n8;
      do {
        s1 = s1 + buf[pos++] | 0;
        s22 = s22 + s1 | 0;
      } while (--n8);
      s1 %= 65521;
      s22 %= 65521;
    }
    return s1 | s22 << 16 | 0;
  }
  exports$a2 = adler32;
  return exports$a2;
}
var exports$92 = {};
var _dewExec$82 = false;
function dew$82() {
  if (_dewExec$82)
    return exports$92;
  _dewExec$82 = true;
  function makeTable() {
    var c7, table = [];
    for (var n8 = 0; n8 < 256; n8++) {
      c7 = n8;
      for (var k4 = 0; k4 < 8; k4++) {
        c7 = c7 & 1 ? 3988292384 ^ c7 >>> 1 : c7 >>> 1;
      }
      table[n8] = c7;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t8 = crcTable, end = pos + len;
    crc ^= -1;
    for (var i7 = pos; i7 < end; i7++) {
      crc = crc >>> 8 ^ t8[(crc ^ buf[i7]) & 255];
    }
    return crc ^ -1;
  }
  exports$92 = crc32;
  return exports$92;
}
var exports$82 = {};
var _dewExec$72 = false;
function dew$72() {
  if (_dewExec$72)
    return exports$82;
  _dewExec$72 = true;
  exports$82 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return exports$82;
}
var exports$72 = {};
var _dewExec$62 = false;
function dew$62() {
  if (_dewExec$62)
    return exports$72;
  _dewExec$62 = true;
  var utils = dew$b2();
  var trees = dew$a2();
  var adler32 = dew$92();
  var crc32 = dew$82();
  var msg = dew$72();
  var Z_NO_FLUSH2 = 0;
  var Z_PARTIAL_FLUSH2 = 1;
  var Z_FULL_FLUSH2 = 3;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFAULT_COMPRESSION2 = -1;
  var Z_FILTERED2 = 1;
  var Z_HUFFMAN_ONLY2 = 2;
  var Z_RLE2 = 3;
  var Z_FIXED2 = 4;
  var Z_DEFAULT_STRATEGY2 = 0;
  var Z_UNKNOWN2 = 2;
  var Z_DEFLATED2 = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f7) {
    return (f7 << 1) - (f7 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s6 = strm.state;
    var len = s6.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s6.pending_buf, s6.pending_out, len, strm.next_out);
    strm.next_out += len;
    s6.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s6.pending -= len;
    if (s6.pending === 0) {
      s6.pending_out = 0;
    }
  }
  function flush_block_only(s6, last) {
    trees._tr_flush_block(s6, s6.block_start >= 0 ? s6.block_start : -1, s6.strstart - s6.block_start, last);
    s6.block_start = s6.strstart;
    flush_pending(s6.strm);
  }
  function put_byte(s6, b5) {
    s6.pending_buf[s6.pending++] = b5;
  }
  function putShortMSB(s6, b5) {
    s6.pending_buf[s6.pending++] = b5 >>> 8 & 255;
    s6.pending_buf[s6.pending++] = b5 & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s6, cur_match) {
    var chain_length = s6.max_chain_length;
    var scan = s6.strstart;
    var match;
    var len;
    var best_len = s6.prev_length;
    var nice_match = s6.nice_match;
    var limit = s6.strstart > s6.w_size - MIN_LOOKAHEAD ? s6.strstart - (s6.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s6.window;
    var wmask = s6.w_mask;
    var prev = s6.prev;
    var strend = s6.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s6.prev_length >= s6.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s6.lookahead) {
      nice_match = s6.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s6.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s6.lookahead) {
      return best_len;
    }
    return s6.lookahead;
  }
  function fill_window(s6) {
    var _w_size = s6.w_size;
    var p7, n8, m6, more, str;
    do {
      more = s6.window_size - s6.lookahead - s6.strstart;
      if (s6.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s6.window, s6.window, _w_size, _w_size, 0);
        s6.match_start -= _w_size;
        s6.strstart -= _w_size;
        s6.block_start -= _w_size;
        n8 = s6.hash_size;
        p7 = n8;
        do {
          m6 = s6.head[--p7];
          s6.head[p7] = m6 >= _w_size ? m6 - _w_size : 0;
        } while (--n8);
        n8 = _w_size;
        p7 = n8;
        do {
          m6 = s6.prev[--p7];
          s6.prev[p7] = m6 >= _w_size ? m6 - _w_size : 0;
        } while (--n8);
        more += _w_size;
      }
      if (s6.strm.avail_in === 0) {
        break;
      }
      n8 = read_buf(s6.strm, s6.window, s6.strstart + s6.lookahead, more);
      s6.lookahead += n8;
      if (s6.lookahead + s6.insert >= MIN_MATCH) {
        str = s6.strstart - s6.insert;
        s6.ins_h = s6.window[str];
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + 1]) & s6.hash_mask;
        while (s6.insert) {
          s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + MIN_MATCH - 1]) & s6.hash_mask;
          s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = str;
          str++;
          s6.insert--;
          if (s6.lookahead + s6.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s6.lookahead < MIN_LOOKAHEAD && s6.strm.avail_in !== 0);
  }
  function deflate_stored(s6, flush) {
    var max_block_size = 65535;
    if (max_block_size > s6.pending_buf_size - 5) {
      max_block_size = s6.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s6.lookahead <= 1) {
        fill_window(s6);
        if (s6.lookahead === 0 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      s6.strstart += s6.lookahead;
      s6.lookahead = 0;
      var max_start = s6.block_start + max_block_size;
      if (s6.strstart === 0 || s6.strstart >= max_start) {
        s6.lookahead = s6.strstart - max_start;
        s6.strstart = max_start;
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s6.strstart - s6.block_start >= s6.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.strstart > s6.block_start) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s6, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s6.lookahead < MIN_LOOKAHEAD) {
        fill_window(s6);
        if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s6.lookahead >= MIN_MATCH) {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
        hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = s6.strstart;
      }
      if (hash_head !== 0 && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
        s6.match_length = longest_match(s6, hash_head);
      }
      if (s6.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s6, s6.strstart - s6.match_start, s6.match_length - MIN_MATCH);
        s6.lookahead -= s6.match_length;
        if (s6.match_length <= s6.max_lazy_match && s6.lookahead >= MIN_MATCH) {
          s6.match_length--;
          do {
            s6.strstart++;
            s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
            hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = s6.strstart;
          } while (--s6.match_length !== 0);
          s6.strstart++;
        } else {
          s6.strstart += s6.match_length;
          s6.match_length = 0;
          s6.ins_h = s6.window[s6.strstart];
          s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + 1]) & s6.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
      }
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s6, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s6.lookahead < MIN_LOOKAHEAD) {
        fill_window(s6);
        if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s6.lookahead >= MIN_MATCH) {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
        hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = s6.strstart;
      }
      s6.prev_length = s6.match_length;
      s6.prev_match = s6.match_start;
      s6.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s6.prev_length < s6.max_lazy_match && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
        s6.match_length = longest_match(s6, hash_head);
        if (s6.match_length <= 5 && (s6.strategy === Z_FILTERED2 || s6.match_length === MIN_MATCH && s6.strstart - s6.match_start > 4096)) {
          s6.match_length = MIN_MATCH - 1;
        }
      }
      if (s6.prev_length >= MIN_MATCH && s6.match_length <= s6.prev_length) {
        max_insert = s6.strstart + s6.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s6, s6.strstart - 1 - s6.prev_match, s6.prev_length - MIN_MATCH);
        s6.lookahead -= s6.prev_length - 1;
        s6.prev_length -= 2;
        do {
          if (++s6.strstart <= max_insert) {
            s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
            hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = s6.strstart;
          }
        } while (--s6.prev_length !== 0);
        s6.match_available = 0;
        s6.match_length = MIN_MATCH - 1;
        s6.strstart++;
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s6.match_available) {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
        if (bflush) {
          flush_block_only(s6, false);
        }
        s6.strstart++;
        s6.lookahead--;
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s6.match_available = 1;
        s6.strstart++;
        s6.lookahead--;
      }
    }
    if (s6.match_available) {
      bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
      s6.match_available = 0;
    }
    s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s6, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s6.window;
    for (; ; ) {
      if (s6.lookahead <= MAX_MATCH) {
        fill_window(s6);
        if (s6.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      s6.match_length = 0;
      if (s6.lookahead >= MIN_MATCH && s6.strstart > 0) {
        scan = s6.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s6.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s6.match_length = MAX_MATCH - (strend - scan);
          if (s6.match_length > s6.lookahead) {
            s6.match_length = s6.lookahead;
          }
        }
      }
      if (s6.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s6, 1, s6.match_length - MIN_MATCH);
        s6.lookahead -= s6.match_length;
        s6.strstart += s6.match_length;
        s6.match_length = 0;
      } else {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
      }
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s6, flush) {
    var bflush;
    for (; ; ) {
      if (s6.lookahead === 0) {
        fill_window(s6);
        if (s6.lookahead === 0) {
          if (flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s6.match_length = 0;
      bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
      s6.lookahead--;
      s6.strstart++;
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s6) {
    s6.window_size = 2 * s6.w_size;
    zero(s6.head);
    s6.max_lazy_match = configuration_table[s6.level].max_lazy;
    s6.good_match = configuration_table[s6.level].good_length;
    s6.nice_match = configuration_table[s6.level].nice_length;
    s6.max_chain_length = configuration_table[s6.level].max_chain;
    s6.strstart = 0;
    s6.block_start = 0;
    s6.lookahead = 0;
    s6.insert = 0;
    s6.match_length = s6.prev_length = MIN_MATCH - 1;
    s6.match_available = 0;
    s6.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s6;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN2;
    s6 = strm.state;
    s6.pending = 0;
    s6.pending_out = 0;
    if (s6.wrap < 0) {
      s6.wrap = -s6.wrap;
    }
    s6.status = s6.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s6.wrap === 2 ? 0 : 1;
    s6.last_flush = Z_NO_FLUSH2;
    trees._tr_init(s6);
    return Z_OK2;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK2) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR2;
    }
    strm.state.gzhead = head;
    return Z_OK2;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION2) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
      return err(strm, Z_STREAM_ERROR2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s6 = new DeflateState();
    strm.state = s6;
    s6.strm = strm;
    s6.wrap = wrap;
    s6.gzhead = null;
    s6.w_bits = windowBits;
    s6.w_size = 1 << s6.w_bits;
    s6.w_mask = s6.w_size - 1;
    s6.hash_bits = memLevel + 7;
    s6.hash_size = 1 << s6.hash_bits;
    s6.hash_mask = s6.hash_size - 1;
    s6.hash_shift = ~~((s6.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s6.window = new utils.Buf8(s6.w_size * 2);
    s6.head = new utils.Buf16(s6.hash_size);
    s6.prev = new utils.Buf16(s6.w_size);
    s6.lit_bufsize = 1 << memLevel + 6;
    s6.pending_buf_size = s6.lit_bufsize * 4;
    s6.pending_buf = new utils.Buf8(s6.pending_buf_size);
    s6.d_buf = 1 * s6.lit_bufsize;
    s6.l_buf = (1 + 2) * s6.lit_bufsize;
    s6.level = level;
    s6.strategy = strategy;
    s6.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED2, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY2);
  }
  function deflate2(strm, flush) {
    var old_flush, s6;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
    }
    s6 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s6.status === FINISH_STATE && flush !== Z_FINISH2) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
    }
    s6.strm = strm;
    old_flush = s6.last_flush;
    s6.last_flush = flush;
    if (s6.status === INIT_STATE) {
      if (s6.wrap === 2) {
        strm.adler = 0;
        put_byte(s6, 31);
        put_byte(s6, 139);
        put_byte(s6, 8);
        if (!s6.gzhead) {
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2 ? 4 : 0);
          put_byte(s6, OS_CODE);
          s6.status = BUSY_STATE;
        } else {
          put_byte(s6, (s6.gzhead.text ? 1 : 0) + (s6.gzhead.hcrc ? 2 : 0) + (!s6.gzhead.extra ? 0 : 4) + (!s6.gzhead.name ? 0 : 8) + (!s6.gzhead.comment ? 0 : 16));
          put_byte(s6, s6.gzhead.time & 255);
          put_byte(s6, s6.gzhead.time >> 8 & 255);
          put_byte(s6, s6.gzhead.time >> 16 & 255);
          put_byte(s6, s6.gzhead.time >> 24 & 255);
          put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2 ? 4 : 0);
          put_byte(s6, s6.gzhead.os & 255);
          if (s6.gzhead.extra && s6.gzhead.extra.length) {
            put_byte(s6, s6.gzhead.extra.length & 255);
            put_byte(s6, s6.gzhead.extra.length >> 8 & 255);
          }
          if (s6.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending, 0);
          }
          s6.gzindex = 0;
          s6.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED2 + (s6.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2) {
          level_flags = 0;
        } else if (s6.level < 6) {
          level_flags = 1;
        } else if (s6.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s6.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s6.status = BUSY_STATE;
        putShortMSB(s6, header);
        if (s6.strstart !== 0) {
          putShortMSB(s6, strm.adler >>> 16);
          putShortMSB(s6, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s6.status === EXTRA_STATE) {
      if (s6.gzhead.extra) {
        beg = s6.pending;
        while (s6.gzindex < (s6.gzhead.extra.length & 65535)) {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              break;
            }
          }
          put_byte(s6, s6.gzhead.extra[s6.gzindex] & 255);
          s6.gzindex++;
        }
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (s6.gzindex === s6.gzhead.extra.length) {
          s6.gzindex = 0;
          s6.status = NAME_STATE;
        }
      } else {
        s6.status = NAME_STATE;
      }
    }
    if (s6.status === NAME_STATE) {
      if (s6.gzhead.name) {
        beg = s6.pending;
        do {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s6.gzindex < s6.gzhead.name.length) {
            val = s6.gzhead.name.charCodeAt(s6.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s6, val);
        } while (val !== 0);
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (val === 0) {
          s6.gzindex = 0;
          s6.status = COMMENT_STATE;
        }
      } else {
        s6.status = COMMENT_STATE;
      }
    }
    if (s6.status === COMMENT_STATE) {
      if (s6.gzhead.comment) {
        beg = s6.pending;
        do {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s6.gzindex < s6.gzhead.comment.length) {
            val = s6.gzhead.comment.charCodeAt(s6.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s6, val);
        } while (val !== 0);
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (val === 0) {
          s6.status = HCRC_STATE;
        }
      } else {
        s6.status = HCRC_STATE;
      }
    }
    if (s6.status === HCRC_STATE) {
      if (s6.gzhead.hcrc) {
        if (s6.pending + 2 > s6.pending_buf_size) {
          flush_pending(strm);
        }
        if (s6.pending + 2 <= s6.pending_buf_size) {
          put_byte(s6, strm.adler & 255);
          put_byte(s6, strm.adler >> 8 & 255);
          strm.adler = 0;
          s6.status = BUSY_STATE;
        }
      } else {
        s6.status = BUSY_STATE;
      }
    }
    if (s6.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s6.last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH2) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (s6.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (strm.avail_in !== 0 || s6.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s6.status !== FINISH_STATE) {
      var bstate = s6.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff(s6, flush) : s6.strategy === Z_RLE2 ? deflate_rle(s6, flush) : configuration_table[s6.level].func(s6, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s6.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH2) {
          trees._tr_align(s6);
        } else if (flush !== Z_BLOCK2) {
          trees._tr_stored_block(s6, 0, 0, false);
          if (flush === Z_FULL_FLUSH2) {
            zero(s6.head);
            if (s6.lookahead === 0) {
              s6.strstart = 0;
              s6.block_start = 0;
              s6.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush !== Z_FINISH2) {
      return Z_OK2;
    }
    if (s6.wrap <= 0) {
      return Z_STREAM_END2;
    }
    if (s6.wrap === 2) {
      put_byte(s6, strm.adler & 255);
      put_byte(s6, strm.adler >> 8 & 255);
      put_byte(s6, strm.adler >> 16 & 255);
      put_byte(s6, strm.adler >> 24 & 255);
      put_byte(s6, strm.total_in & 255);
      put_byte(s6, strm.total_in >> 8 & 255);
      put_byte(s6, strm.total_in >> 16 & 255);
      put_byte(s6, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s6, strm.adler >>> 16);
      putShortMSB(s6, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s6.wrap > 0) {
      s6.wrap = -s6.wrap;
    }
    return s6.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR2) : Z_OK2;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s6;
    var str, n8;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    s6 = strm.state;
    wrap = s6.wrap;
    if (wrap === 2 || wrap === 1 && s6.status !== INIT_STATE || s6.lookahead) {
      return Z_STREAM_ERROR2;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s6.wrap = 0;
    if (dictLength >= s6.w_size) {
      if (wrap === 0) {
        zero(s6.head);
        s6.strstart = 0;
        s6.block_start = 0;
        s6.insert = 0;
      }
      tmpDict = new utils.Buf8(s6.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s6.w_size, s6.w_size, 0);
      dictionary = tmpDict;
      dictLength = s6.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s6);
    while (s6.lookahead >= MIN_MATCH) {
      str = s6.strstart;
      n8 = s6.lookahead - (MIN_MATCH - 1);
      do {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + MIN_MATCH - 1]) & s6.hash_mask;
        s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = str;
        str++;
      } while (--n8);
      s6.strstart = str;
      s6.lookahead = MIN_MATCH - 1;
      fill_window(s6);
    }
    s6.strstart += s6.lookahead;
    s6.block_start = s6.strstart;
    s6.insert = s6.lookahead;
    s6.lookahead = 0;
    s6.match_length = s6.prev_length = MIN_MATCH - 1;
    s6.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s6.wrap = wrap;
    return Z_OK2;
  }
  exports$72.deflateInit = deflateInit;
  exports$72.deflateInit2 = deflateInit2;
  exports$72.deflateReset = deflateReset;
  exports$72.deflateResetKeep = deflateResetKeep;
  exports$72.deflateSetHeader = deflateSetHeader;
  exports$72.deflate = deflate2;
  exports$72.deflateEnd = deflateEnd;
  exports$72.deflateSetDictionary = deflateSetDictionary;
  exports$72.deflateInfo = "pako deflate (from Nodeca project)";
  return exports$72;
}
var exports$62 = {};
var _dewExec$52 = false;
function dew$52() {
  if (_dewExec$52)
    return exports$62;
  _dewExec$52 = true;
  var BAD = 30;
  var TYPE2 = 12;
  exports$62 = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE2;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return exports$62;
}
var exports$52 = {};
var _dewExec$42 = false;
function dew$42() {
  if (_dewExec$42)
    return exports$52;
  _dewExec$42 = true;
  var utils = dew$b2();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  exports$52 = function inflate_table(type2, lens, lens_index, codes2, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return exports$52;
}
var exports$42 = {};
var _dewExec$32 = false;
function dew$32() {
  if (_dewExec$32)
    return exports$42;
  _dewExec$32 = true;
  var utils = dew$b2();
  var adler32 = dew$92();
  var crc32 = dew$82();
  var inflate_fast = dew$52();
  var inflate_table = dew$42();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_TREES2 = 6;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_NEED_DICT2 = 2;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFLATED2 = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE2 = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q3) {
    return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK2;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR2;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK2) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate2(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n8;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.mode === TYPE2) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK2;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE2;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE2;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT2;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE2;
          case TYPE2:
            if (flush === Z_BLOCK2 || flush === Z_TREES2) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES2) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE2;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n8 = here_bits + 2;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n8 = here_bits + 3;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n8 = here_bits + 7;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {
              bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE2) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE2;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n8 = state.extra;
              while (bits < n8) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n8 = state.extra;
              while (bits < n8) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END2;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR2;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR2;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH2)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
        ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
      ret = Z_BUF_ERROR2;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK2;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR2;
    }
    state.head = head;
    head.done = false;
    return Z_OK2;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR2;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR2;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK2;
  }
  exports$42.inflateReset = inflateReset;
  exports$42.inflateReset2 = inflateReset2;
  exports$42.inflateResetKeep = inflateResetKeep;
  exports$42.inflateInit = inflateInit;
  exports$42.inflateInit2 = inflateInit2;
  exports$42.inflate = inflate2;
  exports$42.inflateEnd = inflateEnd;
  exports$42.inflateGetHeader = inflateGetHeader;
  exports$42.inflateSetDictionary = inflateSetDictionary;
  exports$42.inflateInfo = "pako inflate (from Nodeca project)";
  return exports$42;
}
var exports$33 = {};
var _dewExec$23 = false;
function dew$23() {
  if (_dewExec$23)
    return exports$33;
  _dewExec$23 = true;
  exports$33 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return exports$33;
}
var exports$23 = {};
var _dewExec$13 = false;
function dew$13() {
  if (_dewExec$13)
    return exports$23;
  _dewExec$13 = true;
  var Buffer3 = buffer.Buffer;
  var process$1 = process2;
  var assert2 = et;
  var Zstream = dew$c2();
  var zlib_deflate = dew$62();
  var zlib_inflate = dew$32();
  var constants3 = dew$23();
  for (var key in constants3) {
    exports$23[key] = constants3[key];
  }
  exports$23.NONE = 0;
  exports$23.DEFLATE = 1;
  exports$23.INFLATE = 2;
  exports$23.GZIP = 3;
  exports$23.GUNZIP = 4;
  exports$23.DEFLATERAW = 5;
  exports$23.INFLATERAW = 6;
  exports$23.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib2(mode) {
    if (typeof mode !== "number" || mode < exports$23.DEFLATE || mode > exports$23.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib2.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports$23.UNZIP);
    if (this.mode === exports$23.DEFLATE || this.mode === exports$23.GZIP || this.mode === exports$23.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports$23.INFLATE || this.mode === exports$23.GUNZIP || this.mode === exports$23.INFLATERAW || this.mode === exports$23.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports$23.NONE;
    this.dictionary = null;
  };
  Zlib2.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports$23.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports$23.Z_NO_FLUSH && flush !== exports$23.Z_PARTIAL_FLUSH && flush !== exports$23.Z_SYNC_FLUSH && flush !== exports$23.Z_FULL_FLUSH && flush !== exports$23.Z_FINISH && flush !== exports$23.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer3.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    process$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib2.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib2.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports$23.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports$23.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports$23.GUNZIP;
            } else {
              this.mode = exports$23.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports$23.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports$23.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports$23.Z_DATA_ERROR) {
            this.err = exports$23.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports$23.GUNZIP && this.err === exports$23.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib2.prototype._checkError = function() {
    switch (this.err) {
      case exports$23.Z_OK:
      case exports$23.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports$23.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports$23.Z_STREAM_END:
        break;
      case exports$23.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib2.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports$23.Z_FILTERED || strategy === exports$23.Z_HUFFMAN_ONLY || strategy === exports$23.Z_RLE || strategy === exports$23.Z_FIXED || strategy === exports$23.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib2.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib2.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib2.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports$23.Z_NO_FLUSH;
    this.err = exports$23.Z_OK;
    if (this.mode === exports$23.GZIP || this.mode === exports$23.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports$23.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports$23.DEFLATERAW || this.mode === exports$23.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports$23.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
      case exports$23.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib2.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib2.prototype._reset = function() {
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
      case exports$23.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports$23.INFLATE:
      case exports$23.INFLATERAW:
      case exports$23.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports$23.Zlib = Zlib2;
  return exports$23;
}
var exports$16 = {};
var _dewExec7 = false;
function dew7() {
  if (_dewExec7)
    return exports$16;
  _dewExec7 = true;
  var process$1 = process2;
  var Buffer3 = buffer.Buffer;
  var Transform2 = exports6.Transform;
  var binding2 = dew$13();
  var util = X;
  var assert2 = et.ok;
  var kMaxLength2 = buffer.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength2.toString(16) + " bytes";
  binding2.Z_MIN_WINDOWBITS = 8;
  binding2.Z_MAX_WINDOWBITS = 15;
  binding2.Z_DEFAULT_WINDOWBITS = 15;
  binding2.Z_MIN_CHUNK = 64;
  binding2.Z_MAX_CHUNK = Infinity;
  binding2.Z_DEFAULT_CHUNK = 16 * 1024;
  binding2.Z_MIN_MEMLEVEL = 1;
  binding2.Z_MAX_MEMLEVEL = 9;
  binding2.Z_DEFAULT_MEMLEVEL = 8;
  binding2.Z_MIN_LEVEL = -1;
  binding2.Z_MAX_LEVEL = 9;
  binding2.Z_DEFAULT_LEVEL = binding2.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding2);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports$16, bkey, {
        enumerable: true,
        value: binding2[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding2.Z_OK,
    Z_STREAM_END: binding2.Z_STREAM_END,
    Z_NEED_DICT: binding2.Z_NEED_DICT,
    Z_ERRNO: binding2.Z_ERRNO,
    Z_STREAM_ERROR: binding2.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding2.Z_DATA_ERROR,
    Z_MEM_ERROR: binding2.Z_MEM_ERROR,
    Z_BUF_ERROR: binding2.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding2.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports$16, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports$16.Deflate = Deflate2;
  exports$16.Inflate = Inflate2;
  exports$16.Gzip = Gzip2;
  exports$16.Gunzip = Gunzip2;
  exports$16.DeflateRaw = DeflateRaw2;
  exports$16.InflateRaw = InflateRaw2;
  exports$16.Unzip = Unzip2;
  exports$16.createDeflate = function(o8) {
    return new Deflate2(o8);
  };
  exports$16.createInflate = function(o8) {
    return new Inflate2(o8);
  };
  exports$16.createDeflateRaw = function(o8) {
    return new DeflateRaw2(o8);
  };
  exports$16.createInflateRaw = function(o8) {
    return new InflateRaw2(o8);
  };
  exports$16.createGzip = function(o8) {
    return new Gzip2(o8);
  };
  exports$16.createGunzip = function(o8) {
    return new Gunzip2(o8);
  };
  exports$16.createUnzip = function(o8) {
    return new Unzip2(o8);
  };
  exports$16.deflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Deflate2(opts), buffer2, callback);
  };
  exports$16.deflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Deflate2(opts), buffer2);
  };
  exports$16.gzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gzip2(opts), buffer2, callback);
  };
  exports$16.gzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gzip2(opts), buffer2);
  };
  exports$16.deflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new DeflateRaw2(opts), buffer2, callback);
  };
  exports$16.deflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new DeflateRaw2(opts), buffer2);
  };
  exports$16.unzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Unzip2(opts), buffer2, callback);
  };
  exports$16.unzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Unzip2(opts), buffer2);
  };
  exports$16.inflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Inflate2(opts), buffer2, callback);
  };
  exports$16.inflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Inflate2(opts), buffer2);
  };
  exports$16.gunzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gunzip2(opts), buffer2, callback);
  };
  exports$16.gunzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gunzip2(opts), buffer2);
  };
  exports$16.inflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new InflateRaw2(opts), buffer2, callback);
  };
  exports$16.inflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new InflateRaw2(opts), buffer2);
  };
  function zlibBuffer(engine, buffer2, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError);
    engine.on("end", onEnd);
    engine.end(buffer2);
    flow();
    function flow() {
      var chunk;
      while (null !== (chunk = engine.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine.once("readable", flow);
    }
    function onError(err) {
      engine.removeListener("end", onEnd);
      engine.removeListener("readable", flow);
      callback(err);
    }
    function onEnd() {
      var buf;
      var err = null;
      if (nread >= kMaxLength2) {
        err = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer3.concat(buffers, nread);
      }
      buffers = [];
      engine.close();
      callback(err, buf);
    }
  }
  function zlibBufferSync(engine, buffer2) {
    if (typeof buffer2 === "string")
      buffer2 = Buffer3.from(buffer2);
    if (!Buffer3.isBuffer(buffer2))
      throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer2, flushFlag);
  }
  function Deflate2(opts) {
    if (!(this instanceof Deflate2))
      return new Deflate2(opts);
    Zlib2.call(this, opts, binding2.DEFLATE);
  }
  function Inflate2(opts) {
    if (!(this instanceof Inflate2))
      return new Inflate2(opts);
    Zlib2.call(this, opts, binding2.INFLATE);
  }
  function Gzip2(opts) {
    if (!(this instanceof Gzip2))
      return new Gzip2(opts);
    Zlib2.call(this, opts, binding2.GZIP);
  }
  function Gunzip2(opts) {
    if (!(this instanceof Gunzip2))
      return new Gunzip2(opts);
    Zlib2.call(this, opts, binding2.GUNZIP);
  }
  function DeflateRaw2(opts) {
    if (!(this instanceof DeflateRaw2))
      return new DeflateRaw2(opts);
    Zlib2.call(this, opts, binding2.DEFLATERAW);
  }
  function InflateRaw2(opts) {
    if (!(this instanceof InflateRaw2))
      return new InflateRaw2(opts);
    Zlib2.call(this, opts, binding2.INFLATERAW);
  }
  function Unzip2(opts) {
    if (!(this instanceof Unzip2))
      return new Unzip2(opts);
    Zlib2.call(this, opts, binding2.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding2.Z_NO_FLUSH || flag === binding2.Z_PARTIAL_FLUSH || flag === binding2.Z_SYNC_FLUSH || flag === binding2.Z_FULL_FLUSH || flag === binding2.Z_FINISH || flag === binding2.Z_BLOCK;
  }
  function Zlib2(opts, mode) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || exports$16.Z_DEFAULT_CHUNK;
    Transform2.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
      throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || binding2.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding2.Z_FINISH;
    if (opts.chunkSize) {
      if (opts.chunkSize < exports$16.Z_MIN_CHUNK || opts.chunkSize > exports$16.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts.chunkSize);
      }
    }
    if (opts.windowBits) {
      if (opts.windowBits < exports$16.Z_MIN_WINDOWBITS || opts.windowBits > exports$16.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts.windowBits);
      }
    }
    if (opts.level) {
      if (opts.level < exports$16.Z_MIN_LEVEL || opts.level > exports$16.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts.level);
      }
    }
    if (opts.memLevel) {
      if (opts.memLevel < exports$16.Z_MIN_MEMLEVEL || opts.memLevel > exports$16.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts.memLevel);
      }
    }
    if (opts.strategy) {
      if (opts.strategy != exports$16.Z_FILTERED && opts.strategy != exports$16.Z_HUFFMAN_ONLY && opts.strategy != exports$16.Z_RLE && opts.strategy != exports$16.Z_FIXED && opts.strategy != exports$16.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts.strategy);
      }
    }
    if (opts.dictionary) {
      if (!Buffer3.isBuffer(opts.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding2.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports$16.codes[errno];
      self2.emit("error", error);
    };
    var level = exports$16.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number")
      level = opts.level;
    var strategy = exports$16.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number")
      strategy = opts.strategy;
    this._handle.init(opts.windowBits || exports$16.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports$16.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer3.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib2, Transform2);
  Zlib2.prototype.params = function(level, strategy, callback) {
    if (level < exports$16.Z_MIN_LEVEL || level > exports$16.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports$16.Z_FILTERED && strategy != exports$16.Z_HUFFMAN_ONLY && strategy != exports$16.Z_RLE && strategy != exports$16.Z_FIXED && strategy != exports$16.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding2.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback)
            callback();
        }
      });
    } else {
      process$1.nextTick(callback);
    }
  };
  Zlib2.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib2.prototype._flush = function(callback) {
    this._transform(Buffer3.alloc(0), "", callback);
  };
  Zlib2.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding2.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback)
        process$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback)
        this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer3.alloc(0), "", callback);
    }
  };
  Zlib2.prototype.close = function(callback) {
    _close(this, callback);
    process$1.nextTick(emitCloseNT, this);
  };
  function _close(engine, callback) {
    if (callback)
      process$1.nextTick(callback);
    if (!engine._handle)
      return;
    engine._handle.close();
    engine._handle = null;
  }
  function emitCloseNT(self2) {
    self2.emit("close");
  }
  Zlib2.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer3.isBuffer(chunk))
      return cb(new Error("invalid input"));
    if (!this._handle)
      return cb(new Error("zlib binding closed"));
    if (last)
      flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding2.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib2.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength2) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer3.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError)
        return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer3.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async)
          return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async)
        return false;
      cb();
    }
  };
  util.inherits(Deflate2, Zlib2);
  util.inherits(Inflate2, Zlib2);
  util.inherits(Gzip2, Zlib2);
  util.inherits(Gunzip2, Zlib2);
  util.inherits(DeflateRaw2, Zlib2);
  util.inherits(InflateRaw2, Zlib2);
  util.inherits(Unzip2, Zlib2);
  return exports$16;
}
var exports7 = dew7();
exports7["codes"];
exports7["Deflate"];
exports7["Inflate"];
exports7["Gzip"];
exports7["Gunzip"];
exports7["DeflateRaw"];
exports7["InflateRaw"];
exports7["Unzip"];
exports7["createDeflate"];
exports7["createInflate"];
exports7["createDeflateRaw"];
exports7["createInflateRaw"];
exports7["createGzip"];
exports7["createGunzip"];
exports7["createUnzip"];
exports7["deflate"];
exports7["deflateSync"];
exports7["gzip"];
exports7["gzipSync"];
exports7["deflateRaw"];
exports7["deflateRawSync"];
exports7["unzip"];
exports7["unzipSync"];
exports7["inflate"];
exports7["inflateSync"];
exports7["gunzip"];
exports7["gunzipSync"];
exports7["inflateRaw"];
exports7["inflateRawSync"];
var Deflate = exports7.Deflate;
var DeflateRaw = exports7.DeflateRaw;
var Gunzip = exports7.Gunzip;
var Gzip = exports7.Gzip;
var Inflate = exports7.Inflate;
var InflateRaw = exports7.InflateRaw;
var Unzip = exports7.Unzip;
var Z_BEST_COMPRESSION = exports7.Z_BEST_COMPRESSION;
var Z_BEST_SPEED = exports7.Z_BEST_SPEED;
var Z_BINARY = exports7.Z_BINARY;
var Z_BLOCK = exports7.Z_BLOCK;
var Z_BUF_ERROR = exports7.Z_BUF_ERROR;
var Z_DATA_ERROR = exports7.Z_DATA_ERROR;
var Z_DEFAULT_CHUNK = exports7.Z_DEFAULT_CHUNK;
var Z_DEFAULT_COMPRESSION = exports7.Z_DEFAULT_COMPRESSION;
var Z_DEFAULT_LEVEL = exports7.Z_DEFAULT_LEVEL;
var Z_DEFAULT_MEMLEVEL = exports7.Z_DEFAULT_MEMLEVEL;
var Z_DEFAULT_STRATEGY = exports7.Z_DEFAULT_STRATEGY;
var Z_DEFAULT_WINDOWBITS = exports7.Z_DEFAULT_WINDOWBITS;
var Z_DEFLATED = exports7.Z_DEFLATED;
var Z_ERRNO = exports7.Z_ERRNO;
var Z_FILTERED = exports7.Z_FILTERED;
var Z_FINISH = exports7.Z_FINISH;
var Z_FIXED = exports7.Z_FIXED;
var Z_FULL_FLUSH = exports7.Z_FULL_FLUSH;
var Z_HUFFMAN_ONLY = exports7.Z_HUFFMAN_ONLY;
var Z_MAX_CHUNK = exports7.Z_MAX_CHUNK;
var Z_MAX_LEVEL = exports7.Z_MAX_LEVEL;
var Z_MAX_MEMLEVEL = exports7.Z_MAX_MEMLEVEL;
var Z_MAX_WINDOWBITS = exports7.Z_MAX_WINDOWBITS;
var Z_MIN_CHUNK = exports7.Z_MIN_CHUNK;
var Z_MIN_LEVEL = exports7.Z_MIN_LEVEL;
var Z_MIN_MEMLEVEL = exports7.Z_MIN_MEMLEVEL;
var Z_MIN_WINDOWBITS = exports7.Z_MIN_WINDOWBITS;
var Z_NEED_DICT = exports7.Z_NEED_DICT;
var Z_NO_COMPRESSION = exports7.Z_NO_COMPRESSION;
var Z_NO_FLUSH = exports7.Z_NO_FLUSH;
var Z_OK = exports7.Z_OK;
var Z_PARTIAL_FLUSH = exports7.Z_PARTIAL_FLUSH;
var Z_RLE = exports7.Z_RLE;
var Z_STREAM_END = exports7.Z_STREAM_END;
var Z_STREAM_ERROR = exports7.Z_STREAM_ERROR;
var Z_SYNC_FLUSH = exports7.Z_SYNC_FLUSH;
var Z_TEXT = exports7.Z_TEXT;
var Z_TREES = exports7.Z_TREES;
var Z_UNKNOWN = exports7.Z_UNKNOWN;
var Zlib = exports7.Zlib;
var codes = exports7.codes;
var createDeflate = exports7.createDeflate;
var createDeflateRaw = exports7.createDeflateRaw;
var createGunzip = exports7.createGunzip;
var createGzip = exports7.createGzip;
var createInflate = exports7.createInflate;
var createInflateRaw = exports7.createInflateRaw;
var createUnzip = exports7.createUnzip;
var deflate = exports7.deflate;
var deflateRaw = exports7.deflateRaw;
var deflateRawSync = exports7.deflateRawSync;
var deflateSync = exports7.deflateSync;
var gunzip = exports7.gunzip;
var gunzipSync = exports7.gunzipSync;
var gzip = exports7.gzip;
var gzipSync = exports7.gzipSync;
var inflate = exports7.inflate;
var inflateRaw = exports7.inflateRaw;
var inflateRawSync = exports7.inflateRawSync;
var inflateSync = exports7.inflateSync;
var unzip = exports7.unzip;
var unzipSync = exports7.unzipSync;

// node_modules/@jspm/core/nodelibs/browser/fs.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/url.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var t6 = 2147483647;
var o5 = /^xn--/;
var n5 = /[^\0-\x7E]/;
var e6 = /[\x2E\u3002\uFF0E\uFF61]/g;
var r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
var c5 = Math.floor;
var s5 = String.fromCharCode;
function i5(t8) {
  throw new RangeError(r6[t8]);
}
function f5(t8, o8) {
  const n8 = t8.split("@");
  let r9 = "";
  n8.length > 1 && (r9 = n8[0] + "@", t8 = n8[1]);
  const c7 = function(t9, o9) {
    const n9 = [];
    let e9 = t9.length;
    for (; e9--; )
      n9[e9] = o9(t9[e9]);
    return n9;
  }((t8 = t8.replace(e6, ".")).split("."), o8).join(".");
  return r9 + c7;
}
function l5(t8) {
  const o8 = [];
  let n8 = 0;
  const e9 = t8.length;
  for (; n8 < e9; ) {
    const r9 = t8.charCodeAt(n8++);
    if (r9 >= 55296 && r9 <= 56319 && n8 < e9) {
      const e10 = t8.charCodeAt(n8++);
      56320 == (64512 & e10) ? o8.push(((1023 & r9) << 10) + (1023 & e10) + 65536) : (o8.push(r9), n8--);
    } else
      o8.push(r9);
  }
  return o8;
}
var u5 = function(t8, o8) {
  return t8 + 22 + 75 * (t8 < 26) - ((0 != o8) << 5);
};
var a5 = function(t8, o8, n8) {
  let e9 = 0;
  for (t8 = n8 ? c5(t8 / 700) : t8 >> 1, t8 += c5(t8 / o8); t8 > 455; e9 += 36)
    t8 = c5(t8 / 35);
  return c5(e9 + 36 * t8 / (t8 + 38));
};
var d5 = function(o8) {
  const n8 = [], e9 = o8.length;
  let r9 = 0, s6 = 128, f7 = 72, l7 = o8.lastIndexOf("-");
  l7 < 0 && (l7 = 0);
  for (let t8 = 0; t8 < l7; ++t8)
    o8.charCodeAt(t8) >= 128 && i5("not-basic"), n8.push(o8.charCodeAt(t8));
  for (let d6 = l7 > 0 ? l7 + 1 : 0; d6 < e9; ) {
    let l8 = r9;
    for (let n9 = 1, s7 = 36; ; s7 += 36) {
      d6 >= e9 && i5("invalid-input");
      const l9 = (u7 = o8.charCodeAt(d6++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
      (l9 >= 36 || l9 > c5((t6 - r9) / n9)) && i5("overflow"), r9 += l9 * n9;
      const a7 = s7 <= f7 ? 1 : s7 >= f7 + 26 ? 26 : s7 - f7;
      if (l9 < a7)
        break;
      const h9 = 36 - a7;
      n9 > c5(t6 / h9) && i5("overflow"), n9 *= h9;
    }
    const h8 = n8.length + 1;
    f7 = a5(r9 - l8, h8, 0 == l8), c5(r9 / h8) > t6 - s6 && i5("overflow"), s6 += c5(r9 / h8), r9 %= h8, n8.splice(r9++, 0, s6);
  }
  var u7;
  return String.fromCodePoint(...n8);
};
var h6 = function(o8) {
  const n8 = [];
  let e9 = (o8 = l5(o8)).length, r9 = 128, f7 = 0, d6 = 72;
  for (const t8 of o8)
    t8 < 128 && n8.push(s5(t8));
  let h8 = n8.length, p7 = h8;
  for (h8 && n8.push("-"); p7 < e9; ) {
    let e10 = t6;
    for (const t8 of o8)
      t8 >= r9 && t8 < e10 && (e10 = t8);
    const l7 = p7 + 1;
    e10 - r9 > c5((t6 - f7) / l7) && i5("overflow"), f7 += (e10 - r9) * l7, r9 = e10;
    for (const e11 of o8)
      if (e11 < r9 && ++f7 > t6 && i5("overflow"), e11 == r9) {
        let t8 = f7;
        for (let o9 = 36; ; o9 += 36) {
          const e12 = o9 <= d6 ? 1 : o9 >= d6 + 26 ? 26 : o9 - d6;
          if (t8 < e12)
            break;
          const r10 = t8 - e12, i7 = 36 - e12;
          n8.push(s5(u5(e12 + r10 % i7, 0))), t8 = c5(r10 / i7);
        }
        n8.push(s5(u5(t8, 0))), d6 = a5(f7, l7, p7 == h8), f7 = 0, ++p7;
      }
    ++f7, ++r9;
  }
  return n8.join("");
};
var p5 = { version: "2.1.0", ucs2: { decode: l5, encode: (t8) => String.fromCodePoint(...t8) }, decode: d5, encode: h6, toASCII: function(t8) {
  return f5(t8, function(t9) {
    return n5.test(t9) ? "xn--" + h6(t9) : t9;
  });
}, toUnicode: function(t8) {
  return f5(t8, function(t9) {
    return o5.test(t9) ? d5(t9.slice(4).toLowerCase()) : t9;
  });
} };
p5.decode;
p5.encode;
p5.toASCII;
p5.toUnicode;
p5.ucs2;
p5.version;

// node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function e7(e9, n8) {
  return Object.prototype.hasOwnProperty.call(e9, n8);
}
var n6 = function(n8, r9, t8, o8) {
  r9 = r9 || "&", t8 = t8 || "=";
  var a7 = {};
  if ("string" != typeof n8 || 0 === n8.length)
    return a7;
  var u7 = /\+/g;
  n8 = n8.split(r9);
  var c7 = 1e3;
  o8 && "number" == typeof o8.maxKeys && (c7 = o8.maxKeys);
  var i7 = n8.length;
  c7 > 0 && i7 > c7 && (i7 = c7);
  for (var s6 = 0; s6 < i7; ++s6) {
    var p7, f7, d6, y6, m6 = n8[s6].replace(u7, "%20"), l7 = m6.indexOf(t8);
    l7 >= 0 ? (p7 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p7 = m6, f7 = ""), d6 = decodeURIComponent(p7), y6 = decodeURIComponent(f7), e7(a7, d6) ? Array.isArray(a7[d6]) ? a7[d6].push(y6) : a7[d6] = [a7[d6], y6] : a7[d6] = y6;
  }
  return a7;
};
var r7 = function(e9) {
  switch (typeof e9) {
    case "string":
      return e9;
    case "boolean":
      return e9 ? "true" : "false";
    case "number":
      return isFinite(e9) ? e9 : "";
    default:
      return "";
  }
};
var t7 = function(e9, n8, t8, o8) {
  return n8 = n8 || "&", t8 = t8 || "=", null === e9 && (e9 = void 0), "object" == typeof e9 ? Object.keys(e9).map(function(o9) {
    var a7 = encodeURIComponent(r7(o9)) + t8;
    return Array.isArray(e9[o9]) ? e9[o9].map(function(e10) {
      return a7 + encodeURIComponent(r7(e10));
    }).join(n8) : a7 + encodeURIComponent(r7(e9[o9]));
  }).join(n8) : o8 ? encodeURIComponent(r7(o8)) + t8 + encodeURIComponent(r7(e9)) : "";
};
var o6 = {};
o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
o6.decode;
o6.encode;
o6.parse;
o6.stringify;

// node_modules/@jspm/core/nodelibs/browser/url.js
var h7 = {};
var e8 = p5;
var a6 = { isString: function(t8) {
  return "string" == typeof t8;
}, isObject: function(t8) {
  return "object" == typeof t8 && null !== t8;
}, isNull: function(t8) {
  return null === t8;
}, isNullOrUndefined: function(t8) {
  return null == t8;
} };
function r8() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
h7.parse = O4, h7.resolve = function(t8, s6) {
  return O4(t8, false, true).resolve(s6);
}, h7.resolveObject = function(t8, s6) {
  return t8 ? O4(t8, false, true).resolveObject(s6) : s6;
}, h7.format = function(t8) {
  a6.isString(t8) && (t8 = O4(t8));
  return t8 instanceof r8 ? t8.format() : r8.prototype.format.call(t8);
}, h7.Url = r8;
var o7 = /^([a-z0-9.+-]+:)/i;
var n7 = /:[0-9]*$/;
var i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
var p6 = ["'"].concat(l6);
var c6 = ["%", "/", "?", ";", "#"].concat(p6);
var u6 = ["/", "?", "#"];
var f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
var m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var v6 = { javascript: true, "javascript:": true };
var g4 = { javascript: true, "javascript:": true };
var y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
var b4 = o6;
function O4(t8, s6, h8) {
  if (t8 && a6.isObject(t8) && t8 instanceof r8)
    return t8;
  var e9 = new r8();
  return e9.parse(t8, s6, h8), e9;
}
r8.prototype.parse = function(t8, s6, h8) {
  if (!a6.isString(t8))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t8);
  var r9 = t8.indexOf("?"), n8 = -1 !== r9 && r9 < t8.indexOf("#") ? "?" : "#", l7 = t8.split(n8);
  l7[0] = l7[0].replace(/\\/g, "/");
  var O5 = t8 = l7.join(n8);
  if (O5 = O5.trim(), !h8 && 1 === t8.split("#").length) {
    var d6 = i6.exec(O5);
    if (d6)
      return this.path = O5, this.href = O5, this.pathname = d6[1], d6[2] ? (this.search = d6[2], this.query = s6 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s6 && (this.search = "", this.query = {}), this;
  }
  var j4 = o7.exec(O5);
  if (j4) {
    var q3 = (j4 = j4[0]).toLowerCase();
    this.protocol = q3, O5 = O5.substr(j4.length);
  }
  if (h8 || j4 || O5.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var x4 = "//" === O5.substr(0, 2);
    !x4 || j4 && g4[j4] || (O5 = O5.substr(2), this.slashes = true);
  }
  if (!g4[j4] && (x4 || j4 && !y5[j4])) {
    for (var A4, C4, I4 = -1, w4 = 0; w4 < u6.length; w4++) {
      -1 !== (N4 = O5.indexOf(u6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
    }
    -1 !== (C4 = -1 === I4 ? O5.lastIndexOf("@") : O5.lastIndexOf("@", I4)) && (A4 = O5.slice(0, C4), O5 = O5.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
    for (w4 = 0; w4 < c6.length; w4++) {
      var N4;
      -1 !== (N4 = O5.indexOf(c6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
    }
    -1 === I4 && (I4 = O5.length), this.host = O5.slice(0, I4), O5 = O5.slice(I4), this.parseHost(), this.hostname = this.hostname || "";
    var U4 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
    if (!U4)
      for (var k4 = this.hostname.split(/\./), S4 = (w4 = 0, k4.length); w4 < S4; w4++) {
        var R4 = k4[w4];
        if (R4 && !R4.match(f6)) {
          for (var $3 = "", z4 = 0, H3 = R4.length; z4 < H3; z4++)
            R4.charCodeAt(z4) > 127 ? $3 += "x" : $3 += R4[z4];
          if (!$3.match(f6)) {
            var L4 = k4.slice(0, w4), Z3 = k4.slice(w4 + 1), _4 = R4.match(m5);
            _4 && (L4.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O5 = "/" + Z3.join(".") + O5), this.hostname = L4.join(".");
            break;
          }
        }
      }
    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U4 || (this.hostname = e8.toASCII(this.hostname));
    var E4 = this.port ? ":" + this.port : "", P4 = this.hostname || "";
    this.host = P4 + E4, this.href += this.host, U4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O5[0] && (O5 = "/" + O5));
  }
  if (!v6[q3])
    for (w4 = 0, S4 = p6.length; w4 < S4; w4++) {
      var T5 = p6[w4];
      if (-1 !== O5.indexOf(T5)) {
        var B4 = encodeURIComponent(T5);
        B4 === T5 && (B4 = escape(T5)), O5 = O5.split(T5).join(B4);
      }
    }
  var D4 = O5.indexOf("#");
  -1 !== D4 && (this.hash = O5.substr(D4), O5 = O5.slice(0, D4));
  var F4 = O5.indexOf("?");
  if (-1 !== F4 ? (this.search = O5.substr(F4), this.query = O5.substr(F4 + 1), s6 && (this.query = b4.parse(this.query)), O5 = O5.slice(0, F4)) : s6 && (this.search = "", this.query = {}), O5 && (this.pathname = O5), y5[q3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    E4 = this.pathname || "";
    var G3 = this.search || "";
    this.path = E4 + G3;
  }
  return this.href = this.format(), this;
}, r8.prototype.format = function() {
  var t8 = this.auth || "";
  t8 && (t8 = (t8 = encodeURIComponent(t8)).replace(/%3A/i, ":"), t8 += "@");
  var s6 = this.protocol || "", h8 = this.pathname || "", e9 = this.hash || "", r9 = false, o8 = "";
  this.host ? r9 = t8 + this.host : this.hostname && (r9 = t8 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r9 += ":" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o8 = b4.stringify(this.query));
  var n8 = this.search || o8 && "?" + o8 || "";
  return s6 && ":" !== s6.substr(-1) && (s6 += ":"), this.slashes || (!s6 || y5[s6]) && false !== r9 ? (r9 = "//" + (r9 || ""), h8 && "/" !== h8.charAt(0) && (h8 = "/" + h8)) : r9 || (r9 = ""), e9 && "#" !== e9.charAt(0) && (e9 = "#" + e9), n8 && "?" !== n8.charAt(0) && (n8 = "?" + n8), s6 + r9 + (h8 = h8.replace(/[?#]/g, function(t9) {
    return encodeURIComponent(t9);
  })) + (n8 = n8.replace("#", "%23")) + e9;
}, r8.prototype.resolve = function(t8) {
  return this.resolveObject(O4(t8, false, true)).format();
}, r8.prototype.resolveObject = function(t8) {
  if (a6.isString(t8)) {
    var s6 = new r8();
    s6.parse(t8, false, true), t8 = s6;
  }
  for (var h8 = new r8(), e9 = Object.keys(this), o8 = 0; o8 < e9.length; o8++) {
    var n8 = e9[o8];
    h8[n8] = this[n8];
  }
  if (h8.hash = t8.hash, "" === t8.href)
    return h8.href = h8.format(), h8;
  if (t8.slashes && !t8.protocol) {
    for (var i7 = Object.keys(t8), l7 = 0; l7 < i7.length; l7++) {
      var p7 = i7[l7];
      "protocol" !== p7 && (h8[p7] = t8[p7]);
    }
    return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = "/"), h8.href = h8.format(), h8;
  }
  if (t8.protocol && t8.protocol !== h8.protocol) {
    if (!y5[t8.protocol]) {
      for (var c7 = Object.keys(t8), u7 = 0; u7 < c7.length; u7++) {
        var f7 = c7[u7];
        h8[f7] = t8[f7];
      }
      return h8.href = h8.format(), h8;
    }
    if (h8.protocol = t8.protocol, t8.host || g4[t8.protocol])
      h8.pathname = t8.pathname;
    else {
      for (var m6 = (t8.pathname || "").split("/"); m6.length && !(t8.host = m6.shift()); )
        ;
      t8.host || (t8.host = ""), t8.hostname || (t8.hostname = ""), "" !== m6[0] && m6.unshift(""), m6.length < 2 && m6.unshift(""), h8.pathname = m6.join("/");
    }
    if (h8.search = t8.search, h8.query = t8.query, h8.host = t8.host || "", h8.auth = t8.auth, h8.hostname = t8.hostname || t8.host, h8.port = t8.port, h8.pathname || h8.search) {
      var v7 = h8.pathname || "", b5 = h8.search || "";
      h8.path = v7 + b5;
    }
    return h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
  }
  var O5 = h8.pathname && "/" === h8.pathname.charAt(0), d6 = t8.host || t8.pathname && "/" === t8.pathname.charAt(0), j4 = d6 || O5 || h8.host && t8.pathname, q3 = j4, x4 = h8.pathname && h8.pathname.split("/") || [], A4 = (m6 = t8.pathname && t8.pathname.split("/") || [], h8.protocol && !y5[h8.protocol]);
  if (A4 && (h8.hostname = "", h8.port = null, h8.host && ("" === x4[0] ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = "", t8.protocol && (t8.hostname = null, t8.port = null, t8.host && ("" === m6[0] ? m6[0] = t8.host : m6.unshift(t8.host)), t8.host = null), j4 = j4 && ("" === m6[0] || "" === x4[0])), d6)
    h8.host = t8.host || "" === t8.host ? t8.host : h8.host, h8.hostname = t8.hostname || "" === t8.hostname ? t8.hostname : h8.hostname, h8.search = t8.search, h8.query = t8.query, x4 = m6;
  else if (m6.length)
    x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t8.search, h8.query = t8.query;
  else if (!a6.isNullOrUndefined(t8.search)) {
    if (A4)
      h8.hostname = h8.host = x4.shift(), (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift());
    return h8.search = t8.search, h8.query = t8.query, a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.href = h8.format(), h8;
  }
  if (!x4.length)
    return h8.pathname = null, h8.search ? h8.path = "/" + h8.search : h8.path = null, h8.href = h8.format(), h8;
  for (var C4 = x4.slice(-1)[0], I4 = (h8.host || t8.host || x4.length > 1) && ("." === C4 || ".." === C4) || "" === C4, w4 = 0, N4 = x4.length; N4 >= 0; N4--)
    "." === (C4 = x4[N4]) ? x4.splice(N4, 1) : ".." === C4 ? (x4.splice(N4, 1), w4++) : w4 && (x4.splice(N4, 1), w4--);
  if (!j4 && !q3)
    for (; w4--; w4)
      x4.unshift("..");
  !j4 || "" === x4[0] || x4[0] && "/" === x4[0].charAt(0) || x4.unshift(""), I4 && "/" !== x4.join("/").substr(-1) && x4.push("");
  var U4, k4 = "" === x4[0] || x4[0] && "/" === x4[0].charAt(0);
  A4 && (h8.hostname = h8.host = k4 ? "" : x4.length ? x4.shift() : "", (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift()));
  return (j4 = j4 || h8.host && x4.length) && !k4 && x4.unshift(""), x4.length ? h8.pathname = x4.join("/") : (h8.pathname = null, h8.path = null), a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.auth = t8.auth || h8.auth, h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
}, r8.prototype.parseHost = function() {
  var t8 = this.host, s6 = n7.exec(t8);
  s6 && (":" !== (s6 = s6[0]) && (this.port = s6.substr(1)), t8 = t8.substr(0, t8.length - s6.length)), t8 && (this.hostname = t8);
};
h7.Url;
h7.format;
h7.resolve;
h7.resolveObject;
var exports8 = {};
var _dewExec8 = false;
function dew8() {
  if (_dewExec8)
    return exports8;
  _dewExec8 = true;
  var process3 = T;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve4() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd2 === void 0)
            cwd2 = process3.cwd();
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute2)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = "";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports8 = posix2;
  return exports8;
}
var path = dew8();
var processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
h7.URL = typeof URL !== "undefined" ? URL : null;
h7.pathToFileURL = pathToFileURL$1;
h7.fileURLToPath = fileURLToPath$1;
h7.Url;
h7.format;
h7.resolve;
h7.resolveObject;
h7.URL;
var CHAR_BACKWARD_SLASH$1 = 92;
var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;
var isWindows$1 = processPlatform$1 === "win32";
var forwardSlashRegEx$1 = /\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\/g;
var newlineRegEx$1 = /\n/g;
var carriageReturnRegEx$1 = /\r/g;
var tabRegEx$1 = /\t/g;
function fileURLToPath$1(path2) {
  if (typeof path2 === "string")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
}
function getPathFromURLWin$1(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === "%") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n8 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === "%") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$1, "%25");
  if (!isWindows$1 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$1, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$1, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
h7.URL = typeof URL !== "undefined" ? URL : null;
h7.pathToFileURL = pathToFileURL;
h7.fileURLToPath = fileURLToPath;
var Url = h7.Url;
var format4 = h7.format;
var resolve3 = h7.resolve;
var resolveObject = h7.resolveObject;
var parse2 = h7.parse;
var _URL = h7.URL;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;
var isWindows = processPlatform === "win32";
var forwardSlashRegEx = /\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function fileURLToPath(path2) {
  if (typeof path2 === "string")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
}
function getPathFromURLWin(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === "%") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n8 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === "%") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports4.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports4.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}

// node_modules/@jspm/core/nodelibs/browser/fs.js
init_buffer();
var exports$h = {};
var _dewExec$f2 = false;
function dew$f2() {
  if (_dewExec$f2)
    return exports$h;
  _dewExec$f2 = true;
  Object.defineProperty(exports$h, "__esModule", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}
var exports$g2 = {};
var _dewExec$e2 = false;
function dew$e2() {
  if (_dewExec$e2)
    return exports$g2;
  _dewExec$e2 = true;
  if (typeof BigInt === "function")
    exports$g2.default = BigInt;
  else
    exports$g2.default = function BigIntNotSupported() {
      throw new Error("BigInt is not supported in this environment.");
    };
  return exports$g2;
}
var exports$f2 = {};
var _dewExec$d2 = false;
function dew$d2() {
  if (_dewExec$d2)
    return exports$f2;
  _dewExec$d2 = true;
  Object.defineProperty(exports$f2, "__esModule", {
    value: true
  });
  exports$f2.Stats = void 0;
  var constants_1 = dew$f2();
  var getBigInt_1 = dew$e2();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Stats2 = function() {
    function Stats3() {
    }
    Stats3.build = function(node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var stats = new Stats3();
      var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
      var getStatNumber = !bigint ? function(number) {
        return number;
      } : getBigInt_1.default;
      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };
    Stats3.prototype._checkModeProperty = function(property) {
      return (Number(this.mode) & S_IFMT) === property;
    };
    Stats3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR);
    };
    Stats3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG);
    };
    Stats3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK);
    };
    Stats3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR);
    };
    Stats3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK);
    };
    Stats3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO);
    };
    Stats3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK);
    };
    return Stats3;
  }();
  exports$f2.Stats = Stats2;
  exports$f2.default = Stats2;
  return exports$f2;
}
var exports$e2 = {};
var _dewExec$c3 = false;
function dew$c3() {
  if (_dewExec$c3)
    return exports$e2;
  _dewExec$c3 = true;
  var __spreadArray = exports$e2 && exports$e2.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$e2, "__esModule", {
    value: true
  });
  exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e2, "Buffer", {
    enumerable: true,
    get: function() {
      return buffer_1.Buffer;
    }
  });
  function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }
  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e2.bufferFrom = bufferFrom;
  return exports$e2;
}
var exports$d3 = {};
var _dewExec$b3 = false;
var _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$b3() {
  if (_dewExec$b3)
    return exports$d3;
  _dewExec$b3 = true;
  var __extends = exports$d3 && exports$d3.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$d3, "__esModule", {
    value: true
  });
  exports$d3.E = exports$d3.AssertionError = exports$d3.message = exports$d3.RangeError = exports$d3.TypeError = exports$d3.Error = void 0;
  var assert2 = et;
  var util = X;
  var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
  var messages = {};
  function makeNodeError(Base) {
    return function(_super) {
      __extends(NodeError, _super);
      function NodeError(key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, message(key, args)) || this;
        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
        return _this;
      }
      return NodeError;
    }(Base);
  }
  var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
  var AssertionError2 = function(_super) {
    __extends(AssertionError3, _super);
    function AssertionError3(options) {
      var _this = this;
      if (typeof options !== "object" || options === null) {
        throw new exports$d3.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
      }
      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
      }
      _this.generatedMessage = !options.message;
      _this.name = "AssertionError [ERR_ASSERTION]";
      _this.code = "ERR_ASSERTION";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d3.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }
    return AssertionError3;
  }(g5.Error);
  exports$d3.AssertionError = AssertionError2;
  function message(key, args) {
    assert2.strictEqual(typeof key, "string");
    var msg = messages[key];
    assert2(msg, "An invalid error message key was used: " + key + ".");
    var fmt;
    if (typeof msg === "function") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === void 0 || args.length === 0)
        return msg;
      args.unshift(msg);
    }
    return String(fmt.apply(null, args));
  }
  exports$d3.message = message;
  function E4(sym, val) {
    messages[sym] = typeof val === "function" ? val : String(val);
  }
  exports$d3.E = E4;
  exports$d3.Error = makeNodeError(g5.Error);
  exports$d3.TypeError = makeNodeError(g5.TypeError);
  exports$d3.RangeError = makeNodeError(g5.RangeError);
  E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
  E4("ERR_ASSERTION", "%s");
  E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
  E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
  E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
  E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
  E4("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
    return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
  });
  E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
  E4("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
    return 'The "' + enc + '" encoding is not supported';
  });
  E4("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
    return "The encoded data was not valid for encoding " + enc;
  });
  E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
  E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
  E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
  E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
  E4("ERR_INVALID_ARG_TYPE", invalidArgType);
  E4("ERR_INVALID_ARRAY_LENGTH", function(name2, len, actual) {
    assert2.strictEqual(typeof actual, "number");
    return 'The array "' + name2 + '" (length ' + actual + ") must be of length " + len + ".";
  });
  E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
  E4("ERR_INVALID_CALLBACK", "Callback must be a function");
  E4("ERR_INVALID_CHAR", "Invalid character in %s");
  E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
  E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
  E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
  E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
  E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
  E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
  E4("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + String(value) + '" is invalid for option "' + name2 + '"';
  });
  E4("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
    return 'The value "' + String(value) + '" is invalid for option "encoding"';
  });
  E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
  E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
  E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
  E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
  E4("ERR_INVALID_URL", "Invalid URL: %s");
  E4("ERR_INVALID_URL_SCHEME", function(expected) {
    return "The URL must be " + oneOf(expected, "scheme");
  });
  E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
  E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
  E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
  E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
  E4("ERR_MISSING_ARGS", missingArgs);
  E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
  E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
  E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
  E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
  E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
  E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
  E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
  E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
  E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
  E4("ERR_SOCKET_CLOSED", "Socket is closed");
  E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
  E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
  E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
  E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
  E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
  E4("ERR_TLS_DH_PARAM_SIZE", function(size) {
    return "DH parameter size " + size + " is less than 2048";
  });
  E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
  E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
  E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
  E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
  E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
  E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
  E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
  E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
  E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
  E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
  E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function invalidArgType(name2, expected, actual) {
    assert2(name2, "name is required");
    var determiner;
    if (expected.includes("not ")) {
      determiner = "must not be";
      expected = expected.split("not ")[1];
    } else {
      determiner = "must be";
    }
    var msg;
    if (Array.isArray(name2)) {
      var names = name2.map(function(val) {
        return '"' + val + '"';
      }).join(", ");
      msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
    } else if (name2.includes(" argument")) {
      msg = "The " + name2 + " " + determiner + " " + oneOf(expected, "type");
    } else {
      var type2 = name2.includes(".") ? "property" : "argument";
      msg = 'The "' + name2 + '" ' + type2 + " " + determiner + " " + oneOf(expected, "type");
    }
    if (arguments.length >= 3) {
      msg += ". Received type " + (actual !== null ? typeof actual : "null");
    }
    return msg;
  }
  function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    assert2(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a7) {
      return '"' + a7 + '"';
    });
    switch (len) {
      case 1:
        msg += args[0] + " argument";
        break;
      case 2:
        msg += args[0] + " and " + args[1] + " arguments";
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and " + args[len - 1] + " arguments";
        break;
    }
    return msg + " must be specified";
  }
  function oneOf(expected, thing) {
    assert2(expected, "expected is required");
    assert2(typeof thing === "string", "thing is required");
    if (Array.isArray(expected)) {
      var len = expected.length;
      assert2(len > 0, "At least one expected value needs to be specified");
      expected = expected.map(function(i7) {
        return String(i7);
      });
      if (len > 2) {
        return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
      } else if (len === 2) {
        return "one of " + thing + " " + expected[0] + " or " + expected[1];
      } else {
        return "of " + thing + " " + expected[0];
      }
    } else {
      return "of " + thing + " " + String(expected);
    }
  }
  function bufferOutOfBounds(name2, isWriting) {
    if (isWriting) {
      return "Attempt to write outside buffer bounds";
    } else {
      return '"' + name2 + '" is outside of buffer bounds';
    }
  }
  return exports$d3;
}
var exports$c3 = {};
var _dewExec$a3 = false;
function dew$a3() {
  if (_dewExec$a3)
    return exports$c3;
  _dewExec$a3 = true;
  Object.defineProperty(exports$c3, "__esModule", {
    value: true
  });
  exports$c3.strToEncoding = exports$c3.assertEncoding = exports$c3.ENCODING_UTF8 = void 0;
  var buffer_1 = dew$c3();
  var errors = dew$b3();
  exports$c3.ENCODING_UTF8 = "utf8";
  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding))
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
  }
  exports$c3.assertEncoding = assertEncoding;
  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c3.ENCODING_UTF8)
      return str;
    if (encoding === "buffer")
      return new buffer_1.Buffer(str);
    return new buffer_1.Buffer(str).toString(encoding);
  }
  exports$c3.strToEncoding = strToEncoding;
  return exports$c3;
}
var exports$b3 = {};
var _dewExec$93 = false;
function dew$93() {
  if (_dewExec$93)
    return exports$b3;
  _dewExec$93 = true;
  Object.defineProperty(exports$b3, "__esModule", {
    value: true
  });
  exports$b3.Dirent = void 0;
  var constants_1 = dew$f2();
  var encoding_1 = dew$a3();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Dirent2 = function() {
    function Dirent3() {
      this.name = "";
      this.mode = 0;
    }
    Dirent3.build = function(link3, encoding) {
      var dirent = new Dirent3();
      var mode = link3.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link3.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };
    Dirent3.prototype._checkModeProperty = function(property) {
      return (this.mode & S_IFMT) === property;
    };
    Dirent3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR);
    };
    Dirent3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG);
    };
    Dirent3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK);
    };
    Dirent3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR);
    };
    Dirent3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK);
    };
    Dirent3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO);
    };
    Dirent3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK);
    };
    return Dirent3;
  }();
  exports$b3.Dirent = Dirent2;
  exports$b3.default = Dirent2;
  return exports$b3;
}
var exports$a3 = {};
var _dewExec$83 = false;
var _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$83() {
  if (_dewExec$83)
    return exports$a3;
  _dewExec$83 = true;
  var process$1 = process2;
  Object.defineProperty(exports$a3, "__esModule", {
    value: true
  });
  var _setImmediate;
  if (typeof process$1.nextTick === "function")
    _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  else
    _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  exports$a3.default = _setImmediate;
  return exports$a3;
}
var exports$93 = {};
var _dewExec$73 = false;
function dew$73() {
  if (_dewExec$73)
    return exports$93;
  _dewExec$73 = true;
  var process$1 = process2;
  Object.defineProperty(exports$93, "__esModule", {
    value: true
  });
  exports$93.createProcess = void 0;
  var maybeReturnProcess = function() {
    if (typeof process$1 !== "undefined") {
      return process$1;
    }
    try {
      return process2;
    } catch (_a) {
      return void 0;
    }
  };
  function createProcess() {
    var p7 = maybeReturnProcess() || {};
    if (!p7.getuid)
      p7.getuid = function() {
        return 0;
      };
    if (!p7.getgid)
      p7.getgid = function() {
        return 0;
      };
    if (!p7.cwd)
      p7.cwd = function() {
        return "/";
      };
    if (!p7.nextTick)
      p7.nextTick = dew$83().default;
    if (!p7.emitWarning)
      p7.emitWarning = function(message, type2) {
        console.warn("" + type2 + (type2 ? ": " : "") + message);
      };
    if (!p7.env)
      p7.env = {};
    return p7;
  }
  exports$93.createProcess = createProcess;
  exports$93.default = createProcess();
  return exports$93;
}
var exports$83 = {};
var _dewExec$63 = false;
function dew$63() {
  if (_dewExec$63)
    return exports$83;
  _dewExec$63 = true;
  var __extends = exports$83 && exports$83.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$83, "__esModule", {
    value: true
  });
  exports$83.File = exports$83.Link = exports$83.Node = exports$83.SEP = void 0;
  var process_1 = dew$73();
  var buffer_1 = dew$c3();
  var constants_1 = dew$f2();
  var events_1 = y;
  var Stats_1 = dew$d2();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
  exports$83.SEP = "/";
  var Node = function(_super) {
    __extends(Node2, _super);
    function Node2(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }
      var _this = _super.call(this) || this;
      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = /* @__PURE__ */ new Date();
      _this.mtime = /* @__PURE__ */ new Date();
      _this.ctime = /* @__PURE__ */ new Date();
      _this.perm = 438;
      _this.mode = S_IFREG;
      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }
    Node2.prototype.getString = function(encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return this.getBuffer().toString(encoding);
    };
    Node2.prototype.setString = function(str) {
      this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
      this.touch();
    };
    Node2.prototype.getBuffer = function() {
      if (!this.buf)
        this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf);
    };
    Node2.prototype.setBuffer = function(buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf);
      this.touch();
    };
    Node2.prototype.getSize = function() {
      return this.buf ? this.buf.length : 0;
    };
    Node2.prototype.setModeProperty = function(property) {
      this.mode = this.mode & ~S_IFMT | property;
    };
    Node2.prototype.setIsFile = function() {
      this.setModeProperty(S_IFREG);
    };
    Node2.prototype.setIsDirectory = function() {
      this.setModeProperty(S_IFDIR);
    };
    Node2.prototype.setIsSymlink = function() {
      this.setModeProperty(S_IFLNK);
    };
    Node2.prototype.isFile = function() {
      return (this.mode & S_IFMT) === S_IFREG;
    };
    Node2.prototype.isDirectory = function() {
      return (this.mode & S_IFMT) === S_IFDIR;
    };
    Node2.prototype.isSymlink = function() {
      return (this.mode & S_IFMT) === S_IFLNK;
    };
    Node2.prototype.makeSymlink = function(steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };
    Node2.prototype.write = function(buf, off2, len, pos) {
      if (off2 === void 0) {
        off2 = 0;
      }
      if (len === void 0) {
        len = buf.length;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }
      buf.copy(this.buf, pos, off2, off2 + len);
      this.touch();
      return len;
    };
    Node2.prototype.read = function(buf, off2, len, pos) {
      if (off2 === void 0) {
        off2 = 0;
      }
      if (len === void 0) {
        len = buf.byteLength;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;
      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }
      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }
      this.buf.copy(buf, off2, pos, pos + actualLen);
      return actualLen;
    };
    Node2.prototype.truncate = function(len) {
      if (len === void 0) {
        len = 0;
      }
      if (!len)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      else {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };
    Node2.prototype.chmod = function(perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };
    Node2.prototype.chown = function(uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };
    Node2.prototype.touch = function() {
      this.mtime = /* @__PURE__ */ new Date();
      this.emit("change", this);
    };
    Node2.prototype.canRead = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 4) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 32) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 256) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.canWrite = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 2) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 16) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 128) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.del = function() {
      this.emit("delete", this);
    };
    Node2.prototype.toJSON = function() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };
    return Node2;
  }(events_1.EventEmitter);
  exports$83.Node = Node;
  var Link = function(_super) {
    __extends(Link2, _super);
    function Link2(vol2, parent, name2) {
      var _this = _super.call(this) || this;
      _this.children = {};
      _this.steps = [];
      _this.ino = 0;
      _this.length = 0;
      _this.vol = vol2;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name2]) : [name2];
      return _this;
    }
    Link2.prototype.setNode = function(node) {
      this.node = node;
      this.ino = node.ino;
    };
    Link2.prototype.getNode = function() {
      return this.node;
    };
    Link2.prototype.createChild = function(name2, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }
      var link3 = new Link2(this.vol, this, name2);
      link3.setNode(node);
      if (node.isDirectory())
        ;
      this.setChild(name2, link3);
      return link3;
    };
    Link2.prototype.setChild = function(name2, link3) {
      if (link3 === void 0) {
        link3 = new Link2(this.vol, this, name2);
      }
      this.children[name2] = link3;
      link3.parent = this;
      this.length++;
      this.emit("child:add", link3, this);
      return link3;
    };
    Link2.prototype.deleteChild = function(link3) {
      delete this.children[link3.getName()];
      this.length--;
      this.emit("child:delete", link3, this);
    };
    Link2.prototype.getChild = function(name2) {
      if (Object.hasOwnProperty.call(this.children, name2)) {
        return this.children[name2];
      }
    };
    Link2.prototype.getPath = function() {
      return this.steps.join(exports$83.SEP);
    };
    Link2.prototype.getName = function() {
      return this.steps[this.steps.length - 1];
    };
    Link2.prototype.walk = function(steps, stop, i7) {
      if (stop === void 0) {
        stop = steps.length;
      }
      if (i7 === void 0) {
        i7 = 0;
      }
      if (i7 >= steps.length)
        return this;
      if (i7 >= stop)
        return this;
      var step = steps[i7];
      var link3 = this.getChild(step);
      if (!link3)
        return null;
      return link3.walk(steps, stop, i7 + 1);
    };
    Link2.prototype.toJSON = function() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };
    return Link2;
  }(events_1.EventEmitter);
  exports$83.Link = Link;
  var File = function() {
    function File2(link3, node, flags, fd) {
      this.position = 0;
      this.link = link3;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }
    File2.prototype.getString = function(encoding) {
      return this.node.getString();
    };
    File2.prototype.setString = function(str) {
      this.node.setString(str);
    };
    File2.prototype.getBuffer = function() {
      return this.node.getBuffer();
    };
    File2.prototype.setBuffer = function(buf) {
      this.node.setBuffer(buf);
    };
    File2.prototype.getSize = function() {
      return this.node.getSize();
    };
    File2.prototype.truncate = function(len) {
      this.node.truncate(len);
    };
    File2.prototype.seekTo = function(position) {
      this.position = position;
    };
    File2.prototype.stats = function() {
      return Stats_1.default.build(this.node);
    };
    File2.prototype.write = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.length;
      }
      if (typeof position !== "number")
        position = this.position;
      if (this.flags & O_APPEND)
        position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.read = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.byteLength;
      }
      if (typeof position !== "number")
        position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.chmod = function(perm) {
      this.node.chmod(perm);
    };
    File2.prototype.chown = function(uid, gid) {
      this.node.chown(uid, gid);
    };
    return File2;
  }();
  exports$83.File = File;
  return exports$83;
}
var exports$73 = {};
var _dewExec$53 = false;
var _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$53() {
  if (_dewExec$53)
    return exports$73;
  _dewExec$53 = true;
  Object.defineProperty(exports$73, "__esModule", {
    value: true
  });
  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
    if (ref && typeof ref === "object" && typeof ref.unref === "function")
      ref.unref();
    return ref;
  }
  exports$73.default = setTimeoutUnref;
  return exports$73;
}
var exports$63 = {};
var _dewExec$43 = false;
function dew$43() {
  if (_dewExec$43)
    return exports$63;
  _dewExec$43 = true;
  var __spreadArray = exports$63 && exports$63.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$63, "__esModule", {
    value: true
  });
  exports$63.FileHandle = void 0;
  function promisify3(vol2, fn, getResult) {
    if (getResult === void 0) {
      getResult = function(input) {
        return input;
      };
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new Promise(function(resolve4, reject) {
        vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
          if (error)
            return reject(error);
          return resolve4(getResult(result));
        }], false));
      });
    };
  }
  var FileHandle = function() {
    function FileHandle2(vol2, fd) {
      this.vol = vol2;
      this.fd = fd;
    }
    FileHandle2.prototype.appendFile = function(data, options) {
      return promisify3(this.vol, "appendFile")(this.fd, data, options);
    };
    FileHandle2.prototype.chmod = function(mode) {
      return promisify3(this.vol, "fchmod")(this.fd, mode);
    };
    FileHandle2.prototype.chown = function(uid, gid) {
      return promisify3(this.vol, "fchown")(this.fd, uid, gid);
    };
    FileHandle2.prototype.close = function() {
      return promisify3(this.vol, "close")(this.fd);
    };
    FileHandle2.prototype.datasync = function() {
      return promisify3(this.vol, "fdatasync")(this.fd);
    };
    FileHandle2.prototype.read = function(buffer2, offset, length, position) {
      return promisify3(this.vol, "read", function(bytesRead) {
        return {
          bytesRead,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.readFile = function(options) {
      return promisify3(this.vol, "readFile")(this.fd, options);
    };
    FileHandle2.prototype.stat = function(options) {
      return promisify3(this.vol, "fstat")(this.fd, options);
    };
    FileHandle2.prototype.sync = function() {
      return promisify3(this.vol, "fsync")(this.fd);
    };
    FileHandle2.prototype.truncate = function(len) {
      return promisify3(this.vol, "ftruncate")(this.fd, len);
    };
    FileHandle2.prototype.utimes = function(atime, mtime) {
      return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
    };
    FileHandle2.prototype.write = function(buffer2, offset, length, position) {
      return promisify3(this.vol, "write", function(bytesWritten) {
        return {
          bytesWritten,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.writeFile = function(data, options) {
      return promisify3(this.vol, "writeFile")(this.fd, data, options);
    };
    return FileHandle2;
  }();
  exports$63.FileHandle = FileHandle;
  function createPromisesApi(vol2) {
    if (typeof Promise === "undefined")
      return null;
    return {
      FileHandle,
      access: function(path2, mode) {
        return promisify3(vol2, "access")(path2, mode);
      },
      appendFile: function(path2, data, options) {
        return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
      },
      chmod: function(path2, mode) {
        return promisify3(vol2, "chmod")(path2, mode);
      },
      chown: function(path2, uid, gid) {
        return promisify3(vol2, "chown")(path2, uid, gid);
      },
      copyFile: function(src, dest, flags) {
        return promisify3(vol2, "copyFile")(src, dest, flags);
      },
      lchmod: function(path2, mode) {
        return promisify3(vol2, "lchmod")(path2, mode);
      },
      lchown: function(path2, uid, gid) {
        return promisify3(vol2, "lchown")(path2, uid, gid);
      },
      link: function(existingPath, newPath) {
        return promisify3(vol2, "link")(existingPath, newPath);
      },
      lstat: function(path2, options) {
        return promisify3(vol2, "lstat")(path2, options);
      },
      mkdir: function(path2, options) {
        return promisify3(vol2, "mkdir")(path2, options);
      },
      mkdtemp: function(prefix, options) {
        return promisify3(vol2, "mkdtemp")(prefix, options);
      },
      open: function(path2, flags, mode) {
        return promisify3(vol2, "open", function(fd) {
          return new FileHandle(vol2, fd);
        })(path2, flags, mode);
      },
      readdir: function(path2, options) {
        return promisify3(vol2, "readdir")(path2, options);
      },
      readFile: function(id, options) {
        return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function(path2, options) {
        return promisify3(vol2, "readlink")(path2, options);
      },
      realpath: function(path2, options) {
        return promisify3(vol2, "realpath")(path2, options);
      },
      rename: function(oldPath, newPath) {
        return promisify3(vol2, "rename")(oldPath, newPath);
      },
      rmdir: function(path2) {
        return promisify3(vol2, "rmdir")(path2);
      },
      stat: function(path2, options) {
        return promisify3(vol2, "stat")(path2, options);
      },
      symlink: function(target, path2, type2) {
        return promisify3(vol2, "symlink")(target, path2, type2);
      },
      truncate: function(path2, len) {
        return promisify3(vol2, "truncate")(path2, len);
      },
      unlink: function(path2) {
        return promisify3(vol2, "unlink")(path2);
      },
      utimes: function(path2, atime, mtime) {
        return promisify3(vol2, "utimes")(path2, atime, mtime);
      },
      writeFile: function(id, data, options) {
        return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }
  exports$63.default = createPromisesApi;
  return exports$63;
}
var exports$53 = {};
var _dewExec$33 = false;
function dew$33() {
  if (_dewExec$33)
    return exports$53;
  _dewExec$33 = true;
  var process$1 = process2;
  Object.defineProperty(exports$53, "__esModule", {
    value: true
  });
  exports$53.unixify = unixify;
  exports$53.correctPath = correctPath;
  var isWin = process$1.platform === "win32";
  function removeTrailingSeparator(str) {
    var i7 = str.length - 1;
    if (i7 < 2) {
      return str;
    }
    while (isSeparator(str, i7)) {
      i7--;
    }
    return str.substr(0, i7 + 1);
  }
  function isSeparator(str, i7) {
    var _char = str[i7];
    return i7 > 0 && (_char === "/" || isWin && _char === "\\");
  }
  function normalizePath(str, stripTrailing) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    str = str.replace(/[\\\/]+/g, "/");
    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }
    return str;
  }
  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
    }
    return filepath;
  }
  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
  }
  return exports$53;
}
var exports$43 = {};
var _dewExec$24 = false;
var _global5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$24() {
  if (_dewExec$24)
    return exports$43;
  _dewExec$24 = true;
  var __extends = exports$43 && exports$43.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  var __spreadArray = exports$43 && exports$43.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$43, "__esModule", {
    value: true
  });
  exports$43.FSWatcher = exports$43.StatWatcher = exports$43.Volume = exports$43.toUnixTimestamp = exports$43.bufferToEncoding = exports$43.dataToBuffer = exports$43.dataToStr = exports$43.pathToSteps = exports$43.filenameToSteps = exports$43.pathToFilename = exports$43.flagsToNumber = exports$43.FLAGS = void 0;
  var pathModule = exports4;
  var node_1 = dew$63();
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$93();
  var buffer_1 = dew$c3();
  var setImmediate_1 = dew$83();
  var process_1 = dew$73();
  var setTimeoutUnref_1 = dew$53();
  var stream_1 = exports6;
  var constants_1 = dew$f2();
  var events_1 = y;
  var encoding_1 = dew$a3();
  var errors = dew$b3();
  var util = X;
  var promises_1 = dew$43();
  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
  var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
  var isWin = process_1.default.platform === "win32";
  var kMinPoolSpace = 128;
  var ERRSTR = {
    PATH_STR: "path must be a string or Buffer",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  };
  var ERRSTR_OPTS = function(tipeof) {
    return "Expected options to be either an object or a string, but got " + tipeof + " instead";
  };
  var ENOENT = "ENOENT";
  var EBADF = "EBADF";
  var EINVAL = "EINVAL";
  var EPERM = "EPERM";
  var EPROTO = "EPROTO";
  var EEXIST = "EEXIST";
  var ENOTDIR = "ENOTDIR";
  var EMFILE = "EMFILE";
  var EACCES = "EACCES";
  var EISDIR = "EISDIR";
  var ENOTEMPTY = "ENOTEMPTY";
  var ENOSYS = "ENOSYS";
  function formatError(errorCode, func, path2, path22) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    var pathFormatted = "";
    if (path2)
      pathFormatted = " '" + path2 + "'";
    if (path22)
      pathFormatted += " -> '" + path22 + "'";
    switch (errorCode) {
      case ENOENT:
        return "ENOENT: no such file or directory, " + func + pathFormatted;
      case EBADF:
        return "EBADF: bad file descriptor, " + func + pathFormatted;
      case EINVAL:
        return "EINVAL: invalid argument, " + func + pathFormatted;
      case EPERM:
        return "EPERM: operation not permitted, " + func + pathFormatted;
      case EPROTO:
        return "EPROTO: protocol error, " + func + pathFormatted;
      case EEXIST:
        return "EEXIST: file already exists, " + func + pathFormatted;
      case ENOTDIR:
        return "ENOTDIR: not a directory, " + func + pathFormatted;
      case EISDIR:
        return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
      case EACCES:
        return "EACCES: permission denied, " + func + pathFormatted;
      case ENOTEMPTY:
        return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
      case EMFILE:
        return "EMFILE: too many open files, " + func + pathFormatted;
      case ENOSYS:
        return "ENOSYS: function not implemented, " + func + pathFormatted;
      default:
        return errorCode + ": error occurred, " + func + pathFormatted;
    }
  }
  function createError(errorCode, func, path2, path22, Constructor) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    if (Constructor === void 0) {
      Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path2, path22));
    error.code = errorCode;
    return error;
  }
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
    FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
    FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
    FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
    FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
    FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
    FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
    FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
    FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
    FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
    FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
    FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
    FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
    FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
    FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
    FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
    FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
    FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
  })(FLAGS = exports$43.FLAGS || (exports$43.FLAGS = {}));
  function flagsToNumber(flags) {
    if (typeof flags === "number")
      return flags;
    if (typeof flags === "string") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== "undefined")
        return flagsNum;
    }
    throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
  }
  exports$43.flagsToNumber = flagsToNumber;
  function getOptions(defaults2, options) {
    var opts;
    if (!options)
      return defaults2;
    else {
      var tipeof = typeof options;
      switch (tipeof) {
        case "string":
          opts = Object.assign({}, defaults2, {
            encoding: options
          });
          break;
        case "object":
          opts = Object.assign({}, defaults2, options);
          break;
        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== "buffer")
      (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }
  function optsGenerator(defaults2) {
    return function(options) {
      return getOptions(defaults2, options);
    };
  }
  function validateCallback(callback) {
    if (typeof callback !== "function")
      throw TypeError(ERRSTR.CB);
    return callback;
  }
  function optsAndCbGenerator(getOpts) {
    return function(options, callback) {
      return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }
  var optsDefaults = {
    encoding: "utf8"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: "r"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511,
    recursive: false
  };
  var getMkdirOptions = function(options) {
    if (typeof options === "number")
      return Object.assign({}, mkdirDefaults, {
        mode: options
      });
    return Object.assign({}, mkdirDefaults, options);
  };
  var rmdirDefaults = {
    recursive: false
  };
  var getRmdirOptions = function(options) {
    return Object.assign({}, rmdirDefaults, options);
  };
  var readdirDefaults = {
    encoding: "utf8",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };
  var getStatOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    return Object.assign({}, statDefaults, options);
  };
  var getStatOptsAndCb = function(options, callback) {
    return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  };
  function getPathFromURLPosix2(url) {
    if (url.hostname !== "") {
      throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        var third = pathname.codePointAt(n8 + 2) | 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFilename(path2) {
    if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
      try {
        if (!(path2 instanceof h7.URL))
          throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }
      path2 = getPathFromURLPosix2(path2);
    }
    var pathString = String(path2);
    nullCheck(pathString);
    return pathString;
  }
  exports$43.pathToFilename = pathToFilename;
  var resolve4 = function(filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
  };
  if (isWin) {
    var _resolve_1 = resolve4;
    var unixify_1 = dew$33().unixify;
    resolve4 = function(filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }
  function filenameToSteps(filename, base) {
    var fullPath = resolve4(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash)
      return [];
    return fullPathSansSlash.split(sep2);
  }
  exports$43.filenameToSteps = filenameToSteps;
  function pathToSteps(path2) {
    return filenameToSteps(pathToFilename(path2));
  }
  exports$43.pathToSteps = pathToSteps;
  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data.toString(encoding);
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else
      return String(data);
  }
  exports$43.dataToStr = dataToStr;
  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data;
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data);
    else
      return (0, buffer_1.bufferFrom)(String(data), encoding);
  }
  exports$43.dataToBuffer = dataToBuffer;
  function bufferToEncoding(buffer2, encoding) {
    if (!encoding || encoding === "buffer")
      return buffer2;
    else
      return buffer2.toString(encoding);
  }
  exports$43.bufferToEncoding = bufferToEncoding;
  function nullCheck(path2, callback) {
    if (("" + path2).indexOf("\0") !== -1) {
      var er = new Error("Path must be a string without null bytes");
      er.code = ENOENT;
      if (typeof callback !== "function")
        throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }
    return true;
  }
  function _modeToNumber(mode, def) {
    if (typeof mode === "number")
      return mode;
    if (typeof mode === "string")
      return parseInt(mode, 8);
    if (def)
      return modeToNumber(def);
    return void 0;
  }
  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== "number" || isNaN(result))
      throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }
  function isFd(path2) {
    return path2 >>> 0 === path2;
  }
  function validateFd(fd) {
    if (!isFd(fd))
      throw TypeError(ERRSTR.FD);
  }
  function toUnixTimestamp(time) {
    if (typeof time === "string" && +time == time) {
      return +time;
    }
    if (time instanceof Date) {
      return time.getTime() / 1e3;
    }
    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      }
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  }
  exports$43.toUnixTimestamp = toUnixTimestamp;
  function validateUid(uid) {
    if (typeof uid !== "number")
      throw TypeError(ERRSTR.UID);
  }
  function validateGid(gid) {
    if (typeof gid !== "number")
      throw TypeError(ERRSTR.GID);
  }
  function flattenJSON(nestedJSON) {
    var flatJSON = {};
    function flatten(pathPrefix, node) {
      for (var path2 in node) {
        var contentOrNode = node[path2];
        var joinedPath = join2(pathPrefix, path2);
        if (typeof contentOrNode === "string") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    flatten("", nestedJSON);
    return flatJSON;
  }
  var Volume = function() {
    function Volume2(props) {
      if (props === void 0) {
        props = {};
      }
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.maxFiles = 1e4;
      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self2 = this;
      this.StatWatcher = function(_super) {
        __extends(StatWatcher2, _super);
        function StatWatcher2() {
          return _super.call(this, self2) || this;
        }
        return StatWatcher2;
      }(StatWatcher);
      var _ReadStream = FsReadStream;
      this.ReadStream = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_1;
      }(_ReadStream);
      var _WriteStream = FsWriteStream;
      this.WriteStream = function(_super) {
        __extends(class_2, _super);
        function class_2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_2;
      }(_WriteStream);
      this.FSWatcher = function(_super) {
        __extends(FSWatcher2, _super);
        function FSWatcher2() {
          return _super.call(this, self2) || this;
        }
        return FSWatcher2;
      }(FSWatcher);
      this.root = root;
    }
    Volume2.fromJSON = function(json, cwd2) {
      var vol2 = new Volume2();
      vol2.fromJSON(json, cwd2);
      return vol2;
    };
    Volume2.fromNestedJSON = function(json, cwd2) {
      var vol2 = new Volume2();
      vol2.fromNestedJSON(json, cwd2);
      return vol2;
    };
    Object.defineProperty(Volume2.prototype, "promises", {
      get: function() {
        if (this.promisesApi === null)
          throw new Error("Promise is not supported in this environment.");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });
    Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      if (!parent) {
        return new this.props.Link(this, null, "");
      }
      if (!name2) {
        throw new Error("createLink: name cannot be empty");
      }
      return parent.createChild(name2, this.createNode(isDirectory, perm));
    };
    Volume2.prototype.deleteLink = function(link3) {
      var parent = link3.parent;
      if (parent) {
        parent.deleteChild(link3);
        return true;
      }
      return false;
    };
    Volume2.prototype.newInoNumber = function() {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd)
        return releasedFd;
      else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };
    Volume2.prototype.newFdNumber = function() {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
    };
    Volume2.prototype.createNode = function(isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory)
        node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };
    Volume2.prototype.getNode = function(ino) {
      return this.inodes[ino];
    };
    Volume2.prototype.deleteNode = function(node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    };
    Volume2.prototype.genRndStr = function() {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6)
        return str;
      else
        return this.genRndStr();
    };
    Volume2.prototype.getLink = function(steps) {
      return this.root.walk(steps);
    };
    Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
      var steps = filenameToSteps(filename);
      var link3 = this.getLink(steps);
      if (!link3)
        throw createError(ENOENT, funcName, filename);
      return link3;
    };
    Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
      var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link3 = this.root;
      var i7 = 0;
      while (i7 < steps.length) {
        var step = steps[i7];
        link3 = link3.getChild(step);
        if (!link3)
          return null;
        var node = link3.getNode();
        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i7 + 1));
          link3 = this.root;
          i7 = 0;
          continue;
        }
        i7++;
      }
      return link3;
    };
    Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
      var link3 = this.getResolvedLink(filename);
      if (!link3)
        throw createError(ENOENT, funcName, filename);
      return link3;
    };
    Volume2.prototype.resolveSymlinks = function(link3) {
      return this.getResolvedLink(link3.steps.slice(1));
    };
    Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
      var link3 = this.getLinkOrThrow(filename, funcName);
      if (!link3.getNode().isDirectory())
        throw createError(ENOTDIR, funcName, filename);
      return link3;
    };
    Volume2.prototype.getLinkParent = function(steps) {
      return this.root.walk(steps, steps.length - 1);
    };
    Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link3 = this.getLinkParent(steps);
      if (!link3)
        throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
      if (!link3.getNode().isDirectory())
        throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
      return link3;
    };
    Volume2.prototype.getFileByFd = function(fd) {
      return this.fds[String(fd)];
    };
    Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF, funcName);
      return file;
    };
    Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
      if (typeof id === "number") {
        var file = this.getFileByFd(id);
        if (!file)
          throw Error("File nto found");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link3 = this.getLink(steps);
        if (link3)
          return link3.getNode();
        if (flags & O_CREAT) {
          var dirLink = this.getLinkParent(steps);
          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link3 = this.createLink(dirLink, name_1, false, perm);
            return link3.getNode();
          }
        }
        throw createError(ENOENT, "getNodeByIdOrCreate", pathToFilename(id));
      }
    };
    Volume2.prototype.wrapAsync = function(method, args, callback) {
      var _this = this;
      validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        var result;
        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    };
    Volume2.prototype._toJSON = function(link3, json, path2) {
      var _a2;
      if (link3 === void 0) {
        link3 = this.root;
      }
      if (json === void 0) {
        json = {};
      }
      var isEmpty = true;
      var children = link3.children;
      if (link3.getNode().isFile()) {
        children = (_a2 = {}, _a2[link3.getName()] = link3.parent.getChild(link3.getName()), _a2);
        link3 = link3.parent;
      }
      for (var name_2 in children) {
        isEmpty = false;
        var child = link3.getChild(name_2);
        if (!child) {
          throw new Error("_toJSON: unexpected undefined");
        }
        var node = child.getNode();
        if (node.isFile()) {
          var filename = child.getPath();
          if (path2)
            filename = relative2(path2, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path2);
        }
      }
      var dirPath = link3.getPath();
      if (path2)
        dirPath = relative2(path2, dirPath);
      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }
      return json;
    };
    Volume2.prototype.toJSON = function(paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }
      if (isRelative === void 0) {
        isRelative = false;
      }
      var links = [];
      if (paths) {
        if (!(paths instanceof Array))
          paths = [paths];
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path2 = paths_1[_i];
          var filename = pathToFilename(path2);
          var link3 = this.getResolvedLink(filename);
          if (!link3)
            continue;
          links.push(link3);
        }
      } else {
        links.push(this.root);
      }
      if (!links.length)
        return json;
      for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
        var link3 = links_1[_a2];
        this._toJSON(link3, json, isRelative ? link3.getPath() : "");
      }
      return json;
    };
    Volume2.prototype.fromJSON = function(json, cwd2) {
      if (cwd2 === void 0) {
        cwd2 = process_1.default.cwd();
      }
      for (var filename in json) {
        var data = json[filename];
        filename = resolve4(filename, cwd2);
        if (typeof data === "string") {
          var dir = dirname2(filename);
          this.mkdirpBase(
            dir,
            511
            /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(
            filename,
            511
            /* DIR */
          );
        }
      }
    };
    Volume2.prototype.fromNestedJSON = function(json, cwd2) {
      this.fromJSON(flattenJSON(json), cwd2);
    };
    Volume2.prototype.reset = function() {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    };
    Volume2.prototype.mountSync = function(mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };
    Volume2.prototype.openLink = function(link3, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      if (this.openFiles >= this.maxFiles) {
        throw createError(EMFILE, "open", link3.getPath());
      }
      var realLink = link3;
      if (resolveSymlinks)
        realLink = this.resolveSymlinks(link3);
      if (!realLink)
        throw createError(ENOENT, "open", link3.getPath());
      var node = realLink.getNode();
      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
          throw createError(EISDIR, "open", link3.getPath());
      } else {
        if (flagsNum & O_DIRECTORY)
          throw createError(ENOTDIR, "open", link3.getPath());
      }
      if (!(flagsNum & O_WRONLY)) {
        if (!node.canRead()) {
          throw createError(EACCES, "open", link3.getPath());
        }
      }
      var file = new this.props.File(link3, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC)
        file.truncate();
      return file;
    };
    Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var steps = filenameToSteps(filename);
      var link3 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
      if (!link3 && flagsNum & O_CREAT) {
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
        if (!dirLink)
          throw createError(ENOENT, "open", sep2 + steps.join(sep2));
        if (flagsNum & O_CREAT && typeof modeNum === "number") {
          link3 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }
      if (link3)
        return this.openLink(link3, flagsNum, resolveSymlinks);
      throw createError(ENOENT, "open", filename);
    };
    Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file)
        throw createError(ENOENT, "open", filename);
      return file.fd;
    };
    Volume2.prototype.openSync = function(path2, flags, mode) {
      if (mode === void 0) {
        mode = 438;
      }
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume2.prototype.open = function(path2, flags, a7, b5) {
      var mode = a7;
      var callback = b5;
      if (typeof a7 === "function") {
        mode = 438;
        callback = a7;
      }
      mode = mode || 438;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume2.prototype.closeFile = function(file) {
      if (!this.fds[file.fd])
        return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };
    Volume2.prototype.closeSync = function(fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, "close");
      this.closeFile(file);
    };
    Volume2.prototype.close = function(fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
      if (typeof id === "number") {
        var file = this.fds[id];
        if (!file)
          throw createError(ENOENT);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };
    Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer2, Number(offset), Number(length), position);
    };
    Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer2, offset, length, position);
    };
    Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
      var _this = this;
      validateCallback(callback);
      if (length === 0) {
        return process_1.default.nextTick(function() {
          if (callback)
            callback(null, 0, buffer2);
        });
      }
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.readBase(fd, buffer2, offset, length, position);
          callback(null, bytes, buffer2);
        } catch (err) {
          callback(err);
        }
      });
    };
    Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === "number";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd)
        fd = id;
      else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link3 = this.getResolvedLink(steps);
        if (link3) {
          var node = link3.getNode();
          if (node.isDirectory())
            throw createError(EISDIR, "open", link3.getPath());
        }
        fd = this.openSync(id, flagsNum);
      }
      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }
      return result;
    };
    Volume2.prototype.readFileSync = function(file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume2.prototype.readFile = function(id, a7, b5) {
      var _a2 = optsAndCbGenerator(getReadFileOptions)(a7, b5), opts = _a2[0], callback = _a2[1];
      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, "write");
      return file.write(buf, offset, length, position);
    };
    Volume2.prototype.writeSync = function(fd, a7, b5, c7, d6) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer4 = typeof a7 !== "string";
      if (isBuffer4) {
        offset = (b5 || 0) | 0;
        length = c7;
        position = d6;
      } else {
        position = b5;
        encoding = c7;
      }
      var buf = dataToBuffer(a7, encoding);
      if (isBuffer4) {
        if (typeof length === "undefined") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return this.writeBase(fd, buf, offset, length, position);
    };
    Volume2.prototype.write = function(fd, a7, b5, c7, d6, e9) {
      var _this = this;
      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a7;
      var tipb = typeof b5;
      var tipc = typeof c7;
      var tipd = typeof d6;
      if (tipa !== "string") {
        if (tipb === "function") {
          callback = b5;
        } else if (tipc === "function") {
          offset = b5 | 0;
          callback = c7;
        } else if (tipd === "function") {
          offset = b5 | 0;
          length = c7;
          callback = d6;
        } else {
          offset = b5 | 0;
          length = c7;
          position = d6;
          callback = e9;
        }
      } else {
        if (tipb === "function") {
          callback = b5;
        } else if (tipc === "function") {
          position = b5;
          callback = c7;
        } else if (tipd === "function") {
          position = b5;
          encoding = c7;
          callback = d6;
        }
      }
      var buf = dataToBuffer(a7, encoding);
      if (tipa !== "string") {
        if (typeof length === "undefined")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);
          if (tipa !== "string") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a7);
          }
        } catch (err) {
          cb(err);
        }
      });
    };
    Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
      var isUserFd = typeof id === "number";
      var fd;
      if (isUserFd)
        fd = id;
      else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND ? void 0 : 0;
      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== void 0)
            position += written;
        }
      } finally {
        if (!isUserFd)
          this.closeSync(fd);
      }
    };
    Volume2.prototype.writeFileSync = function(id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume2.prototype.writeFile = function(id, data, a7, b5) {
      var options = a7;
      var callback = b5;
      if (typeof a7 === "function") {
        options = writeFileDefaults;
        callback = a7;
      }
      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };
    Volume2.prototype.linkBase = function(filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1)
        throw createError(ENOENT, "link", filename1, filename2);
      var steps2 = filenameToSteps(filename2);
      var dir2 = this.getLinkParent(steps2);
      if (!dir2)
        throw createError(ENOENT, "link", filename1, filename2);
      var name2 = steps2[steps2.length - 1];
      if (dir2.getChild(name2))
        throw createError(EEXIST, "link", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name2, node);
    };
    Volume2.prototype.copyFileBase = function(src, dest, flags) {
      var buf = this.readFileSync(src);
      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST, "copyFile", src, dest);
        }
      }
      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS, "copyFile", src, dest);
      }
      this.writeFileBase(
        dest,
        buf,
        FLAGS.w,
        438
        /* DEFAULT */
      );
    };
    Volume2.prototype.copyFileSync = function(src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };
    Volume2.prototype.copyFile = function(src, dest, a7, b5) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;
      if (typeof a7 === "function") {
        flags = 0;
        callback = a7;
      } else {
        flags = a7;
        callback = b5;
      }
      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume2.prototype.linkSync = function(existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume2.prototype.link = function(existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.unlinkBase = function(filename) {
      var steps = filenameToSteps(filename);
      var link3 = this.getLink(steps);
      if (!link3)
        throw createError(ENOENT, "unlink", filename);
      if (link3.length)
        throw Error("Dir not empty...");
      this.deleteLink(link3);
      var node = link3.getNode();
      node.nlink--;
      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };
    Volume2.prototype.unlinkSync = function(path2) {
      var filename = pathToFilename(path2);
      this.unlinkBase(filename);
    };
    Volume2.prototype.unlink = function(path2, callback) {
      var filename = pathToFilename(path2);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename);
      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink)
        throw createError(ENOENT, "symlink", targetFilename, pathFilename);
      var name2 = pathSteps[pathSteps.length - 1];
      if (dirLink.getChild(name2))
        throw createError(EEXIST, "symlink", targetFilename, pathFilename);
      var symlink3 = dirLink.createChild(name2);
      symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink3;
    };
    Volume2.prototype.symlinkSync = function(target, path2, type2) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.symlinkBase(targetFilename, pathFilename);
    };
    Volume2.prototype.symlink = function(target, path2, a7, b5) {
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume2.prototype.realpathBase = function(filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink)
        throw createError(ENOENT, "realpath", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };
    Volume2.prototype.realpathSync = function(path2, options) {
      return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
    };
    Volume2.prototype.realpath = function(path2, a7, b5) {
      var _a2 = getRealpathOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume2.prototype.lstatBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link3 = this.getLink(filenameToSteps(filename));
      if (!link3)
        throw createError(ENOENT, "lstat", filename);
      return Stats_1.default.build(link3.getNode(), bigint);
    };
    Volume2.prototype.lstatSync = function(path2, options) {
      return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.lstat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.statBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link3 = this.getResolvedLink(filenameToSteps(filename));
      if (!link3)
        throw createError(ENOENT, "stat", filename);
      return Stats_1.default.build(link3.getNode(), bigint);
    };
    Volume2.prototype.statSync = function(path2, options) {
      return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.stat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.fstatBase = function(fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF, "fstat");
      return Stats_1.default.build(file.node, bigint);
    };
    Volume2.prototype.fstatSync = function(fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume2.prototype.fstat = function(fd, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
      var link3 = this.getLink(filenameToSteps(oldPathFilename));
      if (!link3)
        throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
      var newPathSteps = filenameToSteps(newPathFilename);
      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink)
        throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
      var oldLinkParent = link3.parent;
      if (oldLinkParent) {
        oldLinkParent.deleteChild(link3);
      }
      var name2 = newPathSteps[newPathSteps.length - 1];
      link3.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name2], false);
      newPathDirLink.setChild(link3.getName(), link3);
    };
    Volume2.prototype.renameSync = function(oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume2.prototype.rename = function(oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.existsBase = function(filename) {
      return !!this.statBase(filename);
    };
    Volume2.prototype.existsSync = function(path2) {
      try {
        return this.existsBase(pathToFilename(path2));
      } catch (err) {
        return false;
      }
    };
    Volume2.prototype.exists = function(path2, callback) {
      var _this = this;
      var filename = pathToFilename(path2);
      if (typeof callback !== "function")
        throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function() {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };
    Volume2.prototype.accessBase = function(filename, mode) {
      this.getLinkOrThrow(filename, "access");
    };
    Volume2.prototype.accessSync = function(path2, mode) {
      if (mode === void 0) {
        mode = F_OK2;
      }
      var filename = pathToFilename(path2);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };
    Volume2.prototype.access = function(path2, a7, b5) {
      var mode = F_OK2;
      var callback;
      if (typeof a7 !== "function") {
        mode = a7 | 0;
        callback = validateCallback(b5);
      } else {
        callback = a7;
      }
      var filename = pathToFilename(path2);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume2.prototype.appendFileSync = function(id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }
      var opts = getAppendFileOpts(options);
      if (!opts.flag || isFd(id))
        opts.flag = "a";
      this.writeFileSync(id, data, opts);
    };
    Volume2.prototype.appendFile = function(id, data, a7, b5) {
      var _a2 = getAppendFileOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      if (!opts.flag || isFd(id))
        opts.flag = "a";
      this.writeFile(id, data, opts, callback);
    };
    Volume2.prototype.readdirBase = function(filename, options) {
      var steps = filenameToSteps(filename);
      var link3 = this.getResolvedLink(steps);
      if (!link3)
        throw createError(ENOENT, "readdir", filename);
      var node = link3.getNode();
      if (!node.isDirectory())
        throw createError(ENOTDIR, "scandir", filename);
      if (options.withFileTypes) {
        var list_1 = [];
        for (var name_3 in link3.children) {
          var child = link3.getChild(name_3);
          if (!child) {
            continue;
          }
          list_1.push(Dirent_1.default.build(child, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list_1.sort(function(a7, b5) {
            if (a7.name < b5.name)
              return -1;
            if (a7.name > b5.name)
              return 1;
            return 0;
          });
        return list_1;
      }
      var list = [];
      for (var name_4 in link3.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }
      if (!isWin && options.encoding !== "buffer")
        list.sort();
      return list;
    };
    Volume2.prototype.readdirSync = function(path2, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path2);
      return this.readdirBase(filename, opts);
    };
    Volume2.prototype.readdir = function(path2, a7, b5) {
      var _a2 = getReaddirOptsAndCb(a7, b5), options = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume2.prototype.readlinkBase = function(filename, encoding) {
      var link3 = this.getLinkOrThrow(filename, "readlink");
      var node = link3.getNode();
      if (!node.isSymlink())
        throw createError(EINVAL, "readlink", filename);
      var str = sep2 + node.symlink.join(sep2);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };
    Volume2.prototype.readlinkSync = function(path2, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path2);
      return this.readlinkBase(filename, opts.encoding);
    };
    Volume2.prototype.readlink = function(path2, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume2.prototype.fsyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fsync");
    };
    Volume2.prototype.fsyncSync = function(fd) {
      this.fsyncBase(fd);
    };
    Volume2.prototype.fsync = function(fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume2.prototype.fdatasyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fdatasync");
    };
    Volume2.prototype.fdatasyncSync = function(fd) {
      this.fdatasyncBase(fd);
    };
    Volume2.prototype.fdatasync = function(fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume2.prototype.ftruncateBase = function(fd, len) {
      var file = this.getFileByFdOrThrow(fd, "ftruncate");
      file.truncate(len);
    };
    Volume2.prototype.ftruncateSync = function(fd, len) {
      this.ftruncateBase(fd, len);
    };
    Volume2.prototype.ftruncate = function(fd, a7, b5) {
      var len = typeof a7 === "number" ? a7 : 0;
      var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume2.prototype.truncateBase = function(path2, len) {
      var fd = this.openSync(path2, "r+");
      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.truncateSync = function(id, len) {
      if (isFd(id))
        return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };
    Volume2.prototype.truncate = function(id, a7, b5) {
      var len = typeof a7 === "number" ? a7 : 0;
      var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
      if (isFd(id))
        return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume2.prototype.futimesBase = function(fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, "futimes");
      var node = file.node;
      node.atime = new Date(atime * 1e3);
      node.mtime = new Date(mtime * 1e3);
    };
    Volume2.prototype.futimesSync = function(fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.utimesBase = function(filename, atime, mtime) {
      var fd = this.openSync(filename, "r+");
      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.utimesSync = function(path2, atime, mtime) {
      this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.mkdirBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      if (!steps.length) {
        throw createError(EEXIST, "mkdir", filename);
      }
      var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
      var name2 = steps[steps.length - 1];
      if (dir.getChild(name2))
        throw createError(EEXIST, "mkdir", filename);
      dir.createChild(name2, this.createNode(true, modeNum));
    };
    Volume2.prototype.mkdirpBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link3 = this.root;
      for (var i7 = 0; i7 < steps.length; i7++) {
        var step = steps[i7];
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR, "mkdir", link3.getPath());
        var child = link3.getChild(step);
        if (child) {
          if (child.getNode().isDirectory())
            link3 = child;
          else
            throw createError(ENOTDIR, "mkdir", child.getPath());
        } else {
          link3 = link3.createChild(step, this.createNode(true, modeNum));
        }
      }
    };
    Volume2.prototype.mkdirSync = function(path2, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.mkdirpBase(filename, modeNum);
      else
        this.mkdirBase(filename, modeNum);
    };
    Volume2.prototype.mkdir = function(path2, a7, b5) {
      var opts = getMkdirOptions(a7);
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
      else
        this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    Volume2.prototype.mkdirpSync = function(path2, mode) {
      this.mkdirSync(path2, {
        mode,
        recursive: true
      });
    };
    Volume2.prototype.mkdirp = function(path2, a7, b5) {
      var mode = typeof a7 === "function" ? void 0 : a7;
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      this.mkdir(path2, {
        mode,
        recursive: true
      }, callback);
    };
    Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }
      var filename = prefix + this.genRndStr();
      try {
        this.mkdirBase(
          filename,
          511
          /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST) {
          if (retry > 1)
            return this.mkdtempBase(prefix, encoding, retry - 1);
          else
            throw Error("Could not create temp dir.");
        } else
          throw err;
      }
    };
    Volume2.prototype.mkdtempSync = function(prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };
    Volume2.prototype.mkdtemp = function(prefix, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), encoding = _a2[0].encoding, callback = _a2[1];
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      if (!nullCheck(prefix))
        return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume2.prototype.rmdirBase = function(filename, options) {
      var opts = getRmdirOptions(options);
      var link3 = this.getLinkAsDirOrThrow(filename, "rmdir");
      if (link3.length && !opts.recursive)
        throw createError(ENOTEMPTY, "rmdir", filename);
      this.deleteLink(link3);
    };
    Volume2.prototype.rmdirSync = function(path2, options) {
      this.rmdirBase(pathToFilename(path2), options);
    };
    Volume2.prototype.rmdir = function(path2, a7, b5) {
      var opts = getRmdirOptions(a7);
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
    };
    Volume2.prototype.fchmodBase = function(fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, "fchmod");
      file.chmod(modeNum);
    };
    Volume2.prototype.fchmodSync = function(fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume2.prototype.fchmod = function(fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume2.prototype.chmodBase = function(filename, modeNum) {
      var fd = this.openSync(filename, "r+");
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.chmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.chmodBase(filename, modeNum);
    };
    Volume2.prototype.chmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.lchmodBase = function(filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR, 0, false);
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.lchmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.lchmodBase(filename, modeNum);
    };
    Volume2.prototype.lchmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.fchownBase = function(fd, uid, gid) {
      this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
    };
    Volume2.prototype.fchownSync = function(fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };
    Volume2.prototype.fchown = function(fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume2.prototype.chownBase = function(filename, uid, gid) {
      var link3 = this.getResolvedLinkOrThrow(filename, "chown");
      var node = link3.getNode();
      node.chown(uid, gid);
    };
    Volume2.prototype.chownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.chown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.lchownBase = function(filename, uid, gid) {
      this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
    };
    Volume2.prototype.lchownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.lchown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.watchFile = function(path2, a7, b5) {
      var filename = pathToFilename(path2);
      var options = a7;
      var listener = b5;
      if (typeof options === "function") {
        listener = a7;
        options = null;
      }
      if (typeof listener !== "function") {
        throw Error('"watchFile()" requires a listener function');
      }
      var interval = 5007;
      var persistent = true;
      if (options && typeof options === "object") {
        if (typeof options.interval === "number")
          interval = options.interval;
        if (typeof options.persistent === "boolean")
          persistent = options.persistent;
      }
      var watcher = this.statWatchers[filename];
      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }
      watcher.addListener("change", listener);
      return watcher;
    };
    Volume2.prototype.unwatchFile = function(path2, listener) {
      var filename = pathToFilename(path2);
      var watcher = this.statWatchers[filename];
      if (!watcher)
        return;
      if (typeof listener === "function") {
        watcher.removeListener("change", listener);
      } else {
        watcher.removeAllListeners("change");
      }
      if (watcher.listenerCount("change") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };
    Volume2.prototype.createReadStream = function(path2, options) {
      return new this.ReadStream(path2, options);
    };
    Volume2.prototype.createWriteStream = function(path2, options) {
      return new this.WriteStream(path2, options);
    };
    Volume2.prototype.watch = function(path2, options, listener) {
      var filename = pathToFilename(path2);
      var givenOptions = options;
      if (typeof options === "function") {
        listener = options;
        givenOptions = null;
      }
      var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
      if (persistent === void 0)
        persistent = true;
      if (recursive === void 0)
        recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);
      if (listener) {
        watcher.addListener("change", listener);
      }
      return watcher;
    };
    Volume2.fd = 2147483647;
    return Volume2;
  }();
  exports$43.Volume = Volume;
  function emitStop(self2) {
    self2.emit("stop");
  }
  var StatWatcher = function(_super) {
    __extends(StatWatcher2, _super);
    function StatWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this.onInterval = function() {
        try {
          var stats = _this.vol.statSync(_this.filename);
          if (_this.hasChanged(stats)) {
            _this.emit("change", stats, _this.prev);
            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };
      _this.vol = vol2;
      return _this;
    }
    StatWatcher2.prototype.loop = function() {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher2.prototype.hasChanged = function(stats) {
      if (stats.mtimeMs > this.prev.mtimeMs)
        return true;
      if (stats.nlink !== this.prev.nlink)
        return true;
      return false;
    };
    StatWatcher2.prototype.start = function(path2, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (interval === void 0) {
        interval = 5007;
      }
      this.filename = pathToFilename(path2);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global5) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };
    StatWatcher2.prototype.stop = function() {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher2;
  }(events_1.EventEmitter);
  exports$43.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  util.inherits(FsReadStream, stream_1.Readable);
  exports$43.ReadStream = FsReadStream;
  function FsReadStream(vol2, path2, options) {
    if (!(this instanceof FsReadStream))
      return new FsReadStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === void 0)
      options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "r" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw new TypeError('"end" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('"start" option must be <= "end" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== "number")
      this.open();
    this.on("end", function() {
      if (this.autoClose) {
        if (this.destroy)
          this.destroy();
      }
    });
  }
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy)
            self2.destroy();
        }
        self2.emit("error", er);
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n8) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._read(n8);
      });
    }
    if (this.destroyed)
      return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n8);
    var start = pool.used;
    if (this.pos !== void 0)
      toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0)
      return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0)
      this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit("error", er);
      } else {
        var b5 = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b5 = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b5);
      }
    }
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close(function(err2) {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _this = this;
    if (cb)
      this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit("close");
      });
    }
    this.closed = true;
    this._vol.close(this.fd, function(er) {
      if (er)
        _this.emit("error", er);
      else
        _this.emit("close");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  util.inherits(FsWriteStream, stream_1.Writable);
  exports$43.WriteStream = FsWriteStream;
  function FsWriteStream(vol2, path2, options) {
    if (!(this instanceof FsWriteStream))
      return new FsWriteStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "w" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('"start" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options.encoding)
      this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== "number")
      this.open();
    this.once("finish", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit("error", er);
        return;
      }
      this.fd = fd;
      this.emit("open", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer))
      return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._write(data, encoding, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._writev(data, cb);
      });
    }
    var self2 = this;
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i7 = 0; i7 < len; i7++) {
      var chunk = data[i7].chunk;
      chunks[i7] = chunk;
      size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.destroy)
          self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += size;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  var FSWatcher = function(_super) {
    __extends(FSWatcher2, _super);
    function FSWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this._filename = "";
      _this._filenameEncoded = "";
      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;
      _this._onNodeChange = function() {
        _this._emit("change");
      };
      _this._onParentChild = function(link3) {
        if (link3.getName() === _this._getName()) {
          _this._emit("rename");
        }
      };
      _this._emit = function(type2) {
        _this.emit("change", type2, _this._filenameEncoded);
      };
      _this._persist = function() {
        _this._timer = setTimeout(_this._persist, 1e6);
      };
      _this._vol = vol2;
      return _this;
    }
    FSWatcher2.prototype._getName = function() {
      return this._steps[this._steps.length - 1];
    };
    FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (recursive === void 0) {
        recursive = false;
      }
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      this._filename = pathToFilename(path2);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
      this._recursive = recursive;
      this._encoding = encoding;
      try {
        this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
      } catch (err) {
        var error = new Error("watch " + this._filename + " " + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }
      this._link.getNode().on("change", this._onNodeChange);
      this._link.on("child:add", this._onNodeChange);
      this._link.on("child:delete", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on("child:delete", this._onParentChild);
      }
      if (persistent)
        this._persist();
    };
    FSWatcher2.prototype.close = function() {
      clearTimeout(this._timer);
      this._link.getNode().removeListener("change", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.removeListener("child:delete", this._onParentChild);
      }
    };
    return FSWatcher2;
  }(events_1.EventEmitter);
  exports$43.FSWatcher = FSWatcher;
  return exports$43;
}
var exports$34 = {};
var _dewExec$14 = false;
function dew$14() {
  if (_dewExec$14)
    return exports$34;
  _dewExec$14 = true;
  Object.defineProperty(exports$34, "__esModule", {
    value: true
  });
  exports$34.fsAsyncMethods = exports$34.fsSyncMethods = exports$34.fsProps = void 0;
  var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
  exports$34.fsProps = fsProps;
  var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
  exports$34.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
  exports$34.fsAsyncMethods = fsAsyncMethods;
  return exports$34;
}
var exports$24 = {};
var _dewExec9 = false;
function dew9() {
  if (_dewExec9)
    return exports$24;
  _dewExec9 = true;
  var __assign = exports$24 && exports$24.__assign || function() {
    __assign = Object.assign || function(t8) {
      for (var s6, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
        s6 = arguments[i7];
        for (var p7 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p7))
            t8[p7] = s6[p7];
      }
      return t8;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports$24, "__esModule", {
    value: true
  });
  exports$24.fs = exports$24.createFsFromVolume = exports$24.vol = exports$24.Volume = void 0;
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$93();
  var volume_1 = dew$24();
  var _a = dew$14(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
  var constants_1 = dew$f2();
  var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
  exports$24.Volume = volume_1.Volume;
  exports$24.vol = new volume_1.Volume();
  function createFsFromVolume2(vol2) {
    var fs2 = {
      F_OK: F_OK2,
      R_OK: R_OK2,
      W_OK: W_OK2,
      X_OK: X_OK2,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    };
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
      var method = fsAsyncMethods_1[_a2];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    fs2.StatWatcher = vol2.StatWatcher;
    fs2.FSWatcher = vol2.FSWatcher;
    fs2.WriteStream = vol2.WriteStream;
    fs2.ReadStream = vol2.ReadStream;
    fs2.promises = vol2.promises;
    fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs2;
  }
  exports$24.createFsFromVolume = createFsFromVolume2;
  exports$24.fs = createFsFromVolume2(exports$24.vol);
  exports$24 = __assign(__assign({}, exports$24), exports$24.fs);
  exports$24.semantic = true;
  return exports$24;
}
var exports$17 = dew9();
exports$17["__esModule"];
exports$17["fs"];
exports$17["createFsFromVolume"];
exports$17["vol"];
exports$17["Volume"];
exports$17["semantic"];
var exports9 = dew$24();
exports9["__esModule"];
exports9["FSWatcher"];
exports9["StatWatcher"];
exports9["Volume"];
exports9["toUnixTimestamp"];
exports9["bufferToEncoding"];
exports9["dataToBuffer"];
exports9["dataToStr"];
exports9["pathToSteps"];
exports9["filenameToSteps"];
exports9["pathToFilename"];
exports9["flagsToNumber"];
exports9["FLAGS"];
exports9["ReadStream"];
exports9["WriteStream"];
var { vol, createFsFromVolume } = exports$17;
function unimplemented3(name2) {
  throw new Error(`Node.js fs ${name2} is not supported by JSPM core in the browser`);
}
vol.fromNestedJSON({
  "/dev": { stdin: "", stdout: "", stderr: "" },
  "/usr/bin": {},
  "/home": {},
  "/tmp": {}
});
vol.releasedFds = [2, 1, 0];
vol.openSync("/dev/stdin", "w");
vol.openSync("/dev/stdout", "r");
vol.openSync("/dev/stderr", "r");
watchStdo("/dev/stdout", 1, console.log);
watchStdo("/dev/stderr", 2, console.error);
function watchStdo(path2, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path2, "utf8", () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer2.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}
var fs = createFsFromVolume(vol);
fs.opendir = () => unimplemented3("opendir");
fs.opendirSync = () => unimplemented3("opendirSync");
fs.promises.opendir = () => unimplemented3("promises.opendir");
fs.cp = () => unimplemented3("cp");
fs.cpSync = () => unimplemented3("cpSync");
fs.promises.cp = () => unimplemented3("promises.cp");
fs.readv = () => unimplemented3("readv");
fs.readvSync = () => unimplemented3("readvSync");
fs.rm = () => unimplemented3("rm");
fs.rmSync = () => unimplemented3("rmSync");
fs.promises.rm = () => unimplemented3("promises.rm");
fs.Dir = () => unimplemented3("Dir");
fs.promises.watch = () => unimplemented3("promises.watch");
fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;
function handleFsUrl(url, isSync) {
  if (url.protocol === "file:")
    return fileURLToPath(url);
  if (url.protocol === "https:" || url.protocol === "http:") {
    const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
    if (existsSync(path2))
      return path2;
    if (isSync)
      throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
      const buf = await res.arrayBuffer();
      writeFileSync(path2, Buffer2.from(buf));
      return path2;
    })();
  }
  throw new Error("URL " + url + " not supported in JSPM FS implementation.");
}
function wrapFsSync(fn) {
  return function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(handleFsUrl(path2, true), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsPromise(fn) {
  return async function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(await handleFsUrl(path2), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsCallback(fn) {
  return function(path2, ...args) {
    const cb = args[args.length - 1];
    if (path2 instanceof URL && typeof cb === "function") {
      handleFsUrl(path2).then((path3) => {
        fn(path3, ...args);
      }, cb);
    } else {
      fn(path2, ...args);
    }
  };
}
fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);
var {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants: constants2,
  promises: promises2
} = fs;

// node_modules/@jspm/core/nodelibs/browser/fs/promises.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_buffer();
var {
  access: access2,
  copyFile: copyFile2,
  cp: cp2,
  open: open2,
  opendir: opendir2,
  rename: rename2,
  truncate: truncate2,
  rm: rm2,
  rmdir: rmdir2,
  mkdir: mkdir2,
  readdir: readdir2,
  readlink: readlink2,
  symlink: symlink2,
  lstat: lstat2,
  stat: stat2,
  link: link2,
  unlink: unlink2,
  chmod: chmod2,
  lchmod: lchmod2,
  lchown: lchown2,
  chown: chown2,
  utimes: utimes2,
  realpath: realpath2,
  mkdtemp: mkdtemp2,
  writeFile: writeFile2,
  appendFile: appendFile2,
  readFile: readFile2,
  watch: watch2
} = promises2;

// node_modules/rotating-file-stream/dist/es/index.js
async function exists2(filename) {
  return new Promise((resolve4) => access(filename, constants2.F_OK, (error) => resolve4(!error)));
}
var RotatingFileStreamError = class extends Error {
  constructor() {
    super("Too many destination file attempts");
    __publicField(this, "code", "RFS-TOO-MANY");
  }
};
var RotatingFileStream = class extends Writable {
  constructor(generator, options) {
    const { encoding, history, maxFiles, maxSize, path: path2 } = options;
    super({ decodeStrings: true, defaultEncoding: encoding });
    __publicField(this, "createGzip");
    __publicField(this, "exec");
    __publicField(this, "file");
    __publicField(this, "filename");
    __publicField(this, "finished");
    __publicField(this, "fsCreateReadStream");
    __publicField(this, "fsCreateWriteStream");
    __publicField(this, "fsOpen");
    __publicField(this, "fsReadFile");
    __publicField(this, "fsStat");
    __publicField(this, "fsUnlink");
    __publicField(this, "generator");
    __publicField(this, "initPromise");
    __publicField(this, "last");
    __publicField(this, "maxTimeout");
    __publicField(this, "next");
    __publicField(this, "options");
    __publicField(this, "prev");
    __publicField(this, "rotation");
    __publicField(this, "size");
    __publicField(this, "stdout");
    __publicField(this, "timeout");
    __publicField(this, "timeoutPromise");
    this.createGzip = createGzip;
    this.exec = unimplemented2;
    this.filename = path2 + generator(null);
    this.fsCreateReadStream = createReadStream;
    this.fsCreateWriteStream = createWriteStream;
    this.fsOpen = open2;
    this.fsReadFile = readFile2;
    this.fsStat = stat2;
    this.fsUnlink = unlink2;
    this.generator = generator;
    this.maxTimeout = 2147483640;
    this.options = options;
    this.stdout = process_exports.stdout;
    if (maxFiles || maxSize)
      options.history = path2 + (history ? history : this.generator(null) + ".txt");
    this.on("close", () => this.finished ? null : this.emit("finish"));
    this.on("finish", () => this.finished = this.clear());
    (async () => {
      try {
        this.initPromise = this.init();
        await this.initPromise;
        delete this.initPromise;
      } catch (e9) {
      }
    })();
  }
  _destroy(error, callback) {
    this.refinal(error, callback);
  }
  _final(callback) {
    this.refinal(void 0, callback);
  }
  _write(chunk, encoding, callback) {
    this.rewrite([{ chunk, encoding }], 0, callback);
  }
  _writev(chunks, callback) {
    this.rewrite(chunks, 0, callback);
  }
  async refinal(error, callback) {
    try {
      this.clear();
      if (this.initPromise)
        await this.initPromise;
      if (this.timeoutPromise)
        await this.timeoutPromise;
      await this.reclose();
    } catch (e9) {
      return callback(error || e9);
    }
    callback(error);
  }
  async rewrite(chunks, index, callback) {
    const { size, teeToStdout } = this.options;
    try {
      if (this.initPromise)
        await this.initPromise;
      if (this.timeoutPromise)
        await this.timeoutPromise;
      for (let i7 = 0; i7 < chunks.length; ++i7) {
        const { chunk } = chunks[i7];
        this.size += chunk.length;
        await this.file.write(chunk);
        if (teeToStdout && !this.stdout.destroyed)
          this.stdout.write(chunk);
        if (size && this.size >= size)
          await this.rotate();
      }
    } catch (e9) {
      return callback(e9);
    }
    callback();
  }
  async init() {
    const { immutable, initialRotation, interval, size } = this.options;
    if (immutable)
      return new Promise((resolve4, reject) => process_exports.nextTick(() => this.immutate(true).then(resolve4).catch(reject)));
    let stats;
    try {
      stats = await stat2(this.filename);
    } catch (e9) {
      if (e9.code !== "ENOENT")
        throw e9;
      return this.reopen(0);
    }
    if (!stats.isFile())
      throw new Error(`Can't write on: ${this.filename} (it is not a file)`);
    if (initialRotation) {
      this.intervalBounds(this.now());
      const prev = this.prev;
      this.intervalBounds(new Date(stats.mtime.getTime()));
      if (prev !== this.prev)
        return this.rotate();
    }
    this.size = stats.size;
    if (!size || stats.size < size)
      return this.reopen(stats.size);
    if (interval)
      this.intervalBounds(this.now());
    return this.rotate();
  }
  async makePath(name2) {
    return mkdir2(name2.split(sep).slice(0, -1).join(sep), { recursive: true });
  }
  async reopen(size) {
    let file;
    try {
      file = await open2(this.filename, "a", this.options.mode);
    } catch (e9) {
      if (e9.code !== "ENOENT")
        throw e9;
      await this.makePath(this.filename);
      file = await open2(this.filename, "a", this.options.mode);
    }
    this.file = file;
    this.size = size;
    this.interval();
    this.emit("open", this.filename);
  }
  async reclose() {
    const { file } = this;
    if (!file)
      return;
    delete this.file;
    return file.close();
  }
  now() {
    return /* @__PURE__ */ new Date();
  }
  async rotate() {
    const { immutable, rotate } = this.options;
    this.size = 0;
    this.rotation = this.now();
    this.clear();
    this.emit("rotation");
    await this.reclose();
    if (rotate)
      return this.classical();
    if (immutable)
      return this.immutate(false);
    return this.move();
  }
  async findName() {
    const { interval, path: path2, intervalBoundary } = this.options;
    for (let index = 1; index < 1e3; ++index) {
      const filename = path2 + this.generator(interval && intervalBoundary ? new Date(this.prev) : this.rotation, index);
      if (!await exists2(filename))
        return filename;
    }
    throw new RotatingFileStreamError();
  }
  async move() {
    const { compress } = this.options;
    const filename = await this.findName();
    await this.touch(filename);
    if (compress)
      await this.compress(filename);
    else
      await rename2(this.filename, filename);
    return this.rotated(filename);
  }
  async touch(filename) {
    let file;
    try {
      file = await this.fsOpen(filename, "a");
    } catch (e9) {
      if (e9.code !== "ENOENT")
        throw e9;
      await this.makePath(filename);
      file = await open2(filename, "a");
    }
    await file.close();
    return this.unlink(filename);
  }
  async classical() {
    const { compress, path: path2, rotate } = this.options;
    let rotatedName = "";
    for (let count = rotate; count > 0; --count) {
      const currName = path2 + this.generator(count);
      const prevName = count === 1 ? this.filename : path2 + this.generator(count - 1);
      if (!await exists2(prevName))
        continue;
      if (!rotatedName)
        rotatedName = currName;
      if (count === 1 && compress)
        await this.compress(currName);
      else {
        try {
          await rename2(prevName, currName);
        } catch (e9) {
          if (e9.code !== "ENOENT")
            throw e9;
          await this.makePath(currName);
          await rename2(prevName, currName);
        }
      }
    }
    return this.rotated(rotatedName);
  }
  clear() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
    return true;
  }
  intervalBoundsBig(now) {
    const year = now.getFullYear();
    let month = now.getMonth();
    let day = now.getDate();
    let hours = now.getHours();
    const { num, unit } = this.options.interval;
    if (unit === "M") {
      day = 1;
      hours = 0;
    } else if (unit === "d")
      hours = 0;
    else
      hours = parseInt(hours / num, 10) * num;
    this.prev = new Date(year, month, day, hours, 0, 0, 0).getTime();
    if (unit === "M")
      month += num;
    else if (unit === "d")
      day += num;
    else
      hours += num;
    this.next = new Date(year, month, day, hours, 0, 0, 0).getTime();
  }
  intervalBounds(now) {
    const unit = this.options.interval.unit;
    if (unit === "M" || unit === "d" || unit === "h")
      this.intervalBoundsBig(now);
    else {
      let period = 1e3 * this.options.interval.num;
      if (unit === "m")
        period *= 60;
      this.prev = parseInt(now.getTime() / period, 10) * period;
      this.next = this.prev + period;
    }
    return new Date(this.prev);
  }
  interval() {
    if (!this.options.interval)
      return;
    this.intervalBounds(this.now());
    const set = async () => {
      const time = this.next - this.now().getTime();
      if (time <= 0) {
        try {
          this.timeoutPromise = this.rotate();
          await this.timeoutPromise;
          delete this.timeoutPromise;
        } catch (e9) {
        }
      } else {
        this.timeout = setTimeout(set, time > this.maxTimeout ? this.maxTimeout : time);
        this.timeout.unref();
      }
    };
    set();
  }
  async compress(filename) {
    const { compress } = this.options;
    if (typeof compress === "function") {
      await new Promise((resolve4, reject) => {
        this.exec(compress(this.filename, filename), (error, stdout2, stderr2) => {
          this.emit("external", stdout2, stderr2);
          error ? reject(error) : resolve4();
        });
      });
    } else
      await this.gzip(filename);
    return this.unlink(this.filename);
  }
  async gzip(filename) {
    const { mode } = this.options;
    const options = mode ? { mode } : {};
    const inp = this.fsCreateReadStream(this.filename, {});
    const out = this.fsCreateWriteStream(filename, options);
    const zip = this.createGzip();
    return new Promise((resolve4, reject) => {
      [inp, out, zip].map((stream2) => stream2.once("error", reject));
      out.once("finish", resolve4);
      inp.pipe(zip).pipe(out);
    });
  }
  async rotated(filename) {
    const { maxFiles, maxSize } = this.options;
    if (maxFiles || maxSize)
      await this.history(filename);
    this.emit("rotated", filename);
    return this.reopen(0);
  }
  async history(filename) {
    const { history, maxFiles, maxSize } = this.options;
    const res = [];
    let files = [filename];
    try {
      const content = await this.fsReadFile(history, "utf8");
      files = [...content.toString().split("\n"), filename];
    } catch (e9) {
      if (e9.code !== "ENOENT")
        throw e9;
    }
    for (const file of files) {
      if (file) {
        try {
          const stats = await this.fsStat(file);
          if (stats.isFile()) {
            res.push({
              name: file,
              size: stats.size,
              time: stats.ctime.getTime()
            });
          } else
            this.emit("warning", new Error(`File '${file}' contained in history is not a regular file`));
        } catch (e9) {
          if (e9.code !== "ENOENT")
            throw e9;
        }
      }
    }
    res.sort((a7, b5) => a7.time - b5.time);
    if (maxFiles) {
      while (res.length > maxFiles) {
        const file = res.shift();
        await this.unlink(file.name);
        this.emit("removed", file.name, true);
      }
    }
    if (maxSize) {
      while (res.reduce((size, file) => size + file.size, 0) > maxSize) {
        const file = res.shift();
        await this.unlink(file.name);
        this.emit("removed", file.name, false);
      }
    }
    await writeFile2(history, res.map((e9) => e9.name).join("\n") + "\n", "utf-8");
    this.emit("history");
  }
  async immutate(first) {
    const { size } = this.options;
    const now = this.now();
    for (let index = 1; index < 1e3; ++index) {
      let fileSize = 0;
      let stats = void 0;
      this.filename = this.options.path + this.generator(now, index);
      try {
        stats = await this.fsStat(this.filename);
      } catch (e9) {
        if (e9.code !== "ENOENT")
          throw e9;
      }
      if (stats) {
        fileSize = stats.size;
        if (!stats.isFile())
          throw new Error(`Can't write on: '${this.filename}' (it is not a file)`);
        if (size && fileSize >= size)
          continue;
      }
      if (first) {
        this.last = this.filename;
        return this.reopen(fileSize);
      }
      await this.rotated(this.last);
      this.last = this.filename;
      return;
    }
    throw new RotatingFileStreamError();
  }
  async unlink(filename) {
    try {
      await this.fsUnlink(filename);
    } catch (e9) {
      if (e9.code !== "ENOENT")
        throw e9;
      this.emit("warning", e9);
    }
  }
};
function buildNumberCheck(field) {
  return (type2, options, value) => {
    const converted = parseInt(value, 10);
    if (type2 !== "number" || converted !== value || converted <= 0)
      throw new Error(`'${field}' option must be a positive integer number`);
  };
}
function buildStringCheck(field, check) {
  return (type2, options, value) => {
    if (type2 !== "string")
      throw new Error(`Don't know how to handle 'options.${field}' type: ${type2}`);
    options[field] = check(value);
  };
}
function checkMeasure(value, what, units) {
  const ret = {};
  ret.num = parseInt(value, 10);
  if (isNaN(ret.num))
    throw new Error(`Unknown 'options.${what}' format: ${value}`);
  if (ret.num <= 0)
    throw new Error(`A positive integer number is expected for 'options.${what}'`);
  ret.unit = value.replace(/^[ 0]*/g, "").substr((ret.num + "").length, 1);
  if (ret.unit.length === 0)
    throw new Error(`Missing unit for 'options.${what}'`);
  if (!units[ret.unit])
    throw new Error(`Unknown 'options.${what}' unit: ${ret.unit}`);
  return ret;
}
var intervalUnits = { M: true, d: true, h: true, m: true, s: true };
function checkIntervalUnit(ret, unit, amount) {
  if (parseInt(amount / ret.num, 10) * ret.num !== amount)
    throw new Error(`An integer divider of ${amount} is expected as ${unit} for 'options.interval'`);
}
function checkInterval(value) {
  const ret = checkMeasure(value, "interval", intervalUnits);
  switch (ret.unit) {
    case "h":
      checkIntervalUnit(ret, "hours", 24);
      break;
    case "m":
      checkIntervalUnit(ret, "minutes", 60);
      break;
    case "s":
      checkIntervalUnit(ret, "seconds", 60);
      break;
  }
  return ret;
}
var sizeUnits = { B: true, G: true, K: true, M: true };
function checkSize(value) {
  const ret = checkMeasure(value, "size", sizeUnits);
  if (ret.unit === "K")
    return ret.num * 1024;
  if (ret.unit === "M")
    return ret.num * 1048576;
  if (ret.unit === "G")
    return ret.num * 1073741824;
  return ret.num;
}
var checks = {
  encoding: (type2, options, value) => new TextDecoder3(value),
  immutable: () => {
  },
  initialRotation: () => {
  },
  interval: buildStringCheck("interval", checkInterval),
  intervalBoundary: () => {
  },
  maxFiles: buildNumberCheck("maxFiles"),
  maxSize: buildStringCheck("maxSize", checkSize),
  mode: () => {
  },
  omitExtension: () => {
  },
  rotate: buildNumberCheck("rotate"),
  size: buildStringCheck("size", checkSize),
  teeToStdout: () => {
  },
  compress: (type2, options, value) => {
    if (!value)
      throw new Error("A value for 'options.compress' must be specified");
    if (type2 === "boolean")
      return options.compress = (source, dest) => `cat ${source} | gzip -c9 > ${dest}`;
    if (type2 === "function")
      return;
    if (type2 !== "string")
      throw new Error(`Don't know how to handle 'options.compress' type: ${type2}`);
    if (value !== "gzip")
      throw new Error(`Don't know how to handle compression method: ${value}`);
  },
  history: (type2) => {
    if (type2 !== "string")
      throw new Error(`Don't know how to handle 'options.history' type: ${type2}`);
  },
  path: (type2, options, value) => {
    if (type2 !== "string")
      throw new Error(`Don't know how to handle 'options.path' type: ${type2}`);
    if (value[value.length - 1] !== sep)
      options.path = value + sep;
  }
};
function checkOpts(options) {
  const ret = {};
  for (const opt in options) {
    const value = options[opt];
    const type2 = typeof value;
    if (!(opt in checks))
      throw new Error(`Unknown option: ${opt}`);
    ret[opt] = options[opt];
    checks[opt](type2, ret, value);
  }
  if (!ret.path)
    ret.path = "";
  if (!ret.interval) {
    delete ret.immutable;
    delete ret.initialRotation;
    delete ret.intervalBoundary;
  }
  if (ret.rotate) {
    delete ret.history;
    delete ret.immutable;
    delete ret.maxFiles;
    delete ret.maxSize;
    delete ret.intervalBoundary;
  }
  if (ret.immutable)
    delete ret.compress;
  if (!ret.intervalBoundary)
    delete ret.initialRotation;
  return ret;
}
function createClassical(filename, compress, omitExtension) {
  return (index) => index ? `${filename}.${index}${compress && !omitExtension ? ".gz" : ""}` : filename;
}
function createGenerator(filename, compress, omitExtension) {
  const pad = (num) => (num > 9 ? "" : "0") + num;
  return (time, index) => {
    if (!time)
      return filename;
    const month = time.getFullYear() + "" + pad(time.getMonth() + 1);
    const day = pad(time.getDate());
    const hour = pad(time.getHours());
    const minute = pad(time.getMinutes());
    return month + day + "-" + hour + minute + "-" + pad(index) + "-" + filename + (compress && !omitExtension ? ".gz" : "");
  };
}
function createStream(filename, options) {
  if (typeof options === "undefined")
    options = {};
  else if (typeof options !== "object")
    throw new Error(`The "options" argument must be of type object. Received type ${typeof options}`);
  const opts = checkOpts(options);
  const { compress, omitExtension } = opts;
  let generator;
  if (typeof filename === "string")
    generator = options.rotate ? createClassical(filename, compress !== void 0, omitExtension) : createGenerator(filename, compress !== void 0, omitExtension);
  else if (typeof filename === "function")
    generator = filename;
  else
    throw new Error(`The "filename" argument must be one of type string or function. Received type ${typeof filename}`);
  return new RotatingFileStream(generator, opts);
}

// src/logger.ts
var import_pino = __toESM(require_browser2());
var stream = import_browser_or_node.isBrowser ? null : (
  /**
   * Default rotating file locate at `~/.tabby/agent-logs/`.
   */
  createStream("tabby-agent.log", {
    path: exports4.join(exports2.homedir(), ".tabby", "agent-logs"),
    size: "10M",
    interval: "1d"
  })
);
var rootLogger = !!stream ? (0, import_pino.default)(stream) : (0, import_pino.default)();
var allLoggers = [rootLogger];
rootLogger.onChild = (child) => {
  allLoggers.push(child);
};

// src/CompletionCache.ts
var CompletionCache = class {
  constructor() {
    this.logger = rootLogger.child({ component: "CompletionCache" });
    this.options = {
      maxSize: 1 * 1024 * 1024,
      // 1MB
      partiallyAcceptedCacheGeneration: {
        enabled: true,
        perCharacter: {
          lines: 1,
          words: 10,
          max: 30
        },
        perWord: {
          lines: 1,
          max: 20
        },
        perLine: {
          max: 3
        }
      }
    };
    this.cache = new LRUCache({
      maxSize: this.options.maxSize,
      sizeCalculation: import_object_sizeof.default
    });
  }
  has(key) {
    return this.cache.has(this.hash(key));
  }
  set(key, value) {
    for (const entry of this.createCacheEntries(key, value)) {
      this.logger.debug({ entry }, "Setting cache entry");
      this.cache.set(this.hash(entry.key), entry.value);
    }
    this.logger.debug({ size: this.cache.calculatedSize }, "Cache size");
  }
  get(key) {
    return this.cache.get(this.hash(key));
  }
  hash(key) {
    return (0, import_object_hash.default)(key);
  }
  createCacheEntries(key, value) {
    const list = [{ key, value }];
    if (this.options.partiallyAcceptedCacheGeneration.enabled) {
      const entries = value.choices.map((choice) => {
        return this.calculatePartiallyAcceptedPositions(choice.text).map((position) => {
          return {
            prefix: choice.text.slice(0, position),
            suffix: choice.text.slice(position),
            choiceIndex: choice.index
          };
        });
      }).flat().reduce((grouped, entry) => {
        grouped[entry.prefix] = grouped[entry.prefix] || [];
        grouped[entry.prefix].push({ suffix: entry.suffix, choiceIndex: entry.choiceIndex });
        return grouped;
      }, {});
      for (const prefix in entries) {
        const cacheKey = {
          ...key,
          text: key.text.slice(0, key.position) + prefix + key.text.slice(key.position),
          position: key.position + prefix.length
        };
        const cacheValue = {
          ...value,
          choices: entries[prefix].map((choice) => {
            return {
              index: choice.choiceIndex,
              text: choice.suffix
            };
          })
        };
        list.push({
          key: cacheKey,
          value: cacheValue
        });
      }
    }
    return list;
  }
  calculatePartiallyAcceptedPositions(completion) {
    const positions = [];
    const option = this.options.partiallyAcceptedCacheGeneration;
    const lines = splitLines(completion);
    let index = 0;
    let offset = 0;
    while (index < lines.length - 1 && index < option.perLine.max) {
      offset += lines[index].length;
      positions.push(offset);
      index++;
    }
    const words = lines.slice(0, option.perWord.lines).map(splitWords).flat();
    index = 0;
    offset = 0;
    while (index < words.length && index < option.perWord.max) {
      offset += words[index].length;
      positions.push(offset);
      index++;
    }
    const characters = lines.slice(0, option.perCharacter.lines).map(splitWords).flat().slice(0, option.perCharacter.words).join("");
    offset = 1;
    while (offset < characters.length && offset < option.perCharacter.max) {
      positions.push(offset);
      offset++;
    }
    return positions.filter((v7, i7, arr) => arr.indexOf(v7) === i7).sort((a7, b5) => a7 - b5);
  }
};

// src/TabbyAgent.ts
var TabbyAgent = class extends EventEmitter {
  constructor() {
    super();
    this.logger = rootLogger.child({ component: "TabbyAgent" });
    this.config = defaultAgentConfig;
    this.status = "connecting";
    this.completionCache = new CompletionCache();
    this.onConfigUpdated();
  }
  onConfigUpdated() {
    allLoggers.forEach((logger) => logger.level = this.config.logs.level);
    this.api = new TabbyApi({ BASE: this.config.server.endpoint });
    this.ping();
  }
  changeStatus(status) {
    if (this.status != status) {
      this.status = status;
      const event = { event: "statusChanged", status };
      this.logger.debug({ event }, "Status changed");
      super.emit("statusChanged", event);
    }
  }
  async ping(tries = 0) {
    try {
      await axios_default.get(this.config.server.endpoint);
      this.changeStatus("ready");
      return true;
    } catch (e9) {
      if (tries > 5) {
        this.changeStatus("disconnected");
        return false;
      }
      this.changeStatus("connecting");
      const pingRetryDelay = 1e3;
      await sleep(pingRetryDelay);
      return this.ping(tries + 1);
    }
  }
  callApi(api, request2) {
    this.logger.debug({ api: api.name, request: request2 }, "API request");
    const promise = api.call(this.api.default, request2);
    return cancelable(
      promise.then((response) => {
        this.logger.debug({ api: api.name, response }, "API response");
        this.changeStatus("ready");
        return response;
      }).catch((error) => {
        this.logger.error({ api: api.name, error }, "API error");
        this.changeStatus("disconnected");
        throw error;
      }),
      () => {
        promise.cancel();
      }
    );
  }
  createPrompt(request2) {
    const maxLines = 20;
    const prefix = request2.text.slice(0, request2.position);
    const lines = splitLines(prefix);
    const cutoff = Math.max(lines.length - maxLines, 0);
    const prompt = lines.slice(cutoff).join("");
    return prompt;
  }
  initialize(params) {
    if (params.config) {
      this.updateConfig(params.config);
    }
    if (params.client) {
      allLoggers.forEach((logger) => logger.setBindings && logger.setBindings({ client: params.client }));
    }
    this.logger.debug({ params }, "Initialized");
    return true;
  }
  updateConfig(config2) {
    const mergedConfig = (0, import_deepmerge.default)(this.config, config2);
    if (!(0, import_deep_equal.default)(this.config, mergedConfig)) {
      this.config = mergedConfig;
      this.onConfigUpdated();
      const event = { event: "configUpdated", config: this.config };
      this.logger.debug({ event }, "Config updated");
      super.emit("configUpdated", event);
    }
    return true;
  }
  getConfig() {
    return this.config;
  }
  getStatus() {
    return this.status;
  }
  getCompletions(request2) {
    if (this.completionCache.has(request2)) {
      this.logger.debug({ request: request2 }, "Completion cache hit");
      return new CancelablePromise((resolve4) => {
        resolve4(this.completionCache.get(request2));
      });
    }
    const prompt = this.createPrompt(request2);
    if (isBlank(prompt)) {
      this.logger.debug("Prompt is blank, returning empty completion response");
      return new CancelablePromise((resolve4) => {
        resolve4({
          id: "agent-" + v4_default(),
          created: (/* @__PURE__ */ new Date()).getTime(),
          choices: []
        });
      });
    }
    const promise = this.callApi(this.api.default.completionsV1CompletionsPost, {
      prompt,
      language: request2.language
    });
    return cancelable(
      promise.then((response) => {
        this.completionCache.set(request2, response);
        return response;
      }),
      () => {
        promise.cancel();
      }
    );
  }
  postEvent(request2) {
    return this.callApi(this.api.default.eventsV1EventsPost, request2);
  }
};

// src/Agent.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var agentEventNames = ["statusChanged", "configUpdated"];
export {
  ApiError,
  CancelError,
  CancelablePromise,
  EventType,
  TabbyAgent,
  agentEventNames
};
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=index.mjs.map