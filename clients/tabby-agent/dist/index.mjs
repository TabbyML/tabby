var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
  get: (a7, b5) => (typeof require !== "undefined" ? require : a7)[b5]
}) : x4)(function(x4) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x4 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name3 in all3)
    __defProp(target, name3, { get: all3[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/esbuild-plugin-polyfill-node/polyfills/global.js
var global;
var init_global = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/global.js"() {
    global = globalThis;
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
var init_dirname = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js
var init_filename = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js"() {
  }
});

// node_modules/@jspm/core/nodelibs/browser/process.js
var process_exports = {};
__export(process_exports, {
  _debugEnd: () => _debugEnd,
  _debugProcess: () => _debugProcess,
  _events: () => _events,
  _eventsCount: () => _eventsCount,
  _exiting: () => _exiting,
  _fatalExceptions: () => _fatalExceptions,
  _getActiveHandles: () => _getActiveHandles,
  _getActiveRequests: () => _getActiveRequests,
  _kill: () => _kill,
  _linkedBinding: () => _linkedBinding,
  _maxListeners: () => _maxListeners,
  _preload_modules: () => _preload_modules,
  _rawDebug: () => _rawDebug,
  _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
  _tickCallback: () => _tickCallback,
  abort: () => abort,
  addListener: () => addListener,
  allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
  arch: () => arch,
  argv: () => argv,
  argv0: () => argv0,
  assert: () => assert,
  binding: () => binding,
  chdir: () => chdir,
  config: () => config,
  cpuUsage: () => cpuUsage,
  cwd: () => cwd,
  debugPort: () => debugPort,
  default: () => process,
  dlopen: () => dlopen,
  domain: () => domain,
  emit: () => emit,
  emitWarning: () => emitWarning,
  env: () => env,
  execArgv: () => execArgv,
  execPath: () => execPath,
  exit: () => exit,
  features: () => features,
  hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
  hrtime: () => hrtime,
  kill: () => kill,
  listeners: () => listeners,
  memoryUsage: () => memoryUsage,
  moduleLoadList: () => moduleLoadList,
  nextTick: () => nextTick,
  off: () => off,
  on: () => on,
  once: () => once,
  openStdin: () => openStdin,
  pid: () => pid,
  platform: () => platform,
  ppid: () => ppid,
  prependListener: () => prependListener,
  prependOnceListener: () => prependOnceListener,
  reallyExit: () => reallyExit,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  resourceUsage: () => resourceUsage,
  setSourceMapsEnabled: () => setSourceMapsEnabled,
  setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
  stderr: () => stderr,
  stdin: () => stdin,
  stdout: () => stdout,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function unimplemented(name3) {
  throw new Error("Node.js process " + name3 + " is not supported by JSPM core outside of Node.js");
}
function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length)
    drainQueue();
}
function drainQueue() {
  if (draining)
    return;
  var timeout = setTimeout(cleanUpNextTick, 0);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue)
        currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  clearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i7 = 1; i7 < arguments.length; i7++)
      args[i7 - 1] = arguments[i7];
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining)
    setTimeout(drainQueue, 0);
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function _linkedBinding(name3) {
  unimplemented("_linkedBinding");
}
function dlopen(name3) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
function assert(condition, message) {
  if (!condition)
    throw new Error(message || "assertion error");
}
function hasUncaughtExceptionCaptureCallback() {
  return false;
}
function uptime() {
  return _performance.now() / 1e3;
}
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
function on() {
  return process;
}
function listeners(name3) {
  return [];
}
var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
var init_process = __esm({
  "node_modules/@jspm/core/nodelibs/browser/process.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    arch = "x64";
    platform = "browser";
    env = {
      PATH: "/usr/bin",
      LANG: navigator.language + ".UTF-8",
      PWD: "/",
      HOME: "/home",
      TMP: "/tmp"
    };
    argv = ["/usr/bin/node"];
    execArgv = [];
    version = "v16.8.0";
    versions = {};
    emitWarning = function(message, type2) {
      console.warn((type2 ? type2 + ": " : "") + message);
    };
    binding = function(name3) {
      unimplemented("binding");
    };
    umask = function(mask) {
      return 0;
    };
    cwd = function() {
      return "/";
    };
    chdir = function(dir) {
    };
    release = {
      name: "node",
      sourceUrl: "",
      headersUrl: "",
      libUrl: ""
    };
    _rawDebug = noop;
    moduleLoadList = [];
    domain = {};
    _exiting = false;
    config = {};
    reallyExit = noop;
    _kill = noop;
    cpuUsage = function() {
      return {};
    };
    resourceUsage = cpuUsage;
    memoryUsage = cpuUsage;
    kill = noop;
    exit = noop;
    openStdin = noop;
    allowedNodeEnvironmentFlags = {};
    features = {
      inspector: false,
      debug: false,
      uv: false,
      ipv6: false,
      tls_alpn: false,
      tls_sni: false,
      tls_ocsp: false,
      tls: false,
      cached_builtins: true
    };
    _fatalExceptions = noop;
    setUncaughtExceptionCaptureCallback = noop;
    _tickCallback = noop;
    _debugProcess = noop;
    _debugEnd = noop;
    _startProfilerIdleNotifier = noop;
    _stopProfilerIdleNotifier = noop;
    stdout = void 0;
    stderr = void 0;
    stdin = void 0;
    abort = noop;
    pid = 2;
    ppid = 1;
    execPath = "/bin/usr/node";
    debugPort = 9229;
    argv0 = "node";
    _preload_modules = [];
    setSourceMapsEnabled = noop;
    _performance = {
      now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
      timing: typeof performance !== "undefined" ? performance.timing : void 0
    };
    if (_performance.now === void 0) {
      nowOffset = Date.now();
      if (_performance.timing && _performance.timing.navigationStart) {
        nowOffset = _performance.timing.navigationStart;
      }
      _performance.now = () => Date.now() - nowOffset;
    }
    nanoPerSec = 1e9;
    hrtime.bigint = function(time) {
      var diff = hrtime(time);
      if (typeof BigInt === "undefined") {
        return diff[0] * nanoPerSec + diff[1];
      }
      return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
    };
    _maxListeners = 10;
    _events = {};
    _eventsCount = 0;
    addListener = on;
    once = on;
    off = on;
    removeListener = on;
    removeAllListeners = on;
    emit = noop;
    prependListener = on;
    prependOnceListener = on;
    process = {
      version,
      versions,
      arch,
      platform,
      release,
      _rawDebug,
      moduleLoadList,
      binding,
      _linkedBinding,
      _events,
      _eventsCount,
      _maxListeners,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      prependListener,
      prependOnceListener,
      listeners,
      domain,
      _exiting,
      config,
      dlopen,
      uptime,
      _getActiveRequests,
      _getActiveHandles,
      reallyExit,
      _kill,
      cpuUsage,
      resourceUsage,
      memoryUsage,
      kill,
      exit,
      openStdin,
      allowedNodeEnvironmentFlags,
      assert,
      features,
      _fatalExceptions,
      setUncaughtExceptionCaptureCallback,
      hasUncaughtExceptionCaptureCallback,
      emitWarning,
      nextTick,
      _tickCallback,
      _debugProcess,
      _debugEnd,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      stdout,
      stdin,
      stderr,
      abort,
      umask,
      chdir,
      cwd,
      env,
      title,
      argv,
      execArgv,
      pid,
      ppid,
      execPath,
      debugPort,
      hrtime,
      argv0,
      _preload_modules,
      setSourceMapsEnabled
    };
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
var init_process2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
    init_process();
  }
});

// node_modules/@jspm/core/nodelibs/browser/buffer.js
function dew$2() {
  if (_dewExec$2)
    return exports$3;
  _dewExec$2 = true;
  exports$3.byteLength = byteLength;
  exports$3.toByteArray = toByteArray;
  exports$3.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$3;
}
function dew$1() {
  if (_dewExec$1)
    return exports$2;
  _dewExec$1 = true;
  exports$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e10, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e10 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e10 = e10 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e10 & (1 << -nBits) - 1;
    e10 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e10 === 0) {
      e10 = 1 - eBias;
    } else if (e10 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e10 = e10 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e10 - mLen);
  };
  exports$2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e10, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e10 = eMax;
    } else {
      e10 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e10)) < 1) {
        e10--;
        c7 *= 2;
      }
      if (e10 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e10++;
        c7 /= 2;
      }
      if (e10 + eBias >= eMax) {
        m6 = 0;
        e10 = eMax;
      } else if (e10 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e10 = e10 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e10 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e10 = e10 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e10 & 255, i7 += d6, e10 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$2;
}
function dew() {
  if (_dewExec)
    return exports$1;
  _dewExec = true;
  const base642 = dew$2();
  const ieee754 = dew$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer3;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e10) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer4(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
    if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b5, n9, m6) {
    const i7 = b5[n9];
    b5[n9] = b5[m6];
    b5[m6] = i7;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b5) {
    if (!Buffer3.isBuffer(b5))
      throw new TypeError("Argument must be a Buffer");
    if (this === b5)
      return true;
    return Buffer3.compare(this, b5) === 0;
  };
  Buffer3.prototype.inspect = function inspect3() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === "number") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name3) {
    if (name3) {
      return `${name3} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name3, actual) {
    return `The "${name3}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i7 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = `_${val.slice(i7 - 3, i7)}${res}`;
    }
    return `${val.slice(0, i7)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n9 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n9} and < 2${n9} ** ${(byteLength2 + 1) * 8}${n9}`;
        } else {
          range = `>= -(2${n9} ** ${(byteLength2 + 1) * 8 - 1}${n9}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n9}`;
        }
      } else {
        range = `>= ${min}${n9} and <= ${max}${n9}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name3) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name3, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2;
var init_buffer = __esm({
  "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$1 = {};
    _dewExec = false;
    exports = dew();
    exports["Buffer"];
    exports["SlowBuffer"];
    exports["INSPECT_MAX_BYTES"];
    exports["kMaxLength"];
    Buffer2 = exports.Buffer;
    exports.INSPECT_MAX_BYTES;
    exports.kMaxLength;
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
var init_buffer2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
    init_buffer();
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
function o() {
  o.init.call(this);
}
function u(e10) {
  if ("function" != typeof e10)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e10);
}
function f(e10) {
  return void 0 === e10._maxListeners ? o.defaultMaxListeners : e10._maxListeners;
}
function v(e10, t9, n9, r10) {
  var i7, o9, s6, v7;
  if (u(n9), void 0 === (o9 = e10._events) ? (o9 = e10._events = /* @__PURE__ */ Object.create(null), e10._eventsCount = 0) : (void 0 !== o9.newListener && (e10.emit("newListener", t9, n9.listener ? n9.listener : n9), o9 = e10._events), s6 = o9[t9]), void 0 === s6)
    s6 = o9[t9] = n9, ++e10._eventsCount;
  else if ("function" == typeof s6 ? s6 = o9[t9] = r10 ? [n9, s6] : [s6, n9] : r10 ? s6.unshift(n9) : s6.push(n9), (i7 = f(e10)) > 0 && s6.length > i7 && !s6.warned) {
    s6.warned = true;
    var a7 = new Error("Possible EventEmitter memory leak detected. " + s6.length + " " + String(t9) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a7.name = "MaxListenersExceededWarning", a7.emitter = e10, a7.type = t9, a7.count = s6.length, v7 = a7, console && console.warn && console.warn(v7);
  }
  return e10;
}
function a() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e10, t9, n9) {
  var r10 = { fired: false, wrapFn: void 0, target: e10, type: t9, listener: n9 }, i7 = a.bind(r10);
  return i7.listener = n9, r10.wrapFn = i7, i7;
}
function h(e10, t9, n9) {
  var r10 = e10._events;
  if (void 0 === r10)
    return [];
  var i7 = r10[t9];
  return void 0 === i7 ? [] : "function" == typeof i7 ? n9 ? [i7.listener || i7] : [i7] : n9 ? function(e11) {
    for (var t10 = new Array(e11.length), n10 = 0; n10 < t10.length; ++n10)
      t10[n10] = e11[n10].listener || e11[n10];
    return t10;
  }(i7) : c(i7, i7.length);
}
function p(e10) {
  var t9 = this._events;
  if (void 0 !== t9) {
    var n9 = t9[e10];
    if ("function" == typeof n9)
      return 1;
    if (void 0 !== n9)
      return n9.length;
  }
  return 0;
}
function c(e10, t9) {
  for (var n9 = new Array(t9), r10 = 0; r10 < t9; ++r10)
    n9[r10] = e10[r10];
  return n9;
}
var e, t, n, r, i, s, y;
var init_chunk_4bd36a8f = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    n = "object" == typeof Reflect ? Reflect : null;
    r = n && "function" == typeof n.apply ? n.apply : function(e10, t9, n9) {
      return Function.prototype.apply.call(e10, t9, n9);
    };
    t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e10) {
      return Object.getOwnPropertyNames(e10).concat(Object.getOwnPropertySymbols(e10));
    } : function(e10) {
      return Object.getOwnPropertyNames(e10);
    };
    i = Number.isNaN || function(e10) {
      return e10 != e10;
    };
    e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    s = 10;
    Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
      return s;
    }, set: function(e10) {
      if ("number" != typeof e10 || e10 < 0 || i(e10))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e10 + ".");
      s = e10;
    } }), o.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function(e10) {
      if ("number" != typeof e10 || e10 < 0 || i(e10))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e10 + ".");
      return this._maxListeners = e10, this;
    }, o.prototype.getMaxListeners = function() {
      return f(this);
    }, o.prototype.emit = function(e10) {
      for (var t9 = [], n9 = 1; n9 < arguments.length; n9++)
        t9.push(arguments[n9]);
      var i7 = "error" === e10, o9 = this._events;
      if (void 0 !== o9)
        i7 = i7 && void 0 === o9.error;
      else if (!i7)
        return false;
      if (i7) {
        var s6;
        if (t9.length > 0 && (s6 = t9[0]), s6 instanceof Error)
          throw s6;
        var u7 = new Error("Unhandled error." + (s6 ? " (" + s6.message + ")" : ""));
        throw u7.context = s6, u7;
      }
      var f7 = o9[e10];
      if (void 0 === f7)
        return false;
      if ("function" == typeof f7)
        r(f7, this, t9);
      else {
        var v7 = f7.length, a7 = c(f7, v7);
        for (n9 = 0; n9 < v7; ++n9)
          r(a7[n9], this, t9);
      }
      return true;
    }, o.prototype.addListener = function(e10, t9) {
      return v(this, e10, t9, false);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e10, t9) {
      return v(this, e10, t9, true);
    }, o.prototype.once = function(e10, t9) {
      return u(t9), this.on(e10, l(this, e10, t9)), this;
    }, o.prototype.prependOnceListener = function(e10, t9) {
      return u(t9), this.prependListener(e10, l(this, e10, t9)), this;
    }, o.prototype.removeListener = function(e10, t9) {
      var n9, r10, i7, o9, s6;
      if (u(t9), void 0 === (r10 = this._events))
        return this;
      if (void 0 === (n9 = r10[e10]))
        return this;
      if (n9 === t9 || n9.listener === t9)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r10[e10], r10.removeListener && this.emit("removeListener", e10, n9.listener || t9));
      else if ("function" != typeof n9) {
        for (i7 = -1, o9 = n9.length - 1; o9 >= 0; o9--)
          if (n9[o9] === t9 || n9[o9].listener === t9) {
            s6 = n9[o9].listener, i7 = o9;
            break;
          }
        if (i7 < 0)
          return this;
        0 === i7 ? n9.shift() : !function(e11, t10) {
          for (; t10 + 1 < e11.length; t10++)
            e11[t10] = e11[t10 + 1];
          e11.pop();
        }(n9, i7), 1 === n9.length && (r10[e10] = n9[0]), void 0 !== r10.removeListener && this.emit("removeListener", e10, s6 || t9);
      }
      return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e10) {
      var t9, n9, r10;
      if (void 0 === (n9 = this._events))
        return this;
      if (void 0 === n9.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n9[e10] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n9[e10]), this;
      if (0 === arguments.length) {
        var i7, o9 = Object.keys(n9);
        for (r10 = 0; r10 < o9.length; ++r10)
          "removeListener" !== (i7 = o9[r10]) && this.removeAllListeners(i7);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t9 = n9[e10]))
        this.removeListener(e10, t9);
      else if (void 0 !== t9)
        for (r10 = t9.length - 1; r10 >= 0; r10--)
          this.removeListener(e10, t9[r10]);
      return this;
    }, o.prototype.listeners = function(e10) {
      return h(this, e10, true);
    }, o.prototype.rawListeners = function(e10) {
      return h(this, e10, false);
    }, o.listenerCount = function(e10, t9) {
      return "function" == typeof e10.listenerCount ? e10.listenerCount(t9) : p.call(e10, t9);
    }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t(this._events) : [];
    };
    y = e;
    y.EventEmitter;
    y.defaultMaxListeners;
    y.init;
    y.listenerCount;
    y.EventEmitter;
    y.defaultMaxListeners;
    y.init;
    y.listenerCount;
  }
});

// node_modules/@jspm/core/nodelibs/browser/events.js
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter,
  default: () => y,
  defaultMaxListeners: () => defaultMaxListeners,
  init: () => init,
  listenerCount: () => listenerCount,
  on: () => on2,
  once: () => once2
});
var EventEmitter, defaultMaxListeners, init, listenerCount, on2, once2;
var init_events = __esm({
  "node_modules/@jspm/core/nodelibs/browser/events.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_4bd36a8f();
    init_chunk_4bd36a8f();
    y.once = function(emitter, event) {
      return new Promise((resolve4, reject) => {
        function eventListener(...args) {
          if (errorListener !== void 0) {
            emitter.removeListener("error", errorListener);
          }
          resolve4(args);
        }
        let errorListener;
        if (event !== "error") {
          errorListener = (err) => {
            emitter.removeListener(name, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        emitter.once(event, eventListener);
      });
    };
    y.on = function(emitter, event) {
      const unconsumedEventValues = [];
      const unconsumedPromises = [];
      let error = null;
      let finished2 = false;
      const iterator = {
        async next() {
          const value = unconsumedEventValues.shift();
          if (value) {
            return createIterResult(value, false);
          }
          if (error) {
            const p7 = Promise.reject(error);
            error = null;
            return p7;
          }
          if (finished2) {
            return createIterResult(void 0, true);
          }
          return new Promise((resolve4, reject) => unconsumedPromises.push({ resolve: resolve4, reject }));
        },
        async return() {
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
          finished2 = true;
          for (const promise of unconsumedPromises) {
            promise.resolve(createIterResult(void 0, true));
          }
          return createIterResult(void 0, true);
        },
        throw(err) {
          error = err;
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on(event, eventHandler);
      emitter.on("error", errorHandler);
      return iterator;
      function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEventValues.push(args);
        }
      }
      function errorHandler(err) {
        finished2 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }
    };
    ({
      EventEmitter,
      defaultMaxListeners,
      init,
      listenerCount,
      on: on2,
      once: once2
    } = y);
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o9) {
        var ctor = o9.constructor;
        return ctor && ctor.prototype === o9;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k4 in window) {
          try {
            if (!excludedKeys["$" + k4] && has.call(window, k4) && window[k4] !== null && typeof window[k4] === "object") {
              try {
                equalsConstructorPrototype(window[k4]);
              } catch (e10) {
                return true;
              }
            }
          } catch (e10) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o9) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o9);
        }
        try {
          return equalsConstructorPrototype(o9);
        } catch (e10) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject4 = object !== null && typeof object === "object";
        var isFunction4 = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString5 = isObject4 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject4 && !isFunction4 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction4;
        if (isString5 && object.length > 0 && !has.call(object, 0)) {
          for (var i7 = 0; i7 < object.length; ++i7) {
            theKeys.push(String(i7));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j4 = 0; j4 < object.length; ++j4) {
            theKeys.push(String(j4));
          }
        } else {
          for (var name3 in object) {
            if (!(skipProto && name3 === "prototype") && has.call(object, name3)) {
              theKeys.push(String(name3));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k4 = 0; k4 < dontEnums.length; ++k4) {
            if (!(skipConstructor && dontEnums[k4] === "constructor") && has.call(object, dontEnums[k4])) {
              theKeys.push(dontEnums[k4]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o9) {
      return origKeys(o9);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i7 = 0; i7 < boundLength; i7++) {
        boundArgs.push("$" + i7);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var bind2 = require_function_bind();
    module.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e10) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e10) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x4) {
      return x4.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e10) {
        errorProto = getProto(getProto(e10));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name3) {
      var value;
      if (name3 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name3 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name3 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name3 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name3 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name3] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var $exec = bind2.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
      var intrinsicName = name3;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name3, allowMissing) {
      if (typeof name3 !== "string" || name3.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name3) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name3);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i7 = 1, isOwn = true; i7 < parts.length; i7 += 1) {
        var part = parts[i7];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i7 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e10) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e10) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction4 = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name3, value, predicate) {
      if (name3 in object) {
        if (predicate === true) {
          if (object[name3] === value) {
            return;
          }
        } else if (!isFunction4(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name3, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name3] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates2 = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i7 = 0; i7 < props.length; i7 += 1) {
        defineProperty(object, props[i7], map[props[i7]], predicates2[props[i7]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var bind2 = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e10) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind2, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name3, allowMissing) {
      var intrinsic = GetIntrinsic(name3, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name3, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object.assign/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object.assign/implementation.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module.exports = function assign(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = toObject(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s6 = 1; s6 < arguments.length; ++s6) {
        var from = toObject(arguments[s6]);
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j4 = 0; j4 < syms.length; ++j4) {
            var key = syms[j4];
            if ($propIsEnumerable(from, key)) {
              $push(keys, key);
            }
          }
        }
        for (var i7 = 0; i7 < keys.length; ++i7) {
          var nextKey = keys[i7];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// node_modules/object.assign/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.assign/polyfill.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation3();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map = {};
      for (var i7 = 0; i7 < letters.length; ++i7) {
        map[letters[i7]] = letters[i7];
      }
      var obj = Object.assign({}, map);
      var actual = "";
      for (var k4 in obj) {
        actual += k4;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e10) {
        return thrower[1] === "y";
      }
      return false;
    };
    module.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// node_modules/object.assign/shim.js
var require_shim = __commonJS({
  "node_modules/object.assign/shim.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module.exports = function shimAssign() {
      var polyfill = getPolyfill();
      define2(
        Object,
        { assign: polyfill },
        { assign: function() {
          return Object.assign !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/object.assign/index.js
var require_object = __commonJS({
  "node_modules/object.assign/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var defineProperties = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind.apply(getPolyfill());
    var bound = function assign(target, source1) {
      return polyfill(Object, arguments);
    };
    defineProperties(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = bound;
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f7() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e10) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f7() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.unicodeSets) {
        result += "v";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module.exports, "name", { value: "get flags" });
    }
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o9 = {};
          Object.defineProperty(o9, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o9, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O5) {
      return O5.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol3(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray4(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect3(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp4(obj)) {
        var name3 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect3);
        return "[Function" + (name3 ? ": " + name3 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol3(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s6 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i7 = 0; i7 < attrs.length; i7++) {
          s6 += " " + attrs[i7].name + "=" + wrapQuotes(quote(attrs[i7].value), "double", opts);
        }
        s6 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s6 += "...";
        }
        s6 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s6;
      }
      if (isArray4(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect3);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError3(obj)) {
        var parts = arrObjKeys(obj, inspect3);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect3(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect3(key, obj, true) + " => " + inspect3(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect3(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber4(obj)) {
        return markBoxed(inspect3(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect3(bigIntValueOf.call(obj)));
      }
      if (isBoolean4(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString5(obj)) {
        return markBoxed(inspect3(String(obj)));
      }
      if (!isDate4(obj) && !isRegExp4(obj)) {
        var ys = arrObjKeys(obj, inspect3);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s6, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s6 + quoteChar;
    }
    function quote(s6) {
      return $replace.call(String(s6), /"/g, "&quot;");
    }
    function isArray4(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate4(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp4(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError3(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString5(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber4(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean4(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol3(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e10) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e10) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f7) {
      if (f7.name) {
        return f7.name;
      }
      var m6 = $match.call(functionToString.call(f7), /^function\s*([\w$]+)/);
      if (m6) {
        return m6[1];
      }
      return null;
    }
    function indexOf(xs, x4) {
      if (xs.indexOf) {
        return xs.indexOf(x4);
      }
      for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
        if (xs[i7] === x4) {
          return i7;
        }
      }
      return -1;
    }
    function isMap(x4) {
      if (!mapSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        mapSize.call(x4);
        try {
          setSize.call(x4);
        } catch (s6) {
          return true;
        }
        return x4 instanceof Map;
      } catch (e10) {
      }
      return false;
    }
    function isWeakMap(x4) {
      if (!weakMapHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x4, weakMapHas);
        try {
          weakSetHas.call(x4, weakSetHas);
        } catch (s6) {
          return true;
        }
        return x4 instanceof WeakMap;
      } catch (e10) {
      }
      return false;
    }
    function isWeakRef(x4) {
      if (!weakRefDeref || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x4);
        return true;
      } catch (e10) {
      }
      return false;
    }
    function isSet(x4) {
      if (!setSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        setSize.call(x4);
        try {
          mapSize.call(x4);
        } catch (m6) {
          return true;
        }
        return x4 instanceof Set;
      } catch (e10) {
      }
      return false;
    }
    function isWeakSet(x4) {
      if (!weakSetHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x4, weakSetHas);
        try {
          weakMapHas.call(x4, weakMapHas);
        } catch (s6) {
          return true;
        }
        return x4 instanceof WeakSet;
      } catch (e10) {
      }
      return false;
    }
    function isElement(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x4 instanceof HTMLElement) {
        return true;
      }
      return typeof x4.nodeName === "string" && typeof x4.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s6 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s6, "single", opts);
    }
    function lowbyte(c7) {
      var n9 = c7.charCodeAt(0);
      var x4 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n9];
      if (x4) {
        return "\\" + x4;
      }
      return "\\x" + (n9 < 16 ? "0" : "") + $toUpperCase.call(n9.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i7 = 0; i7 < xs.length; i7++) {
        if (indexOf(xs[i7], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect3) {
      var isArr = isArray4(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i7 = 0; i7 < obj.length; i7++) {
          xs[i7] = has(obj, i7) ? inspect3(obj[i7], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k4 = 0; k4 < syms.length; k4++) {
          symMap["$" + syms[k4]] = syms[k4];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect3(key, obj) + ": " + inspect3(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect3(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j4 = 0; j4 < syms.length; j4++) {
          if (isEnumerable.call(obj, syms[j4])) {
            xs.push("[" + inspect3(syms[j4]) + "]: " + inspect3(obj[syms[j4]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect3 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect3(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "node_modules/internal-slot/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O5);
        if (!SLOT.has(O5, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        return slots && slots["$" + slot];
      },
      has: function(O5, slot) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        return !!slots && has(slots, "$" + slot);
      },
      set: function(O5, slot, V3) {
        if (!O5 || typeof O5 !== "object" && typeof O5 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O5);
        if (!slots) {
          slots = {};
          channel.set(O5, slots);
        }
        slots["$" + slot] = V3;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module.exports = SLOT;
  }
});

// node_modules/stop-iteration-iterator/index.js
var require_stop_iteration_iterator = __commonJS({
  "node_modules/stop-iteration-iterator/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var SLOT = require_internal_slot();
    var $SyntaxError = SyntaxError;
    var $StopIteration = typeof StopIteration === "object" ? StopIteration : null;
    module.exports = function getStopIterationIterator(origIterator) {
      if (!$StopIteration) {
        throw new $SyntaxError("this environment lacks StopIteration");
      }
      SLOT.set(origIterator, "[[Done]]", false);
      var siIterator = {
        next: function next() {
          var iterator = SLOT.get(this, "[[Iterator]]");
          var done = SLOT.get(iterator, "[[Done]]");
          try {
            return {
              done,
              value: done ? void 0 : iterator.next()
            };
          } catch (e10) {
            SLOT.set(iterator, "[[Done]]", true);
            if (e10 !== $StopIteration) {
              throw e10;
            }
            return {
              done: true,
              value: void 0
            };
          }
        }
      };
      SLOT.set(siIterator, "[[Iterator]]", origIterator);
      return siIterator;
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toString3 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString3.call(arr) == "[object Array]";
    };
  }
});

// node_modules/is-string/index.js
var require_is_string = __commonJS({
  "node_modules/is-string/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e10) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module.exports = function isString5(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// node_modules/is-map/index.js
var require_is_map = __commonJS({
  "node_modules/is-map/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap(x4) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap(x4) {
        return false;
      };
    }
    module.exports = exported || function isMap(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x4);
        if ($setHas) {
          try {
            $setHas.call(x4);
          } catch (e10) {
            return true;
          }
        }
        return x4 instanceof $Map;
      } catch (e10) {
      }
      return false;
    };
  }
});

// node_modules/is-set/index.js
var require_is_set = __commonJS({
  "node_modules/is-set/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet(x4) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet(x4) {
        return false;
      };
    }
    module.exports = exported || function isSet(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $setHas.call(x4);
        if ($mapHas) {
          try {
            $mapHas.call(x4);
          } catch (e10) {
            return true;
          }
        }
        return x4 instanceof $Set;
      } catch (e10) {
      }
      return false;
    };
  }
});

// node_modules/es-get-iterator/index.js
var require_es_get_iterator = __commonJS({
  "node_modules/es-get-iterator/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isArguments = require_is_arguments();
    var getStopIterationIterator = require_stop_iteration_iterator();
    if (require_has_symbols()() || require_shams()()) {
      $iterator = Symbol.iterator;
      module.exports = function getIterator(iterable) {
        if (iterable != null && typeof iterable[$iterator] !== "undefined") {
          return iterable[$iterator]();
        }
        if (isArguments(iterable)) {
          return Array.prototype[$iterator].call(iterable);
        }
      };
    } else {
      isArray4 = require_isarray();
      isString5 = require_is_string();
      GetIntrinsic = require_get_intrinsic();
      $Map = GetIntrinsic("%Map%", true);
      $Set = GetIntrinsic("%Set%", true);
      callBound = require_callBound();
      $arrayPush = callBound("Array.prototype.push");
      $charCodeAt = callBound("String.prototype.charCodeAt");
      $stringSlice = callBound("String.prototype.slice");
      advanceStringIndex = function advanceStringIndex2(S4, index) {
        var length = S4.length;
        if (index + 1 >= length) {
          return index + 1;
        }
        var first = $charCodeAt(S4, index);
        if (first < 55296 || first > 56319) {
          return index + 1;
        }
        var second = $charCodeAt(S4, index + 1);
        if (second < 56320 || second > 57343) {
          return index + 1;
        }
        return index + 2;
      };
      getArrayIterator = function getArrayIterator2(arraylike) {
        var i7 = 0;
        return {
          next: function next() {
            var done = i7 >= arraylike.length;
            var value;
            if (!done) {
              value = arraylike[i7];
              i7 += 1;
            }
            return {
              done,
              value
            };
          }
        };
      };
      getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
        if (isArray4(iterable) || isArguments(iterable)) {
          return getArrayIterator(iterable);
        }
        if (isString5(iterable)) {
          var i7 = 0;
          return {
            next: function next() {
              var nextIndex = advanceStringIndex(iterable, i7);
              var value = $stringSlice(iterable, i7, nextIndex);
              i7 = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        }
        if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
          return iterable["_es6-shim iterator_"]();
        }
      };
      if (!$Map && !$Set) {
        module.exports = function getIterator(iterable) {
          if (iterable != null) {
            return getNonCollectionIterator(iterable, true);
          }
        };
      } else {
        isMap = require_is_map();
        isSet = require_is_set();
        $mapForEach = callBound("Map.prototype.forEach", true);
        $setForEach = callBound("Set.prototype.forEach", true);
        if (typeof process_exports === "undefined" || !process_exports.versions || !process_exports.versions.node) {
          $mapIterator = callBound("Map.prototype.iterator", true);
          $setIterator = callBound("Set.prototype.iterator", true);
        }
        $mapAtAtIterator = callBound("Map.prototype.@@iterator", true) || callBound("Map.prototype._es6-shim iterator_", true);
        $setAtAtIterator = callBound("Set.prototype.@@iterator", true) || callBound("Set.prototype._es6-shim iterator_", true);
        getCollectionIterator = function getCollectionIterator2(iterable) {
          if (isMap(iterable)) {
            if ($mapIterator) {
              return getStopIterationIterator($mapIterator(iterable));
            }
            if ($mapAtAtIterator) {
              return $mapAtAtIterator(iterable);
            }
            if ($mapForEach) {
              var entries = [];
              $mapForEach(iterable, function(v7, k4) {
                $arrayPush(entries, [k4, v7]);
              });
              return getArrayIterator(entries);
            }
          }
          if (isSet(iterable)) {
            if ($setIterator) {
              return getStopIterationIterator($setIterator(iterable));
            }
            if ($setAtAtIterator) {
              return $setAtAtIterator(iterable);
            }
            if ($setForEach) {
              var values = [];
              $setForEach(iterable, function(v7) {
                $arrayPush(values, v7);
              });
              return getArrayIterator(values);
            }
          }
        };
        module.exports = function getIterator(iterable) {
          return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
        };
      }
    }
    var $iterator;
    var isArray4;
    var isString5;
    var GetIntrinsic;
    var $Map;
    var $Set;
    var callBound;
    var $arrayPush;
    var $charCodeAt;
    var $stringSlice;
    var advanceStringIndex;
    var getArrayIterator;
    var getNonCollectionIterator;
    var isMap;
    var isSet;
    var $mapForEach;
    var $setForEach;
    var $mapIterator;
    var $setIterator;
    var $mapAtAtIterator;
    var $setAtAtIterator;
    var getCollectionIterator;
  }
});

// node_modules/object-is/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/object-is/implementation.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a7, b5) {
      if (a7 === 0 && b5 === 0) {
        return 1 / a7 === 1 / b5;
      }
      if (a7 === b5) {
        return true;
      }
      if (numberIsNaN(a7) && numberIsNaN(b5)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/object-is/polyfill.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var implementation = require_implementation5();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim3 = __commonJS({
  "node_modules/object-is/shim.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var getPolyfill = require_polyfill3();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_4) {
        if (_4 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e10) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e10) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all3 = document.all;
      if (toStr.call(all3) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e10) {
            }
          }
          return false;
        };
      }
    }
    var all3;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e10) {
        if (e10 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i7 = 0, len = array.length; i7 < len; i7++) {
        if (hasOwnProperty2.call(array, i7)) {
          if (receiver == null) {
            iterator(array[i7], i7, array);
          } else {
            iterator.call(receiver, array[i7], i7, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i7 = 0, len = string.length; i7 < len; i7++) {
        if (receiver == null) {
          iterator(string.charAt(i7), i7, string);
        } else {
          iterator.call(receiver, string.charAt(i7), i7, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k4 in object) {
        if (hasOwnProperty2.call(object, k4)) {
          if (receiver == null) {
            iterator(object[k4], k4, object);
          } else {
            iterator.call(receiver, object[k4], k4, object);
          }
        }
      }
    };
    var forEach2 = function forEach3(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach2;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i7 = 0; i7 < possibleNames.length; i7++) {
        if (typeof g5[possibleNames[i7]] === "function") {
          out[out.length] = possibleNames[i7];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e10) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i7 = 0; i7 < array.length; i7 += 1) {
        if (array[i7] === value) {
          return i7;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf2) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g5[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf2(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf2(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach2(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e10) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-array-buffer/index.js
var require_is_array_buffer = __commonJS({
  "node_modules/is-array-buffer/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var GetIntrinsic = require_get_intrinsic();
    var isTypedArray2 = require_is_typed_array();
    var $ArrayBuffer = GetIntrinsic("ArrayBuffer", true);
    var $Float32Array = GetIntrinsic("Float32Array", true);
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;
    var $abSlice = abSlice && callBind(abSlice);
    module.exports = $byteLength || $abSlice ? function isArrayBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        if ($byteLength) {
          $byteLength(obj);
        } else {
          $abSlice(obj, 0);
        }
        return true;
      } catch (e10) {
        return false;
      }
    } : $Float32Array ? function IsArrayBuffer(obj) {
      try {
        return new $Float32Array(obj).buffer === obj && !isTypedArray2(obj);
      } catch (e10) {
        return typeof obj === "object" && e10.name === "RangeError";
      }
    } : function isArrayBuffer2(obj) {
      return false;
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e10) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e10) {
        return e10 === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/is-shared-array-buffer/index.js
var require_is_shared_array_buffer = __commonJS({
  "node_modules/is-shared-array-buffer/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $byteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    module.exports = $byteLength ? function isSharedArrayBuffer(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        $byteLength(obj);
        return true;
      } catch (e10) {
        return false;
      }
    } : function isSharedArrayBuffer(obj) {
      return false;
    };
  }
});

// node_modules/is-number-object/index.js
var require_is_number_object = __commonJS({
  "node_modules/is-number-object/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var numToStr = Number.prototype.toString;
    var tryNumberObject = function tryNumberObject2(value) {
      try {
        numToStr.call(value);
        return true;
      } catch (e10) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var numClass = "[object Number]";
    var hasToStringTag = require_shams2()();
    module.exports = function isNumberObject(value) {
      if (typeof value === "number") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
    };
  }
});

// node_modules/is-boolean-object/index.js
var require_is_boolean_object = __commonJS({
  "node_modules/is-boolean-object/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
      try {
        $boolToStr(value);
        return true;
      } catch (e10) {
        return false;
      }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = require_shams2()();
    module.exports = function isBoolean4(value) {
      if (typeof value === "boolean") {
        return true;
      }
      if (value === null || typeof value !== "object") {
        return false;
      }
      return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module.exports = function isSymbol3(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e10) {
          return false;
        }
      };
    } else {
      module.exports = function isSymbol3(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/has-bigints/index.js
var require_has_bigints = __commonJS({
  "node_modules/has-bigints/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    module.exports = function hasNativeBigInts() {
      return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
  }
});

// node_modules/is-bigint/index.js
var require_is_bigint = __commonJS({
  "node_modules/is-bigint/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var hasBigInts = require_has_bigints()();
    if (hasBigInts) {
      bigIntValueOf = BigInt.prototype.valueOf;
      tryBigInt = function tryBigIntObject(value) {
        try {
          bigIntValueOf.call(value);
          return true;
        } catch (e10) {
        }
        return false;
      };
      module.exports = function isBigInt(value) {
        if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
          return false;
        }
        if (typeof value === "bigint") {
          return true;
        }
        return tryBigInt(value);
      };
    } else {
      module.exports = function isBigInt(value) {
        return false;
      };
    }
    var bigIntValueOf;
    var tryBigInt;
  }
});

// node_modules/which-boxed-primitive/index.js
var require_which_boxed_primitive = __commonJS({
  "node_modules/which-boxed-primitive/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isString5 = require_is_string();
    var isNumber4 = require_is_number_object();
    var isBoolean4 = require_is_boolean_object();
    var isSymbol3 = require_is_symbol();
    var isBigInt = require_is_bigint();
    module.exports = function whichBoxedPrimitive(value) {
      if (value == null || typeof value !== "object" && typeof value !== "function") {
        return null;
      }
      if (isString5(value)) {
        return "String";
      }
      if (isNumber4(value)) {
        return "Number";
      }
      if (isBoolean4(value)) {
        return "Boolean";
      }
      if (isSymbol3(value)) {
        return "Symbol";
      }
      if (isBigInt(value)) {
        return "BigInt";
      }
    };
  }
});

// node_modules/is-weakmap/index.js
var require_is_weakmap = __commonJS({
  "node_modules/is-weakmap/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
      exported = function isWeakMap(x4) {
        return false;
      };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isWeakMap(x4) {
        return false;
      };
    }
    module.exports = exported || function isWeakMap(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x4, $mapHas);
        if ($setHas) {
          try {
            $setHas.call(x4, $setHas);
          } catch (e10) {
            return true;
          }
        }
        return x4 instanceof $WeakMap;
      } catch (e10) {
      }
      return false;
    };
  }
});

// node_modules/is-weakset/index.js
var require_is_weakset = __commonJS({
  "node_modules/is-weakset/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound("WeakSet.prototype.has", true);
    if ($setHas) {
      $mapHas = callBound("WeakMap.prototype.has", true);
      module.exports = function isWeakSet(x4) {
        if (!x4 || typeof x4 !== "object") {
          return false;
        }
        try {
          $setHas(x4, $setHas);
          if ($mapHas) {
            try {
              $mapHas(x4, $mapHas);
            } catch (e10) {
              return true;
            }
          }
          return x4 instanceof $WeakSet;
        } catch (e10) {
        }
        return false;
      };
    } else {
      module.exports = function isWeakSet(x4) {
        return false;
      };
    }
    var $mapHas;
  }
});

// node_modules/which-collection/index.js
var require_which_collection = __commonJS({
  "node_modules/which-collection/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isMap = require_is_map();
    var isSet = require_is_set();
    var isWeakMap = require_is_weakmap();
    var isWeakSet = require_is_weakset();
    module.exports = function whichCollection(value) {
      if (value && typeof value === "object") {
        if (isMap(value)) {
          return "Map";
        }
        if (isSet(value)) {
          return "Set";
        }
        if (isWeakMap(value)) {
          return "WeakMap";
        }
        if (isWeakSet(value)) {
          return "WeakSet";
        }
      }
      return false;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf2) {
      forEach2(typedArrays, function(typedArray) {
        if (typeof g5[typedArray] === "function") {
          var arr = new g5[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf2(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf2(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach2(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name3 = getter.call(value);
            if (name3 === typedArray) {
              foundName = name3;
            }
          } catch (e10) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray2(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/array-buffer-byte-length/index.js
var require_array_buffer_byte_length = __commonJS({
  "node_modules/array-buffer-byte-length/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var callBound = require_callBound();
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var isArrayBuffer2 = require_is_array_buffer();
    module.exports = function byteLength(ab) {
      if (!isArrayBuffer2(ab)) {
        return NaN;
      }
      return $byteLength ? $byteLength(ab) : ab.byteLength;
    };
  }
});

// node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "node_modules/deep-equal/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var assign = require_object();
    var callBound = require_callBound();
    var flags = require_regexp_prototype();
    var GetIntrinsic = require_get_intrinsic();
    var getIterator = require_es_get_iterator();
    var getSideChannel = require_side_channel();
    var is = require_object_is();
    var isArguments = require_is_arguments();
    var isArray4 = require_isarray();
    var isArrayBuffer2 = require_is_array_buffer();
    var isDate4 = require_is_date_object();
    var isRegex = require_is_regex();
    var isSharedArrayBuffer = require_is_shared_array_buffer();
    var objectKeys = require_object_keys();
    var whichBoxedPrimitive = require_which_boxed_primitive();
    var whichCollection = require_which_collection();
    var whichTypedArray = require_which_typed_array();
    var byteLength = require_array_buffer_byte_length();
    var sabByteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    var $getTime = callBound("Date.prototype.getTime");
    var gPO = Object.getPrototypeOf;
    var $objToString = callBound("Object.prototype.toString");
    var $Set = GetIntrinsic("%Set%", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSize = callBound("Map.prototype.size", true);
    var $setAdd = callBound("Set.prototype.add", true);
    var $setDelete = callBound("Set.prototype.delete", true);
    var $setHas = callBound("Set.prototype.has", true);
    var $setSize = callBound("Set.prototype.size", true);
    function setHasEqualElement(set, val1, opts, channel) {
      var i7 = getIterator(set);
      var result;
      while ((result = i7.next()) && !result.done) {
        if (internalDeepEqual(val1, result.value, opts, channel)) {
          $setDelete(set, result.value);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      if (typeof prim === "undefined") {
        return null;
      }
      if (typeof prim === "object") {
        return void 0;
      }
      if (typeof prim === "symbol") {
        return false;
      }
      if (typeof prim === "string" || typeof prim === "number") {
        return +prim === +prim;
      }
      return true;
    }
    function mapMightHaveLoosePrim(a7, b5, prim, item, opts, channel) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = $mapGet(b5, altValue);
      var looseOpts = assign({}, opts, { strict: false });
      if (typeof curB === "undefined" && !$mapHas(b5, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
        return false;
      }
      return !$mapHas(a7, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    function setMightHaveLoosePrim(a7, b5, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      return $setHas(b5, altValue) && !$setHas(a7, altValue);
    }
    function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
      var i7 = getIterator(set);
      var result;
      var key2;
      while ((result = i7.next()) && !result.done) {
        key2 = result.value;
        if (
          // eslint-disable-next-line no-use-before-define
          internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)
        ) {
          $setDelete(set, key2);
          return true;
        }
      }
      return false;
    }
    function internalDeepEqual(actual, expected, options, channel) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      var actualBoxed = whichBoxedPrimitive(actual);
      var expectedBoxed = whichBoxedPrimitive(expected);
      if (actualBoxed !== expectedBoxed) {
        return false;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      var hasActual = channel.has(actual);
      var hasExpected = channel.has(expected);
      var sentinel;
      if (hasActual && hasExpected) {
        if (channel.get(actual) === channel.get(expected)) {
          return true;
        }
      } else {
        sentinel = {};
      }
      if (!hasActual) {
        channel.set(actual, sentinel);
      }
      if (!hasExpected) {
        channel.set(expected, sentinel);
      }
      return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer4(x4) {
      if (!x4 || typeof x4 !== "object" || typeof x4.length !== "number") {
        return false;
      }
      if (typeof x4.copy !== "function" || typeof x4.slice !== "function") {
        return false;
      }
      if (x4.length > 0 && typeof x4[0] !== "number") {
        return false;
      }
      return !!(x4.constructor && x4.constructor.isBuffer && x4.constructor.isBuffer(x4));
    }
    function setEquiv(a7, b5, opts, channel) {
      if ($setSize(a7) !== $setSize(b5)) {
        return false;
      }
      var iA = getIterator(a7);
      var iB = getIterator(b5);
      var resultA;
      var resultB;
      var set;
      while ((resultA = iA.next()) && !resultA.done) {
        if (resultA.value && typeof resultA.value === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        } else if (!$setHas(b5, resultA.value)) {
          if (opts.strict) {
            return false;
          }
          if (!setMightHaveLoosePrim(a7, b5, resultA.value)) {
            return false;
          }
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          if (resultB.value && typeof resultB.value === "object") {
            if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
              return false;
            }
          } else if (!opts.strict && !$setHas(a7, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function mapEquiv(a7, b5, opts, channel) {
      if ($mapSize(a7) !== $mapSize(b5)) {
        return false;
      }
      var iA = getIterator(a7);
      var iB = getIterator(b5);
      var resultA;
      var resultB;
      var set;
      var key;
      var item1;
      var item2;
      while ((resultA = iA.next()) && !resultA.done) {
        key = resultA.value[0];
        item1 = resultA.value[1];
        if (key && typeof key === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, key);
        } else {
          item2 = $mapGet(b5, key);
          if (typeof item2 === "undefined" && !$mapHas(b5, key) || !internalDeepEqual(item1, item2, opts, channel)) {
            if (opts.strict) {
              return false;
            }
            if (!mapMightHaveLoosePrim(a7, b5, key, item1, opts, channel)) {
              return false;
            }
            if (!set) {
              set = new $Set();
            }
            $setAdd(set, key);
          }
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          key = resultB.value[0];
          item2 = resultB.value[1];
          if (key && typeof key === "object") {
            if (!mapHasEqualEntry(set, a7, key, item2, opts, channel)) {
              return false;
            }
          } else if (!opts.strict && (!a7.has(key) || !internalDeepEqual($mapGet(a7, key), item2, opts, channel)) && !mapHasEqualEntry(set, a7, key, item2, assign({}, opts, { strict: false }), channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function objEquiv(a7, b5, opts, channel) {
      var i7, key;
      if (typeof a7 !== typeof b5) {
        return false;
      }
      if (a7 == null || b5 == null) {
        return false;
      }
      if ($objToString(a7) !== $objToString(b5)) {
        return false;
      }
      if (isArguments(a7) !== isArguments(b5)) {
        return false;
      }
      var aIsArray = isArray4(a7);
      var bIsArray = isArray4(b5);
      if (aIsArray !== bIsArray) {
        return false;
      }
      var aIsError = a7 instanceof Error;
      var bIsError = b5 instanceof Error;
      if (aIsError !== bIsError) {
        return false;
      }
      if (aIsError || bIsError) {
        if (a7.name !== b5.name || a7.message !== b5.message) {
          return false;
        }
      }
      var aIsRegex = isRegex(a7);
      var bIsRegex = isRegex(b5);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if ((aIsRegex || bIsRegex) && (a7.source !== b5.source || flags(a7) !== flags(b5))) {
        return false;
      }
      var aIsDate = isDate4(a7);
      var bIsDate = isDate4(b5);
      if (aIsDate !== bIsDate) {
        return false;
      }
      if (aIsDate || bIsDate) {
        if ($getTime(a7) !== $getTime(b5)) {
          return false;
        }
      }
      if (opts.strict && gPO && gPO(a7) !== gPO(b5)) {
        return false;
      }
      var aWhich = whichTypedArray(a7);
      var bWhich = whichTypedArray(b5);
      if ((aWhich || bWhich) && aWhich !== bWhich) {
        return false;
      }
      var aIsBuffer = isBuffer4(a7);
      var bIsBuffer = isBuffer4(b5);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a7.length !== b5.length) {
          return false;
        }
        for (i7 = 0; i7 < a7.length; i7++) {
          if (a7[i7] !== b5[i7]) {
            return false;
          }
        }
        return true;
      }
      var aIsArrayBuffer = isArrayBuffer2(a7);
      var bIsArrayBuffer = isArrayBuffer2(b5);
      if (aIsArrayBuffer !== bIsArrayBuffer) {
        return false;
      }
      if (aIsArrayBuffer || bIsArrayBuffer) {
        if (byteLength(a7) !== byteLength(b5)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a7), new Uint8Array(b5), opts, channel);
      }
      var aIsSAB = isSharedArrayBuffer(a7);
      var bIsSAB = isSharedArrayBuffer(b5);
      if (aIsSAB !== bIsSAB) {
        return false;
      }
      if (aIsSAB || bIsSAB) {
        if (sabByteLength(a7) !== sabByteLength(b5)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a7), new Uint8Array(b5), opts, channel);
      }
      if (typeof a7 !== typeof b5) {
        return false;
      }
      var ka = objectKeys(a7);
      var kb = objectKeys(b5);
      if (ka.length !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (i7 = ka.length - 1; i7 >= 0; i7--) {
        if (ka[i7] != kb[i7]) {
          return false;
        }
      }
      for (i7 = ka.length - 1; i7 >= 0; i7--) {
        key = ka[i7];
        if (!internalDeepEqual(a7[key], b5[key], opts, channel)) {
          return false;
        }
      }
      var aCollection = whichCollection(a7);
      var bCollection = whichCollection(b5);
      if (aCollection !== bCollection) {
        return false;
      }
      if (aCollection === "Set" || bCollection === "Set") {
        return setEquiv(a7, b5, opts, channel);
      }
      if (aCollection === "Map") {
        return mapEquiv(a7, b5, opts, channel);
      }
      return true;
    }
    module.exports = function deepEqual3(a7, b5, opts) {
      return internalDeepEqual(a7, b5, opts, getSideChannel());
    };
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_4) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// src/env.ts
var isBrowser;
var init_env = __esm({
  "src/env.ts"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    isBrowser = true;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
function dew2() {
  if (_dewExec2)
    return exports2;
  _dewExec2 = true;
  var process3 = exports2 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e10) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e10) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e10) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e11) {
        return cachedSetTimeout.call(this || _global2, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e10) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e11) {
        return cachedClearTimeout.call(this || _global2, marker);
      }
    }
  }
  var queue2 = [];
  var draining2 = false;
  var currentQueue2;
  var queueIndex2 = -1;
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout(timeout);
  }
  process3.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        args[i7 - 1] = arguments[i7];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout(drainQueue2);
    }
  };
  function Item2(fun, array) {
    (this || _global2).fun = fun;
    (this || _global2).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global2).fun.apply(null, (this || _global2).array);
  };
  process3.title = "browser";
  process3.browser = true;
  process3.env = {};
  process3.argv = [];
  process3.version = "";
  process3.versions = {};
  function noop3() {
  }
  process3.on = noop3;
  process3.addListener = noop3;
  process3.once = noop3;
  process3.off = noop3;
  process3.removeListener = noop3;
  process3.removeAllListeners = noop3;
  process3.emit = noop3;
  process3.prependListener = noop3;
  process3.prependOnceListener = noop3;
  process3.listeners = function(name3) {
    return [];
  };
  process3.binding = function(name3) {
    throw new Error("process.binding is not supported");
  };
  process3.cwd = function() {
    return "/";
  };
  process3.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process3.umask = function() {
    return 0;
  };
  return exports2;
}
var exports2, _dewExec2, _global2, process2;
var init_chunk_2eac56ff = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports2 = {};
    _dewExec2 = false;
    _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    process2 = dew2();
    process2.platform = "browser";
    process2.addListener;
    process2.argv;
    process2.binding;
    process2.browser;
    process2.chdir;
    process2.cwd;
    process2.emit;
    process2.env;
    process2.listeners;
    process2.nextTick;
    process2.off;
    process2.on;
    process2.once;
    process2.prependListener;
    process2.prependOnceListener;
    process2.removeAllListeners;
    process2.removeListener;
    process2.title;
    process2.umask;
    process2.version;
    process2.versions;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
function dew3() {
  if (_dewExec3)
    return exports$12;
  _dewExec3 = true;
  var process$1 = process2;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve4() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd2 === void 0)
            cwd2 = process$1.cwd();
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute2)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = "";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$12 = posix2;
  return exports$12;
}
var exports$12, _dewExec3, exports3;
var init_chunk_23dbec7b = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_2eac56ff();
    exports$12 = {};
    _dewExec3 = false;
    exports3 = dew3();
  }
});

// node_modules/@jspm/core/nodelibs/browser/path.js
var path_exports = {};
__export(path_exports, {
  _makeLong: () => _makeLong,
  basename: () => basename,
  default: () => exports3,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  parse: () => parse,
  posix: () => posix,
  relative: () => relative,
  resolve: () => resolve2,
  sep: () => sep,
  win32: () => win32
});
var _makeLong, basename, delimiter, dirname, extname, format, isAbsolute, join, normalize, parse, posix, relative, resolve2, sep, win32;
var init_path = __esm({
  "node_modules/@jspm/core/nodelibs/browser/path.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_23dbec7b();
    init_chunk_23dbec7b();
    init_chunk_2eac56ff();
    _makeLong = exports3._makeLong;
    basename = exports3.basename;
    delimiter = exports3.delimiter;
    dirname = exports3.dirname;
    extname = exports3.extname;
    format = exports3.format;
    isAbsolute = exports3.isAbsolute;
    join = exports3.join;
    normalize = exports3.normalize;
    parse = exports3.parse;
    posix = exports3.posix;
    relative = exports3.relative;
    resolve2 = exports3.resolve;
    sep = exports3.sep;
    win32 = exports3.win32;
  }
});

// node_modules/@jspm/core/nodelibs/browser/os.js
var os_exports = {};
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch2,
  constants: () => constants,
  cpus: () => cpus,
  default: () => exports4,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  homedir: () => homedir,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform2,
  release: () => release2,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime,
  version: () => version2
});
function dew4() {
  if (_dewExec4)
    return exports$13;
  _dewExec4 = true;
  exports$13.endianness = function() {
    return "LE";
  };
  exports$13.hostname = function() {
    if (typeof location !== "undefined") {
      return location.hostname;
    } else
      return "";
  };
  exports$13.loadavg = function() {
    return [];
  };
  exports$13.uptime = function() {
    return 0;
  };
  exports$13.freemem = function() {
    return Number.MAX_VALUE;
  };
  exports$13.totalmem = function() {
    return Number.MAX_VALUE;
  };
  exports$13.cpus = function() {
    return [];
  };
  exports$13.type = function() {
    return "Browser";
  };
  exports$13.release = function() {
    if (typeof navigator !== "undefined") {
      return navigator.appVersion;
    }
    return "";
  };
  exports$13.networkInterfaces = exports$13.getNetworkInterfaces = function() {
    return {};
  };
  exports$13.arch = function() {
    return "javascript";
  };
  exports$13.platform = function() {
    return "browser";
  };
  exports$13.tmpdir = exports$13.tmpDir = function() {
    return "/tmp";
  };
  exports$13.EOL = "\n";
  exports$13.homedir = function() {
    return "/";
  };
  return exports$13;
}
var exports$13, _dewExec4, exports4, _endianness, version2, constants, EOL, arch2, cpus, endianness, freemem, getNetworkInterfaces, homedir, hostname, loadavg, networkInterfaces, platform2, release2, tmpDir, tmpdir, totalmem, type;
var init_os = __esm({
  "node_modules/@jspm/core/nodelibs/browser/os.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_process();
    init_process();
    exports$13 = {};
    _dewExec4 = false;
    exports4 = dew4();
    exports4["endianness"];
    exports4["hostname"];
    exports4["loadavg"];
    exports4["uptime"];
    exports4["freemem"];
    exports4["totalmem"];
    exports4["cpus"];
    exports4["type"];
    exports4["release"];
    exports4["networkInterfaces"];
    exports4["getNetworkInterfaces"];
    exports4["arch"];
    exports4["platform"];
    exports4["tmpdir"];
    exports4["tmpDir"];
    exports4["EOL"];
    exports4["homedir"];
    _endianness = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1 ? "LE" : "BE";
    exports4.endianness = function() {
      return _endianness;
    };
    exports4.homedir = function() {
      return "/home";
    };
    exports4.version = function() {
      return "";
    };
    exports4.arch = function() {
      return "x64";
    };
    exports4.totalmem = function() {
      return navigator.deviceMemory !== void 0 ? navigator.deviceMemory * (1 << 30) : 2 * (1 << 30);
    };
    exports4.cpus = function() {
      return Array(navigator.hardwareConcurrency || 0).fill({ model: "", times: {} });
    };
    exports4.uptime = uptime;
    exports4.constants = {};
    version2 = exports4.version;
    constants = exports4.constants;
    EOL = exports4.EOL;
    arch2 = exports4.arch;
    cpus = exports4.cpus;
    endianness = exports4.endianness;
    freemem = exports4.freemem;
    getNetworkInterfaces = exports4.getNetworkInterfaces;
    homedir = exports4.homedir;
    hostname = exports4.hostname;
    loadavg = exports4.loadavg;
    networkInterfaces = exports4.networkInterfaces;
    platform2 = exports4.platform;
    release2 = exports4.release;
    tmpDir = exports4.tmpDir;
    tmpdir = exports4.tmpdir;
    totalmem = exports4.totalmem;
    type = exports4.type;
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve4(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports10.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r10) => cb(null, r10), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
function i2() {
  throw new Error("setTimeout has not been defined");
}
function u2() {
  throw new Error("clearTimeout has not been defined");
}
function c2(e10) {
  if (t3 === setTimeout)
    return setTimeout(e10, 0);
  if ((t3 === i2 || !t3) && setTimeout)
    return t3 = setTimeout, setTimeout(e10, 0);
  try {
    return t3(e10, 0);
  } catch (n9) {
    try {
      return t3.call(null, e10, 0);
    } catch (n10) {
      return t3.call(this || r3, e10, 0);
    }
  }
}
function h2() {
  f2 && l2 && (f2 = false, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
}
function d() {
  if (!f2) {
    var e10 = c2(h2);
    f2 = true;
    for (var t9 = s2.length; t9; ) {
      for (l2 = s2, s2 = []; ++a2 < t9; )
        l2 && l2[a2].run();
      a2 = -1, t9 = s2.length;
    }
    l2 = null, f2 = false, function(e11) {
      if (n3 === clearTimeout)
        return clearTimeout(e11);
      if ((n3 === u2 || !n3) && clearTimeout)
        return n3 = clearTimeout, clearTimeout(e11);
      try {
        n3(e11);
      } catch (t10) {
        try {
          return n3.call(null, e11);
        } catch (t11) {
          return n3.call(this || r3, e11);
        }
      }
    }(e10);
  }
}
function m(e10, t9) {
  (this || r3).fun = e10, (this || r3).array = t9;
}
function p2() {
}
var e3, t3, n3, r3, o3, l2, s2, f2, a2, T;
var init_chunk_5decc758 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    r3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
    o3 = e3 = {};
    !function() {
      try {
        t3 = "function" == typeof setTimeout ? setTimeout : i2;
      } catch (e10) {
        t3 = i2;
      }
      try {
        n3 = "function" == typeof clearTimeout ? clearTimeout : u2;
      } catch (e10) {
        n3 = u2;
      }
    }();
    s2 = [];
    f2 = false;
    a2 = -1;
    o3.nextTick = function(e10) {
      var t9 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n9 = 1; n9 < arguments.length; n9++)
          t9[n9 - 1] = arguments[n9];
      s2.push(new m(e10, t9)), 1 !== s2.length || f2 || c2(d);
    }, m.prototype.run = function() {
      (this || r3).fun.apply(null, (this || r3).array);
    }, o3.title = "browser", o3.browser = true, o3.env = {}, o3.argv = [], o3.version = "", o3.versions = {}, o3.on = p2, o3.addListener = p2, o3.once = p2, o3.off = p2, o3.removeListener = p2, o3.removeAllListeners = p2, o3.emit = p2, o3.prependListener = p2, o3.prependOnceListener = p2, o3.listeners = function(e10) {
      return [];
    }, o3.binding = function(e10) {
      throw new Error("process.binding is not supported");
    }, o3.cwd = function() {
      return "/";
    }, o3.chdir = function(e10) {
      throw new Error("process.chdir is not supported");
    }, o3.umask = function() {
      return 0;
    };
    T = e3;
    T.addListener;
    T.argv;
    T.binding;
    T.browser;
    T.chdir;
    T.cwd;
    T.emit;
    T.env;
    T.listeners;
    T.nextTick;
    T.off;
    T.on;
    T.once;
    T.prependListener;
    T.prependOnceListener;
    T.removeAllListeners;
    T.removeListener;
    T.title;
    T.umask;
    T.version;
    T.versions;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
function c$1(e10) {
  return e10.call.bind(e10);
}
function O(e10, t9) {
  if ("object" != typeof e10)
    return false;
  try {
    return t9(e10), true;
  } catch (e11) {
    return false;
  }
}
function S(e10) {
  return l$1 && y2 ? void 0 !== b(e10) : B(e10) || k(e10) || E(e10) || D(e10) || U(e10) || P(e10) || x(e10) || I(e10) || M(e10) || z(e10) || F(e10);
}
function B(e10) {
  return l$1 && y2 ? "Uint8Array" === b(e10) : "[object Uint8Array]" === m2(e10) || u$1(e10) && void 0 !== e10.buffer;
}
function k(e10) {
  return l$1 && y2 ? "Uint8ClampedArray" === b(e10) : "[object Uint8ClampedArray]" === m2(e10);
}
function E(e10) {
  return l$1 && y2 ? "Uint16Array" === b(e10) : "[object Uint16Array]" === m2(e10);
}
function D(e10) {
  return l$1 && y2 ? "Uint32Array" === b(e10) : "[object Uint32Array]" === m2(e10);
}
function U(e10) {
  return l$1 && y2 ? "Int8Array" === b(e10) : "[object Int8Array]" === m2(e10);
}
function P(e10) {
  return l$1 && y2 ? "Int16Array" === b(e10) : "[object Int16Array]" === m2(e10);
}
function x(e10) {
  return l$1 && y2 ? "Int32Array" === b(e10) : "[object Int32Array]" === m2(e10);
}
function I(e10) {
  return l$1 && y2 ? "Float32Array" === b(e10) : "[object Float32Array]" === m2(e10);
}
function M(e10) {
  return l$1 && y2 ? "Float64Array" === b(e10) : "[object Float64Array]" === m2(e10);
}
function z(e10) {
  return l$1 && y2 ? "BigInt64Array" === b(e10) : "[object BigInt64Array]" === m2(e10);
}
function F(e10) {
  return l$1 && y2 ? "BigUint64Array" === b(e10) : "[object BigUint64Array]" === m2(e10);
}
function T2(e10) {
  return "[object Map]" === m2(e10);
}
function N(e10) {
  return "[object Set]" === m2(e10);
}
function W(e10) {
  return "[object WeakMap]" === m2(e10);
}
function $(e10) {
  return "[object WeakSet]" === m2(e10);
}
function C(e10) {
  return "[object ArrayBuffer]" === m2(e10);
}
function V(e10) {
  return "undefined" != typeof ArrayBuffer && (C.working ? C(e10) : e10 instanceof ArrayBuffer);
}
function G(e10) {
  return "[object DataView]" === m2(e10);
}
function R(e10) {
  return "undefined" != typeof DataView && (G.working ? G(e10) : e10 instanceof DataView);
}
function J(e10) {
  return "[object SharedArrayBuffer]" === m2(e10);
}
function _(e10) {
  return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e10) : e10 instanceof SharedArrayBuffer);
}
function H(e10) {
  return O(e10, h3);
}
function Z(e10) {
  return O(e10, j);
}
function q(e10) {
  return O(e10, A);
}
function K(e10) {
  return s3 && O(e10, w);
}
function L(e10) {
  return p3 && O(e10, v2);
}
function oe(e10, t9) {
  var r10 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r10.depth = arguments[2]), arguments.length >= 4 && (r10.colors = arguments[3]), ye(t9) ? r10.showHidden = t9 : t9 && X._extend(r10, t9), be(r10.showHidden) && (r10.showHidden = false), be(r10.depth) && (r10.depth = 2), be(r10.colors) && (r10.colors = false), be(r10.customInspect) && (r10.customInspect = true), r10.colors && (r10.stylize = ue), ae(r10, e10, r10.depth);
}
function ue(e10, t9) {
  var r10 = oe.styles[t9];
  return r10 ? "\x1B[" + oe.colors[r10][0] + "m" + e10 + "\x1B[" + oe.colors[r10][1] + "m" : e10;
}
function fe(e10, t9) {
  return e10;
}
function ae(e10, t9, r10) {
  if (e10.customInspect && t9 && we(t9.inspect) && t9.inspect !== X.inspect && (!t9.constructor || t9.constructor.prototype !== t9)) {
    var n9 = t9.inspect(r10, e10);
    return ge(n9) || (n9 = ae(e10, n9, r10)), n9;
  }
  var i7 = function(e11, t10) {
    if (be(t10))
      return e11.stylize("undefined", "undefined");
    if (ge(t10)) {
      var r11 = "'" + JSON.stringify(t10).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e11.stylize(r11, "string");
    }
    if (de(t10))
      return e11.stylize("" + t10, "number");
    if (ye(t10))
      return e11.stylize("" + t10, "boolean");
    if (le(t10))
      return e11.stylize("null", "null");
  }(e10, t9);
  if (i7)
    return i7;
  var o9 = Object.keys(t9), u7 = function(e11) {
    var t10 = {};
    return e11.forEach(function(e12, r11) {
      t10[e12] = true;
    }), t10;
  }(o9);
  if (e10.showHidden && (o9 = Object.getOwnPropertyNames(t9)), Ae(t9) && (o9.indexOf("message") >= 0 || o9.indexOf("description") >= 0))
    return ce(t9);
  if (0 === o9.length) {
    if (we(t9)) {
      var f7 = t9.name ? ": " + t9.name : "";
      return e10.stylize("[Function" + f7 + "]", "special");
    }
    if (me(t9))
      return e10.stylize(RegExp.prototype.toString.call(t9), "regexp");
    if (je(t9))
      return e10.stylize(Date.prototype.toString.call(t9), "date");
    if (Ae(t9))
      return ce(t9);
  }
  var a7, c7 = "", s6 = false, p7 = ["{", "}"];
  (pe(t9) && (s6 = true, p7 = ["[", "]"]), we(t9)) && (c7 = " [Function" + (t9.name ? ": " + t9.name : "") + "]");
  return me(t9) && (c7 = " " + RegExp.prototype.toString.call(t9)), je(t9) && (c7 = " " + Date.prototype.toUTCString.call(t9)), Ae(t9) && (c7 = " " + ce(t9)), 0 !== o9.length || s6 && 0 != t9.length ? r10 < 0 ? me(t9) ? e10.stylize(RegExp.prototype.toString.call(t9), "regexp") : e10.stylize("[Object]", "special") : (e10.seen.push(t9), a7 = s6 ? function(e11, t10, r11, n10, i8) {
    for (var o10 = [], u8 = 0, f8 = t10.length; u8 < f8; ++u8)
      ke(t10, String(u8)) ? o10.push(se(e11, t10, r11, n10, String(u8), true)) : o10.push("");
    return i8.forEach(function(i9) {
      i9.match(/^\d+$/) || o10.push(se(e11, t10, r11, n10, i9, true));
    }), o10;
  }(e10, t9, r10, u7, o9) : o9.map(function(n10) {
    return se(e10, t9, r10, u7, n10, s6);
  }), e10.seen.pop(), function(e11, t10, r11) {
    var n10 = 0;
    if (e11.reduce(function(e12, t11) {
      return n10++, t11.indexOf("\n") >= 0 && n10++, e12 + t11.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r11[0] + ("" === t10 ? "" : t10 + "\n ") + " " + e11.join(",\n  ") + " " + r11[1];
    return r11[0] + t10 + " " + e11.join(", ") + " " + r11[1];
  }(a7, c7, p7)) : p7[0] + c7 + p7[1];
}
function ce(e10) {
  return "[" + Error.prototype.toString.call(e10) + "]";
}
function se(e10, t9, r10, n9, i7, o9) {
  var u7, f7, a7;
  if ((a7 = Object.getOwnPropertyDescriptor(t9, i7) || { value: t9[i7] }).get ? f7 = a7.set ? e10.stylize("[Getter/Setter]", "special") : e10.stylize("[Getter]", "special") : a7.set && (f7 = e10.stylize("[Setter]", "special")), ke(n9, i7) || (u7 = "[" + i7 + "]"), f7 || (e10.seen.indexOf(a7.value) < 0 ? (f7 = le(r10) ? ae(e10, a7.value, null) : ae(e10, a7.value, r10 - 1)).indexOf("\n") > -1 && (f7 = o9 ? f7.split("\n").map(function(e11) {
    return "  " + e11;
  }).join("\n").substr(2) : "\n" + f7.split("\n").map(function(e11) {
    return "   " + e11;
  }).join("\n")) : f7 = e10.stylize("[Circular]", "special")), be(u7)) {
    if (o9 && i7.match(/^\d+$/))
      return f7;
    (u7 = JSON.stringify("" + i7)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e10.stylize(u7, "name")) : (u7 = u7.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u7 = e10.stylize(u7, "string"));
  }
  return u7 + ": " + f7;
}
function pe(e10) {
  return Array.isArray(e10);
}
function ye(e10) {
  return "boolean" == typeof e10;
}
function le(e10) {
  return null === e10;
}
function de(e10) {
  return "number" == typeof e10;
}
function ge(e10) {
  return "string" == typeof e10;
}
function be(e10) {
  return void 0 === e10;
}
function me(e10) {
  return he(e10) && "[object RegExp]" === ve(e10);
}
function he(e10) {
  return "object" == typeof e10 && null !== e10;
}
function je(e10) {
  return he(e10) && "[object Date]" === ve(e10);
}
function Ae(e10) {
  return he(e10) && ("[object Error]" === ve(e10) || e10 instanceof Error);
}
function we(e10) {
  return "function" == typeof e10;
}
function ve(e10) {
  return Object.prototype.toString.call(e10);
}
function Oe(e10) {
  return e10 < 10 ? "0" + e10.toString(10) : e10.toString(10);
}
function Be() {
  var e10 = /* @__PURE__ */ new Date(), t9 = [Oe(e10.getHours()), Oe(e10.getMinutes()), Oe(e10.getSeconds())].join(":");
  return [e10.getDate(), Se[e10.getMonth()], t9].join(" ");
}
function ke(e10, t9) {
  return Object.prototype.hasOwnProperty.call(e10, t9);
}
function De(e10, t9) {
  if (!e10) {
    var r10 = new Error("Promise was rejected with a falsy value");
    r10.reason = e10, e10 = r10;
  }
  return t9(e10);
}
var t4, e4, o4, n4, r4, l3, t$1, o$1, n$1, e$1, r$1, c3, u3, i3, t$2, i$1, o$2, u$1, f3, a3, s3, p3, y2, l$1, d2, m2, h3, j, A, Q, X, Y, ee, te, re, ne, ie, Se, Ee;
var init_chunk_b4205b57 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_5decc758();
    t4 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e4 = Object.prototype.toString;
    o4 = function(o9) {
      return !(t4 && o9 && "object" == typeof o9 && Symbol.toStringTag in o9) && "[object Arguments]" === e4.call(o9);
    };
    n4 = function(t9) {
      return !!o4(t9) || null !== t9 && "object" == typeof t9 && "number" == typeof t9.length && t9.length >= 0 && "[object Array]" !== e4.call(t9) && "[object Function]" === e4.call(t9.callee);
    };
    r4 = function() {
      return o4(arguments);
    }();
    o4.isLegacyArguments = n4;
    l3 = r4 ? o4 : n4;
    t$1 = Object.prototype.toString;
    o$1 = Function.prototype.toString;
    n$1 = /^\s*(?:function)?\*/;
    e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$1 = Object.getPrototypeOf;
    c3 = function() {
      if (!e$1)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t9) {
      }
    }();
    u3 = c3 ? r$1(c3) : {};
    i3 = function(c7) {
      return "function" == typeof c7 && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u3 : "[object GeneratorFunction]" === t$1.call(c7)));
    };
    t$2 = "function" == typeof Object.create ? function(t9, e10) {
      e10 && (t9.super_ = e10, t9.prototype = Object.create(e10.prototype, { constructor: { value: t9, enumerable: false, writable: true, configurable: true } }));
    } : function(t9, e10) {
      if (e10) {
        t9.super_ = e10;
        var o9 = function() {
        };
        o9.prototype = e10.prototype, t9.prototype = new o9(), t9.prototype.constructor = t9;
      }
    };
    i$1 = function(e10) {
      return e10 && "object" == typeof e10 && "function" == typeof e10.copy && "function" == typeof e10.fill && "function" == typeof e10.readUInt8;
    };
    o$2 = {};
    u$1 = i$1;
    f3 = l3;
    a3 = i3;
    s3 = "undefined" != typeof BigInt;
    p3 = "undefined" != typeof Symbol;
    y2 = p3 && void 0 !== Symbol.toStringTag;
    l$1 = "undefined" != typeof Uint8Array;
    d2 = "undefined" != typeof ArrayBuffer;
    if (l$1 && y2)
      var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
    m2 = c$1(Object.prototype.toString);
    h3 = c$1(Number.prototype.valueOf);
    j = c$1(String.prototype.valueOf);
    A = c$1(Boolean.prototype.valueOf);
    if (s3)
      var w = c$1(BigInt.prototype.valueOf);
    if (p3)
      var v2 = c$1(Symbol.prototype.valueOf);
    o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(e10) {
      return "undefined" != typeof Promise && e10 instanceof Promise || null !== e10 && "object" == typeof e10 && "function" == typeof e10.then && "function" == typeof e10.catch;
    }, o$2.isArrayBufferView = function(e10) {
      return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e10) : S(e10) || R(e10);
    }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e10) {
      return "undefined" != typeof Map && (T2.working ? T2(e10) : e10 instanceof Map);
    }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e10) {
      return "undefined" != typeof Set && (N.working ? N(e10) : e10 instanceof Set);
    }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e10) {
      return "undefined" != typeof WeakMap && (W.working ? W(e10) : e10 instanceof WeakMap);
    }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e10) {
      return $(e10);
    }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e10) {
      return "[object AsyncFunction]" === m2(e10);
    }, o$2.isMapIterator = function(e10) {
      return "[object Map Iterator]" === m2(e10);
    }, o$2.isSetIterator = function(e10) {
      return "[object Set Iterator]" === m2(e10);
    }, o$2.isGeneratorObject = function(e10) {
      return "[object Generator]" === m2(e10);
    }, o$2.isWebAssemblyCompiledModule = function(e10) {
      return "[object WebAssembly.Module]" === m2(e10);
    }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e10) {
      return H(e10) || Z(e10) || q(e10) || K(e10) || L(e10);
    }, o$2.isAnyArrayBuffer = function(e10) {
      return l$1 && (V(e10) || _(e10));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e10) {
      Object.defineProperty(o$2, e10, { enumerable: false, value: function() {
        throw new Error(e10 + " is not supported in userland");
      } });
    });
    Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
    X = {};
    Y = T;
    ee = Object.getOwnPropertyDescriptors || function(e10) {
      for (var t9 = Object.keys(e10), r10 = {}, n9 = 0; n9 < t9.length; n9++)
        r10[t9[n9]] = Object.getOwnPropertyDescriptor(e10, t9[n9]);
      return r10;
    };
    te = /%[sdj%]/g;
    X.format = function(e10) {
      if (!ge(e10)) {
        for (var t9 = [], r10 = 0; r10 < arguments.length; r10++)
          t9.push(oe(arguments[r10]));
        return t9.join(" ");
      }
      r10 = 1;
      for (var n9 = arguments, i7 = n9.length, o9 = String(e10).replace(te, function(e11) {
        if ("%%" === e11)
          return "%";
        if (r10 >= i7)
          return e11;
        switch (e11) {
          case "%s":
            return String(n9[r10++]);
          case "%d":
            return Number(n9[r10++]);
          case "%j":
            try {
              return JSON.stringify(n9[r10++]);
            } catch (e12) {
              return "[Circular]";
            }
          default:
            return e11;
        }
      }), u7 = n9[r10]; r10 < i7; u7 = n9[++r10])
        le(u7) || !he(u7) ? o9 += " " + u7 : o9 += " " + oe(u7);
      return o9;
    }, X.deprecate = function(e10, t9) {
      if (void 0 !== Y && true === Y.noDeprecation)
        return e10;
      if (void 0 === Y)
        return function() {
          return X.deprecate(e10, t9).apply(this || Q, arguments);
        };
      var r10 = false;
      return function() {
        if (!r10) {
          if (Y.throwDeprecation)
            throw new Error(t9);
          Y.traceDeprecation ? console.trace(t9) : console.error(t9), r10 = true;
        }
        return e10.apply(this || Q, arguments);
      };
    };
    re = {};
    ne = /^$/;
    if (Y.env.NODE_DEBUG) {
      ie = Y.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
    }
    X.debuglog = function(e10) {
      if (e10 = e10.toUpperCase(), !re[e10])
        if (ne.test(e10)) {
          var t9 = Y.pid;
          re[e10] = function() {
            var r10 = X.format.apply(X, arguments);
            console.error("%s %d: %s", e10, t9, r10);
          };
        } else
          re[e10] = function() {
          };
      return re[e10];
    }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e10) {
      return null == e10;
    }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e10) {
      return "symbol" == typeof e10;
    }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e10) {
      return null === e10 || "boolean" == typeof e10 || "number" == typeof e10 || "string" == typeof e10 || "symbol" == typeof e10 || void 0 === e10;
    }, X.isBuffer = i$1;
    Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X.log = function() {
      console.log("%s - %s", Be(), X.format.apply(X, arguments));
    }, X.inherits = t$2, X._extend = function(e10, t9) {
      if (!t9 || !he(t9))
        return e10;
      for (var r10 = Object.keys(t9), n9 = r10.length; n9--; )
        e10[r10[n9]] = t9[r10[n9]];
      return e10;
    };
    Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X.promisify = function(e10) {
      if ("function" != typeof e10)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee && e10[Ee]) {
        var t9;
        if ("function" != typeof (t9 = e10[Ee]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t9, Ee, { value: t9, enumerable: false, writable: false, configurable: true }), t9;
      }
      function t9() {
        for (var t10, r10, n9 = new Promise(function(e11, n10) {
          t10 = e11, r10 = n10;
        }), i7 = [], o9 = 0; o9 < arguments.length; o9++)
          i7.push(arguments[o9]);
        i7.push(function(e11, n10) {
          e11 ? r10(e11) : t10(n10);
        });
        try {
          e10.apply(this || Q, i7);
        } catch (e11) {
          r10(e11);
        }
        return n9;
      }
      return Object.setPrototypeOf(t9, Object.getPrototypeOf(e10)), Ee && Object.defineProperty(t9, Ee, { value: t9, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t9, ee(e10));
    }, X.promisify.custom = Ee, X.callbackify = function(e10) {
      if ("function" != typeof e10)
        throw new TypeError('The "original" argument must be of type Function');
      function t9() {
        for (var t10 = [], r10 = 0; r10 < arguments.length; r10++)
          t10.push(arguments[r10]);
        var n9 = t10.pop();
        if ("function" != typeof n9)
          throw new TypeError("The last argument must be of type Function");
        var i7 = this || Q, o9 = function() {
          return n9.apply(i7, arguments);
        };
        e10.apply(this || Q, t10).then(function(e11) {
          Y.nextTick(o9.bind(null, null, e11));
        }, function(e11) {
          Y.nextTick(De.bind(null, e11, o9));
        });
      }
      return Object.setPrototypeOf(t9, Object.getPrototypeOf(e10)), Object.defineProperties(t9, ee(e10)), t9;
    };
  }
});
var init_chunk_ce0fbc82 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    X.types;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
function u$2(r10) {
  var t9 = r10.length;
  if (t9 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e10 = r10.indexOf("=");
  return -1 === e10 && (e10 = t9), [e10, e10 === t9 ? 0 : 4 - e10 % 4];
}
function c$12(r10, e10, n9) {
  for (var o9, a7, h8 = [], u7 = e10; u7 < n9; u7 += 3)
    o9 = (r10[u7] << 16 & 16711680) + (r10[u7 + 1] << 8 & 65280) + (255 & r10[u7 + 2]), h8.push(t$13[(a7 = o9) >> 18 & 63] + t$13[a7 >> 12 & 63] + t$13[a7 >> 6 & 63] + t$13[63 & a7]);
  return h8.join("");
}
function f$2(t9) {
  if (t9 > 2147483647)
    throw new RangeError('The value "' + t9 + '" is invalid for option "size"');
  var r10 = new Uint8Array(t9);
  return Object.setPrototypeOf(r10, u$1$1.prototype), r10;
}
function u$1$1(t9, r10, e10) {
  if ("number" == typeof t9) {
    if ("string" == typeof r10)
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$2(t9);
  }
  return s$1(t9, r10, e10);
}
function s$1(t9, r10, e10) {
  if ("string" == typeof t9)
    return function(t10, r11) {
      "string" == typeof r11 && "" !== r11 || (r11 = "utf8");
      if (!u$1$1.isEncoding(r11))
        throw new TypeError("Unknown encoding: " + r11);
      var e11 = 0 | y3(t10, r11), n10 = f$2(e11), i8 = n10.write(t10, r11);
      i8 !== e11 && (n10 = n10.slice(0, i8));
      return n10;
    }(t9, r10);
  if (ArrayBuffer.isView(t9))
    return p4(t9);
  if (null == t9)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t9);
  if (F2(t9, ArrayBuffer) || t9 && F2(t9.buffer, ArrayBuffer))
    return c$1$1(t9, r10, e10);
  if ("undefined" != typeof SharedArrayBuffer && (F2(t9, SharedArrayBuffer) || t9 && F2(t9.buffer, SharedArrayBuffer)))
    return c$1$1(t9, r10, e10);
  if ("number" == typeof t9)
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n9 = t9.valueOf && t9.valueOf();
  if (null != n9 && n9 !== t9)
    return u$1$1.from(n9, r10, e10);
  var i7 = function(t10) {
    if (u$1$1.isBuffer(t10)) {
      var r11 = 0 | l$12(t10.length), e11 = f$2(r11);
      return 0 === e11.length || t10.copy(e11, 0, 0, r11), e11;
    }
    if (void 0 !== t10.length)
      return "number" != typeof t10.length || N2(t10.length) ? f$2(0) : p4(t10);
    if ("Buffer" === t10.type && Array.isArray(t10.data))
      return p4(t10.data);
  }(t9);
  if (i7)
    return i7;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t9[Symbol.toPrimitive])
    return u$1$1.from(t9[Symbol.toPrimitive]("string"), r10, e10);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t9);
}
function h$1$1(t9) {
  if ("number" != typeof t9)
    throw new TypeError('"size" argument must be of type number');
  if (t9 < 0)
    throw new RangeError('The value "' + t9 + '" is invalid for option "size"');
}
function a$2(t9) {
  return h$1$1(t9), f$2(t9 < 0 ? 0 : 0 | l$12(t9));
}
function p4(t9) {
  for (var r10 = t9.length < 0 ? 0 : 0 | l$12(t9.length), e10 = f$2(r10), n9 = 0; n9 < r10; n9 += 1)
    e10[n9] = 255 & t9[n9];
  return e10;
}
function c$1$1(t9, r10, e10) {
  if (r10 < 0 || t9.byteLength < r10)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (t9.byteLength < r10 + (e10 || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var n9;
  return n9 = void 0 === r10 && void 0 === e10 ? new Uint8Array(t9) : void 0 === e10 ? new Uint8Array(t9, r10) : new Uint8Array(t9, r10, e10), Object.setPrototypeOf(n9, u$1$1.prototype), n9;
}
function l$12(t9) {
  if (t9 >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t9;
}
function y3(t9, r10) {
  if (u$1$1.isBuffer(t9))
    return t9.length;
  if (ArrayBuffer.isView(t9) || F2(t9, ArrayBuffer))
    return t9.byteLength;
  if ("string" != typeof t9)
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t9);
  var e10 = t9.length, n9 = arguments.length > 2 && true === arguments[2];
  if (!n9 && 0 === e10)
    return 0;
  for (var i7 = false; ; )
    switch (r10) {
      case "ascii":
      case "latin1":
      case "binary":
        return e10;
      case "utf8":
      case "utf-8":
        return _2(t9).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e10;
      case "hex":
        return e10 >>> 1;
      case "base64":
        return z2(t9).length;
      default:
        if (i7)
          return n9 ? -1 : _2(t9).length;
        r10 = ("" + r10).toLowerCase(), i7 = true;
    }
}
function g2(t9, r10, e10) {
  var n9 = false;
  if ((void 0 === r10 || r10 < 0) && (r10 = 0), r10 > this.length)
    return "";
  if ((void 0 === e10 || e10 > this.length) && (e10 = this.length), e10 <= 0)
    return "";
  if ((e10 >>>= 0) <= (r10 >>>= 0))
    return "";
  for (t9 || (t9 = "utf8"); ; )
    switch (t9) {
      case "hex":
        return O2(this, r10, e10);
      case "utf8":
      case "utf-8":
        return I2(this, r10, e10);
      case "ascii":
        return S2(this, r10, e10);
      case "latin1":
      case "binary":
        return R2(this, r10, e10);
      case "base64":
        return T3(this, r10, e10);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, r10, e10);
      default:
        if (n9)
          throw new TypeError("Unknown encoding: " + t9);
        t9 = (t9 + "").toLowerCase(), n9 = true;
    }
}
function w2(t9, r10, e10) {
  var n9 = t9[r10];
  t9[r10] = t9[e10], t9[e10] = n9;
}
function d3(t9, r10, e10, n9, i7) {
  if (0 === t9.length)
    return -1;
  if ("string" == typeof e10 ? (n9 = e10, e10 = 0) : e10 > 2147483647 ? e10 = 2147483647 : e10 < -2147483648 && (e10 = -2147483648), N2(e10 = +e10) && (e10 = i7 ? 0 : t9.length - 1), e10 < 0 && (e10 = t9.length + e10), e10 >= t9.length) {
    if (i7)
      return -1;
    e10 = t9.length - 1;
  } else if (e10 < 0) {
    if (!i7)
      return -1;
    e10 = 0;
  }
  if ("string" == typeof r10 && (r10 = u$1$1.from(r10, n9)), u$1$1.isBuffer(r10))
    return 0 === r10.length ? -1 : v3(t9, r10, e10, n9, i7);
  if ("number" == typeof r10)
    return r10 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i7 ? Uint8Array.prototype.indexOf.call(t9, r10, e10) : Uint8Array.prototype.lastIndexOf.call(t9, r10, e10) : v3(t9, [r10], e10, n9, i7);
  throw new TypeError("val must be string, number or Buffer");
}
function v3(t9, r10, e10, n9, i7) {
  var o9, f7 = 1, u7 = t9.length, s6 = r10.length;
  if (void 0 !== n9 && ("ucs2" === (n9 = String(n9).toLowerCase()) || "ucs-2" === n9 || "utf16le" === n9 || "utf-16le" === n9)) {
    if (t9.length < 2 || r10.length < 2)
      return -1;
    f7 = 2, u7 /= 2, s6 /= 2, e10 /= 2;
  }
  function h8(t10, r11) {
    return 1 === f7 ? t10[r11] : t10.readUInt16BE(r11 * f7);
  }
  if (i7) {
    var a7 = -1;
    for (o9 = e10; o9 < u7; o9++)
      if (h8(t9, o9) === h8(r10, -1 === a7 ? 0 : o9 - a7)) {
        if (-1 === a7 && (a7 = o9), o9 - a7 + 1 === s6)
          return a7 * f7;
      } else
        -1 !== a7 && (o9 -= o9 - a7), a7 = -1;
  } else
    for (e10 + s6 > u7 && (e10 = u7 - s6), o9 = e10; o9 >= 0; o9--) {
      for (var p7 = true, c7 = 0; c7 < s6; c7++)
        if (h8(t9, o9 + c7) !== h8(r10, c7)) {
          p7 = false;
          break;
        }
      if (p7)
        return o9;
    }
  return -1;
}
function b2(t9, r10, e10, n9) {
  e10 = Number(e10) || 0;
  var i7 = t9.length - e10;
  n9 ? (n9 = Number(n9)) > i7 && (n9 = i7) : n9 = i7;
  var o9 = r10.length;
  n9 > o9 / 2 && (n9 = o9 / 2);
  for (var f7 = 0; f7 < n9; ++f7) {
    var u7 = parseInt(r10.substr(2 * f7, 2), 16);
    if (N2(u7))
      return f7;
    t9[e10 + f7] = u7;
  }
  return f7;
}
function m3(t9, r10, e10, n9) {
  return D2(_2(r10, t9.length - e10), t9, e10, n9);
}
function E2(t9, r10, e10, n9) {
  return D2(function(t10) {
    for (var r11 = [], e11 = 0; e11 < t10.length; ++e11)
      r11.push(255 & t10.charCodeAt(e11));
    return r11;
  }(r10), t9, e10, n9);
}
function B2(t9, r10, e10, n9) {
  return E2(t9, r10, e10, n9);
}
function A2(t9, r10, e10, n9) {
  return D2(z2(r10), t9, e10, n9);
}
function U2(t9, r10, e10, n9) {
  return D2(function(t10, r11) {
    for (var e11, n10, i7, o9 = [], f7 = 0; f7 < t10.length && !((r11 -= 2) < 0); ++f7)
      e11 = t10.charCodeAt(f7), n10 = e11 >> 8, i7 = e11 % 256, o9.push(i7), o9.push(n10);
    return o9;
  }(r10, t9.length - e10), t9, e10, n9);
}
function T3(t9, r10, e10) {
  return 0 === r10 && e10 === t9.length ? n$1$1.fromByteArray(t9) : n$1$1.fromByteArray(t9.slice(r10, e10));
}
function I2(t9, r10, e10) {
  e10 = Math.min(t9.length, e10);
  for (var n9 = [], i7 = r10; i7 < e10; ) {
    var o9, f7, u7, s6, h8 = t9[i7], a7 = null, p7 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
    if (i7 + p7 <= e10)
      switch (p7) {
        case 1:
          h8 < 128 && (a7 = h8);
          break;
        case 2:
          128 == (192 & (o9 = t9[i7 + 1])) && (s6 = (31 & h8) << 6 | 63 & o9) > 127 && (a7 = s6);
          break;
        case 3:
          o9 = t9[i7 + 1], f7 = t9[i7 + 2], 128 == (192 & o9) && 128 == (192 & f7) && (s6 = (15 & h8) << 12 | (63 & o9) << 6 | 63 & f7) > 2047 && (s6 < 55296 || s6 > 57343) && (a7 = s6);
          break;
        case 4:
          o9 = t9[i7 + 1], f7 = t9[i7 + 2], u7 = t9[i7 + 3], 128 == (192 & o9) && 128 == (192 & f7) && 128 == (192 & u7) && (s6 = (15 & h8) << 18 | (63 & o9) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s6 < 1114112 && (a7 = s6);
      }
    null === a7 ? (a7 = 65533, p7 = 1) : a7 > 65535 && (a7 -= 65536, n9.push(a7 >>> 10 & 1023 | 55296), a7 = 56320 | 1023 & a7), n9.push(a7), i7 += p7;
  }
  return function(t10) {
    var r11 = t10.length;
    if (r11 <= 4096)
      return String.fromCharCode.apply(String, t10);
    var e11 = "", n10 = 0;
    for (; n10 < r11; )
      e11 += String.fromCharCode.apply(String, t10.slice(n10, n10 += 4096));
    return e11;
  }(n9);
}
function S2(t9, r10, e10) {
  var n9 = "";
  e10 = Math.min(t9.length, e10);
  for (var i7 = r10; i7 < e10; ++i7)
    n9 += String.fromCharCode(127 & t9[i7]);
  return n9;
}
function R2(t9, r10, e10) {
  var n9 = "";
  e10 = Math.min(t9.length, e10);
  for (var i7 = r10; i7 < e10; ++i7)
    n9 += String.fromCharCode(t9[i7]);
  return n9;
}
function O2(t9, r10, e10) {
  var n9 = t9.length;
  (!r10 || r10 < 0) && (r10 = 0), (!e10 || e10 < 0 || e10 > n9) && (e10 = n9);
  for (var i7 = "", o9 = r10; o9 < e10; ++o9)
    i7 += Y2[t9[o9]];
  return i7;
}
function L2(t9, r10, e10) {
  for (var n9 = t9.slice(r10, e10), i7 = "", o9 = 0; o9 < n9.length; o9 += 2)
    i7 += String.fromCharCode(n9[o9] + 256 * n9[o9 + 1]);
  return i7;
}
function x2(t9, r10, e10) {
  if (t9 % 1 != 0 || t9 < 0)
    throw new RangeError("offset is not uint");
  if (t9 + r10 > e10)
    throw new RangeError("Trying to access beyond buffer length");
}
function C2(t9, r10, e10, n9, i7, o9) {
  if (!u$1$1.isBuffer(t9))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r10 > i7 || r10 < o9)
    throw new RangeError('"value" argument is out of bounds');
  if (e10 + n9 > t9.length)
    throw new RangeError("Index out of range");
}
function P2(t9, r10, e10, n9, i7, o9) {
  if (e10 + n9 > t9.length)
    throw new RangeError("Index out of range");
  if (e10 < 0)
    throw new RangeError("Index out of range");
}
function k2(t9, r10, e10, n9, o9) {
  return r10 = +r10, e10 >>>= 0, o9 || P2(t9, 0, e10, 4), i$12.write(t9, r10, e10, n9, 23, 4), e10 + 4;
}
function M2(t9, r10, e10, n9, o9) {
  return r10 = +r10, e10 >>>= 0, o9 || P2(t9, 0, e10, 8), i$12.write(t9, r10, e10, n9, 52, 8), e10 + 8;
}
function _2(t9, r10) {
  var e10;
  r10 = r10 || 1 / 0;
  for (var n9 = t9.length, i7 = null, o9 = [], f7 = 0; f7 < n9; ++f7) {
    if ((e10 = t9.charCodeAt(f7)) > 55295 && e10 < 57344) {
      if (!i7) {
        if (e10 > 56319) {
          (r10 -= 3) > -1 && o9.push(239, 191, 189);
          continue;
        }
        if (f7 + 1 === n9) {
          (r10 -= 3) > -1 && o9.push(239, 191, 189);
          continue;
        }
        i7 = e10;
        continue;
      }
      if (e10 < 56320) {
        (r10 -= 3) > -1 && o9.push(239, 191, 189), i7 = e10;
        continue;
      }
      e10 = 65536 + (i7 - 55296 << 10 | e10 - 56320);
    } else
      i7 && (r10 -= 3) > -1 && o9.push(239, 191, 189);
    if (i7 = null, e10 < 128) {
      if ((r10 -= 1) < 0)
        break;
      o9.push(e10);
    } else if (e10 < 2048) {
      if ((r10 -= 2) < 0)
        break;
      o9.push(e10 >> 6 | 192, 63 & e10 | 128);
    } else if (e10 < 65536) {
      if ((r10 -= 3) < 0)
        break;
      o9.push(e10 >> 12 | 224, e10 >> 6 & 63 | 128, 63 & e10 | 128);
    } else {
      if (!(e10 < 1114112))
        throw new Error("Invalid code point");
      if ((r10 -= 4) < 0)
        break;
      o9.push(e10 >> 18 | 240, e10 >> 12 & 63 | 128, e10 >> 6 & 63 | 128, 63 & e10 | 128);
    }
  }
  return o9;
}
function z2(t9) {
  return n$1$1.toByteArray(function(t10) {
    if ((t10 = (t10 = t10.split("=")[0]).trim().replace(j2, "")).length < 2)
      return "";
    for (; t10.length % 4 != 0; )
      t10 += "=";
    return t10;
  }(t9));
}
function D2(t9, r10, e10, n9) {
  for (var i7 = 0; i7 < n9 && !(i7 + e10 >= r10.length || i7 >= t9.length); ++i7)
    r10[i7 + e10] = t9[i7];
  return i7;
}
function F2(t9, r10) {
  return t9 instanceof r10 || null != t9 && null != t9.constructor && null != t9.constructor.name && t9.constructor.name === r10.name;
}
function N2(t9) {
  return t9 != t9;
}
function t5(r10, e10) {
  for (var n9 in r10)
    e10[n9] = r10[n9];
}
function f4(r10, e10, n9) {
  return o5(r10, e10, n9);
}
function a4(t9) {
  var e10;
  switch (this.encoding = function(t10) {
    var e11 = function(t11) {
      if (!t11)
        return "utf8";
      for (var e12; ; )
        switch (t11) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t11;
          default:
            if (e12)
              return;
            t11 = ("" + t11).toLowerCase(), e12 = true;
        }
    }(t10);
    if ("string" != typeof e11 && (s4.isEncoding === i4 || !i4(t10)))
      throw new Error("Unknown encoding: " + t10);
    return e11 || t10;
  }(t9), this.encoding) {
    case "utf16le":
      this.text = h4, this.end = l4, e10 = 4;
      break;
    case "utf8":
      this.fillLast = n$12, e10 = 4;
      break;
    case "base64":
      this.text = u$12, this.end = o$12, e10 = 3;
      break;
    default:
      return this.write = f$1, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e10);
}
function r5(t9) {
  return t9 <= 127 ? 0 : t9 >> 5 == 6 ? 2 : t9 >> 4 == 14 ? 3 : t9 >> 3 == 30 ? 4 : t9 >> 6 == 2 ? -1 : -2;
}
function n$12(t9) {
  var e10 = this.lastTotal - this.lastNeed, s6 = function(t10, e11, s7) {
    if (128 != (192 & e11[0]))
      return t10.lastNeed = 0, "\uFFFD";
    if (t10.lastNeed > 1 && e11.length > 1) {
      if (128 != (192 & e11[1]))
        return t10.lastNeed = 1, "\uFFFD";
      if (t10.lastNeed > 2 && e11.length > 2 && 128 != (192 & e11[2]))
        return t10.lastNeed = 2, "\uFFFD";
    }
  }(this, t9);
  return void 0 !== s6 ? s6 : this.lastNeed <= t9.length ? (t9.copy(this.lastChar, e10, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t9.copy(this.lastChar, e10, 0, t9.length), this.lastNeed -= t9.length, void 0);
}
function h4(t9, e10) {
  if ((t9.length - e10) % 2 == 0) {
    var s6 = t9.toString("utf16le", e10);
    if (s6) {
      var i7 = s6.charCodeAt(s6.length - 1);
      if (i7 >= 55296 && i7 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t9[t9.length - 2], this.lastChar[1] = t9[t9.length - 1], s6.slice(0, -1);
    }
    return s6;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t9[t9.length - 1], t9.toString("utf16le", e10, t9.length - 1);
}
function l4(t9) {
  var e10 = t9 && t9.length ? this.write(t9) : "";
  if (this.lastNeed) {
    var s6 = this.lastTotal - this.lastNeed;
    return e10 + this.lastChar.toString("utf16le", 0, s6);
  }
  return e10;
}
function u$12(t9, e10) {
  var s6 = (t9.length - e10) % 3;
  return 0 === s6 ? t9.toString("base64", e10) : (this.lastNeed = 3 - s6, this.lastTotal = 3, 1 === s6 ? this.lastChar[0] = t9[t9.length - 1] : (this.lastChar[0] = t9[t9.length - 2], this.lastChar[1] = t9[t9.length - 1]), t9.toString("base64", e10, t9.length - s6));
}
function o$12(t9) {
  var e10 = t9 && t9.length ? this.write(t9) : "";
  return this.lastNeed ? e10 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e10;
}
function f$1(t9) {
  return t9.toString(this.encoding);
}
function c4(t9) {
  return t9 && t9.length ? this.write(t9) : "";
}
var r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1, n$1$1, i$12, o$1$1, j2, Y2, e5, n5, o5, u4, e$12, s4, i4;
var init_chunk_4ccc3a29 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    for (r$13 = { byteLength: function(r10) {
      var t9 = u$2(r10), e10 = t9[0], n9 = t9[1];
      return 3 * (e10 + n9) / 4 - n9;
    }, toByteArray: function(r10) {
      var t9, o9, a7 = u$2(r10), h8 = a7[0], c7 = a7[1], d6 = new n$22(function(r11, t10, e10) {
        return 3 * (t10 + e10) / 4 - e10;
      }(0, h8, c7)), f7 = 0, A4 = c7 > 0 ? h8 - 4 : h8;
      for (o9 = 0; o9 < A4; o9 += 4)
        t9 = e$22[r10.charCodeAt(o9)] << 18 | e$22[r10.charCodeAt(o9 + 1)] << 12 | e$22[r10.charCodeAt(o9 + 2)] << 6 | e$22[r10.charCodeAt(o9 + 3)], d6[f7++] = t9 >> 16 & 255, d6[f7++] = t9 >> 8 & 255, d6[f7++] = 255 & t9;
      2 === c7 && (t9 = e$22[r10.charCodeAt(o9)] << 2 | e$22[r10.charCodeAt(o9 + 1)] >> 4, d6[f7++] = 255 & t9);
      1 === c7 && (t9 = e$22[r10.charCodeAt(o9)] << 10 | e$22[r10.charCodeAt(o9 + 1)] << 4 | e$22[r10.charCodeAt(o9 + 2)] >> 2, d6[f7++] = t9 >> 8 & 255, d6[f7++] = 255 & t9);
      return d6;
    }, fromByteArray: function(r10) {
      for (var e10, n9 = r10.length, o9 = n9 % 3, a7 = [], h8 = 0, u7 = n9 - o9; h8 < u7; h8 += 16383)
        a7.push(c$12(r10, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
      1 === o9 ? (e10 = r10[n9 - 1], a7.push(t$13[e10 >> 2] + t$13[e10 << 4 & 63] + "==")) : 2 === o9 && (e10 = (r10[n9 - 2] << 8) + r10[n9 - 1], a7.push(t$13[e10 >> 10] + t$13[e10 >> 4 & 63] + t$13[e10 << 2 & 63] + "="));
      return a7.join("");
    } }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
      t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
    e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
    a$1$1 = { read: function(a7, t9, o9, r10, h8) {
      var M4, f7, p7 = 8 * h8 - r10 - 1, w4 = (1 << p7) - 1, e10 = w4 >> 1, i7 = -7, N4 = o9 ? h8 - 1 : 0, n9 = o9 ? -1 : 1, u7 = a7[t9 + N4];
      for (N4 += n9, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p7; i7 > 0; M4 = 256 * M4 + a7[t9 + N4], N4 += n9, i7 -= 8)
        ;
      for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r10; i7 > 0; f7 = 256 * f7 + a7[t9 + N4], N4 += n9, i7 -= 8)
        ;
      if (0 === M4)
        M4 = 1 - e10;
      else {
        if (M4 === w4)
          return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
        f7 += Math.pow(2, r10), M4 -= e10;
      }
      return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r10);
    }, write: function(a7, t9, o9, r10, h8, M4) {
      var f7, p7, w4, e10 = 8 * M4 - h8 - 1, i7 = (1 << e10) - 1, N4 = i7 >> 1, n9 = 23 === h8 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r10 ? 0 : M4 - 1, l7 = r10 ? 1 : -1, s6 = t9 < 0 || 0 === t9 && 1 / t9 < 0 ? 1 : 0;
      for (t9 = Math.abs(t9), isNaN(t9) || t9 === 1 / 0 ? (p7 = isNaN(t9) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t9) / Math.LN2), t9 * (w4 = Math.pow(2, -f7)) < 1 && (f7--, w4 *= 2), (t9 += f7 + N4 >= 1 ? n9 / w4 : n9 * Math.pow(2, 1 - N4)) * w4 >= 2 && (f7++, w4 /= 2), f7 + N4 >= i7 ? (p7 = 0, f7 = i7) : f7 + N4 >= 1 ? (p7 = (t9 * w4 - 1) * Math.pow(2, h8), f7 += N4) : (p7 = t9 * Math.pow(2, N4 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a7[o9 + u7] = 255 & p7, u7 += l7, p7 /= 256, h8 -= 8)
        ;
      for (f7 = f7 << h8 | p7, e10 += h8; e10 > 0; a7[o9 + u7] = 255 & f7, u7 += l7, f7 /= 256, e10 -= 8)
        ;
      a7[o9 + u7 - l7] |= 128 * s6;
    } };
    e$1$1 = {};
    n$1$1 = r$13;
    i$12 = a$1$1;
    o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t9) {
      +t9 != t9 && (t9 = 0);
      return u$1$1.alloc(+t9);
    }, e$1$1.INSPECT_MAX_BYTES = 50;
    e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
      try {
        var t9 = new Uint8Array(1), r10 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r10, Uint8Array.prototype), Object.setPrototypeOf(t9, r10), 42 === t9.foo();
      } catch (t10) {
        return false;
      }
    }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
      if (u$1$1.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
      if (u$1$1.isBuffer(this))
        return this.byteOffset;
    } }), u$1$1.poolSize = 8192, u$1$1.from = function(t9, r10, e10) {
      return s$1(t9, r10, e10);
    }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t9, r10, e10) {
      return function(t10, r11, e11) {
        return h$1$1(t10), t10 <= 0 ? f$2(t10) : void 0 !== r11 ? "string" == typeof e11 ? f$2(t10).fill(r11, e11) : f$2(t10).fill(r11) : f$2(t10);
      }(t9, r10, e10);
    }, u$1$1.allocUnsafe = function(t9) {
      return a$2(t9);
    }, u$1$1.allocUnsafeSlow = function(t9) {
      return a$2(t9);
    }, u$1$1.isBuffer = function(t9) {
      return null != t9 && true === t9._isBuffer && t9 !== u$1$1.prototype;
    }, u$1$1.compare = function(t9, r10) {
      if (F2(t9, Uint8Array) && (t9 = u$1$1.from(t9, t9.offset, t9.byteLength)), F2(r10, Uint8Array) && (r10 = u$1$1.from(r10, r10.offset, r10.byteLength)), !u$1$1.isBuffer(t9) || !u$1$1.isBuffer(r10))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t9 === r10)
        return 0;
      for (var e10 = t9.length, n9 = r10.length, i7 = 0, o9 = Math.min(e10, n9); i7 < o9; ++i7)
        if (t9[i7] !== r10[i7]) {
          e10 = t9[i7], n9 = r10[i7];
          break;
        }
      return e10 < n9 ? -1 : n9 < e10 ? 1 : 0;
    }, u$1$1.isEncoding = function(t9) {
      switch (String(t9).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, u$1$1.concat = function(t9, r10) {
      if (!Array.isArray(t9))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t9.length)
        return u$1$1.alloc(0);
      var e10;
      if (void 0 === r10)
        for (r10 = 0, e10 = 0; e10 < t9.length; ++e10)
          r10 += t9[e10].length;
      var n9 = u$1$1.allocUnsafe(r10), i7 = 0;
      for (e10 = 0; e10 < t9.length; ++e10) {
        var o9 = t9[e10];
        if (F2(o9, Uint8Array) && (o9 = u$1$1.from(o9)), !u$1$1.isBuffer(o9))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o9.copy(n9, i7), i7 += o9.length;
      }
      return n9;
    }, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
      var t9 = this.length;
      if (t9 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var r10 = 0; r10 < t9; r10 += 2)
        w2(this, r10, r10 + 1);
      return this;
    }, u$1$1.prototype.swap32 = function() {
      var t9 = this.length;
      if (t9 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var r10 = 0; r10 < t9; r10 += 4)
        w2(this, r10, r10 + 3), w2(this, r10 + 1, r10 + 2);
      return this;
    }, u$1$1.prototype.swap64 = function() {
      var t9 = this.length;
      if (t9 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var r10 = 0; r10 < t9; r10 += 8)
        w2(this, r10, r10 + 7), w2(this, r10 + 1, r10 + 6), w2(this, r10 + 2, r10 + 5), w2(this, r10 + 3, r10 + 4);
      return this;
    }, u$1$1.prototype.toString = function() {
      var t9 = this.length;
      return 0 === t9 ? "" : 0 === arguments.length ? I2(this, 0, t9) : g2.apply(this, arguments);
    }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t9) {
      if (!u$1$1.isBuffer(t9))
        throw new TypeError("Argument must be a Buffer");
      return this === t9 || 0 === u$1$1.compare(this, t9);
    }, u$1$1.prototype.inspect = function() {
      var t9 = "", r10 = e$1$1.INSPECT_MAX_BYTES;
      return t9 = this.toString("hex", 0, r10).replace(/(.{2})/g, "$1 ").trim(), this.length > r10 && (t9 += " ... "), "<Buffer " + t9 + ">";
    }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t9, r10, e10, n9, i7) {
      if (F2(t9, Uint8Array) && (t9 = u$1$1.from(t9, t9.offset, t9.byteLength)), !u$1$1.isBuffer(t9))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t9);
      if (void 0 === r10 && (r10 = 0), void 0 === e10 && (e10 = t9 ? t9.length : 0), void 0 === n9 && (n9 = 0), void 0 === i7 && (i7 = this.length), r10 < 0 || e10 > t9.length || n9 < 0 || i7 > this.length)
        throw new RangeError("out of range index");
      if (n9 >= i7 && r10 >= e10)
        return 0;
      if (n9 >= i7)
        return -1;
      if (r10 >= e10)
        return 1;
      if (this === t9)
        return 0;
      for (var o9 = (i7 >>>= 0) - (n9 >>>= 0), f7 = (e10 >>>= 0) - (r10 >>>= 0), s6 = Math.min(o9, f7), h8 = this.slice(n9, i7), a7 = t9.slice(r10, e10), p7 = 0; p7 < s6; ++p7)
        if (h8[p7] !== a7[p7]) {
          o9 = h8[p7], f7 = a7[p7];
          break;
        }
      return o9 < f7 ? -1 : f7 < o9 ? 1 : 0;
    }, u$1$1.prototype.includes = function(t9, r10, e10) {
      return -1 !== this.indexOf(t9, r10, e10);
    }, u$1$1.prototype.indexOf = function(t9, r10, e10) {
      return d3(this, t9, r10, e10, true);
    }, u$1$1.prototype.lastIndexOf = function(t9, r10, e10) {
      return d3(this, t9, r10, e10, false);
    }, u$1$1.prototype.write = function(t9, r10, e10, n9) {
      if (void 0 === r10)
        n9 = "utf8", e10 = this.length, r10 = 0;
      else if (void 0 === e10 && "string" == typeof r10)
        n9 = r10, e10 = this.length, r10 = 0;
      else {
        if (!isFinite(r10))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        r10 >>>= 0, isFinite(e10) ? (e10 >>>= 0, void 0 === n9 && (n9 = "utf8")) : (n9 = e10, e10 = void 0);
      }
      var i7 = this.length - r10;
      if ((void 0 === e10 || e10 > i7) && (e10 = i7), t9.length > 0 && (e10 < 0 || r10 < 0) || r10 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n9 || (n9 = "utf8");
      for (var o9 = false; ; )
        switch (n9) {
          case "hex":
            return b2(this, t9, r10, e10);
          case "utf8":
          case "utf-8":
            return m3(this, t9, r10, e10);
          case "ascii":
            return E2(this, t9, r10, e10);
          case "latin1":
          case "binary":
            return B2(this, t9, r10, e10);
          case "base64":
            return A2(this, t9, r10, e10);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U2(this, t9, r10, e10);
          default:
            if (o9)
              throw new TypeError("Unknown encoding: " + n9);
            n9 = ("" + n9).toLowerCase(), o9 = true;
        }
    }, u$1$1.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    u$1$1.prototype.slice = function(t9, r10) {
      var e10 = this.length;
      (t9 = ~~t9) < 0 ? (t9 += e10) < 0 && (t9 = 0) : t9 > e10 && (t9 = e10), (r10 = void 0 === r10 ? e10 : ~~r10) < 0 ? (r10 += e10) < 0 && (r10 = 0) : r10 > e10 && (r10 = e10), r10 < t9 && (r10 = t9);
      var n9 = this.subarray(t9, r10);
      return Object.setPrototypeOf(n9, u$1$1.prototype), n9;
    }, u$1$1.prototype.readUIntLE = function(t9, r10, e10) {
      t9 >>>= 0, r10 >>>= 0, e10 || x2(t9, r10, this.length);
      for (var n9 = this[t9], i7 = 1, o9 = 0; ++o9 < r10 && (i7 *= 256); )
        n9 += this[t9 + o9] * i7;
      return n9;
    }, u$1$1.prototype.readUIntBE = function(t9, r10, e10) {
      t9 >>>= 0, r10 >>>= 0, e10 || x2(t9, r10, this.length);
      for (var n9 = this[t9 + --r10], i7 = 1; r10 > 0 && (i7 *= 256); )
        n9 += this[t9 + --r10] * i7;
      return n9;
    }, u$1$1.prototype.readUInt8 = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 1, this.length), this[t9];
    }, u$1$1.prototype.readUInt16LE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 2, this.length), this[t9] | this[t9 + 1] << 8;
    }, u$1$1.prototype.readUInt16BE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 2, this.length), this[t9] << 8 | this[t9 + 1];
    }, u$1$1.prototype.readUInt32LE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), (this[t9] | this[t9 + 1] << 8 | this[t9 + 2] << 16) + 16777216 * this[t9 + 3];
    }, u$1$1.prototype.readUInt32BE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), 16777216 * this[t9] + (this[t9 + 1] << 16 | this[t9 + 2] << 8 | this[t9 + 3]);
    }, u$1$1.prototype.readIntLE = function(t9, r10, e10) {
      t9 >>>= 0, r10 >>>= 0, e10 || x2(t9, r10, this.length);
      for (var n9 = this[t9], i7 = 1, o9 = 0; ++o9 < r10 && (i7 *= 256); )
        n9 += this[t9 + o9] * i7;
      return n9 >= (i7 *= 128) && (n9 -= Math.pow(2, 8 * r10)), n9;
    }, u$1$1.prototype.readIntBE = function(t9, r10, e10) {
      t9 >>>= 0, r10 >>>= 0, e10 || x2(t9, r10, this.length);
      for (var n9 = r10, i7 = 1, o9 = this[t9 + --n9]; n9 > 0 && (i7 *= 256); )
        o9 += this[t9 + --n9] * i7;
      return o9 >= (i7 *= 128) && (o9 -= Math.pow(2, 8 * r10)), o9;
    }, u$1$1.prototype.readInt8 = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 1, this.length), 128 & this[t9] ? -1 * (255 - this[t9] + 1) : this[t9];
    }, u$1$1.prototype.readInt16LE = function(t9, r10) {
      t9 >>>= 0, r10 || x2(t9, 2, this.length);
      var e10 = this[t9] | this[t9 + 1] << 8;
      return 32768 & e10 ? 4294901760 | e10 : e10;
    }, u$1$1.prototype.readInt16BE = function(t9, r10) {
      t9 >>>= 0, r10 || x2(t9, 2, this.length);
      var e10 = this[t9 + 1] | this[t9] << 8;
      return 32768 & e10 ? 4294901760 | e10 : e10;
    }, u$1$1.prototype.readInt32LE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), this[t9] | this[t9 + 1] << 8 | this[t9 + 2] << 16 | this[t9 + 3] << 24;
    }, u$1$1.prototype.readInt32BE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), this[t9] << 24 | this[t9 + 1] << 16 | this[t9 + 2] << 8 | this[t9 + 3];
    }, u$1$1.prototype.readFloatLE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), i$12.read(this, t9, true, 23, 4);
    }, u$1$1.prototype.readFloatBE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 4, this.length), i$12.read(this, t9, false, 23, 4);
    }, u$1$1.prototype.readDoubleLE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 8, this.length), i$12.read(this, t9, true, 52, 8);
    }, u$1$1.prototype.readDoubleBE = function(t9, r10) {
      return t9 >>>= 0, r10 || x2(t9, 8, this.length), i$12.read(this, t9, false, 52, 8);
    }, u$1$1.prototype.writeUIntLE = function(t9, r10, e10, n9) {
      (t9 = +t9, r10 >>>= 0, e10 >>>= 0, n9) || C2(this, t9, r10, e10, Math.pow(2, 8 * e10) - 1, 0);
      var i7 = 1, o9 = 0;
      for (this[r10] = 255 & t9; ++o9 < e10 && (i7 *= 256); )
        this[r10 + o9] = t9 / i7 & 255;
      return r10 + e10;
    }, u$1$1.prototype.writeUIntBE = function(t9, r10, e10, n9) {
      (t9 = +t9, r10 >>>= 0, e10 >>>= 0, n9) || C2(this, t9, r10, e10, Math.pow(2, 8 * e10) - 1, 0);
      var i7 = e10 - 1, o9 = 1;
      for (this[r10 + i7] = 255 & t9; --i7 >= 0 && (o9 *= 256); )
        this[r10 + i7] = t9 / o9 & 255;
      return r10 + e10;
    }, u$1$1.prototype.writeUInt8 = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 1, 255, 0), this[r10] = 255 & t9, r10 + 1;
    }, u$1$1.prototype.writeUInt16LE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 2, 65535, 0), this[r10] = 255 & t9, this[r10 + 1] = t9 >>> 8, r10 + 2;
    }, u$1$1.prototype.writeUInt16BE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 2, 65535, 0), this[r10] = t9 >>> 8, this[r10 + 1] = 255 & t9, r10 + 2;
    }, u$1$1.prototype.writeUInt32LE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 4, 4294967295, 0), this[r10 + 3] = t9 >>> 24, this[r10 + 2] = t9 >>> 16, this[r10 + 1] = t9 >>> 8, this[r10] = 255 & t9, r10 + 4;
    }, u$1$1.prototype.writeUInt32BE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 4, 4294967295, 0), this[r10] = t9 >>> 24, this[r10 + 1] = t9 >>> 16, this[r10 + 2] = t9 >>> 8, this[r10 + 3] = 255 & t9, r10 + 4;
    }, u$1$1.prototype.writeIntLE = function(t9, r10, e10, n9) {
      if (t9 = +t9, r10 >>>= 0, !n9) {
        var i7 = Math.pow(2, 8 * e10 - 1);
        C2(this, t9, r10, e10, i7 - 1, -i7);
      }
      var o9 = 0, f7 = 1, u7 = 0;
      for (this[r10] = 255 & t9; ++o9 < e10 && (f7 *= 256); )
        t9 < 0 && 0 === u7 && 0 !== this[r10 + o9 - 1] && (u7 = 1), this[r10 + o9] = (t9 / f7 >> 0) - u7 & 255;
      return r10 + e10;
    }, u$1$1.prototype.writeIntBE = function(t9, r10, e10, n9) {
      if (t9 = +t9, r10 >>>= 0, !n9) {
        var i7 = Math.pow(2, 8 * e10 - 1);
        C2(this, t9, r10, e10, i7 - 1, -i7);
      }
      var o9 = e10 - 1, f7 = 1, u7 = 0;
      for (this[r10 + o9] = 255 & t9; --o9 >= 0 && (f7 *= 256); )
        t9 < 0 && 0 === u7 && 0 !== this[r10 + o9 + 1] && (u7 = 1), this[r10 + o9] = (t9 / f7 >> 0) - u7 & 255;
      return r10 + e10;
    }, u$1$1.prototype.writeInt8 = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 1, 127, -128), t9 < 0 && (t9 = 255 + t9 + 1), this[r10] = 255 & t9, r10 + 1;
    }, u$1$1.prototype.writeInt16LE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 2, 32767, -32768), this[r10] = 255 & t9, this[r10 + 1] = t9 >>> 8, r10 + 2;
    }, u$1$1.prototype.writeInt16BE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 2, 32767, -32768), this[r10] = t9 >>> 8, this[r10 + 1] = 255 & t9, r10 + 2;
    }, u$1$1.prototype.writeInt32LE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 4, 2147483647, -2147483648), this[r10] = 255 & t9, this[r10 + 1] = t9 >>> 8, this[r10 + 2] = t9 >>> 16, this[r10 + 3] = t9 >>> 24, r10 + 4;
    }, u$1$1.prototype.writeInt32BE = function(t9, r10, e10) {
      return t9 = +t9, r10 >>>= 0, e10 || C2(this, t9, r10, 4, 2147483647, -2147483648), t9 < 0 && (t9 = 4294967295 + t9 + 1), this[r10] = t9 >>> 24, this[r10 + 1] = t9 >>> 16, this[r10 + 2] = t9 >>> 8, this[r10 + 3] = 255 & t9, r10 + 4;
    }, u$1$1.prototype.writeFloatLE = function(t9, r10, e10) {
      return k2(this, t9, r10, true, e10);
    }, u$1$1.prototype.writeFloatBE = function(t9, r10, e10) {
      return k2(this, t9, r10, false, e10);
    }, u$1$1.prototype.writeDoubleLE = function(t9, r10, e10) {
      return M2(this, t9, r10, true, e10);
    }, u$1$1.prototype.writeDoubleBE = function(t9, r10, e10) {
      return M2(this, t9, r10, false, e10);
    }, u$1$1.prototype.copy = function(t9, r10, e10, n9) {
      if (!u$1$1.isBuffer(t9))
        throw new TypeError("argument should be a Buffer");
      if (e10 || (e10 = 0), n9 || 0 === n9 || (n9 = this.length), r10 >= t9.length && (r10 = t9.length), r10 || (r10 = 0), n9 > 0 && n9 < e10 && (n9 = e10), n9 === e10)
        return 0;
      if (0 === t9.length || 0 === this.length)
        return 0;
      if (r10 < 0)
        throw new RangeError("targetStart out of bounds");
      if (e10 < 0 || e10 >= this.length)
        throw new RangeError("Index out of range");
      if (n9 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n9 > this.length && (n9 = this.length), t9.length - r10 < n9 - e10 && (n9 = t9.length - r10 + e10);
      var i7 = n9 - e10;
      if (this === t9 && "function" == typeof Uint8Array.prototype.copyWithin)
        this.copyWithin(r10, e10, n9);
      else if (this === t9 && e10 < r10 && r10 < n9)
        for (var o9 = i7 - 1; o9 >= 0; --o9)
          t9[o9 + r10] = this[o9 + e10];
      else
        Uint8Array.prototype.set.call(t9, this.subarray(e10, n9), r10);
      return i7;
    }, u$1$1.prototype.fill = function(t9, r10, e10, n9) {
      if ("string" == typeof t9) {
        if ("string" == typeof r10 ? (n9 = r10, r10 = 0, e10 = this.length) : "string" == typeof e10 && (n9 = e10, e10 = this.length), void 0 !== n9 && "string" != typeof n9)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n9 && !u$1$1.isEncoding(n9))
          throw new TypeError("Unknown encoding: " + n9);
        if (1 === t9.length) {
          var i7 = t9.charCodeAt(0);
          ("utf8" === n9 && i7 < 128 || "latin1" === n9) && (t9 = i7);
        }
      } else
        "number" == typeof t9 ? t9 &= 255 : "boolean" == typeof t9 && (t9 = Number(t9));
      if (r10 < 0 || this.length < r10 || this.length < e10)
        throw new RangeError("Out of range index");
      if (e10 <= r10)
        return this;
      var o9;
      if (r10 >>>= 0, e10 = void 0 === e10 ? this.length : e10 >>> 0, t9 || (t9 = 0), "number" == typeof t9)
        for (o9 = r10; o9 < e10; ++o9)
          this[o9] = t9;
      else {
        var f7 = u$1$1.isBuffer(t9) ? t9 : u$1$1.from(t9, n9), s6 = f7.length;
        if (0 === s6)
          throw new TypeError('The value "' + t9 + '" is invalid for argument "value"');
        for (o9 = 0; o9 < e10 - r10; ++o9)
          this[o9 + r10] = f7[o9 % s6];
      }
      return this;
    };
    j2 = /[^+/0-9A-Za-z-_]/g;
    Y2 = function() {
      for (var t9 = new Array(256), r10 = 0; r10 < 16; ++r10)
        for (var e10 = 16 * r10, n9 = 0; n9 < 16; ++n9)
          t9[e10 + n9] = "0123456789abcdef"[r10] + "0123456789abcdef"[n9];
      return t9;
    }();
    e$1$1.Buffer;
    e$1$1.INSPECT_MAX_BYTES;
    e$1$1.kMaxLength;
    e5 = {};
    n5 = e$1$1;
    o5 = n5.Buffer;
    o5.from && o5.alloc && o5.allocUnsafe && o5.allocUnsafeSlow ? e5 = n5 : (t5(n5, e5), e5.Buffer = f4), f4.prototype = Object.create(o5.prototype), t5(o5, f4), f4.from = function(r10, e10, n9) {
      if ("number" == typeof r10)
        throw new TypeError("Argument must not be a number");
      return o5(r10, e10, n9);
    }, f4.alloc = function(r10, e10, n9) {
      if ("number" != typeof r10)
        throw new TypeError("Argument must be a number");
      var t9 = o5(r10);
      return void 0 !== e10 ? "string" == typeof n9 ? t9.fill(e10, n9) : t9.fill(e10) : t9.fill(0), t9;
    }, f4.allocUnsafe = function(r10) {
      if ("number" != typeof r10)
        throw new TypeError("Argument must be a number");
      return o5(r10);
    }, f4.allocUnsafeSlow = function(r10) {
      if ("number" != typeof r10)
        throw new TypeError("Argument must be a number");
      return n5.SlowBuffer(r10);
    };
    u4 = e5;
    e$12 = {};
    s4 = u4.Buffer;
    i4 = s4.isEncoding || function(t9) {
      switch ((t9 = "" + t9) && t9.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    e$12.StringDecoder = a4, a4.prototype.write = function(t9) {
      if (0 === t9.length)
        return "";
      var e10, s6;
      if (this.lastNeed) {
        if (void 0 === (e10 = this.fillLast(t9)))
          return "";
        s6 = this.lastNeed, this.lastNeed = 0;
      } else
        s6 = 0;
      return s6 < t9.length ? e10 ? e10 + this.text(t9, s6) : this.text(t9, s6) : e10 || "";
    }, a4.prototype.end = function(t9) {
      var e10 = t9 && t9.length ? this.write(t9) : "";
      return this.lastNeed ? e10 + "\uFFFD" : e10;
    }, a4.prototype.text = function(t9, e10) {
      var s6 = function(t10, e11, s7) {
        var i8 = e11.length - 1;
        if (i8 < s7)
          return 0;
        var a7 = r5(e11[i8]);
        if (a7 >= 0)
          return a7 > 0 && (t10.lastNeed = a7 - 1), a7;
        if (--i8 < s7 || -2 === a7)
          return 0;
        if ((a7 = r5(e11[i8])) >= 0)
          return a7 > 0 && (t10.lastNeed = a7 - 2), a7;
        if (--i8 < s7 || -2 === a7)
          return 0;
        if ((a7 = r5(e11[i8])) >= 0)
          return a7 > 0 && (2 === a7 ? a7 = 0 : t10.lastNeed = a7 - 3), a7;
        return 0;
      }(this, t9, e10);
      if (!this.lastNeed)
        return t9.toString("utf8", e10);
      this.lastTotal = s6;
      var i7 = t9.length - (s6 - this.lastNeed);
      return t9.copy(this.lastChar, 0, i7), t9.toString("utf8", e10, i7);
    }, a4.prototype.fillLast = function(t9) {
      if (this.lastNeed <= t9.length)
        return t9.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t9.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t9.length), this.lastNeed -= t9.length;
    };
    e$12.StringDecoder;
    e$12.StringDecoder;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
function dew$2$1() {
  if (_dewExec$2$1)
    return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$1;
}
function dew$1$1() {
  if (_dewExec$1$1)
    return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e10, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e10 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e10 = e10 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e10 & (1 << -nBits) - 1;
    e10 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e10 === 0) {
      e10 = 1 - eBias;
    } else if (e10 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e10 = e10 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e10 - mLen);
  };
  exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e10, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e10 = eMax;
    } else {
      e10 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e10)) < 1) {
        e10--;
        c7 *= 2;
      }
      if (e10 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e10++;
        c7 /= 2;
      }
      if (e10 + eBias >= eMax) {
        m6 = 0;
        e10 = eMax;
      } else if (e10 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e10 = e10 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e10 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e10 = e10 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e10 & 255, i7 += d6, e10 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$1$1;
}
function dew$g() {
  if (_dewExec$g)
    return exports$g;
  _dewExec$g = true;
  const base642 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Buffer3;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e10) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer4(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
    if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b5, n9, m6) {
    const i7 = b5[n9];
    b5[n9] = b5[m6];
    b5[m6] = i7;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b5) {
    if (!Buffer3.isBuffer(b5))
      throw new TypeError("Argument must be a Buffer");
    if (this === b5)
      return true;
    return Buffer3.compare(this, b5) === 0;
  };
  Buffer3.prototype.inspect = function inspect3() {
    let str = "";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === "number") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name3) {
    if (name3) {
      return `${name3} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name3, actual) {
    return `The "${name3}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i7 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = `_${val.slice(i7 - 3, i7)}${res}`;
    }
    return `${val.slice(0, i7)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n9 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n9} and < 2${n9} ** ${(byteLength2 + 1) * 8}${n9}`;
        } else {
          range = `>= -(2${n9} ** ${(byteLength2 + 1) * 8 - 1}${n9}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n9}`;
        }
      } else {
        range = `>= ${min}${n9} and <= ${max}${n9}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name3) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name3, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
function dew$f() {
  if (_dewExec$f)
    return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === "function") {
    exports$f = function inherits4(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits4(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
function dew$e() {
  if (_dewExec$e)
    return exports$e;
  _dewExec$e = true;
  exports$e = y.EventEmitter;
  return exports$e;
}
function dew$d() {
  if (_dewExec$d)
    return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i7 = 1; i7 < arguments.length; i7++) {
      var source = arguments[i7] != null ? arguments[i7] : {};
      if (i7 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i7 = 0; i7 < props.length; i7++) {
      var descriptor = props[i7];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer, Buffer3 = _require.Buffer;
  var _require2 = X, inspect3 = _require2.inspect;
  var custom = inspect3 && inspect3.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v7) {
        var entry = {
          data: v7,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v7) {
        var entry = {
          data: v7,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s6) {
        if (this.length === 0)
          return "";
        var p7 = this.head;
        var ret = "" + p7.data;
        while (p7 = p7.next) {
          ret += s6 + p7.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n9) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n9 >>> 0);
        var p7 = this.head;
        var i7 = 0;
        while (p7) {
          copyBuffer(p7.data, ret, i7);
          i7 += p7.data.length;
          p7 = p7.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n9, hasStrings) {
        var ret;
        if (n9 < this.head.data.length) {
          ret = this.head.data.slice(0, n9);
          this.head.data = this.head.data.slice(n9);
        } else if (n9 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n9) : this._getBuffer(n9);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n9) {
        var p7 = this.head;
        var c7 = 1;
        var ret = p7.data;
        n9 -= ret.length;
        while (p7 = p7.next) {
          var str = p7.data;
          var nb = n9 > str.length ? str.length : n9;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n9);
          n9 -= nb;
          if (n9 === 0) {
            if (nb === str.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = str.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n9) {
        var ret = Buffer3.allocUnsafe(n9);
        var p7 = this.head;
        var c7 = 1;
        p7.data.copy(ret);
        n9 -= p7.data.length;
        while (p7 = p7.next) {
          var buf = p7.data;
          var nb = n9 > buf.length ? buf.length : n9;
          buf.copy(ret, ret.length - n9, 0, nb);
          n9 -= nb;
          if (n9 === 0) {
            if (nb === buf.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = buf.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_4, options) {
        return inspect3(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
function dew$c() {
  if (_dewExec$c)
    return exports$c;
  _dewExec$c = true;
  var process$1 = process2;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream2.destroy(err);
    else
      stream2.emit("error", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
function dew$b() {
  if (_dewExec$b)
    return exports$b;
  _dewExec$b = true;
  const codes2 = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes2[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i7) => String(i7));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith2(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name3, value) {
    return 'The value "' + value + '" is invalid for option "' + name3 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name3, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith2(name3, " argument")) {
      msg = `The ${name3} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name3, ".") ? "property" : "argument";
      msg = `The "${name3}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name3) {
    return "The " + name3 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name3) {
    return "Cannot call " + name3 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b.codes = codes2;
  return exports$b;
}
function dew$a() {
  if (_dewExec$a)
    return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name3 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name3, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
function dew$9() {
  if (_dewExec$9)
    return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate3;
  function deprecate3(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned2 = false;
    function deprecated() {
      if (!warned2) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned2 = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config2(name3) {
    try {
      if (!_global$2.localStorage)
        return false;
    } catch (_4) {
      return false;
    }
    var val = _global$2.localStorage[name3];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$9;
}
function dew$8() {
  if (_dewExec$8)
    return exports$8;
  _dewExec$8 = true;
  var process$1 = process2;
  exports$8 = Writable2;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex2;
  Writable2.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream2 = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_4) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable2(options) {
    Duplex2 = Duplex2 || dew$7();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable2, this))
      return new Writable2(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream2, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2)
      stream2._writev(chunk, state.onwrite);
    else
      stream2._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream2, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream2, state);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state = stream2._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream2, state, sync, er, cb);
    else {
      var finished2 = needFinish(state) || stream2.destroyed;
      if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream2, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream2, state, finished2, cb);
      } else {
        afterWrite(stream2, state, finished2, cb);
      }
    }
  }
  function afterWrite(stream2, state, finished2, cb) {
    if (!finished2)
      onwriteDrain(stream2, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream2, state);
  }
  function onwriteDrain(stream2, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l7 = state.bufferedRequestCount;
      var buffer2 = new Array(l7);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream2, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream2, state) {
    stream2._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream2, err);
      }
      state.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state);
    });
  }
  function prefinish(stream2, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream2._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream2, state);
      } else {
        state.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream2, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream2.emit("finish");
        if (state.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state, cb) {
    state.ending = true;
    finishMaybe(stream2, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
function dew$7() {
  if (_dewExec$7)
    return exports$7;
  _dewExec$7 = true;
  var process$1 = process2;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex2;
  var Readable2 = dew$3();
  var Writable2 = dew$8();
  dew$f()(Duplex2, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v7 = 0; v7 < keys.length; v7++) {
      var method = keys[v7];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
function dew$6() {
  if (_dewExec$6)
    return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop3() {
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos(stream2, opts, callback) {
    if (typeof opts === "function")
      return eos(stream2, null, opts);
    if (!opts)
      opts = {};
    callback = once3(callback || noop3);
    var readable = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable)
        onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream2);
    };
    var onerror = function onerror2(err) {
      callback.call(stream2, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req)
        onrequest();
      else
        stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false)
      stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req)
        stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
function dew$5() {
  if (_dewExec$5)
    return exports$5;
  _dewExec$5 = true;
  var process$1 = process2;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished2 = dew$6();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve4 = iter[kLastResolve];
    if (resolve4 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve4(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve4, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve4(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve4, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve4, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve4(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve4, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve4(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve4, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve4(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve4;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished2(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve4 = iterator[kLastResolve];
      if (resolve4 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve4(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
function dew$4() {
  if (_dewExec$4)
    return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$4;
}
function dew$3() {
  if (_dewExec$3)
    return exports$32;
  _dewExec$3 = true;
  var process$1 = process2;
  exports$32 = Readable2;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  y.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global3.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex2 = Duplex2 || dew$7();
    if (!(this instanceof Readable2))
      return new Readable2(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream2._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream2, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream2, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream2, state, chunk, false);
            else
              maybeReadMore(stream2, state);
          } else {
            addChunk(stream2, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream2, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream2, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$12.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p7 = this._readableState.buffer.head;
    var content = "";
    while (p7 !== null) {
      content += decoder.write(p7.data);
      p7 = p7.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n9) {
    if (n9 >= MAX_HWM) {
      n9 = MAX_HWM;
    } else {
      n9--;
      n9 |= n9 >>> 1;
      n9 |= n9 >>> 2;
      n9 |= n9 >>> 4;
      n9 |= n9 >>> 8;
      n9 |= n9 >>> 16;
      n9++;
    }
    return n9;
  }
  function howMuchToRead(n9, state) {
    if (n9 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n9 !== n9) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n9 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n9);
    if (n9 <= state.length)
      return n9;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n9) {
    debug("read", n9);
    n9 = parseInt(n9, 10);
    var state = this._readableState;
    var nOrig = n9;
    if (n9 !== 0)
      state.emittedReadable = false;
    if (n9 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n9 = howMuchToRead(n9, state);
    if (n9 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n9 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n9 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n9 > 0)
      ret = fromList(n9, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n9 = 0;
    } else {
      state.length -= n9;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n9 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream2);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state = stream2._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state = stream2._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream2.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream2, state);
    }
  }
  function maybeReadMore_(stream2, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n9) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i7 = 0; i7 < len; i7++) {
        dests[i7].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream2, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream2, state);
    }
  }
  function resume_(stream2, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream2.read(0);
    }
    state.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state.flowing && !state.reading)
      stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state = stream2._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i7 in stream2) {
      if (this[i7] === void 0 && typeof stream2[i7] === "function") {
        this[i7] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i7);
      }
    }
    for (var n9 = 0; n9 < kProxyEvents.length; n9++) {
      stream2.on(kProxyEvents[n9], this.emit.bind(this, kProxyEvents[n9]));
    }
    this._read = function(n10) {
      debug("wrapped _read", n10);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n9, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n9 || n9 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n9, state.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state = stream2._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream2);
    }
  }
  function endReadableNT(state, stream2) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x4) {
    for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
      if (xs[i7] === x4)
        return i7;
    }
    return -1;
  }
  return exports$32;
}
function dew$22() {
  if (_dewExec$22)
    return exports$22;
  _dewExec$22 = true;
  exports$22 = Transform2;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex2 = dew$7();
  dew$f()(Transform2, Duplex2);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex2.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex2.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n9) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex2.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream2, er, data) {
    if (er)
      return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return exports$22;
}
function dew$12() {
  if (_dewExec$12)
    return exports$14;
  _dewExec$12 = true;
  exports$14 = PassThrough2;
  var Transform2 = dew$22();
  dew$f()(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2))
      return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$14;
}
function dew5() {
  if (_dewExec5)
    return exports5;
  _dewExec5 = true;
  var eos;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop3(err) {
    if (err)
      throw err;
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$6();
    eos(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream2))
        return stream2.abort();
      if (typeof stream2.destroy === "function")
        return stream2.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop3;
    if (typeof streams[streams.length - 1] !== "function")
      return noop3;
    return streams.pop();
  }
  function pipeline2() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream2, i7) {
      var reading = i7 < streams.length - 1;
      var writing = i7 > 0;
      return destroyer(stream2, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports5 = pipeline2;
  return exports5;
}
var exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$32, _dewExec$3, _global3, exports$22, _dewExec$22, exports$14, _dewExec$12, exports5, _dewExec5;
var init_chunk_44e51b61 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_2eac56ff();
    init_chunk_4ccc3a29();
    exports$2$1 = {};
    _dewExec$2$1 = false;
    exports$1$1 = {};
    _dewExec$1$1 = false;
    exports$g = {};
    _dewExec$g = false;
    buffer = dew$g();
    buffer.Buffer;
    buffer.INSPECT_MAX_BYTES;
    buffer.kMaxLength;
    exports$f = {};
    _dewExec$f = false;
    exports$e = {};
    _dewExec$e = false;
    exports$d = {};
    _dewExec$d = false;
    exports$c = {};
    _dewExec$c = false;
    exports$b = {};
    _dewExec$b = false;
    exports$a = {};
    _dewExec$a = false;
    exports$9 = {};
    _dewExec$9 = false;
    _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$8 = {};
    _dewExec$8 = false;
    _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$7 = {};
    _dewExec$7 = false;
    exports$6 = {};
    _dewExec$6 = false;
    exports$5 = {};
    _dewExec$5 = false;
    exports$4 = {};
    _dewExec$4 = false;
    exports$32 = {};
    _dewExec$3 = false;
    _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$22 = {};
    _dewExec$22 = false;
    exports$14 = {};
    _dewExec$12 = false;
    exports5 = {};
    _dewExec5 = false;
  }
});

// node_modules/@jspm/core/nodelibs/browser/assert.js
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => et,
  doesNotReject: () => doesNotReject,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  rejects: () => rejects,
  strict: () => strict,
  strictEqual: () => strictEqual,
  throws: () => throws
});
function e6(e10, r10) {
  if (null == e10)
    throw new TypeError("Cannot convert first argument to object");
  for (var t9 = Object(e10), n9 = 1; n9 < arguments.length; n9++) {
    var o9 = arguments[n9];
    if (null != o9)
      for (var a7 = Object.keys(Object(o9)), l7 = 0, i7 = a7.length; l7 < i7; l7++) {
        var c7 = a7[l7], b5 = Object.getOwnPropertyDescriptor(o9, c7);
        void 0 !== b5 && b5.enumerable && (t9[c7] = o9[c7]);
      }
  }
  return t9;
}
function i$5() {
  if (a$6)
    return c$4;
  function e10(t9) {
    return (e10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t10) {
      return typeof t10;
    } : function(t10) {
      return t10 && "function" == typeof Symbol && t10.constructor === Symbol && t10 !== Symbol.prototype ? "symbol" : typeof t10;
    })(t9);
  }
  function n9(t9, n10) {
    return !n10 || "object" !== e10(n10) && "function" != typeof n10 ? function(t10) {
      if (void 0 === t10)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t10;
    }(t9) : n10;
  }
  function r10(t9) {
    return (r10 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t10) {
      return t10.__proto__ || Object.getPrototypeOf(t10);
    })(t9);
  }
  function o9(t9, e11) {
    return (o9 = Object.setPrototypeOf || function(t10, e12) {
      return t10.__proto__ = e12, t10;
    })(t9, e11);
  }
  a$6 = true;
  var i7, u7, l7 = {};
  function f7(t9, e11, c7) {
    c7 || (c7 = Error);
    var a7 = function(c8) {
      function a8(o10, c9, i8) {
        var u8;
        return !function(t10, e12) {
          if (!(t10 instanceof e12))
            throw new TypeError("Cannot call a class as a function");
        }(this, a8), (u8 = n9(this, r10(a8).call(this, function(t10, n10, r11) {
          return "string" == typeof e11 ? e11 : e11(t10, n10, r11);
        }(o10, c9, i8)))).code = t9, u8;
      }
      return !function(t10, e12) {
        if ("function" != typeof e12 && null !== e12)
          throw new TypeError("Super expression must either be null or a function");
        t10.prototype = Object.create(e12 && e12.prototype, { constructor: { value: t10, writable: true, configurable: true } }), e12 && o9(t10, e12);
      }(a8, c8), a8;
    }(c7);
    l7[t9] = a7;
  }
  function s6(t9, e11) {
    if (Array.isArray(t9)) {
      var n10 = t9.length;
      return t9 = t9.map(function(t10) {
        return String(t10);
      }), n10 > 2 ? "one of ".concat(e11, " ").concat(t9.slice(0, n10 - 1).join(", "), ", or ") + t9[n10 - 1] : 2 === n10 ? "one of ".concat(e11, " ").concat(t9[0], " or ").concat(t9[1]) : "of ".concat(e11, " ").concat(t9[0]);
    }
    return "of ".concat(e11, " ").concat(String(t9));
  }
  return f7("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f7("ERR_INVALID_ARG_TYPE", function(t9, n10, r11) {
    var o10, c7, u8;
    if (void 0 === i7 && (i7 = tt()), i7("string" == typeof t9, "'name' must be a string"), "string" == typeof n10 && (c7 = "not ", n10.substr(0, c7.length) === c7) ? (o10 = "must not be", n10 = n10.replace(/^not /, "")) : o10 = "must be", function(t10, e11, n11) {
      return (void 0 === n11 || n11 > t10.length) && (n11 = t10.length), t10.substring(n11 - e11.length, n11) === e11;
    }(t9, " argument"))
      u8 = "The ".concat(t9, " ").concat(o10, " ").concat(s6(n10, "type"));
    else {
      var l8 = function(t10, e11, n11) {
        return "number" != typeof n11 && (n11 = 0), !(n11 + e11.length > t10.length) && -1 !== t10.indexOf(e11, n11);
      }(t9, ".") ? "property" : "argument";
      u8 = 'The "'.concat(t9, '" ').concat(l8, " ").concat(o10, " ").concat(s6(n10, "type"));
    }
    return u8 += ". Received type ".concat(e10(r11));
  }, TypeError), f7("ERR_INVALID_ARG_VALUE", function(e11, n10) {
    var r11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u7 && (u7 = X);
    var o10 = u7.inspect(n10);
    return o10.length > 128 && (o10 = "".concat(o10.slice(0, 128), "...")), "The argument '".concat(e11, "' ").concat(r11, ". Received ").concat(o10);
  }, TypeError), f7("ERR_INVALID_RETURN_VALUE", function(t9, n10, r11) {
    var o10;
    return o10 = r11 && r11.constructor && r11.constructor.name ? "instance of ".concat(r11.constructor.name) : "type ".concat(e10(r11)), "Expected ".concat(t9, ' to be returned from the "').concat(n10, '"') + " function but got ".concat(o10, ".");
  }, TypeError), f7("ERR_MISSING_ARGS", function() {
    for (var t9 = arguments.length, e11 = new Array(t9), n10 = 0; n10 < t9; n10++)
      e11[n10] = arguments[n10];
    void 0 === i7 && (i7 = tt()), i7(e11.length > 0, "At least one arg needs to be specified");
    var r11 = "The ", o10 = e11.length;
    switch (e11 = e11.map(function(t10) {
      return '"'.concat(t10, '"');
    }), o10) {
      case 1:
        r11 += "".concat(e11[0], " argument");
        break;
      case 2:
        r11 += "".concat(e11[0], " and ").concat(e11[1], " arguments");
        break;
      default:
        r11 += e11.slice(0, o10 - 1).join(", "), r11 += ", and ".concat(e11[o10 - 1], " arguments");
    }
    return "".concat(r11, " must be specified");
  }, TypeError), c$4.codes = l7, c$4;
}
function f$6() {
  if (l$6)
    return u$5;
  l$6 = true;
  var n9 = T;
  function r10(t9, e10, n10) {
    return e10 in t9 ? Object.defineProperty(t9, e10, { value: n10, enumerable: true, configurable: true, writable: true }) : t9[e10] = n10, t9;
  }
  function o9(t9, e10) {
    for (var n10 = 0; n10 < e10.length; n10++) {
      var r11 = e10[n10];
      r11.enumerable = r11.enumerable || false, r11.configurable = true, "value" in r11 && (r11.writable = true), Object.defineProperty(t9, r11.key, r11);
    }
  }
  function c7(t9, e10) {
    return !e10 || "object" !== y6(e10) && "function" != typeof e10 ? a7(t9) : e10;
  }
  function a7(t9) {
    if (void 0 === t9)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t9;
  }
  function f7(t9) {
    var e10 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f7 = function(t10) {
      if (null === t10 || (n10 = t10, -1 === Function.toString.call(n10).indexOf("[native code]")))
        return t10;
      var n10;
      if ("function" != typeof t10)
        throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e10) {
        if (e10.has(t10))
          return e10.get(t10);
        e10.set(t10, r11);
      }
      function r11() {
        return p7(t10, arguments, h8(this).constructor);
      }
      return r11.prototype = Object.create(t10.prototype, { constructor: { value: r11, enumerable: false, writable: true, configurable: true } }), g5(r11, t10);
    })(t9);
  }
  function s6() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t9) {
      return false;
    }
  }
  function p7(t9, e10, n10) {
    return (p7 = s6() ? Reflect.construct : function(t10, e11, n11) {
      var r11 = [null];
      r11.push.apply(r11, e11);
      var o10 = new (Function.bind.apply(t10, r11))();
      return n11 && g5(o10, n11.prototype), o10;
    }).apply(null, arguments);
  }
  function g5(t9, e10) {
    return (g5 = Object.setPrototypeOf || function(t10, e11) {
      return t10.__proto__ = e11, t10;
    })(t9, e10);
  }
  function h8(t9) {
    return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t10) {
      return t10.__proto__ || Object.getPrototypeOf(t10);
    })(t9);
  }
  function y6(t9) {
    return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t10) {
      return typeof t10;
    } : function(t10) {
      return t10 && "function" == typeof Symbol && t10.constructor === Symbol && t10 !== Symbol.prototype ? "symbol" : typeof t10;
    })(t9);
  }
  var b5 = X.inspect, v7 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d6(t9, e10, n10) {
    return (void 0 === n10 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
  }
  var m6 = "", E4 = "", w4 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O5(t9) {
    var e10 = Object.keys(t9), n10 = Object.create(Object.getPrototypeOf(t9));
    return e10.forEach(function(e11) {
      n10[e11] = t9[e11];
    }), Object.defineProperty(n10, "message", { value: t9.message }), n10;
  }
  function x4(t9) {
    return b5(t9, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q3(t9, e10, r11) {
    var o10 = "", c8 = "", a8 = 0, i7 = "", u7 = false, l7 = x4(t9), f8 = l7.split("\n"), s7 = x4(e10).split("\n"), p8 = 0, g6 = "";
    if ("strictEqual" === r11 && "object" === y6(t9) && "object" === y6(e10) && null !== t9 && null !== e10 && (r11 = "strictEqualObject"), 1 === f8.length && 1 === s7.length && f8[0] !== s7[0]) {
      var h9 = f8[0].length + s7[0].length;
      if (h9 <= 10) {
        if (!("object" === y6(t9) && null !== t9 || "object" === y6(e10) && null !== e10 || 0 === t9 && 0 === e10))
          return "".concat(j4[r11], "\n\n") + "".concat(f8[0], " !== ").concat(s7[0], "\n");
      } else if ("strictEqualObject" !== r11) {
        if (h9 < (n9.stderr && n9.stderr.isTTY ? n9.stderr.columns : 80)) {
          for (; f8[0][p8] === s7[0][p8]; )
            p8++;
          p8 > 2 && (g6 = "\n  ".concat(function(t10, e11) {
            if (e11 = Math.floor(e11), 0 == t10.length || 0 == e11)
              return "";
            var n10 = t10.length * e11;
            for (e11 = Math.floor(Math.log(e11) / Math.log(2)); e11; )
              t10 += t10, e11--;
            return t10 += t10.substring(0, n10 - t10.length);
          }(" ", p8), "^"), p8 = 0);
        }
      }
    }
    for (var b6 = f8[f8.length - 1], v8 = s7[s7.length - 1]; b6 === v8 && (p8++ < 2 ? i7 = "\n  ".concat(b6).concat(i7) : o10 = b6, f8.pop(), s7.pop(), 0 !== f8.length && 0 !== s7.length); )
      b6 = f8[f8.length - 1], v8 = s7[s7.length - 1];
    var O6 = Math.max(f8.length, s7.length);
    if (0 === O6) {
      var q4 = l7.split("\n");
      if (q4.length > 30)
        for (q4[26] = "".concat(m6, "...").concat(S4); q4.length > 27; )
          q4.pop();
      return "".concat(j4.notIdentical, "\n\n").concat(q4.join("\n"), "\n");
    }
    p8 > 3 && (i7 = "\n".concat(m6, "...").concat(S4).concat(i7), u7 = true), "" !== o10 && (i7 = "\n  ".concat(o10).concat(i7), o10 = "");
    var R5 = 0, A4 = j4[r11] + "\n".concat(E4, "+ actual").concat(S4, " ").concat(w4, "- expected").concat(S4), k4 = " ".concat(m6, "...").concat(S4, " Lines skipped");
    for (p8 = 0; p8 < O6; p8++) {
      var _4 = p8 - a8;
      if (f8.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(s7[p8 - 2]), R5++), c8 += "\n  ".concat(s7[p8 - 1]), R5++), a8 = p8, o10 += "\n".concat(w4, "-").concat(S4, " ").concat(s7[p8]), R5++;
      else if (s7.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(f8[p8]), R5++;
      else {
        var T5 = s7[p8], P4 = f8[p8], I4 = P4 !== T5 && (!d6(P4, ",") || P4.slice(0, -1) !== T5);
        I4 && d6(T5, ",") && T5.slice(0, -1) === P4 && (I4 = false, P4 += ","), I4 ? (_4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(P4), o10 += "\n".concat(w4, "-").concat(S4, " ").concat(T5), R5 += 2) : (c8 += o10, o10 = "", 1 !== _4 && 0 !== p8 || (c8 += "\n  ".concat(P4), R5++));
      }
      if (R5 > 20 && p8 < O6 - 2)
        return "".concat(A4).concat(k4, "\n").concat(c8, "\n").concat(m6, "...").concat(S4).concat(o10, "\n") + "".concat(m6, "...").concat(S4);
    }
    return "".concat(A4).concat(u7 ? k4 : "", "\n").concat(c8).concat(o10).concat(i7).concat(g6);
  }
  var R4 = function(t9) {
    function e10(t10) {
      var r11;
      if (!function(t11, e11) {
        if (!(t11 instanceof e11))
          throw new TypeError("Cannot call a class as a function");
      }(this, e10), "object" !== y6(t10) || null === t10)
        throw new v7("options", "Object", t10);
      var o10 = t10.message, i8 = t10.operator, u8 = t10.stackStartFn, l7 = t10.actual, f8 = t10.expected, s7 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o10)
        r11 = c7(this, h8(e10).call(this, String(o10)));
      else if (n9.stderr && n9.stderr.isTTY && (n9.stderr && n9.stderr.getColorDepth && 1 !== n9.stderr.getColorDepth() ? (m6 = "\x1B[34m", E4 = "\x1B[32m", S4 = "\x1B[39m", w4 = "\x1B[31m") : (m6 = "", E4 = "", S4 = "", w4 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f8) && null !== f8 && "stack" in l7 && l7 instanceof Error && "stack" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), "deepStrictEqual" === i8 || "strictEqual" === i8)
        r11 = c7(this, h8(e10).call(this, q3(l7, f8, i8)));
      else if ("notDeepStrictEqual" === i8 || "notStrictEqual" === i8) {
        var p8 = j4[i8], g6 = x4(l7).split("\n");
        if ("notStrictEqual" === i8 && "object" === y6(l7) && null !== l7 && (p8 = j4.notStrictEqualObject), g6.length > 30)
          for (g6[26] = "".concat(m6, "...").concat(S4); g6.length > 27; )
            g6.pop();
        r11 = 1 === g6.length ? c7(this, h8(e10).call(this, "".concat(p8, " ").concat(g6[0]))) : c7(this, h8(e10).call(this, "".concat(p8, "\n\n").concat(g6.join("\n"), "\n")));
      } else {
        var b6 = x4(l7), d7 = "", R5 = j4[i8];
        "notDeepEqual" === i8 || "notEqual" === i8 ? (b6 = "".concat(j4[i8], "\n\n").concat(b6)).length > 1024 && (b6 = "".concat(b6.slice(0, 1021), "...")) : (d7 = "".concat(x4(f8)), b6.length > 512 && (b6 = "".concat(b6.slice(0, 509), "...")), d7.length > 512 && (d7 = "".concat(d7.slice(0, 509), "...")), "deepEqual" === i8 || "equal" === i8 ? b6 = "".concat(R5, "\n\n").concat(b6, "\n\nshould equal\n\n") : d7 = " ".concat(i8, " ").concat(d7)), r11 = c7(this, h8(e10).call(this, "".concat(b6).concat(d7)));
      }
      return Error.stackTraceLimit = s7, r11.generatedMessage = !o10, Object.defineProperty(a7(r11), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r11.code = "ERR_ASSERTION", r11.actual = l7, r11.expected = f8, r11.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a7(r11), u8), r11.stack, r11.name = "AssertionError", c7(r11);
    }
    var i7, u7;
    return !function(t10, e11) {
      if ("function" != typeof e11 && null !== e11)
        throw new TypeError("Super expression must either be null or a function");
      t10.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t10, writable: true, configurable: true } }), e11 && g5(t10, e11);
    }(e10, t9), i7 = e10, (u7 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b5.custom, value: function(t10, e11) {
      return b5(this, function(t11) {
        for (var e12 = 1; e12 < arguments.length; e12++) {
          var n10 = null != arguments[e12] ? arguments[e12] : {}, o10 = Object.keys(n10);
          "function" == typeof Object.getOwnPropertySymbols && (o10 = o10.concat(Object.getOwnPropertySymbols(n10).filter(function(t12) {
            return Object.getOwnPropertyDescriptor(n10, t12).enumerable;
          }))), o10.forEach(function(e13) {
            r10(t11, e13, n10[e13]);
          });
        }
        return t11;
      }({}, e11, { customInspect: false, depth: 0 }));
    } }]) && o9(i7.prototype, u7), e10;
  }(f7(Error));
  return u$5 = R4;
}
function s$3(t9, e10) {
  return function(t10) {
    if (Array.isArray(t10))
      return t10;
  }(t9) || function(t10, e11) {
    var n9 = [], r10 = true, o9 = false, c7 = void 0;
    try {
      for (var a7, i7 = t10[Symbol.iterator](); !(r10 = (a7 = i7.next()).done) && (n9.push(a7.value), !e11 || n9.length !== e11); r10 = true)
        ;
    } catch (t11) {
      o9 = true, c7 = t11;
    } finally {
      try {
        r10 || null == i7.return || i7.return();
      } finally {
        if (o9)
          throw c7;
      }
    }
    return n9;
  }(t9, e10) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t9) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t10) {
    return typeof t10;
  } : function(t10) {
    return t10 && "function" == typeof Symbol && t10.constructor === Symbol && t10 !== Symbol.prototype ? "symbol" : typeof t10;
  })(t9);
}
function m$2(t9) {
  return t9.call.bind(t9);
}
function U3(t9) {
  if (0 === t9.length || t9.length > 10)
    return true;
  for (var e10 = 0; e10 < t9.length; e10++) {
    var n9 = t9.charCodeAt(e10);
    if (n9 < 48 || n9 > 57)
      return true;
  }
  return 10 === t9.length && t9 >= Math.pow(2, 32);
}
function G2(t9) {
  return Object.keys(t9).filter(U3).concat(v$1(t9).filter(Object.prototype.propertyIsEnumerable.bind(t9)));
}
function V2(t9, e10) {
  if (t9 === e10)
    return 0;
  for (var n9 = t9.length, r10 = e10.length, o9 = 0, c7 = Math.min(n9, r10); o9 < c7; ++o9)
    if (t9[o9] !== e10[o9]) {
      n9 = t9[o9], r10 = e10[o9];
      break;
    }
  return n9 < r10 ? -1 : r10 < n9 ? 1 : 0;
}
function B3(t9, e10, n9, r10) {
  if (t9 === e10)
    return 0 !== t9 || (!n9 || b$1(t9, e10));
  if (n9) {
    if ("object" !== p$3(t9))
      return "number" == typeof t9 && d$1(t9) && d$1(e10);
    if ("object" !== p$3(e10) || null === t9 || null === e10)
      return false;
    if (Object.getPrototypeOf(t9) !== Object.getPrototypeOf(e10))
      return false;
  } else {
    if (null === t9 || "object" !== p$3(t9))
      return (null === e10 || "object" !== p$3(e10)) && t9 == e10;
    if (null === e10 || "object" !== p$3(e10))
      return false;
  }
  var o9, c7, a7, i7, u7 = S3(t9);
  if (u7 !== S3(e10))
    return false;
  if (Array.isArray(t9)) {
    if (t9.length !== e10.length)
      return false;
    var l7 = G2(t9), f7 = G2(e10);
    return l7.length === f7.length && C3(t9, e10, n9, r10, 1, l7);
  }
  if ("[object Object]" === u7 && (!R3(t9) && R3(e10) || !k3(t9) && k3(e10)))
    return false;
  if (q2(t9)) {
    if (!q2(e10) || Date.prototype.getTime.call(t9) !== Date.prototype.getTime.call(e10))
      return false;
  } else if (A$1(t9)) {
    if (!A$1(e10) || (a7 = t9, i7 = e10, !(g$1 ? a7.source === i7.source && a7.flags === i7.flags : RegExp.prototype.toString.call(a7) === RegExp.prototype.toString.call(i7))))
      return false;
  } else if (_3(t9) || t9 instanceof Error) {
    if (t9.message !== e10.message || t9.name !== e10.name)
      return false;
  } else {
    if (x3(t9)) {
      if (n9 || !L3(t9) && !M3(t9)) {
        if (!function(t10, e11) {
          return t10.byteLength === e11.byteLength && 0 === V2(new Uint8Array(t10.buffer, t10.byteOffset, t10.byteLength), new Uint8Array(e11.buffer, e11.byteOffset, e11.byteLength));
        }(t9, e10))
          return false;
      } else if (!function(t10, e11) {
        if (t10.byteLength !== e11.byteLength)
          return false;
        for (var n10 = 0; n10 < t10.byteLength; n10++)
          if (t10[n10] !== e11[n10])
            return false;
        return true;
      }(t9, e10))
        return false;
      var s6 = G2(t9), h8 = G2(e10);
      return s6.length === h8.length && C3(t9, e10, n9, r10, 0, s6);
    }
    if (k3(t9))
      return !(!k3(e10) || t9.size !== e10.size) && C3(t9, e10, n9, r10, 2);
    if (R3(t9))
      return !(!R3(e10) || t9.size !== e10.size) && C3(t9, e10, n9, r10, 3);
    if (O3(t9)) {
      if (c7 = e10, (o9 = t9).byteLength !== c7.byteLength || 0 !== V2(new Uint8Array(o9), new Uint8Array(c7)))
        return false;
    } else if (T4(t9) && !function(t10, e11) {
      return P$1(t10) ? P$1(e11) && b$1(Number.prototype.valueOf.call(t10), Number.prototype.valueOf.call(e11)) : I3(t10) ? I3(e11) && String.prototype.valueOf.call(t10) === String.prototype.valueOf.call(e11) : D3(t10) ? D3(e11) && Boolean.prototype.valueOf.call(t10) === Boolean.prototype.valueOf.call(e11) : F3(t10) ? F3(e11) && BigInt.prototype.valueOf.call(t10) === BigInt.prototype.valueOf.call(e11) : N$1(e11) && Symbol.prototype.valueOf.call(t10) === Symbol.prototype.valueOf.call(e11);
    }(t9, e10))
      return false;
  }
  return C3(t9, e10, n9, r10, 0);
}
function z3(t9, e10) {
  return e10.filter(function(e11) {
    return w$1(t9, e11);
  });
}
function C3(t9, e10, n9, r10, o9, c7) {
  if (5 === arguments.length) {
    c7 = Object.keys(t9);
    var a7 = Object.keys(e10);
    if (c7.length !== a7.length)
      return false;
  }
  for (var i7 = 0; i7 < c7.length; i7++)
    if (!E3(e10, c7[i7]))
      return false;
  if (n9 && 5 === arguments.length) {
    var u7 = v$1(t9);
    if (0 !== u7.length) {
      var l7 = 0;
      for (i7 = 0; i7 < u7.length; i7++) {
        var f7 = u7[i7];
        if (w$1(t9, f7)) {
          if (!w$1(e10, f7))
            return false;
          c7.push(f7), l7++;
        } else if (w$1(e10, f7))
          return false;
      }
      var s6 = v$1(e10);
      if (u7.length !== s6.length && z3(e10, s6).length !== l7)
        return false;
    } else {
      var p7 = v$1(e10);
      if (0 !== p7.length && 0 !== z3(e10, p7).length)
        return false;
    }
  }
  if (0 === c7.length && (0 === o9 || 1 === o9 && 0 === t9.length || 0 === t9.size))
    return true;
  if (void 0 === r10)
    r10 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g5 = r10.val1.get(t9);
    if (void 0 !== g5) {
      var h8 = r10.val2.get(e10);
      if (void 0 !== h8)
        return g5 === h8;
    }
    r10.position++;
  }
  r10.val1.set(t9, r10.position), r10.val2.set(e10, r10.position);
  var y6 = Q2(t9, e10, n9, c7, r10, o9);
  return r10.val1.delete(t9), r10.val2.delete(e10), y6;
}
function Y3(t9, e10, n9, r10) {
  for (var o9 = h$1(t9), c7 = 0; c7 < o9.length; c7++) {
    var a7 = o9[c7];
    if (B3(e10, a7, n9, r10))
      return t9.delete(a7), true;
  }
  return false;
}
function W2(t9) {
  switch (p$3(t9)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t9 = +t9;
    case "number":
      if (d$1(t9))
        return false;
  }
  return true;
}
function H2(t9, e10, n9) {
  var r10 = W2(n9);
  return null != r10 ? r10 : e10.has(r10) && !t9.has(r10);
}
function J2(t9, e10, n9, r10, o9) {
  var c7 = W2(n9);
  if (null != c7)
    return c7;
  var a7 = e10.get(c7);
  return !(void 0 === a7 && !e10.has(c7) || !B3(r10, a7, false, o9)) && (!t9.has(c7) && B3(r10, a7, false, o9));
}
function K2(t9, e10, n9, r10, o9, c7) {
  for (var a7 = h$1(t9), i7 = 0; i7 < a7.length; i7++) {
    var u7 = a7[i7];
    if (B3(n9, u7, o9, c7) && B3(r10, e10.get(u7), o9, c7))
      return t9.delete(u7), true;
  }
  return false;
}
function Q2(t9, e10, n9, r10, o9, c7) {
  var a7 = 0;
  if (2 === c7) {
    if (!function(t10, e11, n10, r11) {
      for (var o10 = null, c8 = h$1(t10), a8 = 0; a8 < c8.length; a8++) {
        var i8 = c8[a8];
        if ("object" === p$3(i8) && null !== i8)
          null === o10 && (o10 = /* @__PURE__ */ new Set()), o10.add(i8);
        else if (!e11.has(i8)) {
          if (n10)
            return false;
          if (!H2(t10, e11, i8))
            return false;
          null === o10 && (o10 = /* @__PURE__ */ new Set()), o10.add(i8);
        }
      }
      if (null !== o10) {
        for (var u8 = h$1(e11), l8 = 0; l8 < u8.length; l8++) {
          var f7 = u8[l8];
          if ("object" === p$3(f7) && null !== f7) {
            if (!Y3(o10, f7, n10, r11))
              return false;
          } else if (!n10 && !t10.has(f7) && !Y3(o10, f7, n10, r11))
            return false;
        }
        return 0 === o10.size;
      }
      return true;
    }(t9, e10, n9, o9))
      return false;
  } else if (3 === c7) {
    if (!function(t10, e11, n10, r11) {
      for (var o10 = null, c8 = y$2(t10), a8 = 0; a8 < c8.length; a8++) {
        var i8 = s$3(c8[a8], 2), u8 = i8[0], l8 = i8[1];
        if ("object" === p$3(u8) && null !== u8)
          null === o10 && (o10 = /* @__PURE__ */ new Set()), o10.add(u8);
        else {
          var f7 = e11.get(u8);
          if (void 0 === f7 && !e11.has(u8) || !B3(l8, f7, n10, r11)) {
            if (n10)
              return false;
            if (!J2(t10, e11, u8, l8, r11))
              return false;
            null === o10 && (o10 = /* @__PURE__ */ new Set()), o10.add(u8);
          }
        }
      }
      if (null !== o10) {
        for (var g5 = y$2(e11), h8 = 0; h8 < g5.length; h8++) {
          var b5 = s$3(g5[h8], 2), v7 = (u8 = b5[0], b5[1]);
          if ("object" === p$3(u8) && null !== u8) {
            if (!K2(o10, t10, u8, v7, n10, r11))
              return false;
          } else if (!(n10 || t10.has(u8) && B3(t10.get(u8), v7, false, r11) || K2(o10, t10, u8, v7, false, r11)))
            return false;
        }
        return 0 === o10.size;
      }
      return true;
    }(t9, e10, n9, o9))
      return false;
  } else if (1 === c7)
    for (; a7 < t9.length; a7++) {
      if (!E3(t9, a7)) {
        if (E3(e10, a7))
          return false;
        for (var i7 = Object.keys(t9); a7 < i7.length; a7++) {
          var u7 = i7[a7];
          if (!E3(e10, u7) || !B3(t9[u7], e10[u7], n9, o9))
            return false;
        }
        return i7.length === Object.keys(e10).length;
      }
      if (!E3(e10, a7) || !B3(t9[a7], e10[a7], n9, o9))
        return false;
    }
  for (a7 = 0; a7 < r10.length; a7++) {
    var l7 = r10[a7];
    if (!B3(t9[l7], e10[l7], n9, o9))
      return false;
  }
  return true;
}
function tt() {
  if ($$1)
    return Z2;
  $$1 = true;
  var o9 = T;
  function c7(t9) {
    return (c7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t10) {
      return typeof t10;
    } : function(t10) {
      return t10 && "function" == typeof Symbol && t10.constructor === Symbol && t10 !== Symbol.prototype ? "symbol" : typeof t10;
    })(t9);
  }
  var a7, u7, l7 = i$5().codes, s6 = l7.ERR_AMBIGUOUS_ARGUMENT, p7 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b5 = f$6(), v7 = X.inspect, d6 = X.types, m$12 = d6.isPromise, E4 = d6.isRegExp, w4 = Object.assign ? Object.assign : r6.assign, S4 = Object.is ? Object.is : m4;
  function j4() {
    a7 = X2.isDeepEqual, u7 = X2.isDeepStrictEqual;
  }
  var O5 = false, x4 = Z2 = k4, q3 = {};
  function R4(t9) {
    if (t9.message instanceof Error)
      throw t9.message;
    throw new b5(t9);
  }
  function A4(t9, e10, n9, r10) {
    if (!n9) {
      var o10 = false;
      if (0 === e10)
        o10 = true, r10 = "No value argument passed to `assert.ok()`";
      else if (r10 instanceof Error)
        throw r10;
      var c8 = new b5({ actual: n9, expected: true, message: r10, operator: "==", stackStartFn: t9 });
      throw c8.generatedMessage = o10, c8;
    }
  }
  function k4() {
    for (var t9 = arguments.length, e10 = new Array(t9), n9 = 0; n9 < t9; n9++)
      e10[n9] = arguments[n9];
    A4.apply(void 0, [k4, e10.length].concat(e10));
  }
  x4.fail = function t9(e10, n9, r10, c8, a8) {
    var i7, u8 = arguments.length;
    if (0 === u8)
      i7 = "Failed";
    else if (1 === u8)
      r10 = e10, e10 = void 0;
    else {
      if (false === O5) {
        O5 = true;
        var l8 = o9.emitWarning ? o9.emitWarning : console.warn.bind(console);
        l8("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u8 && (c8 = "!=");
    }
    if (r10 instanceof Error)
      throw r10;
    var f7 = { actual: e10, expected: n9, operator: void 0 === c8 ? "fail" : c8, stackStartFn: a8 || t9 };
    void 0 !== r10 && (f7.message = r10);
    var s7 = new b5(f7);
    throw i7 && (s7.message = i7, s7.generatedMessage = true), s7;
  }, x4.AssertionError = b5, x4.ok = k4, x4.equal = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    e10 != n9 && R4({ actual: e10, expected: n9, message: r10, operator: "==", stackStartFn: t9 });
  }, x4.notEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    e10 == n9 && R4({ actual: e10, expected: n9, message: r10, operator: "!=", stackStartFn: t9 });
  }, x4.deepEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), a7(e10, n9) || R4({ actual: e10, expected: n9, message: r10, operator: "deepEqual", stackStartFn: t9 });
  }, x4.notDeepEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), a7(e10, n9) && R4({ actual: e10, expected: n9, message: r10, operator: "notDeepEqual", stackStartFn: t9 });
  }, x4.deepStrictEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4(), u7(e10, n9) || R4({ actual: e10, expected: n9, message: r10, operator: "deepStrictEqual", stackStartFn: t9 });
  }, x4.notDeepStrictEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    void 0 === a7 && j4();
    u7(e10, n9) && R4({ actual: e10, expected: n9, message: r10, operator: "notDeepStrictEqual", stackStartFn: t9 });
  }, x4.strictEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    S4(e10, n9) || R4({ actual: e10, expected: n9, message: r10, operator: "strictEqual", stackStartFn: t9 });
  }, x4.notStrictEqual = function t9(e10, n9, r10) {
    if (arguments.length < 2)
      throw new y6("actual", "expected");
    S4(e10, n9) && R4({ actual: e10, expected: n9, message: r10, operator: "notStrictEqual", stackStartFn: t9 });
  };
  var _4 = function t9(e10, n9, r10) {
    var o10 = this;
    !function(t10, e11) {
      if (!(t10 instanceof e11))
        throw new TypeError("Cannot call a class as a function");
    }(this, t9), n9.forEach(function(t10) {
      t10 in e10 && (void 0 !== r10 && "string" == typeof r10[t10] && E4(e10[t10]) && e10[t10].test(r10[t10]) ? o10[t10] = r10[t10] : o10[t10] = e10[t10]);
    });
  };
  function T5(t9, e10, n9, r10, o10, c8) {
    if (!(n9 in t9) || !u7(t9[n9], e10[n9])) {
      if (!r10) {
        var a8 = new _4(t9, o10), i7 = new _4(e10, o10, t9), l8 = new b5({ actual: a8, expected: i7, operator: "deepStrictEqual", stackStartFn: c8 });
        throw l8.actual = t9, l8.expected = e10, l8.operator = c8.name, l8;
      }
      R4({ actual: t9, expected: e10, message: r10, operator: c8.name, stackStartFn: c8 });
    }
  }
  function P4(t9, e10, n9, r10) {
    if ("function" != typeof e10) {
      if (E4(e10))
        return e10.test(t9);
      if (2 === arguments.length)
        throw new p7("expected", ["Function", "RegExp"], e10);
      if ("object" !== c7(t9) || null === t9) {
        var o10 = new b5({ actual: t9, expected: e10, message: n9, operator: "deepStrictEqual", stackStartFn: r10 });
        throw o10.operator = r10.name, o10;
      }
      var i7 = Object.keys(e10);
      if (e10 instanceof Error)
        i7.push("name", "message");
      else if (0 === i7.length)
        throw new g5("error", e10, "may not be an empty object");
      return void 0 === a7 && j4(), i7.forEach(function(o11) {
        "string" == typeof t9[o11] && E4(e10[o11]) && e10[o11].test(t9[o11]) || T5(t9, e10, o11, n9, i7, r10);
      }), true;
    }
    return void 0 !== e10.prototype && t9 instanceof e10 || !Error.isPrototypeOf(e10) && true === e10.call({}, t9);
  }
  function I4(t9) {
    if ("function" != typeof t9)
      throw new p7("fn", "Function", t9);
    try {
      t9();
    } catch (t10) {
      return t10;
    }
    return q3;
  }
  function D4(t9) {
    return m$12(t9) || null !== t9 && "object" === c7(t9) && "function" == typeof t9.then && "function" == typeof t9.catch;
  }
  function F4(t9) {
    return Promise.resolve().then(function() {
      var e10;
      if ("function" == typeof t9) {
        if (!D4(e10 = t9()))
          throw new h8("instance of Promise", "promiseFn", e10);
      } else {
        if (!D4(t9))
          throw new p7("promiseFn", ["Function", "Promise"], t9);
        e10 = t9;
      }
      return Promise.resolve().then(function() {
        return e10;
      }).then(function() {
        return q3;
      }).catch(function(t10) {
        return t10;
      });
    });
  }
  function N4(t9, e10, n9, r10) {
    if ("string" == typeof n9) {
      if (4 === arguments.length)
        throw new p7("error", ["Object", "Error", "Function", "RegExp"], n9);
      if ("object" === c7(e10) && null !== e10) {
        if (e10.message === n9)
          throw new s6("error/message", 'The error message "'.concat(e10.message, '" is identical to the message.'));
      } else if (e10 === n9)
        throw new s6("error/message", 'The error "'.concat(e10, '" is identical to the message.'));
      r10 = n9, n9 = void 0;
    } else if (null != n9 && "object" !== c7(n9) && "function" != typeof n9)
      throw new p7("error", ["Object", "Error", "Function", "RegExp"], n9);
    if (e10 === q3) {
      var o10 = "";
      n9 && n9.name && (o10 += " (".concat(n9.name, ")")), o10 += r10 ? ": ".concat(r10) : ".";
      var a8 = "rejects" === t9.name ? "rejection" : "exception";
      R4({ actual: void 0, expected: n9, operator: t9.name, message: "Missing expected ".concat(a8).concat(o10), stackStartFn: t9 });
    }
    if (n9 && !P4(e10, n9, r10, t9))
      throw e10;
  }
  function L4(t9, e10, n9, r10) {
    if (e10 !== q3) {
      if ("string" == typeof n9 && (r10 = n9, n9 = void 0), !n9 || P4(e10, n9)) {
        var o10 = r10 ? ": ".concat(r10) : ".", c8 = "doesNotReject" === t9.name ? "rejection" : "exception";
        R4({ actual: e10, expected: n9, operator: t9.name, message: "Got unwanted ".concat(c8).concat(o10, "\n") + 'Actual message: "'.concat(e10 && e10.message, '"'), stackStartFn: t9 });
      }
      throw e10;
    }
  }
  function M4() {
    for (var t9 = arguments.length, e10 = new Array(t9), n9 = 0; n9 < t9; n9++)
      e10[n9] = arguments[n9];
    A4.apply(void 0, [M4, e10.length].concat(e10));
  }
  return x4.throws = function t9(e10) {
    for (var n9 = arguments.length, r10 = new Array(n9 > 1 ? n9 - 1 : 0), o10 = 1; o10 < n9; o10++)
      r10[o10 - 1] = arguments[o10];
    N4.apply(void 0, [t9, I4(e10)].concat(r10));
  }, x4.rejects = function t9(e10) {
    for (var n9 = arguments.length, r10 = new Array(n9 > 1 ? n9 - 1 : 0), o10 = 1; o10 < n9; o10++)
      r10[o10 - 1] = arguments[o10];
    return F4(e10).then(function(e11) {
      return N4.apply(void 0, [t9, e11].concat(r10));
    });
  }, x4.doesNotThrow = function t9(e10) {
    for (var n9 = arguments.length, r10 = new Array(n9 > 1 ? n9 - 1 : 0), o10 = 1; o10 < n9; o10++)
      r10[o10 - 1] = arguments[o10];
    L4.apply(void 0, [t9, I4(e10)].concat(r10));
  }, x4.doesNotReject = function t9(e10) {
    for (var n9 = arguments.length, r10 = new Array(n9 > 1 ? n9 - 1 : 0), o10 = 1; o10 < n9; o10++)
      r10[o10 - 1] = arguments[o10];
    return F4(e10).then(function(e11) {
      return L4.apply(void 0, [t9, e11].concat(r10));
    });
  }, x4.ifError = function t9(e10) {
    if (null != e10) {
      var n9 = "ifError got unwanted exception: ";
      "object" === c7(e10) && "string" == typeof e10.message ? 0 === e10.message.length && e10.constructor ? n9 += e10.constructor.name : n9 += e10.message : n9 += v7(e10);
      var r10 = new b5({ actual: e10, expected: null, operator: "ifError", message: n9, stackStartFn: t9 }), o10 = e10.stack;
      if ("string" == typeof o10) {
        var a8 = o10.split("\n");
        a8.shift();
        for (var i7 = r10.stack.split("\n"), u8 = 0; u8 < a8.length; u8++) {
          var l8 = i7.indexOf(a8[u8]);
          if (-1 !== l8) {
            i7 = i7.slice(0, l8);
            break;
          }
        }
        r10.stack = "".concat(i7.join("\n"), "\n").concat(a8.join("\n"));
      }
      throw r10;
    }
  }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
}
var r6, t6, e$13, r$12, n9, o9, c7, l7, i7, a7, u7, f7, p7, s6, y4, b3, g3, h5, $2, j3, w3, r$2, e$2, o$13, n$13, a$1, c$13, l$13, u$13, f$12, t$12, f$22, e$3, l$2, t$22, n$2, o$22, r$3, e$4, o$3, t$3, n$3, y$1, a$22, i$13, d4, f$3, u$22, A3, l$3, v5, P3, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$12, a$4, l$5, p$2, m4, N3, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E3, w$1, S3, j$1, O3, x3, q2, R3, A$1, k3, _3, T4, P$1, I3, D3, F3, N$1, L3, M3, X2, Z2, $$1, et, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws;
var init_assert = __esm({
  "node_modules/@jspm/core/nodelibs/browser/assert.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    r6 = { assign: e6, polyfill: function() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e6 });
    } };
    e$13 = Object.prototype.toString;
    r$12 = function(t9) {
      var r10 = e$13.call(t9), n9 = "[object Arguments]" === r10;
      return n9 || (n9 = "[object Array]" !== r10 && null !== t9 && "object" == typeof t9 && "number" == typeof t9.length && t9.length >= 0 && "[object Function]" === e$13.call(t9.callee)), n9;
    };
    if (!Object.keys) {
      n9 = Object.prototype.hasOwnProperty, o9 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a7 = l7.call(function() {
      }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t9) {
        var e10 = t9.constructor;
        return e10 && e10.prototype === t9;
      }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
        if ("undefined" == typeof window)
          return false;
        for (var t9 in window)
          try {
            if (!p7["$" + t9] && n9.call(window, t9) && null !== window[t9] && "object" == typeof window[t9])
              try {
                f7(window[t9]);
              } catch (t10) {
                return true;
              }
          } catch (t10) {
            return true;
          }
        return false;
      }();
      t6 = function(t9) {
        var e10 = null !== t9 && "object" == typeof t9, r10 = "[object Function]" === o9.call(t9), l8 = c7(t9), p8 = e10 && "[object String]" === o9.call(t9), y6 = [];
        if (!e10 && !r10 && !l8)
          throw new TypeError("Object.keys called on a non-object");
        var b5 = a7 && r10;
        if (p8 && t9.length > 0 && !n9.call(t9, 0))
          for (var g5 = 0; g5 < t9.length; ++g5)
            y6.push(String(g5));
        if (l8 && t9.length > 0)
          for (var h8 = 0; h8 < t9.length; ++h8)
            y6.push(String(h8));
        else
          for (var $3 in t9)
            b5 && "prototype" === $3 || !n9.call(t9, $3) || y6.push(String($3));
        if (i7)
          for (var j4 = function(t10) {
            if ("undefined" == typeof window || !s6)
              return f7(t10);
            try {
              return f7(t10);
            } catch (t11) {
              return false;
            }
          }(t9), w4 = 0; w4 < u7.length; ++w4)
            j4 && "constructor" === u7[w4] || !n9.call(t9, u7[w4]) || y6.push(u7[w4]);
        return y6;
      };
    }
    y4 = t6;
    b3 = Array.prototype.slice;
    g3 = r$12;
    h5 = Object.keys;
    $2 = h5 ? function(t9) {
      return h5(t9);
    } : y4;
    j3 = Object.keys;
    $2.shim = function() {
      Object.keys ? function() {
        var t9 = Object.keys(arguments);
        return t9 && t9.length === arguments.length;
      }(1, 2) || (Object.keys = function(t9) {
        return g3(t9) ? j3(b3.call(t9)) : j3(t9);
      }) : Object.keys = $2;
      return Object.keys || $2;
    };
    w3 = $2;
    r$2 = w3;
    e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
    o$13 = Object.prototype.toString;
    n$13 = Array.prototype.concat;
    a$1 = Object.defineProperty;
    c$13 = a$1 && function() {
      var t9 = {};
      try {
        for (var r10 in a$1(t9, "x", { enumerable: false, value: t9 }), t9)
          return false;
        return t9.x === t9;
      } catch (t10) {
        return false;
      }
    }();
    l$13 = function(t9, r10, e10, n9) {
      var l7;
      (!(r10 in t9) || "function" == typeof (l7 = n9) && "[object Function]" === o$13.call(l7) && n9()) && (c$13 ? a$1(t9, r10, { configurable: true, enumerable: false, value: e10, writable: true }) : t9[r10] = e10);
    };
    u$13 = function(t9, o9) {
      var a7 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o9);
      e$2 && (c7 = n$13.call(c7, Object.getOwnPropertySymbols(o9)));
      for (var u7 = 0; u7 < c7.length; u7 += 1)
        l$13(t9, c7[u7], o9[c7[u7]], a7[c7[u7]]);
    };
    u$13.supportsDescriptors = !!c$13;
    f$12 = u$13;
    t$12 = function() {
      if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
        return false;
      if ("symbol" == typeof Symbol.iterator)
        return true;
      var t9 = {}, e10 = Symbol("test"), r10 = Object(e10);
      if ("string" == typeof e10)
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(e10))
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(r10))
        return false;
      for (e10 in t9[e10] = 42, t9)
        return false;
      if ("function" == typeof Object.keys && 0 !== Object.keys(t9).length)
        return false;
      if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t9).length)
        return false;
      var o9 = Object.getOwnPropertySymbols(t9);
      if (1 !== o9.length || o9[0] !== e10)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(t9, e10))
        return false;
      if ("function" == typeof Object.getOwnPropertyDescriptor) {
        var n9 = Object.getOwnPropertyDescriptor(t9, e10);
        if (42 !== n9.value || true !== n9.enumerable)
          return false;
      }
      return true;
    };
    f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
    e$3 = t$12;
    l$2 = function() {
      return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
    };
    t$22 = "Function.prototype.bind called on incompatible ";
    n$2 = Array.prototype.slice;
    o$22 = Object.prototype.toString;
    r$3 = function(r10) {
      var e10 = this;
      if ("function" != typeof e10 || "[object Function]" !== o$22.call(e10))
        throw new TypeError(t$22 + e10);
      for (var p7, i7 = n$2.call(arguments, 1), c7 = function() {
        if (this instanceof p7) {
          var t9 = e10.apply(this, i7.concat(n$2.call(arguments)));
          return Object(t9) === t9 ? t9 : this;
        }
        return e10.apply(r10, i7.concat(n$2.call(arguments)));
      }, a7 = Math.max(0, e10.length - i7.length), l7 = [], u7 = 0; u7 < a7; u7++)
        l7.push("$" + u7);
      if (p7 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c7), e10.prototype) {
        var y6 = function() {
        };
        y6.prototype = e10.prototype, p7.prototype = new y6(), y6.prototype = null;
      }
      return p7;
    };
    e$4 = Function.prototype.bind || r$3;
    o$3 = TypeError;
    t$3 = Object.getOwnPropertyDescriptor;
    if (t$3)
      try {
        t$3({}, "");
      } catch (r10) {
        t$3 = null;
      }
    n$3 = function() {
      throw new o$3();
    };
    y$1 = t$3 ? function() {
      try {
        return arguments.callee, n$3;
      } catch (r10) {
        try {
          return t$3(arguments, "callee").get;
        } catch (r11) {
          return n$3;
        }
      }
    }() : n$3;
    a$22 = l$2();
    i$13 = Object.getPrototypeOf || function(r10) {
      return r10.__proto__;
    };
    d4 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
    f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d4, "%TypedArrayPrototype%": d4 ? d4.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
    u$22 = e$4.call(Function.call, String.prototype.replace);
    A3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    l$3 = /\\(\\)?/g;
    v5 = function(r10) {
      var e10 = [];
      return u$22(r10, A3, function(r11, o9, t9, n9) {
        e10[e10.length] = t9 ? u$22(n9, l$3, "$1") : o9 || r11;
      }), e10;
    };
    P3 = function(r10, e10) {
      if (!(r10 in f$3))
        throw new SyntaxError("intrinsic " + r10 + " does not exist!");
      if (void 0 === f$3[r10] && !e10)
        throw new o$3("intrinsic " + r10 + " exists, but is not available. Please file an issue!");
      return f$3[r10];
    };
    c$2 = function(r10, e10) {
      if ("string" != typeof r10 || 0 === r10.length)
        throw new TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && "boolean" != typeof e10)
        throw new TypeError('"allowMissing" argument must be a boolean');
      for (var n9 = v5(r10), y6 = P3("%" + (n9.length > 0 ? n9[0] : "") + "%", e10), a7 = 1; a7 < n9.length; a7 += 1)
        if (null != y6)
          if (t$3 && a7 + 1 >= n9.length) {
            var i7 = t$3(y6, n9[a7]);
            if (!e10 && !(n9[a7] in y6))
              throw new o$3("base intrinsic for " + r10 + " exists, but the property is not available.");
            y6 = i7 ? i7.get || i7.value : y6[n9[a7]];
          } else
            y6 = y6[n9[a7]];
      return y6;
    };
    p$1 = e$4;
    o$4 = c$2("%Function%");
    i$2 = o$4.apply;
    a$3 = o$4.call;
    (t$4 = function() {
      return p$1.apply(a$3, arguments);
    }).apply = function() {
      return p$1.apply(i$2, arguments);
    };
    l$4 = t$4;
    i$3 = function(t9) {
      return t9 != t9;
    };
    o$5 = (r$4 = function(t9, e10) {
      return 0 === t9 && 0 === e10 ? 1 / t9 == 1 / e10 : t9 === e10 || !(!i$3(t9) || !i$3(e10));
    }, r$4);
    c$3 = (n$4 = function() {
      return "function" == typeof Object.is ? Object.is : o$5;
    }, n$4);
    f$4 = f$12;
    u$3 = f$12;
    s$12 = r$4;
    a$4 = n$4;
    l$5 = function() {
      var t9 = c$3();
      return f$4(Object, { is: t9 }, { is: function() {
        return Object.is !== t9;
      } }), t9;
    };
    p$2 = l$4(a$4(), Object);
    u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
    m4 = p$2;
    N3 = function(r10) {
      return r10 != r10;
    };
    i$4 = N3;
    n$5 = (e$5 = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
    }, f$12);
    t$5 = e$5;
    u$4 = f$12;
    a$5 = N3;
    m$1 = e$5;
    o$6 = function() {
      var r10 = t$5();
      return n$5(Number, { isNaN: r10 }, { isNaN: function() {
        return Number.isNaN !== r10;
      } }), r10;
    };
    s$2 = m$1();
    u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
    f$5 = s$2;
    c$4 = {};
    a$6 = false;
    u$5 = {};
    l$6 = false;
    g$1 = void 0 !== /a/g.flags;
    h$1 = function(t9) {
      var e10 = [];
      return t9.forEach(function(t10) {
        return e10.push(t10);
      }), e10;
    };
    y$2 = function(t9) {
      var e10 = [];
      return t9.forEach(function(t10, n9) {
        return e10.push([n9, t10]);
      }), e10;
    };
    b$1 = Object.is ? Object.is : m4;
    v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    d$1 = Number.isNaN ? Number.isNaN : f$5;
    E3 = m$2(Object.prototype.hasOwnProperty);
    w$1 = m$2(Object.prototype.propertyIsEnumerable);
    S3 = m$2(Object.prototype.toString);
    j$1 = X.types;
    O3 = j$1.isAnyArrayBuffer;
    x3 = j$1.isArrayBufferView;
    q2 = j$1.isDate;
    R3 = j$1.isMap;
    A$1 = j$1.isRegExp;
    k3 = j$1.isSet;
    _3 = j$1.isNativeError;
    T4 = j$1.isBoxedPrimitive;
    P$1 = j$1.isNumberObject;
    I3 = j$1.isStringObject;
    D3 = j$1.isBooleanObject;
    F3 = j$1.isBigIntObject;
    N$1 = j$1.isSymbolObject;
    L3 = j$1.isFloat32Array;
    M3 = j$1.isFloat64Array;
    X2 = { isDeepEqual: function(t9, e10) {
      return B3(t9, e10, false);
    }, isDeepStrictEqual: function(t9, e10) {
      return B3(t9, e10, true);
    } };
    Z2 = {};
    $$1 = false;
    et = tt();
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    AssertionError = et.AssertionError;
    deepEqual = et.deepEqual;
    deepStrictEqual = et.deepStrictEqual;
    doesNotReject = et.doesNotReject;
    doesNotThrow = et.doesNotThrow;
    equal = et.equal;
    fail = et.fail;
    ifError = et.ifError;
    notDeepEqual = et.notDeepEqual;
    notDeepStrictEqual = et.notDeepStrictEqual;
    notEqual = et.notEqual;
    notStrictEqual = et.notStrictEqual;
    ok = et.ok;
    rejects = et.rejects;
    strict = et.strict;
    strictEqual = et.strictEqual;
    throws = et.throws;
  }
});

// node_modules/@jspm/core/nodelibs/browser/util.js
var util_exports = {};
__export(util_exports, {
  TextDecoder: () => TextDecoder3,
  TextEncoder: () => TextEncoder2,
  _extend: () => _extend2,
  callbackify: () => callbackify2,
  debuglog: () => debuglog2,
  default: () => X,
  deprecate: () => deprecate2,
  format: () => format3,
  inherits: () => inherits3,
  inspect: () => inspect2,
  isArray: () => isArray3,
  isBoolean: () => isBoolean3,
  isBuffer: () => isBuffer3,
  isDate: () => isDate3,
  isError: () => isError2,
  isFunction: () => isFunction3,
  isNull: () => isNull2,
  isNullOrUndefined: () => isNullOrUndefined2,
  isNumber: () => isNumber3,
  isObject: () => isObject3,
  isPrimitive: () => isPrimitive2,
  isRegExp: () => isRegExp3,
  isString: () => isString4,
  isSymbol: () => isSymbol2,
  isUndefined: () => isUndefined3,
  log: () => log2,
  promisify: () => promisify2,
  types: () => types2
});
var _extend2, callbackify2, debuglog2, deprecate2, format3, inherits3, inspect2, isArray3, isBoolean3, isBuffer3, isDate3, isError2, isFunction3, isNull2, isNullOrUndefined2, isNumber3, isObject3, isPrimitive2, isRegExp3, isString4, isSymbol2, isUndefined3, log2, promisify2, types2, TextEncoder2, TextDecoder3;
var init_util = __esm({
  "node_modules/@jspm/core/nodelibs/browser/util.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    _extend2 = X._extend;
    callbackify2 = X.callbackify;
    debuglog2 = X.debuglog;
    deprecate2 = X.deprecate;
    format3 = X.format;
    inherits3 = X.inherits;
    inspect2 = X.inspect;
    isArray3 = X.isArray;
    isBoolean3 = X.isBoolean;
    isBuffer3 = X.isBuffer;
    isDate3 = X.isDate;
    isError2 = X.isError;
    isFunction3 = X.isFunction;
    isNull2 = X.isNull;
    isNullOrUndefined2 = X.isNullOrUndefined;
    isNumber3 = X.isNumber;
    isObject3 = X.isObject;
    isPrimitive2 = X.isPrimitive;
    isRegExp3 = X.isRegExp;
    isString4 = X.isString;
    isSymbol2 = X.isSymbol;
    isUndefined3 = X.isUndefined;
    log2 = X.log;
    promisify2 = X.promisify;
    types2 = X.types;
    TextEncoder2 = X.TextEncoder = globalThis.TextEncoder;
    TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
function dew6() {
  if (_dewExec6)
    return exports$15;
  _dewExec6 = true;
  exports$15 = Stream2;
  var EE = y.EventEmitter;
  var inherits4 = dew$f();
  inherits4(Stream2, EE);
  Stream2.Readable = dew$3();
  Stream2.Writable = dew$8();
  Stream2.Duplex = dew$7();
  Stream2.Transform = dew$22();
  Stream2.PassThrough = dew$12();
  Stream2.finished = dew$6();
  Stream2.pipeline = dew5();
  Stream2.Stream = Stream2;
  function Stream2() {
    EE.call(this || _global4);
  }
  Stream2.prototype.pipe = function(dest, options) {
    var source = this || _global4;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global4, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$15;
}
var exports$15, _dewExec6, _global4, exports6;
var init_chunk_6c718bbe = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_events();
    init_chunk_44e51b61();
    init_chunk_4bd36a8f();
    exports$15 = {};
    _dewExec6 = false;
    _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports6 = dew6();
  }
});

// node_modules/@jspm/core/nodelibs/browser/stream.js
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => exports6,
  finished: () => finished,
  pipeline: () => pipeline,
  promises: () => promises
});
var Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
var init_stream = __esm({
  "node_modules/@jspm/core/nodelibs/browser/stream.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_6c718bbe();
    init_chunk_6c718bbe();
    init_util();
    init_events();
    init_chunk_4bd36a8f();
    init_chunk_44e51b61();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_2eac56ff();
    init_chunk_4ccc3a29();
    Readable = exports6.Readable;
    Readable.wrap = function(src, options) {
      options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
      options.destroy = function(err, callback) {
        src.destroy(err);
        callback(err);
      };
      return new Readable(options).wrap(src);
    };
    Writable = exports6.Writable;
    Duplex = exports6.Duplex;
    Transform = exports6.Transform;
    PassThrough = exports6.PassThrough;
    finished = exports6.finished;
    pipeline = exports6.pipeline;
    Stream = exports6.Stream;
    promises = {
      finished: promisify2(exports6.finished),
      pipeline: promisify2(exports6.pipeline)
    };
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
function i5(t9) {
  throw new RangeError(r7[t9]);
}
function f5(t9, o9) {
  const n9 = t9.split("@");
  let r10 = "";
  n9.length > 1 && (r10 = n9[0] + "@", t9 = n9[1]);
  const c7 = function(t10, o10) {
    const n10 = [];
    let e10 = t10.length;
    for (; e10--; )
      n10[e10] = o10(t10[e10]);
    return n10;
  }((t9 = t9.replace(e7, ".")).split("."), o9).join(".");
  return r10 + c7;
}
function l5(t9) {
  const o9 = [];
  let n9 = 0;
  const e10 = t9.length;
  for (; n9 < e10; ) {
    const r10 = t9.charCodeAt(n9++);
    if (r10 >= 55296 && r10 <= 56319 && n9 < e10) {
      const e11 = t9.charCodeAt(n9++);
      56320 == (64512 & e11) ? o9.push(((1023 & r10) << 10) + (1023 & e11) + 65536) : (o9.push(r10), n9--);
    } else
      o9.push(r10);
  }
  return o9;
}
var t7, o6, n6, e7, r7, c5, s5, u5, a5, d5, h6, p5;
var init_chunk_924bb2e1 = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    t7 = 2147483647;
    o6 = /^xn--/;
    n6 = /[^\0-\x7E]/;
    e7 = /[\x2E\u3002\uFF0E\uFF61]/g;
    r7 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
    c5 = Math.floor;
    s5 = String.fromCharCode;
    u5 = function(t9, o9) {
      return t9 + 22 + 75 * (t9 < 26) - ((0 != o9) << 5);
    };
    a5 = function(t9, o9, n9) {
      let e10 = 0;
      for (t9 = n9 ? c5(t9 / 700) : t9 >> 1, t9 += c5(t9 / o9); t9 > 455; e10 += 36)
        t9 = c5(t9 / 35);
      return c5(e10 + 36 * t9 / (t9 + 38));
    };
    d5 = function(o9) {
      const n9 = [], e10 = o9.length;
      let r10 = 0, s6 = 128, f7 = 72, l7 = o9.lastIndexOf("-");
      l7 < 0 && (l7 = 0);
      for (let t9 = 0; t9 < l7; ++t9)
        o9.charCodeAt(t9) >= 128 && i5("not-basic"), n9.push(o9.charCodeAt(t9));
      for (let d6 = l7 > 0 ? l7 + 1 : 0; d6 < e10; ) {
        let l8 = r10;
        for (let n10 = 1, s7 = 36; ; s7 += 36) {
          d6 >= e10 && i5("invalid-input");
          const l9 = (u7 = o9.charCodeAt(d6++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
          (l9 >= 36 || l9 > c5((t7 - r10) / n10)) && i5("overflow"), r10 += l9 * n10;
          const a7 = s7 <= f7 ? 1 : s7 >= f7 + 26 ? 26 : s7 - f7;
          if (l9 < a7)
            break;
          const h9 = 36 - a7;
          n10 > c5(t7 / h9) && i5("overflow"), n10 *= h9;
        }
        const h8 = n9.length + 1;
        f7 = a5(r10 - l8, h8, 0 == l8), c5(r10 / h8) > t7 - s6 && i5("overflow"), s6 += c5(r10 / h8), r10 %= h8, n9.splice(r10++, 0, s6);
      }
      var u7;
      return String.fromCodePoint(...n9);
    };
    h6 = function(o9) {
      const n9 = [];
      let e10 = (o9 = l5(o9)).length, r10 = 128, f7 = 0, d6 = 72;
      for (const t9 of o9)
        t9 < 128 && n9.push(s5(t9));
      let h8 = n9.length, p7 = h8;
      for (h8 && n9.push("-"); p7 < e10; ) {
        let e11 = t7;
        for (const t9 of o9)
          t9 >= r10 && t9 < e11 && (e11 = t9);
        const l7 = p7 + 1;
        e11 - r10 > c5((t7 - f7) / l7) && i5("overflow"), f7 += (e11 - r10) * l7, r10 = e11;
        for (const e12 of o9)
          if (e12 < r10 && ++f7 > t7 && i5("overflow"), e12 == r10) {
            let t9 = f7;
            for (let o10 = 36; ; o10 += 36) {
              const e13 = o10 <= d6 ? 1 : o10 >= d6 + 26 ? 26 : o10 - d6;
              if (t9 < e13)
                break;
              const r11 = t9 - e13, i7 = 36 - e13;
              n9.push(s5(u5(e13 + r11 % i7, 0))), t9 = c5(r11 / i7);
            }
            n9.push(s5(u5(t9, 0))), d6 = a5(f7, l7, p7 == h8), f7 = 0, ++p7;
          }
        ++f7, ++r10;
      }
      return n9.join("");
    };
    p5 = { version: "2.1.0", ucs2: { decode: l5, encode: (t9) => String.fromCodePoint(...t9) }, decode: d5, encode: h6, toASCII: function(t9) {
      return f5(t9, function(t10) {
        return n6.test(t10) ? "xn--" + h6(t10) : t10;
      });
    }, toUnicode: function(t9) {
      return f5(t9, function(t10) {
        return o6.test(t10) ? d5(t10.slice(4).toLowerCase()) : t10;
      });
    } };
    p5.decode;
    p5.encode;
    p5.toASCII;
    p5.toUnicode;
    p5.ucs2;
    p5.version;
  }
});

// node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
function e8(e10, n9) {
  return Object.prototype.hasOwnProperty.call(e10, n9);
}
var n7, r8, t8, o7;
var init_chunk_b04e620d = __esm({
  "node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    n7 = function(n9, r10, t9, o9) {
      r10 = r10 || "&", t9 = t9 || "=";
      var a7 = {};
      if ("string" != typeof n9 || 0 === n9.length)
        return a7;
      var u7 = /\+/g;
      n9 = n9.split(r10);
      var c7 = 1e3;
      o9 && "number" == typeof o9.maxKeys && (c7 = o9.maxKeys);
      var i7 = n9.length;
      c7 > 0 && i7 > c7 && (i7 = c7);
      for (var s6 = 0; s6 < i7; ++s6) {
        var p7, f7, d6, y6, m6 = n9[s6].replace(u7, "%20"), l7 = m6.indexOf(t9);
        l7 >= 0 ? (p7 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p7 = m6, f7 = ""), d6 = decodeURIComponent(p7), y6 = decodeURIComponent(f7), e8(a7, d6) ? Array.isArray(a7[d6]) ? a7[d6].push(y6) : a7[d6] = [a7[d6], y6] : a7[d6] = y6;
      }
      return a7;
    };
    r8 = function(e10) {
      switch (typeof e10) {
        case "string":
          return e10;
        case "boolean":
          return e10 ? "true" : "false";
        case "number":
          return isFinite(e10) ? e10 : "";
        default:
          return "";
      }
    };
    t8 = function(e10, n9, t9, o9) {
      return n9 = n9 || "&", t9 = t9 || "=", null === e10 && (e10 = void 0), "object" == typeof e10 ? Object.keys(e10).map(function(o10) {
        var a7 = encodeURIComponent(r8(o10)) + t9;
        return Array.isArray(e10[o10]) ? e10[o10].map(function(e11) {
          return a7 + encodeURIComponent(r8(e11));
        }).join(n9) : a7 + encodeURIComponent(r8(e10[o10]));
      }).join(n9) : o9 ? encodeURIComponent(r8(o9)) + t9 + encodeURIComponent(r8(e10)) : "";
    };
    o7 = {};
    o7.decode = o7.parse = n7, o7.encode = o7.stringify = t8;
    o7.decode;
    o7.encode;
    o7.parse;
    o7.stringify;
  }
});

// node_modules/@jspm/core/nodelibs/browser/url.js
function r9() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O4(t9, s6, h8) {
  if (t9 && a6.isObject(t9) && t9 instanceof r9)
    return t9;
  var e10 = new r9();
  return e10.parse(t9, s6, h8), e10;
}
function dew7() {
  if (_dewExec7)
    return exports7;
  _dewExec7 = true;
  var process3 = T;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve4() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd2 === void 0)
            cwd2 = process3.cwd();
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute2)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = "";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports7 = posix2;
  return exports7;
}
function fileURLToPath$1(path2) {
  if (typeof path2 === "string")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
}
function getPathFromURLWin$1(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n9 = 0; n9 < pathname.length; n9++) {
    if (pathname[n9] === "%") {
      const third = pathname.codePointAt(n9 + 2) || 32;
      if (pathname[n9 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n9 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n9 = 0; n9 < pathname.length; n9++) {
    if (pathname[n9] === "%") {
      const third = pathname.codePointAt(n9 + 2) || 32;
      if (pathname[n9 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$1, "%25");
  if (!isWindows$1 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$1, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$1, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function fileURLToPath(path2) {
  if (typeof path2 === "string")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
}
function getPathFromURLWin(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n9 = 0; n9 < pathname.length; n9++) {
    if (pathname[n9] === "%") {
      const third = pathname.codePointAt(n9 + 2) || 32;
      if (pathname[n9 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n9 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n9 = 0; n9 < pathname.length; n9++) {
    if (pathname[n9] === "%") {
      const third = pathname.codePointAt(n9 + 2) || 32;
      if (pathname[n9 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports3.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports3.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var h7, e9, a6, o8, n8, i6, l6, p6, c6, u6, f6, m5, v6, g4, y5, b4, exports7, _dewExec7, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
var init_url = __esm({
  "node_modules/@jspm/core/nodelibs/browser/url.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_5decc758();
    init_chunk_23dbec7b();
    init_chunk_2eac56ff();
    h7 = {};
    e9 = p5;
    a6 = { isString: function(t9) {
      return "string" == typeof t9;
    }, isObject: function(t9) {
      return "object" == typeof t9 && null !== t9;
    }, isNull: function(t9) {
      return null === t9;
    }, isNullOrUndefined: function(t9) {
      return null == t9;
    } };
    h7.parse = O4, h7.resolve = function(t9, s6) {
      return O4(t9, false, true).resolve(s6);
    }, h7.resolveObject = function(t9, s6) {
      return t9 ? O4(t9, false, true).resolveObject(s6) : s6;
    }, h7.format = function(t9) {
      a6.isString(t9) && (t9 = O4(t9));
      return t9 instanceof r9 ? t9.format() : r9.prototype.format.call(t9);
    }, h7.Url = r9;
    o8 = /^([a-z0-9.+-]+:)/i;
    n8 = /:[0-9]*$/;
    i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
    p6 = ["'"].concat(l6);
    c6 = ["%", "/", "?", ";", "#"].concat(p6);
    u6 = ["/", "?", "#"];
    f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
    m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    v6 = { javascript: true, "javascript:": true };
    g4 = { javascript: true, "javascript:": true };
    y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    b4 = o7;
    r9.prototype.parse = function(t9, s6, h8) {
      if (!a6.isString(t9))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t9);
      var r10 = t9.indexOf("?"), n9 = -1 !== r10 && r10 < t9.indexOf("#") ? "?" : "#", l7 = t9.split(n9);
      l7[0] = l7[0].replace(/\\/g, "/");
      var O5 = t9 = l7.join(n9);
      if (O5 = O5.trim(), !h8 && 1 === t9.split("#").length) {
        var d6 = i6.exec(O5);
        if (d6)
          return this.path = O5, this.href = O5, this.pathname = d6[1], d6[2] ? (this.search = d6[2], this.query = s6 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s6 && (this.search = "", this.query = {}), this;
      }
      var j4 = o8.exec(O5);
      if (j4) {
        var q3 = (j4 = j4[0]).toLowerCase();
        this.protocol = q3, O5 = O5.substr(j4.length);
      }
      if (h8 || j4 || O5.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var x4 = "//" === O5.substr(0, 2);
        !x4 || j4 && g4[j4] || (O5 = O5.substr(2), this.slashes = true);
      }
      if (!g4[j4] && (x4 || j4 && !y5[j4])) {
        for (var A4, C4, I4 = -1, w4 = 0; w4 < u6.length; w4++) {
          -1 !== (N4 = O5.indexOf(u6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
        }
        -1 !== (C4 = -1 === I4 ? O5.lastIndexOf("@") : O5.lastIndexOf("@", I4)) && (A4 = O5.slice(0, C4), O5 = O5.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
        for (w4 = 0; w4 < c6.length; w4++) {
          var N4;
          -1 !== (N4 = O5.indexOf(c6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
        }
        -1 === I4 && (I4 = O5.length), this.host = O5.slice(0, I4), O5 = O5.slice(I4), this.parseHost(), this.hostname = this.hostname || "";
        var U4 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!U4)
          for (var k4 = this.hostname.split(/\./), S4 = (w4 = 0, k4.length); w4 < S4; w4++) {
            var R4 = k4[w4];
            if (R4 && !R4.match(f6)) {
              for (var $3 = "", z4 = 0, H3 = R4.length; z4 < H3; z4++)
                R4.charCodeAt(z4) > 127 ? $3 += "x" : $3 += R4[z4];
              if (!$3.match(f6)) {
                var L4 = k4.slice(0, w4), Z3 = k4.slice(w4 + 1), _4 = R4.match(m5);
                _4 && (L4.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O5 = "/" + Z3.join(".") + O5), this.hostname = L4.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U4 || (this.hostname = e9.toASCII(this.hostname));
        var E4 = this.port ? ":" + this.port : "", P4 = this.hostname || "";
        this.host = P4 + E4, this.href += this.host, U4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O5[0] && (O5 = "/" + O5));
      }
      if (!v6[q3])
        for (w4 = 0, S4 = p6.length; w4 < S4; w4++) {
          var T5 = p6[w4];
          if (-1 !== O5.indexOf(T5)) {
            var B4 = encodeURIComponent(T5);
            B4 === T5 && (B4 = escape(T5)), O5 = O5.split(T5).join(B4);
          }
        }
      var D4 = O5.indexOf("#");
      -1 !== D4 && (this.hash = O5.substr(D4), O5 = O5.slice(0, D4));
      var F4 = O5.indexOf("?");
      if (-1 !== F4 ? (this.search = O5.substr(F4), this.query = O5.substr(F4 + 1), s6 && (this.query = b4.parse(this.query)), O5 = O5.slice(0, F4)) : s6 && (this.search = "", this.query = {}), O5 && (this.pathname = O5), y5[q3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        E4 = this.pathname || "";
        var G3 = this.search || "";
        this.path = E4 + G3;
      }
      return this.href = this.format(), this;
    }, r9.prototype.format = function() {
      var t9 = this.auth || "";
      t9 && (t9 = (t9 = encodeURIComponent(t9)).replace(/%3A/i, ":"), t9 += "@");
      var s6 = this.protocol || "", h8 = this.pathname || "", e10 = this.hash || "", r10 = false, o9 = "";
      this.host ? r10 = t9 + this.host : this.hostname && (r10 = t9 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r10 += ":" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o9 = b4.stringify(this.query));
      var n9 = this.search || o9 && "?" + o9 || "";
      return s6 && ":" !== s6.substr(-1) && (s6 += ":"), this.slashes || (!s6 || y5[s6]) && false !== r10 ? (r10 = "//" + (r10 || ""), h8 && "/" !== h8.charAt(0) && (h8 = "/" + h8)) : r10 || (r10 = ""), e10 && "#" !== e10.charAt(0) && (e10 = "#" + e10), n9 && "?" !== n9.charAt(0) && (n9 = "?" + n9), s6 + r10 + (h8 = h8.replace(/[?#]/g, function(t10) {
        return encodeURIComponent(t10);
      })) + (n9 = n9.replace("#", "%23")) + e10;
    }, r9.prototype.resolve = function(t9) {
      return this.resolveObject(O4(t9, false, true)).format();
    }, r9.prototype.resolveObject = function(t9) {
      if (a6.isString(t9)) {
        var s6 = new r9();
        s6.parse(t9, false, true), t9 = s6;
      }
      for (var h8 = new r9(), e10 = Object.keys(this), o9 = 0; o9 < e10.length; o9++) {
        var n9 = e10[o9];
        h8[n9] = this[n9];
      }
      if (h8.hash = t9.hash, "" === t9.href)
        return h8.href = h8.format(), h8;
      if (t9.slashes && !t9.protocol) {
        for (var i7 = Object.keys(t9), l7 = 0; l7 < i7.length; l7++) {
          var p7 = i7[l7];
          "protocol" !== p7 && (h8[p7] = t9[p7]);
        }
        return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = "/"), h8.href = h8.format(), h8;
      }
      if (t9.protocol && t9.protocol !== h8.protocol) {
        if (!y5[t9.protocol]) {
          for (var c7 = Object.keys(t9), u7 = 0; u7 < c7.length; u7++) {
            var f7 = c7[u7];
            h8[f7] = t9[f7];
          }
          return h8.href = h8.format(), h8;
        }
        if (h8.protocol = t9.protocol, t9.host || g4[t9.protocol])
          h8.pathname = t9.pathname;
        else {
          for (var m6 = (t9.pathname || "").split("/"); m6.length && !(t9.host = m6.shift()); )
            ;
          t9.host || (t9.host = ""), t9.hostname || (t9.hostname = ""), "" !== m6[0] && m6.unshift(""), m6.length < 2 && m6.unshift(""), h8.pathname = m6.join("/");
        }
        if (h8.search = t9.search, h8.query = t9.query, h8.host = t9.host || "", h8.auth = t9.auth, h8.hostname = t9.hostname || t9.host, h8.port = t9.port, h8.pathname || h8.search) {
          var v7 = h8.pathname || "", b5 = h8.search || "";
          h8.path = v7 + b5;
        }
        return h8.slashes = h8.slashes || t9.slashes, h8.href = h8.format(), h8;
      }
      var O5 = h8.pathname && "/" === h8.pathname.charAt(0), d6 = t9.host || t9.pathname && "/" === t9.pathname.charAt(0), j4 = d6 || O5 || h8.host && t9.pathname, q3 = j4, x4 = h8.pathname && h8.pathname.split("/") || [], A4 = (m6 = t9.pathname && t9.pathname.split("/") || [], h8.protocol && !y5[h8.protocol]);
      if (A4 && (h8.hostname = "", h8.port = null, h8.host && ("" === x4[0] ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = "", t9.protocol && (t9.hostname = null, t9.port = null, t9.host && ("" === m6[0] ? m6[0] = t9.host : m6.unshift(t9.host)), t9.host = null), j4 = j4 && ("" === m6[0] || "" === x4[0])), d6)
        h8.host = t9.host || "" === t9.host ? t9.host : h8.host, h8.hostname = t9.hostname || "" === t9.hostname ? t9.hostname : h8.hostname, h8.search = t9.search, h8.query = t9.query, x4 = m6;
      else if (m6.length)
        x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t9.search, h8.query = t9.query;
      else if (!a6.isNullOrUndefined(t9.search)) {
        if (A4)
          h8.hostname = h8.host = x4.shift(), (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift());
        return h8.search = t9.search, h8.query = t9.query, a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.href = h8.format(), h8;
      }
      if (!x4.length)
        return h8.pathname = null, h8.search ? h8.path = "/" + h8.search : h8.path = null, h8.href = h8.format(), h8;
      for (var C4 = x4.slice(-1)[0], I4 = (h8.host || t9.host || x4.length > 1) && ("." === C4 || ".." === C4) || "" === C4, w4 = 0, N4 = x4.length; N4 >= 0; N4--)
        "." === (C4 = x4[N4]) ? x4.splice(N4, 1) : ".." === C4 ? (x4.splice(N4, 1), w4++) : w4 && (x4.splice(N4, 1), w4--);
      if (!j4 && !q3)
        for (; w4--; w4)
          x4.unshift("..");
      !j4 || "" === x4[0] || x4[0] && "/" === x4[0].charAt(0) || x4.unshift(""), I4 && "/" !== x4.join("/").substr(-1) && x4.push("");
      var U4, k4 = "" === x4[0] || x4[0] && "/" === x4[0].charAt(0);
      A4 && (h8.hostname = h8.host = k4 ? "" : x4.length ? x4.shift() : "", (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift()));
      return (j4 = j4 || h8.host && x4.length) && !k4 && x4.unshift(""), x4.length ? h8.pathname = x4.join("/") : (h8.pathname = null, h8.path = null), a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.auth = t9.auth || h8.auth, h8.slashes = h8.slashes || t9.slashes, h8.href = h8.format(), h8;
    }, r9.prototype.parseHost = function() {
      var t9 = this.host, s6 = n8.exec(t9);
      s6 && (":" !== (s6 = s6[0]) && (this.port = s6.substr(1)), t9 = t9.substr(0, t9.length - s6.length)), t9 && (this.hostname = t9);
    };
    h7.Url;
    h7.format;
    h7.resolve;
    h7.resolveObject;
    exports7 = {};
    _dewExec7 = false;
    path = dew7();
    processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h7.URL = typeof URL !== "undefined" ? URL : null;
    h7.pathToFileURL = pathToFileURL$1;
    h7.fileURLToPath = fileURLToPath$1;
    h7.Url;
    h7.format;
    h7.resolve;
    h7.resolveObject;
    h7.URL;
    CHAR_BACKWARD_SLASH$1 = 92;
    CHAR_FORWARD_SLASH$1 = 47;
    CHAR_LOWERCASE_A$1 = 97;
    CHAR_LOWERCASE_Z$1 = 122;
    isWindows$1 = processPlatform$1 === "win32";
    forwardSlashRegEx$1 = /\//g;
    percentRegEx$1 = /%/g;
    backslashRegEx$1 = /\\/g;
    newlineRegEx$1 = /\n/g;
    carriageReturnRegEx$1 = /\r/g;
    tabRegEx$1 = /\t/g;
    processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h7.URL = typeof URL !== "undefined" ? URL : null;
    h7.pathToFileURL = pathToFileURL;
    h7.fileURLToPath = fileURLToPath;
    h7.Url;
    h7.format;
    h7.resolve;
    h7.resolveObject;
    h7.parse;
    h7.URL;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_FORWARD_SLASH = 47;
    CHAR_LOWERCASE_A = 97;
    CHAR_LOWERCASE_Z = 122;
    isWindows = processPlatform === "win32";
    forwardSlashRegEx = /\//g;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
  }
});

// node_modules/@jspm/core/nodelibs/browser/fs.js
var fs_exports = {};
__export(fs_exports, {
  Dir: () => Dir,
  Dirent: () => Dirent,
  F_OK: () => F_OK,
  FileReadStream: () => FileReadStream,
  FileWriteStream: () => FileWriteStream,
  R_OK: () => R_OK,
  ReadStream: () => ReadStream,
  Stats: () => Stats,
  W_OK: () => W_OK,
  WriteStream: () => WriteStream,
  X_OK: () => X_OK,
  _toUnixTimestamp: () => _toUnixTimestamp,
  access: () => access,
  accessSync: () => accessSync,
  appendFile: () => appendFile,
  appendFileSync: () => appendFileSync,
  chmod: () => chmod,
  chmodSync: () => chmodSync,
  chown: () => chown,
  chownSync: () => chownSync,
  close: () => close,
  closeSync: () => closeSync,
  constants: () => constants2,
  copyFile: () => copyFile,
  copyFileSync: () => copyFileSync,
  cp: () => cp,
  cpSync: () => cpSync,
  createReadStream: () => createReadStream,
  createWriteStream: () => createWriteStream,
  default: () => fs,
  exists: () => exists,
  existsSync: () => existsSync,
  fchmod: () => fchmod,
  fchmodSync: () => fchmodSync,
  fchown: () => fchown,
  fchownSync: () => fchownSync,
  fdatasync: () => fdatasync,
  fdatasyncSync: () => fdatasyncSync,
  fstat: () => fstat,
  fstatSync: () => fstatSync,
  fsync: () => fsync,
  fsyncSync: () => fsyncSync,
  ftruncate: () => ftruncate,
  ftruncateSync: () => ftruncateSync,
  futimes: () => futimes,
  futimesSync: () => futimesSync,
  lchmod: () => lchmod,
  lchmodSync: () => lchmodSync,
  lchown: () => lchown,
  lchownSync: () => lchownSync,
  link: () => link,
  linkSync: () => linkSync,
  lstat: () => lstat,
  lstatSync: () => lstatSync,
  mkdir: () => mkdir,
  mkdirSync: () => mkdirSync,
  mkdtemp: () => mkdtemp,
  mkdtempSync: () => mkdtempSync,
  open: () => open,
  openSync: () => openSync,
  opendir: () => opendir,
  opendirSync: () => opendirSync,
  promises: () => promises2,
  read: () => read,
  readFile: () => readFile,
  readFileSync: () => readFileSync,
  readSync: () => readSync,
  readdir: () => readdir,
  readdirSync: () => readdirSync,
  readlink: () => readlink,
  readlinkSync: () => readlinkSync,
  readv: () => readv,
  readvSync: () => readvSync,
  realpath: () => realpath,
  realpathSync: () => realpathSync,
  rename: () => rename,
  renameSync: () => renameSync,
  rm: () => rm,
  rmSync: () => rmSync,
  rmdir: () => rmdir,
  rmdirSync: () => rmdirSync,
  stat: () => stat,
  statSync: () => statSync,
  symlink: () => symlink,
  symlinkSync: () => symlinkSync,
  truncate: () => truncate,
  truncateSync: () => truncateSync,
  unlink: () => unlink,
  unlinkSync: () => unlinkSync,
  unwatchFile: () => unwatchFile,
  utimes: () => utimes,
  utimesSync: () => utimesSync,
  watch: () => watch,
  watchFile: () => watchFile,
  write: () => write,
  writeFile: () => writeFile,
  writeFileSync: () => writeFileSync,
  writeSync: () => writeSync,
  writev: () => writev,
  writevSync: () => writevSync
});
function dew$f2() {
  if (_dewExec$f2)
    return exports$h;
  _dewExec$f2 = true;
  Object.defineProperty(exports$h, "__esModule", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}
function dew$e2() {
  if (_dewExec$e2)
    return exports$g2;
  _dewExec$e2 = true;
  if (typeof BigInt === "function")
    exports$g2.default = BigInt;
  else
    exports$g2.default = function BigIntNotSupported() {
      throw new Error("BigInt is not supported in this environment.");
    };
  return exports$g2;
}
function dew$d2() {
  if (_dewExec$d2)
    return exports$f2;
  _dewExec$d2 = true;
  Object.defineProperty(exports$f2, "__esModule", {
    value: true
  });
  exports$f2.Stats = void 0;
  var constants_1 = dew$f2();
  var getBigInt_1 = dew$e2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFBLK2 = constants_1.constants.S_IFBLK, S_IFCHR2 = constants_1.constants.S_IFCHR, S_IFLNK2 = constants_1.constants.S_IFLNK, S_IFIFO2 = constants_1.constants.S_IFIFO, S_IFSOCK2 = constants_1.constants.S_IFSOCK;
  var Stats2 = function() {
    function Stats3() {
    }
    Stats3.build = function(node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var stats = new Stats3();
      var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
      var getStatNumber = !bigint ? function(number) {
        return number;
      } : getBigInt_1.default;
      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };
    Stats3.prototype._checkModeProperty = function(property) {
      return (Number(this.mode) & S_IFMT2) === property;
    };
    Stats3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR2);
    };
    Stats3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG2);
    };
    Stats3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK2);
    };
    Stats3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR2);
    };
    Stats3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK2);
    };
    Stats3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO2);
    };
    Stats3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK2);
    };
    return Stats3;
  }();
  exports$f2.Stats = Stats2;
  exports$f2.default = Stats2;
  return exports$f2;
}
function dew$c2() {
  if (_dewExec$c2)
    return exports$e2;
  _dewExec$c2 = true;
  var __spreadArray = exports$e2 && exports$e2.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$e2, "__esModule", {
    value: true
  });
  exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e2, "Buffer", {
    enumerable: true,
    get: function() {
      return buffer_1.Buffer;
    }
  });
  function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }
  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e2.bufferFrom = bufferFrom;
  return exports$e2;
}
function dew$b2() {
  if (_dewExec$b2)
    return exports$d2;
  _dewExec$b2 = true;
  var __extends = exports$d2 && exports$d2.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$d2, "__esModule", {
    value: true
  });
  exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
  var assert2 = et;
  var util = X;
  var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
  var messages = {};
  function makeNodeError(Base) {
    return function(_super) {
      __extends(NodeError, _super);
      function NodeError(key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, message(key, args)) || this;
        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
        return _this;
      }
      return NodeError;
    }(Base);
  }
  var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
  var AssertionError2 = function(_super) {
    __extends(AssertionError3, _super);
    function AssertionError3(options) {
      var _this = this;
      if (typeof options !== "object" || options === null) {
        throw new exports$d2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
      }
      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
      }
      _this.generatedMessage = !options.message;
      _this.name = "AssertionError [ERR_ASSERTION]";
      _this.code = "ERR_ASSERTION";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }
    return AssertionError3;
  }(g5.Error);
  exports$d2.AssertionError = AssertionError2;
  function message(key, args) {
    assert2.strictEqual(typeof key, "string");
    var msg = messages[key];
    assert2(msg, "An invalid error message key was used: " + key + ".");
    var fmt;
    if (typeof msg === "function") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === void 0 || args.length === 0)
        return msg;
      args.unshift(msg);
    }
    return String(fmt.apply(null, args));
  }
  exports$d2.message = message;
  function E4(sym, val) {
    messages[sym] = typeof val === "function" ? val : String(val);
  }
  exports$d2.E = E4;
  exports$d2.Error = makeNodeError(g5.Error);
  exports$d2.TypeError = makeNodeError(g5.TypeError);
  exports$d2.RangeError = makeNodeError(g5.RangeError);
  E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
  E4("ERR_ASSERTION", "%s");
  E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
  E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
  E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
  E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
  E4("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
    return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
  });
  E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
  E4("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
    return 'The "' + enc + '" encoding is not supported';
  });
  E4("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
    return "The encoded data was not valid for encoding " + enc;
  });
  E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
  E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
  E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
  E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
  E4("ERR_INVALID_ARG_TYPE", invalidArgType);
  E4("ERR_INVALID_ARRAY_LENGTH", function(name3, len, actual) {
    assert2.strictEqual(typeof actual, "number");
    return 'The array "' + name3 + '" (length ' + actual + ") must be of length " + len + ".";
  });
  E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
  E4("ERR_INVALID_CALLBACK", "Callback must be a function");
  E4("ERR_INVALID_CHAR", "Invalid character in %s");
  E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
  E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
  E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
  E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
  E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
  E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
  E4("ERR_INVALID_OPT_VALUE", function(name3, value) {
    return 'The value "' + String(value) + '" is invalid for option "' + name3 + '"';
  });
  E4("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
    return 'The value "' + String(value) + '" is invalid for option "encoding"';
  });
  E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
  E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
  E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
  E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
  E4("ERR_INVALID_URL", "Invalid URL: %s");
  E4("ERR_INVALID_URL_SCHEME", function(expected) {
    return "The URL must be " + oneOf(expected, "scheme");
  });
  E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
  E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
  E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
  E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
  E4("ERR_MISSING_ARGS", missingArgs);
  E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
  E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
  E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
  E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
  E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
  E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
  E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
  E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
  E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
  E4("ERR_SOCKET_CLOSED", "Socket is closed");
  E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
  E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
  E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
  E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
  E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
  E4("ERR_TLS_DH_PARAM_SIZE", function(size) {
    return "DH parameter size " + size + " is less than 2048";
  });
  E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
  E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
  E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
  E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
  E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
  E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
  E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
  E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
  E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
  E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
  E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function invalidArgType(name3, expected, actual) {
    assert2(name3, "name is required");
    var determiner;
    if (expected.includes("not ")) {
      determiner = "must not be";
      expected = expected.split("not ")[1];
    } else {
      determiner = "must be";
    }
    var msg;
    if (Array.isArray(name3)) {
      var names = name3.map(function(val) {
        return '"' + val + '"';
      }).join(", ");
      msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
    } else if (name3.includes(" argument")) {
      msg = "The " + name3 + " " + determiner + " " + oneOf(expected, "type");
    } else {
      var type2 = name3.includes(".") ? "property" : "argument";
      msg = 'The "' + name3 + '" ' + type2 + " " + determiner + " " + oneOf(expected, "type");
    }
    if (arguments.length >= 3) {
      msg += ". Received type " + (actual !== null ? typeof actual : "null");
    }
    return msg;
  }
  function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    assert2(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a7) {
      return '"' + a7 + '"';
    });
    switch (len) {
      case 1:
        msg += args[0] + " argument";
        break;
      case 2:
        msg += args[0] + " and " + args[1] + " arguments";
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and " + args[len - 1] + " arguments";
        break;
    }
    return msg + " must be specified";
  }
  function oneOf(expected, thing) {
    assert2(expected, "expected is required");
    assert2(typeof thing === "string", "thing is required");
    if (Array.isArray(expected)) {
      var len = expected.length;
      assert2(len > 0, "At least one expected value needs to be specified");
      expected = expected.map(function(i7) {
        return String(i7);
      });
      if (len > 2) {
        return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
      } else if (len === 2) {
        return "one of " + thing + " " + expected[0] + " or " + expected[1];
      } else {
        return "of " + thing + " " + expected[0];
      }
    } else {
      return "of " + thing + " " + String(expected);
    }
  }
  function bufferOutOfBounds(name3, isWriting) {
    if (isWriting) {
      return "Attempt to write outside buffer bounds";
    } else {
      return '"' + name3 + '" is outside of buffer bounds';
    }
  }
  return exports$d2;
}
function dew$a2() {
  if (_dewExec$a2)
    return exports$c2;
  _dewExec$a2 = true;
  Object.defineProperty(exports$c2, "__esModule", {
    value: true
  });
  exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
  var buffer_1 = dew$c2();
  var errors = dew$b2();
  exports$c2.ENCODING_UTF8 = "utf8";
  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding))
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
  }
  exports$c2.assertEncoding = assertEncoding;
  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c2.ENCODING_UTF8)
      return str;
    if (encoding === "buffer")
      return new buffer_1.Buffer(str);
    return new buffer_1.Buffer(str).toString(encoding);
  }
  exports$c2.strToEncoding = strToEncoding;
  return exports$c2;
}
function dew$92() {
  if (_dewExec$92)
    return exports$b2;
  _dewExec$92 = true;
  Object.defineProperty(exports$b2, "__esModule", {
    value: true
  });
  exports$b2.Dirent = void 0;
  var constants_1 = dew$f2();
  var encoding_1 = dew$a2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFBLK2 = constants_1.constants.S_IFBLK, S_IFCHR2 = constants_1.constants.S_IFCHR, S_IFLNK2 = constants_1.constants.S_IFLNK, S_IFIFO2 = constants_1.constants.S_IFIFO, S_IFSOCK2 = constants_1.constants.S_IFSOCK;
  var Dirent2 = function() {
    function Dirent3() {
      this.name = "";
      this.mode = 0;
    }
    Dirent3.build = function(link3, encoding) {
      var dirent = new Dirent3();
      var mode = link3.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link3.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };
    Dirent3.prototype._checkModeProperty = function(property) {
      return (this.mode & S_IFMT2) === property;
    };
    Dirent3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR2);
    };
    Dirent3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG2);
    };
    Dirent3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK2);
    };
    Dirent3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR2);
    };
    Dirent3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK2);
    };
    Dirent3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO2);
    };
    Dirent3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK2);
    };
    return Dirent3;
  }();
  exports$b2.Dirent = Dirent2;
  exports$b2.default = Dirent2;
  return exports$b2;
}
function dew$82() {
  if (_dewExec$82)
    return exports$a2;
  _dewExec$82 = true;
  var process$1 = process2;
  Object.defineProperty(exports$a2, "__esModule", {
    value: true
  });
  var _setImmediate;
  if (typeof process$1.nextTick === "function")
    _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  else
    _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  exports$a2.default = _setImmediate;
  return exports$a2;
}
function dew$72() {
  if (_dewExec$72)
    return exports$92;
  _dewExec$72 = true;
  var process$1 = process2;
  Object.defineProperty(exports$92, "__esModule", {
    value: true
  });
  exports$92.createProcess = void 0;
  var maybeReturnProcess = function() {
    if (typeof process$1 !== "undefined") {
      return process$1;
    }
    try {
      return process2;
    } catch (_a) {
      return void 0;
    }
  };
  function createProcess() {
    var p7 = maybeReturnProcess() || {};
    if (!p7.getuid)
      p7.getuid = function() {
        return 0;
      };
    if (!p7.getgid)
      p7.getgid = function() {
        return 0;
      };
    if (!p7.cwd)
      p7.cwd = function() {
        return "/";
      };
    if (!p7.nextTick)
      p7.nextTick = dew$82().default;
    if (!p7.emitWarning)
      p7.emitWarning = function(message, type2) {
        console.warn("" + type2 + (type2 ? ": " : "") + message);
      };
    if (!p7.env)
      p7.env = {};
    return p7;
  }
  exports$92.createProcess = createProcess;
  exports$92.default = createProcess();
  return exports$92;
}
function dew$62() {
  if (_dewExec$62)
    return exports$82;
  _dewExec$62 = true;
  var __extends = exports$82 && exports$82.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$82, "__esModule", {
    value: true
  });
  exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
  var process_1 = dew$72();
  var buffer_1 = dew$c2();
  var constants_1 = dew$f2();
  var events_1 = y;
  var Stats_1 = dew$d2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFLNK2 = constants_1.constants.S_IFLNK, O_APPEND2 = constants_1.constants.O_APPEND;
  exports$82.SEP = "/";
  var Node = function(_super) {
    __extends(Node2, _super);
    function Node2(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }
      var _this = _super.call(this) || this;
      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = /* @__PURE__ */ new Date();
      _this.mtime = /* @__PURE__ */ new Date();
      _this.ctime = /* @__PURE__ */ new Date();
      _this.perm = 438;
      _this.mode = S_IFREG2;
      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }
    Node2.prototype.getString = function(encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return this.getBuffer().toString(encoding);
    };
    Node2.prototype.setString = function(str) {
      this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
      this.touch();
    };
    Node2.prototype.getBuffer = function() {
      if (!this.buf)
        this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf);
    };
    Node2.prototype.setBuffer = function(buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf);
      this.touch();
    };
    Node2.prototype.getSize = function() {
      return this.buf ? this.buf.length : 0;
    };
    Node2.prototype.setModeProperty = function(property) {
      this.mode = this.mode & ~S_IFMT2 | property;
    };
    Node2.prototype.setIsFile = function() {
      this.setModeProperty(S_IFREG2);
    };
    Node2.prototype.setIsDirectory = function() {
      this.setModeProperty(S_IFDIR2);
    };
    Node2.prototype.setIsSymlink = function() {
      this.setModeProperty(S_IFLNK2);
    };
    Node2.prototype.isFile = function() {
      return (this.mode & S_IFMT2) === S_IFREG2;
    };
    Node2.prototype.isDirectory = function() {
      return (this.mode & S_IFMT2) === S_IFDIR2;
    };
    Node2.prototype.isSymlink = function() {
      return (this.mode & S_IFMT2) === S_IFLNK2;
    };
    Node2.prototype.makeSymlink = function(steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };
    Node2.prototype.write = function(buf, off2, len, pos) {
      if (off2 === void 0) {
        off2 = 0;
      }
      if (len === void 0) {
        len = buf.length;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }
      buf.copy(this.buf, pos, off2, off2 + len);
      this.touch();
      return len;
    };
    Node2.prototype.read = function(buf, off2, len, pos) {
      if (off2 === void 0) {
        off2 = 0;
      }
      if (len === void 0) {
        len = buf.byteLength;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;
      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }
      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }
      this.buf.copy(buf, off2, pos, pos + actualLen);
      return actualLen;
    };
    Node2.prototype.truncate = function(len) {
      if (len === void 0) {
        len = 0;
      }
      if (!len)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      else {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };
    Node2.prototype.chmod = function(perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };
    Node2.prototype.chown = function(uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };
    Node2.prototype.touch = function() {
      this.mtime = /* @__PURE__ */ new Date();
      this.emit("change", this);
    };
    Node2.prototype.canRead = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 4) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 32) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 256) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.canWrite = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 2) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 16) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 128) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.del = function() {
      this.emit("delete", this);
    };
    Node2.prototype.toJSON = function() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };
    return Node2;
  }(events_1.EventEmitter);
  exports$82.Node = Node;
  var Link = function(_super) {
    __extends(Link2, _super);
    function Link2(vol2, parent, name3) {
      var _this = _super.call(this) || this;
      _this.children = {};
      _this.steps = [];
      _this.ino = 0;
      _this.length = 0;
      _this.vol = vol2;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name3]) : [name3];
      return _this;
    }
    Link2.prototype.setNode = function(node) {
      this.node = node;
      this.ino = node.ino;
    };
    Link2.prototype.getNode = function() {
      return this.node;
    };
    Link2.prototype.createChild = function(name3, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }
      var link3 = new Link2(this.vol, this, name3);
      link3.setNode(node);
      if (node.isDirectory())
        ;
      this.setChild(name3, link3);
      return link3;
    };
    Link2.prototype.setChild = function(name3, link3) {
      if (link3 === void 0) {
        link3 = new Link2(this.vol, this, name3);
      }
      this.children[name3] = link3;
      link3.parent = this;
      this.length++;
      this.emit("child:add", link3, this);
      return link3;
    };
    Link2.prototype.deleteChild = function(link3) {
      delete this.children[link3.getName()];
      this.length--;
      this.emit("child:delete", link3, this);
    };
    Link2.prototype.getChild = function(name3) {
      if (Object.hasOwnProperty.call(this.children, name3)) {
        return this.children[name3];
      }
    };
    Link2.prototype.getPath = function() {
      return this.steps.join(exports$82.SEP);
    };
    Link2.prototype.getName = function() {
      return this.steps[this.steps.length - 1];
    };
    Link2.prototype.walk = function(steps, stop, i7) {
      if (stop === void 0) {
        stop = steps.length;
      }
      if (i7 === void 0) {
        i7 = 0;
      }
      if (i7 >= steps.length)
        return this;
      if (i7 >= stop)
        return this;
      var step = steps[i7];
      var link3 = this.getChild(step);
      if (!link3)
        return null;
      return link3.walk(steps, stop, i7 + 1);
    };
    Link2.prototype.toJSON = function() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };
    return Link2;
  }(events_1.EventEmitter);
  exports$82.Link = Link;
  var File = function() {
    function File2(link3, node, flags, fd) {
      this.position = 0;
      this.link = link3;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }
    File2.prototype.getString = function(encoding) {
      return this.node.getString();
    };
    File2.prototype.setString = function(str) {
      this.node.setString(str);
    };
    File2.prototype.getBuffer = function() {
      return this.node.getBuffer();
    };
    File2.prototype.setBuffer = function(buf) {
      this.node.setBuffer(buf);
    };
    File2.prototype.getSize = function() {
      return this.node.getSize();
    };
    File2.prototype.truncate = function(len) {
      this.node.truncate(len);
    };
    File2.prototype.seekTo = function(position) {
      this.position = position;
    };
    File2.prototype.stats = function() {
      return Stats_1.default.build(this.node);
    };
    File2.prototype.write = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.length;
      }
      if (typeof position !== "number")
        position = this.position;
      if (this.flags & O_APPEND2)
        position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.read = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.byteLength;
      }
      if (typeof position !== "number")
        position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.chmod = function(perm) {
      this.node.chmod(perm);
    };
    File2.prototype.chown = function(uid, gid) {
      this.node.chown(uid, gid);
    };
    return File2;
  }();
  exports$82.File = File;
  return exports$82;
}
function dew$52() {
  if (_dewExec$52)
    return exports$72;
  _dewExec$52 = true;
  Object.defineProperty(exports$72, "__esModule", {
    value: true
  });
  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
    if (ref && typeof ref === "object" && typeof ref.unref === "function")
      ref.unref();
    return ref;
  }
  exports$72.default = setTimeoutUnref;
  return exports$72;
}
function dew$42() {
  if (_dewExec$42)
    return exports$62;
  _dewExec$42 = true;
  var __spreadArray = exports$62 && exports$62.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$62, "__esModule", {
    value: true
  });
  exports$62.FileHandle = void 0;
  function promisify3(vol2, fn, getResult) {
    if (getResult === void 0) {
      getResult = function(input) {
        return input;
      };
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new Promise(function(resolve4, reject) {
        vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
          if (error)
            return reject(error);
          return resolve4(getResult(result));
        }], false));
      });
    };
  }
  var FileHandle = function() {
    function FileHandle2(vol2, fd) {
      this.vol = vol2;
      this.fd = fd;
    }
    FileHandle2.prototype.appendFile = function(data, options) {
      return promisify3(this.vol, "appendFile")(this.fd, data, options);
    };
    FileHandle2.prototype.chmod = function(mode) {
      return promisify3(this.vol, "fchmod")(this.fd, mode);
    };
    FileHandle2.prototype.chown = function(uid, gid) {
      return promisify3(this.vol, "fchown")(this.fd, uid, gid);
    };
    FileHandle2.prototype.close = function() {
      return promisify3(this.vol, "close")(this.fd);
    };
    FileHandle2.prototype.datasync = function() {
      return promisify3(this.vol, "fdatasync")(this.fd);
    };
    FileHandle2.prototype.read = function(buffer2, offset, length, position) {
      return promisify3(this.vol, "read", function(bytesRead) {
        return {
          bytesRead,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.readFile = function(options) {
      return promisify3(this.vol, "readFile")(this.fd, options);
    };
    FileHandle2.prototype.stat = function(options) {
      return promisify3(this.vol, "fstat")(this.fd, options);
    };
    FileHandle2.prototype.sync = function() {
      return promisify3(this.vol, "fsync")(this.fd);
    };
    FileHandle2.prototype.truncate = function(len) {
      return promisify3(this.vol, "ftruncate")(this.fd, len);
    };
    FileHandle2.prototype.utimes = function(atime, mtime) {
      return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
    };
    FileHandle2.prototype.write = function(buffer2, offset, length, position) {
      return promisify3(this.vol, "write", function(bytesWritten) {
        return {
          bytesWritten,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.writeFile = function(data, options) {
      return promisify3(this.vol, "writeFile")(this.fd, data, options);
    };
    return FileHandle2;
  }();
  exports$62.FileHandle = FileHandle;
  function createPromisesApi(vol2) {
    if (typeof Promise === "undefined")
      return null;
    return {
      FileHandle,
      access: function(path2, mode) {
        return promisify3(vol2, "access")(path2, mode);
      },
      appendFile: function(path2, data, options) {
        return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
      },
      chmod: function(path2, mode) {
        return promisify3(vol2, "chmod")(path2, mode);
      },
      chown: function(path2, uid, gid) {
        return promisify3(vol2, "chown")(path2, uid, gid);
      },
      copyFile: function(src, dest, flags) {
        return promisify3(vol2, "copyFile")(src, dest, flags);
      },
      lchmod: function(path2, mode) {
        return promisify3(vol2, "lchmod")(path2, mode);
      },
      lchown: function(path2, uid, gid) {
        return promisify3(vol2, "lchown")(path2, uid, gid);
      },
      link: function(existingPath, newPath) {
        return promisify3(vol2, "link")(existingPath, newPath);
      },
      lstat: function(path2, options) {
        return promisify3(vol2, "lstat")(path2, options);
      },
      mkdir: function(path2, options) {
        return promisify3(vol2, "mkdir")(path2, options);
      },
      mkdtemp: function(prefix, options) {
        return promisify3(vol2, "mkdtemp")(prefix, options);
      },
      open: function(path2, flags, mode) {
        return promisify3(vol2, "open", function(fd) {
          return new FileHandle(vol2, fd);
        })(path2, flags, mode);
      },
      readdir: function(path2, options) {
        return promisify3(vol2, "readdir")(path2, options);
      },
      readFile: function(id, options) {
        return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function(path2, options) {
        return promisify3(vol2, "readlink")(path2, options);
      },
      realpath: function(path2, options) {
        return promisify3(vol2, "realpath")(path2, options);
      },
      rename: function(oldPath, newPath) {
        return promisify3(vol2, "rename")(oldPath, newPath);
      },
      rmdir: function(path2) {
        return promisify3(vol2, "rmdir")(path2);
      },
      stat: function(path2, options) {
        return promisify3(vol2, "stat")(path2, options);
      },
      symlink: function(target, path2, type2) {
        return promisify3(vol2, "symlink")(target, path2, type2);
      },
      truncate: function(path2, len) {
        return promisify3(vol2, "truncate")(path2, len);
      },
      unlink: function(path2) {
        return promisify3(vol2, "unlink")(path2);
      },
      utimes: function(path2, atime, mtime) {
        return promisify3(vol2, "utimes")(path2, atime, mtime);
      },
      writeFile: function(id, data, options) {
        return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }
  exports$62.default = createPromisesApi;
  return exports$62;
}
function dew$32() {
  if (_dewExec$32)
    return exports$52;
  _dewExec$32 = true;
  var process$1 = process2;
  Object.defineProperty(exports$52, "__esModule", {
    value: true
  });
  exports$52.unixify = unixify;
  exports$52.correctPath = correctPath;
  var isWin = process$1.platform === "win32";
  function removeTrailingSeparator(str) {
    var i7 = str.length - 1;
    if (i7 < 2) {
      return str;
    }
    while (isSeparator(str, i7)) {
      i7--;
    }
    return str.substr(0, i7 + 1);
  }
  function isSeparator(str, i7) {
    var _char = str[i7];
    return i7 > 0 && (_char === "/" || isWin && _char === "\\");
  }
  function normalizePath(str, stripTrailing) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    str = str.replace(/[\\\/]+/g, "/");
    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }
    return str;
  }
  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
    }
    return filepath;
  }
  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
  }
  return exports$52;
}
function dew$23() {
  if (_dewExec$23)
    return exports$42;
  _dewExec$23 = true;
  var __extends = exports$42 && exports$42.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== "function" && b5 !== null)
        throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  var __spreadArray = exports$42 && exports$42.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$42, "__esModule", {
    value: true
  });
  exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
  var pathModule = exports3;
  var node_1 = dew$62();
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var buffer_1 = dew$c2();
  var setImmediate_1 = dew$82();
  var process_1 = dew$72();
  var setTimeoutUnref_1 = dew$52();
  var stream_1 = exports6;
  var constants_1 = dew$f2();
  var events_1 = y;
  var encoding_1 = dew$a2();
  var errors = dew$b2();
  var util = X;
  var promises_1 = dew$42();
  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY2 = constants_1.constants.O_RDONLY, O_WRONLY2 = constants_1.constants.O_WRONLY, O_RDWR2 = constants_1.constants.O_RDWR, O_CREAT2 = constants_1.constants.O_CREAT, O_EXCL2 = constants_1.constants.O_EXCL, O_TRUNC2 = constants_1.constants.O_TRUNC, O_APPEND2 = constants_1.constants.O_APPEND, O_SYNC2 = constants_1.constants.O_SYNC, O_DIRECTORY2 = constants_1.constants.O_DIRECTORY, F_OK3 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
  var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
  var isWin = process_1.default.platform === "win32";
  var kMinPoolSpace = 128;
  var ERRSTR = {
    PATH_STR: "path must be a string or Buffer",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  };
  var ERRSTR_OPTS = function(tipeof) {
    return "Expected options to be either an object or a string, but got " + tipeof + " instead";
  };
  var ENOENT2 = "ENOENT";
  var EBADF2 = "EBADF";
  var EINVAL2 = "EINVAL";
  var EPERM2 = "EPERM";
  var EPROTO2 = "EPROTO";
  var EEXIST2 = "EEXIST";
  var ENOTDIR2 = "ENOTDIR";
  var EMFILE2 = "EMFILE";
  var EACCES2 = "EACCES";
  var EISDIR2 = "EISDIR";
  var ENOTEMPTY2 = "ENOTEMPTY";
  var ENOSYS2 = "ENOSYS";
  function formatError(errorCode, func, path2, path22) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    var pathFormatted = "";
    if (path2)
      pathFormatted = " '" + path2 + "'";
    if (path22)
      pathFormatted += " -> '" + path22 + "'";
    switch (errorCode) {
      case ENOENT2:
        return "ENOENT: no such file or directory, " + func + pathFormatted;
      case EBADF2:
        return "EBADF: bad file descriptor, " + func + pathFormatted;
      case EINVAL2:
        return "EINVAL: invalid argument, " + func + pathFormatted;
      case EPERM2:
        return "EPERM: operation not permitted, " + func + pathFormatted;
      case EPROTO2:
        return "EPROTO: protocol error, " + func + pathFormatted;
      case EEXIST2:
        return "EEXIST: file already exists, " + func + pathFormatted;
      case ENOTDIR2:
        return "ENOTDIR: not a directory, " + func + pathFormatted;
      case EISDIR2:
        return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
      case EACCES2:
        return "EACCES: permission denied, " + func + pathFormatted;
      case ENOTEMPTY2:
        return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
      case EMFILE2:
        return "EMFILE: too many open files, " + func + pathFormatted;
      case ENOSYS2:
        return "ENOSYS: function not implemented, " + func + pathFormatted;
      default:
        return errorCode + ": error occurred, " + func + pathFormatted;
    }
  }
  function createError(errorCode, func, path2, path22, Constructor) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    if (Constructor === void 0) {
      Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path2, path22));
    error.code = errorCode;
    return error;
  }
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["r"] = O_RDONLY2] = "r";
    FLAGS2[FLAGS2["r+"] = O_RDWR2] = "r+";
    FLAGS2[FLAGS2["rs"] = O_RDONLY2 | O_SYNC2] = "rs";
    FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
    FLAGS2[FLAGS2["rs+"] = O_RDWR2 | O_SYNC2] = "rs+";
    FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
    FLAGS2[FLAGS2["w"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2] = "w";
    FLAGS2[FLAGS2["wx"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx";
    FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
    FLAGS2[FLAGS2["w+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2] = "w+";
    FLAGS2[FLAGS2["wx+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx+";
    FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
    FLAGS2[FLAGS2["a"] = O_WRONLY2 | O_APPEND2 | O_CREAT2] = "a";
    FLAGS2[FLAGS2["ax"] = O_WRONLY2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax";
    FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
    FLAGS2[FLAGS2["a+"] = O_RDWR2 | O_APPEND2 | O_CREAT2] = "a+";
    FLAGS2[FLAGS2["ax+"] = O_RDWR2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax+";
    FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
  })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
  function flagsToNumber(flags) {
    if (typeof flags === "number")
      return flags;
    if (typeof flags === "string") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== "undefined")
        return flagsNum;
    }
    throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
  }
  exports$42.flagsToNumber = flagsToNumber;
  function getOptions(defaults2, options) {
    var opts;
    if (!options)
      return defaults2;
    else {
      var tipeof = typeof options;
      switch (tipeof) {
        case "string":
          opts = Object.assign({}, defaults2, {
            encoding: options
          });
          break;
        case "object":
          opts = Object.assign({}, defaults2, options);
          break;
        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== "buffer")
      (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }
  function optsGenerator(defaults2) {
    return function(options) {
      return getOptions(defaults2, options);
    };
  }
  function validateCallback(callback) {
    if (typeof callback !== "function")
      throw TypeError(ERRSTR.CB);
    return callback;
  }
  function optsAndCbGenerator(getOpts) {
    return function(options, callback) {
      return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }
  var optsDefaults = {
    encoding: "utf8"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: "r"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511,
    recursive: false
  };
  var getMkdirOptions = function(options) {
    if (typeof options === "number")
      return Object.assign({}, mkdirDefaults, {
        mode: options
      });
    return Object.assign({}, mkdirDefaults, options);
  };
  var rmdirDefaults = {
    recursive: false
  };
  var getRmdirOptions = function(options) {
    return Object.assign({}, rmdirDefaults, options);
  };
  var readdirDefaults = {
    encoding: "utf8",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };
  var getStatOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    return Object.assign({}, statDefaults, options);
  };
  var getStatOptsAndCb = function(options, callback) {
    return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  };
  function getPathFromURLPosix2(url) {
    if (url.hostname !== "") {
      throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n9 = 0; n9 < pathname.length; n9++) {
      if (pathname[n9] === "%") {
        var third = pathname.codePointAt(n9 + 2) | 32;
        if (pathname[n9 + 1] === "2" && third === 102) {
          throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFilename(path2) {
    if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
      try {
        if (!(path2 instanceof h7.URL))
          throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }
      path2 = getPathFromURLPosix2(path2);
    }
    var pathString = String(path2);
    nullCheck(pathString);
    return pathString;
  }
  exports$42.pathToFilename = pathToFilename;
  var resolve4 = function(filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
  };
  if (isWin) {
    var _resolve_1 = resolve4;
    var unixify_1 = dew$32().unixify;
    resolve4 = function(filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }
  function filenameToSteps(filename, base) {
    var fullPath = resolve4(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash)
      return [];
    return fullPathSansSlash.split(sep2);
  }
  exports$42.filenameToSteps = filenameToSteps;
  function pathToSteps(path2) {
    return filenameToSteps(pathToFilename(path2));
  }
  exports$42.pathToSteps = pathToSteps;
  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data.toString(encoding);
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else
      return String(data);
  }
  exports$42.dataToStr = dataToStr;
  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data;
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data);
    else
      return (0, buffer_1.bufferFrom)(String(data), encoding);
  }
  exports$42.dataToBuffer = dataToBuffer;
  function bufferToEncoding(buffer2, encoding) {
    if (!encoding || encoding === "buffer")
      return buffer2;
    else
      return buffer2.toString(encoding);
  }
  exports$42.bufferToEncoding = bufferToEncoding;
  function nullCheck(path2, callback) {
    if (("" + path2).indexOf("\0") !== -1) {
      var er = new Error("Path must be a string without null bytes");
      er.code = ENOENT2;
      if (typeof callback !== "function")
        throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }
    return true;
  }
  function _modeToNumber(mode, def) {
    if (typeof mode === "number")
      return mode;
    if (typeof mode === "string")
      return parseInt(mode, 8);
    if (def)
      return modeToNumber(def);
    return void 0;
  }
  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== "number" || isNaN(result))
      throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }
  function isFd(path2) {
    return path2 >>> 0 === path2;
  }
  function validateFd(fd) {
    if (!isFd(fd))
      throw TypeError(ERRSTR.FD);
  }
  function toUnixTimestamp(time) {
    if (typeof time === "string" && +time == time) {
      return +time;
    }
    if (time instanceof Date) {
      return time.getTime() / 1e3;
    }
    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      }
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  }
  exports$42.toUnixTimestamp = toUnixTimestamp;
  function validateUid(uid) {
    if (typeof uid !== "number")
      throw TypeError(ERRSTR.UID);
  }
  function validateGid(gid) {
    if (typeof gid !== "number")
      throw TypeError(ERRSTR.GID);
  }
  function flattenJSON(nestedJSON) {
    var flatJSON = {};
    function flatten(pathPrefix, node) {
      for (var path2 in node) {
        var contentOrNode = node[path2];
        var joinedPath = join2(pathPrefix, path2);
        if (typeof contentOrNode === "string") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    flatten("", nestedJSON);
    return flatJSON;
  }
  var Volume = function() {
    function Volume2(props) {
      if (props === void 0) {
        props = {};
      }
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.maxFiles = 1e4;
      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self2 = this;
      this.StatWatcher = function(_super) {
        __extends(StatWatcher2, _super);
        function StatWatcher2() {
          return _super.call(this, self2) || this;
        }
        return StatWatcher2;
      }(StatWatcher);
      var _ReadStream = FsReadStream;
      this.ReadStream = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_1;
      }(_ReadStream);
      var _WriteStream = FsWriteStream;
      this.WriteStream = function(_super) {
        __extends(class_2, _super);
        function class_2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_2;
      }(_WriteStream);
      this.FSWatcher = function(_super) {
        __extends(FSWatcher2, _super);
        function FSWatcher2() {
          return _super.call(this, self2) || this;
        }
        return FSWatcher2;
      }(FSWatcher);
      this.root = root;
    }
    Volume2.fromJSON = function(json, cwd2) {
      var vol2 = new Volume2();
      vol2.fromJSON(json, cwd2);
      return vol2;
    };
    Volume2.fromNestedJSON = function(json, cwd2) {
      var vol2 = new Volume2();
      vol2.fromNestedJSON(json, cwd2);
      return vol2;
    };
    Object.defineProperty(Volume2.prototype, "promises", {
      get: function() {
        if (this.promisesApi === null)
          throw new Error("Promise is not supported in this environment.");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });
    Volume2.prototype.createLink = function(parent, name3, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      if (!parent) {
        return new this.props.Link(this, null, "");
      }
      if (!name3) {
        throw new Error("createLink: name cannot be empty");
      }
      return parent.createChild(name3, this.createNode(isDirectory, perm));
    };
    Volume2.prototype.deleteLink = function(link3) {
      var parent = link3.parent;
      if (parent) {
        parent.deleteChild(link3);
        return true;
      }
      return false;
    };
    Volume2.prototype.newInoNumber = function() {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd)
        return releasedFd;
      else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };
    Volume2.prototype.newFdNumber = function() {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
    };
    Volume2.prototype.createNode = function(isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory)
        node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };
    Volume2.prototype.getNode = function(ino) {
      return this.inodes[ino];
    };
    Volume2.prototype.deleteNode = function(node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    };
    Volume2.prototype.genRndStr = function() {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6)
        return str;
      else
        return this.genRndStr();
    };
    Volume2.prototype.getLink = function(steps) {
      return this.root.walk(steps);
    };
    Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
      var steps = filenameToSteps(filename);
      var link3 = this.getLink(steps);
      if (!link3)
        throw createError(ENOENT2, funcName, filename);
      return link3;
    };
    Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
      var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link3 = this.root;
      var i7 = 0;
      while (i7 < steps.length) {
        var step = steps[i7];
        link3 = link3.getChild(step);
        if (!link3)
          return null;
        var node = link3.getNode();
        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i7 + 1));
          link3 = this.root;
          i7 = 0;
          continue;
        }
        i7++;
      }
      return link3;
    };
    Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
      var link3 = this.getResolvedLink(filename);
      if (!link3)
        throw createError(ENOENT2, funcName, filename);
      return link3;
    };
    Volume2.prototype.resolveSymlinks = function(link3) {
      return this.getResolvedLink(link3.steps.slice(1));
    };
    Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
      var link3 = this.getLinkOrThrow(filename, funcName);
      if (!link3.getNode().isDirectory())
        throw createError(ENOTDIR2, funcName, filename);
      return link3;
    };
    Volume2.prototype.getLinkParent = function(steps) {
      return this.root.walk(steps, steps.length - 1);
    };
    Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link3 = this.getLinkParent(steps);
      if (!link3)
        throw createError(ENOENT2, funcName, sep2 + steps.join(sep2));
      if (!link3.getNode().isDirectory())
        throw createError(ENOTDIR2, funcName, sep2 + steps.join(sep2));
      return link3;
    };
    Volume2.prototype.getFileByFd = function(fd) {
      return this.fds[String(fd)];
    };
    Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF2, funcName);
      return file;
    };
    Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
      if (typeof id === "number") {
        var file = this.getFileByFd(id);
        if (!file)
          throw Error("File nto found");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link3 = this.getLink(steps);
        if (link3)
          return link3.getNode();
        if (flags & O_CREAT2) {
          var dirLink = this.getLinkParent(steps);
          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link3 = this.createLink(dirLink, name_1, false, perm);
            return link3.getNode();
          }
        }
        throw createError(ENOENT2, "getNodeByIdOrCreate", pathToFilename(id));
      }
    };
    Volume2.prototype.wrapAsync = function(method, args, callback) {
      var _this = this;
      validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        var result;
        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    };
    Volume2.prototype._toJSON = function(link3, json, path2) {
      var _a2;
      if (link3 === void 0) {
        link3 = this.root;
      }
      if (json === void 0) {
        json = {};
      }
      var isEmpty = true;
      var children = link3.children;
      if (link3.getNode().isFile()) {
        children = (_a2 = {}, _a2[link3.getName()] = link3.parent.getChild(link3.getName()), _a2);
        link3 = link3.parent;
      }
      for (var name_2 in children) {
        isEmpty = false;
        var child = link3.getChild(name_2);
        if (!child) {
          throw new Error("_toJSON: unexpected undefined");
        }
        var node = child.getNode();
        if (node.isFile()) {
          var filename = child.getPath();
          if (path2)
            filename = relative2(path2, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path2);
        }
      }
      var dirPath = link3.getPath();
      if (path2)
        dirPath = relative2(path2, dirPath);
      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }
      return json;
    };
    Volume2.prototype.toJSON = function(paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }
      if (isRelative === void 0) {
        isRelative = false;
      }
      var links = [];
      if (paths) {
        if (!(paths instanceof Array))
          paths = [paths];
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path2 = paths_1[_i];
          var filename = pathToFilename(path2);
          var link3 = this.getResolvedLink(filename);
          if (!link3)
            continue;
          links.push(link3);
        }
      } else {
        links.push(this.root);
      }
      if (!links.length)
        return json;
      for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
        var link3 = links_1[_a2];
        this._toJSON(link3, json, isRelative ? link3.getPath() : "");
      }
      return json;
    };
    Volume2.prototype.fromJSON = function(json, cwd2) {
      if (cwd2 === void 0) {
        cwd2 = process_1.default.cwd();
      }
      for (var filename in json) {
        var data = json[filename];
        filename = resolve4(filename, cwd2);
        if (typeof data === "string") {
          var dir = dirname2(filename);
          this.mkdirpBase(
            dir,
            511
            /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(
            filename,
            511
            /* DIR */
          );
        }
      }
    };
    Volume2.prototype.fromNestedJSON = function(json, cwd2) {
      this.fromJSON(flattenJSON(json), cwd2);
    };
    Volume2.prototype.reset = function() {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    };
    Volume2.prototype.mountSync = function(mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };
    Volume2.prototype.openLink = function(link3, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      if (this.openFiles >= this.maxFiles) {
        throw createError(EMFILE2, "open", link3.getPath());
      }
      var realLink = link3;
      if (resolveSymlinks)
        realLink = this.resolveSymlinks(link3);
      if (!realLink)
        throw createError(ENOENT2, "open", link3.getPath());
      var node = realLink.getNode();
      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY2 | O_RDWR2 | O_WRONLY2)) !== O_RDONLY2)
          throw createError(EISDIR2, "open", link3.getPath());
      } else {
        if (flagsNum & O_DIRECTORY2)
          throw createError(ENOTDIR2, "open", link3.getPath());
      }
      if (!(flagsNum & O_WRONLY2)) {
        if (!node.canRead()) {
          throw createError(EACCES2, "open", link3.getPath());
        }
      }
      var file = new this.props.File(link3, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC2)
        file.truncate();
      return file;
    };
    Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var steps = filenameToSteps(filename);
      var link3 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
      if (!link3 && flagsNum & O_CREAT2) {
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
        if (!dirLink)
          throw createError(ENOENT2, "open", sep2 + steps.join(sep2));
        if (flagsNum & O_CREAT2 && typeof modeNum === "number") {
          link3 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }
      if (link3)
        return this.openLink(link3, flagsNum, resolveSymlinks);
      throw createError(ENOENT2, "open", filename);
    };
    Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file)
        throw createError(ENOENT2, "open", filename);
      return file.fd;
    };
    Volume2.prototype.openSync = function(path2, flags, mode) {
      if (mode === void 0) {
        mode = 438;
      }
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume2.prototype.open = function(path2, flags, a7, b5) {
      var mode = a7;
      var callback = b5;
      if (typeof a7 === "function") {
        mode = 438;
        callback = a7;
      }
      mode = mode || 438;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume2.prototype.closeFile = function(file) {
      if (!this.fds[file.fd])
        return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };
    Volume2.prototype.closeSync = function(fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, "close");
      this.closeFile(file);
    };
    Volume2.prototype.close = function(fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
      if (typeof id === "number") {
        var file = this.fds[id];
        if (!file)
          throw createError(ENOENT2);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };
    Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer2, Number(offset), Number(length), position);
    };
    Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer2, offset, length, position);
    };
    Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
      var _this = this;
      validateCallback(callback);
      if (length === 0) {
        return process_1.default.nextTick(function() {
          if (callback)
            callback(null, 0, buffer2);
        });
      }
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.readBase(fd, buffer2, offset, length, position);
          callback(null, bytes, buffer2);
        } catch (err) {
          callback(err);
        }
      });
    };
    Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === "number";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd)
        fd = id;
      else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link3 = this.getResolvedLink(steps);
        if (link3) {
          var node = link3.getNode();
          if (node.isDirectory())
            throw createError(EISDIR2, "open", link3.getPath());
        }
        fd = this.openSync(id, flagsNum);
      }
      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }
      return result;
    };
    Volume2.prototype.readFileSync = function(file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume2.prototype.readFile = function(id, a7, b5) {
      var _a2 = optsAndCbGenerator(getReadFileOptions)(a7, b5), opts = _a2[0], callback = _a2[1];
      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, "write");
      return file.write(buf, offset, length, position);
    };
    Volume2.prototype.writeSync = function(fd, a7, b5, c7, d6) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer4 = typeof a7 !== "string";
      if (isBuffer4) {
        offset = (b5 || 0) | 0;
        length = c7;
        position = d6;
      } else {
        position = b5;
        encoding = c7;
      }
      var buf = dataToBuffer(a7, encoding);
      if (isBuffer4) {
        if (typeof length === "undefined") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return this.writeBase(fd, buf, offset, length, position);
    };
    Volume2.prototype.write = function(fd, a7, b5, c7, d6, e10) {
      var _this = this;
      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a7;
      var tipb = typeof b5;
      var tipc = typeof c7;
      var tipd = typeof d6;
      if (tipa !== "string") {
        if (tipb === "function") {
          callback = b5;
        } else if (tipc === "function") {
          offset = b5 | 0;
          callback = c7;
        } else if (tipd === "function") {
          offset = b5 | 0;
          length = c7;
          callback = d6;
        } else {
          offset = b5 | 0;
          length = c7;
          position = d6;
          callback = e10;
        }
      } else {
        if (tipb === "function") {
          callback = b5;
        } else if (tipc === "function") {
          position = b5;
          callback = c7;
        } else if (tipd === "function") {
          position = b5;
          encoding = c7;
          callback = d6;
        }
      }
      var buf = dataToBuffer(a7, encoding);
      if (tipa !== "string") {
        if (typeof length === "undefined")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);
          if (tipa !== "string") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a7);
          }
        } catch (err) {
          cb(err);
        }
      });
    };
    Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
      var isUserFd = typeof id === "number";
      var fd;
      if (isUserFd)
        fd = id;
      else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND2 ? void 0 : 0;
      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== void 0)
            position += written;
        }
      } finally {
        if (!isUserFd)
          this.closeSync(fd);
      }
    };
    Volume2.prototype.writeFileSync = function(id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume2.prototype.writeFile = function(id, data, a7, b5) {
      var options = a7;
      var callback = b5;
      if (typeof a7 === "function") {
        options = writeFileDefaults;
        callback = a7;
      }
      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };
    Volume2.prototype.linkBase = function(filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1)
        throw createError(ENOENT2, "link", filename1, filename2);
      var steps2 = filenameToSteps(filename2);
      var dir2 = this.getLinkParent(steps2);
      if (!dir2)
        throw createError(ENOENT2, "link", filename1, filename2);
      var name3 = steps2[steps2.length - 1];
      if (dir2.getChild(name3))
        throw createError(EEXIST2, "link", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name3, node);
    };
    Volume2.prototype.copyFileBase = function(src, dest, flags) {
      var buf = this.readFileSync(src);
      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST2, "copyFile", src, dest);
        }
      }
      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS2, "copyFile", src, dest);
      }
      this.writeFileBase(
        dest,
        buf,
        FLAGS.w,
        438
        /* DEFAULT */
      );
    };
    Volume2.prototype.copyFileSync = function(src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };
    Volume2.prototype.copyFile = function(src, dest, a7, b5) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;
      if (typeof a7 === "function") {
        flags = 0;
        callback = a7;
      } else {
        flags = a7;
        callback = b5;
      }
      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume2.prototype.linkSync = function(existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume2.prototype.link = function(existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.unlinkBase = function(filename) {
      var steps = filenameToSteps(filename);
      var link3 = this.getLink(steps);
      if (!link3)
        throw createError(ENOENT2, "unlink", filename);
      if (link3.length)
        throw Error("Dir not empty...");
      this.deleteLink(link3);
      var node = link3.getNode();
      node.nlink--;
      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };
    Volume2.prototype.unlinkSync = function(path2) {
      var filename = pathToFilename(path2);
      this.unlinkBase(filename);
    };
    Volume2.prototype.unlink = function(path2, callback) {
      var filename = pathToFilename(path2);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename);
      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink)
        throw createError(ENOENT2, "symlink", targetFilename, pathFilename);
      var name3 = pathSteps[pathSteps.length - 1];
      if (dirLink.getChild(name3))
        throw createError(EEXIST2, "symlink", targetFilename, pathFilename);
      var symlink3 = dirLink.createChild(name3);
      symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink3;
    };
    Volume2.prototype.symlinkSync = function(target, path2, type2) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.symlinkBase(targetFilename, pathFilename);
    };
    Volume2.prototype.symlink = function(target, path2, a7, b5) {
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume2.prototype.realpathBase = function(filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink)
        throw createError(ENOENT2, "realpath", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };
    Volume2.prototype.realpathSync = function(path2, options) {
      return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
    };
    Volume2.prototype.realpath = function(path2, a7, b5) {
      var _a2 = getRealpathOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume2.prototype.lstatBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link3 = this.getLink(filenameToSteps(filename));
      if (!link3)
        throw createError(ENOENT2, "lstat", filename);
      return Stats_1.default.build(link3.getNode(), bigint);
    };
    Volume2.prototype.lstatSync = function(path2, options) {
      return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.lstat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.statBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link3 = this.getResolvedLink(filenameToSteps(filename));
      if (!link3)
        throw createError(ENOENT2, "stat", filename);
      return Stats_1.default.build(link3.getNode(), bigint);
    };
    Volume2.prototype.statSync = function(path2, options) {
      return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.stat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.fstatBase = function(fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF2, "fstat");
      return Stats_1.default.build(file.node, bigint);
    };
    Volume2.prototype.fstatSync = function(fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume2.prototype.fstat = function(fd, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
      var link3 = this.getLink(filenameToSteps(oldPathFilename));
      if (!link3)
        throw createError(ENOENT2, "rename", oldPathFilename, newPathFilename);
      var newPathSteps = filenameToSteps(newPathFilename);
      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink)
        throw createError(ENOENT2, "rename", oldPathFilename, newPathFilename);
      var oldLinkParent = link3.parent;
      if (oldLinkParent) {
        oldLinkParent.deleteChild(link3);
      }
      var name3 = newPathSteps[newPathSteps.length - 1];
      link3.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name3], false);
      newPathDirLink.setChild(link3.getName(), link3);
    };
    Volume2.prototype.renameSync = function(oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume2.prototype.rename = function(oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.existsBase = function(filename) {
      return !!this.statBase(filename);
    };
    Volume2.prototype.existsSync = function(path2) {
      try {
        return this.existsBase(pathToFilename(path2));
      } catch (err) {
        return false;
      }
    };
    Volume2.prototype.exists = function(path2, callback) {
      var _this = this;
      var filename = pathToFilename(path2);
      if (typeof callback !== "function")
        throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function() {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };
    Volume2.prototype.accessBase = function(filename, mode) {
      this.getLinkOrThrow(filename, "access");
    };
    Volume2.prototype.accessSync = function(path2, mode) {
      if (mode === void 0) {
        mode = F_OK3;
      }
      var filename = pathToFilename(path2);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };
    Volume2.prototype.access = function(path2, a7, b5) {
      var mode = F_OK3;
      var callback;
      if (typeof a7 !== "function") {
        mode = a7 | 0;
        callback = validateCallback(b5);
      } else {
        callback = a7;
      }
      var filename = pathToFilename(path2);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume2.prototype.appendFileSync = function(id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }
      var opts = getAppendFileOpts(options);
      if (!opts.flag || isFd(id))
        opts.flag = "a";
      this.writeFileSync(id, data, opts);
    };
    Volume2.prototype.appendFile = function(id, data, a7, b5) {
      var _a2 = getAppendFileOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      if (!opts.flag || isFd(id))
        opts.flag = "a";
      this.writeFile(id, data, opts, callback);
    };
    Volume2.prototype.readdirBase = function(filename, options) {
      var steps = filenameToSteps(filename);
      var link3 = this.getResolvedLink(steps);
      if (!link3)
        throw createError(ENOENT2, "readdir", filename);
      var node = link3.getNode();
      if (!node.isDirectory())
        throw createError(ENOTDIR2, "scandir", filename);
      if (options.withFileTypes) {
        var list_1 = [];
        for (var name_3 in link3.children) {
          var child = link3.getChild(name_3);
          if (!child) {
            continue;
          }
          list_1.push(Dirent_1.default.build(child, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list_1.sort(function(a7, b5) {
            if (a7.name < b5.name)
              return -1;
            if (a7.name > b5.name)
              return 1;
            return 0;
          });
        return list_1;
      }
      var list = [];
      for (var name_4 in link3.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }
      if (!isWin && options.encoding !== "buffer")
        list.sort();
      return list;
    };
    Volume2.prototype.readdirSync = function(path2, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path2);
      return this.readdirBase(filename, opts);
    };
    Volume2.prototype.readdir = function(path2, a7, b5) {
      var _a2 = getReaddirOptsAndCb(a7, b5), options = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume2.prototype.readlinkBase = function(filename, encoding) {
      var link3 = this.getLinkOrThrow(filename, "readlink");
      var node = link3.getNode();
      if (!node.isSymlink())
        throw createError(EINVAL2, "readlink", filename);
      var str = sep2 + node.symlink.join(sep2);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };
    Volume2.prototype.readlinkSync = function(path2, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path2);
      return this.readlinkBase(filename, opts.encoding);
    };
    Volume2.prototype.readlink = function(path2, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume2.prototype.fsyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fsync");
    };
    Volume2.prototype.fsyncSync = function(fd) {
      this.fsyncBase(fd);
    };
    Volume2.prototype.fsync = function(fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume2.prototype.fdatasyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fdatasync");
    };
    Volume2.prototype.fdatasyncSync = function(fd) {
      this.fdatasyncBase(fd);
    };
    Volume2.prototype.fdatasync = function(fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume2.prototype.ftruncateBase = function(fd, len) {
      var file = this.getFileByFdOrThrow(fd, "ftruncate");
      file.truncate(len);
    };
    Volume2.prototype.ftruncateSync = function(fd, len) {
      this.ftruncateBase(fd, len);
    };
    Volume2.prototype.ftruncate = function(fd, a7, b5) {
      var len = typeof a7 === "number" ? a7 : 0;
      var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume2.prototype.truncateBase = function(path2, len) {
      var fd = this.openSync(path2, "r+");
      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.truncateSync = function(id, len) {
      if (isFd(id))
        return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };
    Volume2.prototype.truncate = function(id, a7, b5) {
      var len = typeof a7 === "number" ? a7 : 0;
      var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
      if (isFd(id))
        return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume2.prototype.futimesBase = function(fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, "futimes");
      var node = file.node;
      node.atime = new Date(atime * 1e3);
      node.mtime = new Date(mtime * 1e3);
    };
    Volume2.prototype.futimesSync = function(fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.utimesBase = function(filename, atime, mtime) {
      var fd = this.openSync(filename, "r+");
      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.utimesSync = function(path2, atime, mtime) {
      this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.mkdirBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      if (!steps.length) {
        throw createError(EEXIST2, "mkdir", filename);
      }
      var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
      var name3 = steps[steps.length - 1];
      if (dir.getChild(name3))
        throw createError(EEXIST2, "mkdir", filename);
      dir.createChild(name3, this.createNode(true, modeNum));
    };
    Volume2.prototype.mkdirpBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link3 = this.root;
      for (var i7 = 0; i7 < steps.length; i7++) {
        var step = steps[i7];
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR2, "mkdir", link3.getPath());
        var child = link3.getChild(step);
        if (child) {
          if (child.getNode().isDirectory())
            link3 = child;
          else
            throw createError(ENOTDIR2, "mkdir", child.getPath());
        } else {
          link3 = link3.createChild(step, this.createNode(true, modeNum));
        }
      }
    };
    Volume2.prototype.mkdirSync = function(path2, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.mkdirpBase(filename, modeNum);
      else
        this.mkdirBase(filename, modeNum);
    };
    Volume2.prototype.mkdir = function(path2, a7, b5) {
      var opts = getMkdirOptions(a7);
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
      else
        this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    Volume2.prototype.mkdirpSync = function(path2, mode) {
      this.mkdirSync(path2, {
        mode,
        recursive: true
      });
    };
    Volume2.prototype.mkdirp = function(path2, a7, b5) {
      var mode = typeof a7 === "function" ? void 0 : a7;
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      this.mkdir(path2, {
        mode,
        recursive: true
      }, callback);
    };
    Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }
      var filename = prefix + this.genRndStr();
      try {
        this.mkdirBase(
          filename,
          511
          /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST2) {
          if (retry > 1)
            return this.mkdtempBase(prefix, encoding, retry - 1);
          else
            throw Error("Could not create temp dir.");
        } else
          throw err;
      }
    };
    Volume2.prototype.mkdtempSync = function(prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };
    Volume2.prototype.mkdtemp = function(prefix, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), encoding = _a2[0].encoding, callback = _a2[1];
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      if (!nullCheck(prefix))
        return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume2.prototype.rmdirBase = function(filename, options) {
      var opts = getRmdirOptions(options);
      var link3 = this.getLinkAsDirOrThrow(filename, "rmdir");
      if (link3.length && !opts.recursive)
        throw createError(ENOTEMPTY2, "rmdir", filename);
      this.deleteLink(link3);
    };
    Volume2.prototype.rmdirSync = function(path2, options) {
      this.rmdirBase(pathToFilename(path2), options);
    };
    Volume2.prototype.rmdir = function(path2, a7, b5) {
      var opts = getRmdirOptions(a7);
      var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
    };
    Volume2.prototype.fchmodBase = function(fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, "fchmod");
      file.chmod(modeNum);
    };
    Volume2.prototype.fchmodSync = function(fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume2.prototype.fchmod = function(fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume2.prototype.chmodBase = function(filename, modeNum) {
      var fd = this.openSync(filename, "r+");
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.chmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.chmodBase(filename, modeNum);
    };
    Volume2.prototype.chmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.lchmodBase = function(filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR2, 0, false);
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.lchmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.lchmodBase(filename, modeNum);
    };
    Volume2.prototype.lchmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.fchownBase = function(fd, uid, gid) {
      this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
    };
    Volume2.prototype.fchownSync = function(fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };
    Volume2.prototype.fchown = function(fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume2.prototype.chownBase = function(filename, uid, gid) {
      var link3 = this.getResolvedLinkOrThrow(filename, "chown");
      var node = link3.getNode();
      node.chown(uid, gid);
    };
    Volume2.prototype.chownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.chown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.lchownBase = function(filename, uid, gid) {
      this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
    };
    Volume2.prototype.lchownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.lchown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.watchFile = function(path2, a7, b5) {
      var filename = pathToFilename(path2);
      var options = a7;
      var listener = b5;
      if (typeof options === "function") {
        listener = a7;
        options = null;
      }
      if (typeof listener !== "function") {
        throw Error('"watchFile()" requires a listener function');
      }
      var interval = 5007;
      var persistent = true;
      if (options && typeof options === "object") {
        if (typeof options.interval === "number")
          interval = options.interval;
        if (typeof options.persistent === "boolean")
          persistent = options.persistent;
      }
      var watcher = this.statWatchers[filename];
      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }
      watcher.addListener("change", listener);
      return watcher;
    };
    Volume2.prototype.unwatchFile = function(path2, listener) {
      var filename = pathToFilename(path2);
      var watcher = this.statWatchers[filename];
      if (!watcher)
        return;
      if (typeof listener === "function") {
        watcher.removeListener("change", listener);
      } else {
        watcher.removeAllListeners("change");
      }
      if (watcher.listenerCount("change") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };
    Volume2.prototype.createReadStream = function(path2, options) {
      return new this.ReadStream(path2, options);
    };
    Volume2.prototype.createWriteStream = function(path2, options) {
      return new this.WriteStream(path2, options);
    };
    Volume2.prototype.watch = function(path2, options, listener) {
      var filename = pathToFilename(path2);
      var givenOptions = options;
      if (typeof options === "function") {
        listener = options;
        givenOptions = null;
      }
      var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
      if (persistent === void 0)
        persistent = true;
      if (recursive === void 0)
        recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);
      if (listener) {
        watcher.addListener("change", listener);
      }
      return watcher;
    };
    Volume2.fd = 2147483647;
    return Volume2;
  }();
  exports$42.Volume = Volume;
  function emitStop(self2) {
    self2.emit("stop");
  }
  var StatWatcher = function(_super) {
    __extends(StatWatcher2, _super);
    function StatWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this.onInterval = function() {
        try {
          var stats = _this.vol.statSync(_this.filename);
          if (_this.hasChanged(stats)) {
            _this.emit("change", stats, _this.prev);
            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };
      _this.vol = vol2;
      return _this;
    }
    StatWatcher2.prototype.loop = function() {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher2.prototype.hasChanged = function(stats) {
      if (stats.mtimeMs > this.prev.mtimeMs)
        return true;
      if (stats.nlink !== this.prev.nlink)
        return true;
      return false;
    };
    StatWatcher2.prototype.start = function(path2, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (interval === void 0) {
        interval = 5007;
      }
      this.filename = pathToFilename(path2);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global5) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };
    StatWatcher2.prototype.stop = function() {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher2;
  }(events_1.EventEmitter);
  exports$42.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  util.inherits(FsReadStream, stream_1.Readable);
  exports$42.ReadStream = FsReadStream;
  function FsReadStream(vol2, path2, options) {
    if (!(this instanceof FsReadStream))
      return new FsReadStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === void 0)
      options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "r" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw new TypeError('"end" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('"start" option must be <= "end" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== "number")
      this.open();
    this.on("end", function() {
      if (this.autoClose) {
        if (this.destroy)
          this.destroy();
      }
    });
  }
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy)
            self2.destroy();
        }
        self2.emit("error", er);
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n9) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._read(n9);
      });
    }
    if (this.destroyed)
      return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n9);
    var start = pool.used;
    if (this.pos !== void 0)
      toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0)
      return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0)
      this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit("error", er);
      } else {
        var b5 = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b5 = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b5);
      }
    }
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close(function(err2) {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _this = this;
    if (cb)
      this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit("close");
      });
    }
    this.closed = true;
    this._vol.close(this.fd, function(er) {
      if (er)
        _this.emit("error", er);
      else
        _this.emit("close");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  util.inherits(FsWriteStream, stream_1.Writable);
  exports$42.WriteStream = FsWriteStream;
  function FsWriteStream(vol2, path2, options) {
    if (!(this instanceof FsWriteStream))
      return new FsWriteStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "w" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('"start" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options.encoding)
      this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== "number")
      this.open();
    this.once("finish", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit("error", er);
        return;
      }
      this.fd = fd;
      this.emit("open", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer))
      return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._write(data, encoding, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._writev(data, cb);
      });
    }
    var self2 = this;
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i7 = 0; i7 < len; i7++) {
      var chunk = data[i7].chunk;
      chunks[i7] = chunk;
      size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.destroy)
          self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += size;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  var FSWatcher = function(_super) {
    __extends(FSWatcher2, _super);
    function FSWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this._filename = "";
      _this._filenameEncoded = "";
      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;
      _this._onNodeChange = function() {
        _this._emit("change");
      };
      _this._onParentChild = function(link3) {
        if (link3.getName() === _this._getName()) {
          _this._emit("rename");
        }
      };
      _this._emit = function(type2) {
        _this.emit("change", type2, _this._filenameEncoded);
      };
      _this._persist = function() {
        _this._timer = setTimeout(_this._persist, 1e6);
      };
      _this._vol = vol2;
      return _this;
    }
    FSWatcher2.prototype._getName = function() {
      return this._steps[this._steps.length - 1];
    };
    FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (recursive === void 0) {
        recursive = false;
      }
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      this._filename = pathToFilename(path2);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
      this._recursive = recursive;
      this._encoding = encoding;
      try {
        this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
      } catch (err) {
        var error = new Error("watch " + this._filename + " " + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }
      this._link.getNode().on("change", this._onNodeChange);
      this._link.on("child:add", this._onNodeChange);
      this._link.on("child:delete", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on("child:delete", this._onParentChild);
      }
      if (persistent)
        this._persist();
    };
    FSWatcher2.prototype.close = function() {
      clearTimeout(this._timer);
      this._link.getNode().removeListener("change", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.removeListener("child:delete", this._onParentChild);
      }
    };
    return FSWatcher2;
  }(events_1.EventEmitter);
  exports$42.FSWatcher = FSWatcher;
  return exports$42;
}
function dew$13() {
  if (_dewExec$13)
    return exports$33;
  _dewExec$13 = true;
  Object.defineProperty(exports$33, "__esModule", {
    value: true
  });
  exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
  var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
  exports$33.fsProps = fsProps;
  var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
  exports$33.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
  exports$33.fsAsyncMethods = fsAsyncMethods;
  return exports$33;
}
function dew8() {
  if (_dewExec8)
    return exports$23;
  _dewExec8 = true;
  var __assign = exports$23 && exports$23.__assign || function() {
    __assign = Object.assign || function(t9) {
      for (var s6, i7 = 1, n9 = arguments.length; i7 < n9; i7++) {
        s6 = arguments[i7];
        for (var p7 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p7))
            t9[p7] = s6[p7];
      }
      return t9;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports$23, "__esModule", {
    value: true
  });
  exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var volume_1 = dew$23();
  var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
  var constants_1 = dew$f2();
  var F_OK3 = constants_1.constants.F_OK, R_OK3 = constants_1.constants.R_OK, W_OK3 = constants_1.constants.W_OK, X_OK3 = constants_1.constants.X_OK;
  exports$23.Volume = volume_1.Volume;
  exports$23.vol = new volume_1.Volume();
  function createFsFromVolume2(vol2) {
    var fs2 = {
      F_OK: F_OK3,
      R_OK: R_OK3,
      W_OK: W_OK3,
      X_OK: X_OK3,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    };
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
      var method = fsAsyncMethods_1[_a2];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    fs2.StatWatcher = vol2.StatWatcher;
    fs2.FSWatcher = vol2.FSWatcher;
    fs2.WriteStream = vol2.WriteStream;
    fs2.ReadStream = vol2.ReadStream;
    fs2.promises = vol2.promises;
    fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs2;
  }
  exports$23.createFsFromVolume = createFsFromVolume2;
  exports$23.fs = createFsFromVolume2(exports$23.vol);
  exports$23 = __assign(__assign({}, exports$23), exports$23.fs);
  exports$23.semantic = true;
  return exports$23;
}
function unimplemented2(name3) {
  throw new Error(`Node.js fs ${name3} is not supported by JSPM core in the browser`);
}
function watchStdo(path2, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path2, "utf8", () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer2.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}
function handleFsUrl(url, isSync) {
  if (url.protocol === "file:")
    return fileURLToPath(url);
  if (url.protocol === "https:" || url.protocol === "http:") {
    const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
    if (existsSync(path2))
      return path2;
    if (isSync)
      throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
      const buf = await res.arrayBuffer();
      writeFileSync(path2, Buffer2.from(buf));
      return path2;
    })();
  }
  throw new Error("URL " + url + " not supported in JSPM FS implementation.");
}
function wrapFsSync(fn) {
  return function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(handleFsUrl(path2, true), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsPromise(fn) {
  return async function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(await handleFsUrl(path2), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsCallback(fn) {
  return function(path2, ...args) {
    const cb = args[args.length - 1];
    if (path2 instanceof URL && typeof cb === "function") {
      handleFsUrl(path2).then((path3) => {
        fn(path3, ...args);
      }, cb);
    } else {
      fn(path2, ...args);
    }
  };
}
var exports$h, _dewExec$f2, exports$g2, _dewExec$e2, exports$f2, _dewExec$d2, exports$e2, _dewExec$c2, exports$d2, _dewExec$b2, _global$3, exports$c2, _dewExec$a2, exports$b2, _dewExec$92, exports$a2, _dewExec$82, _global$22, exports$92, _dewExec$72, exports$82, _dewExec$62, exports$72, _dewExec$52, _global$12, exports$62, _dewExec$42, exports$52, _dewExec$32, exports$42, _dewExec$23, _global5, exports$33, _dewExec$13, exports$23, _dewExec8, exports$16, exports8, vol, createFsFromVolume, fs, appendFile, appendFileSync, access, accessSync, chown, chownSync, chmod, chmodSync, close, closeSync, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, exists, existsSync, fchown, fchownSync, fchmod, fchmodSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchown, lchownSync, lchmod, lchmodSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, readdir, readdirSync, read, readSync, readv, readvSync, readFile, readFileSync, readlink, readlinkSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unwatchFile, unlink, unlinkSync, utimes, utimesSync, watch, watchFile, writeFile, writeFileSync, write, writeSync, writev, writevSync, Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, _toUnixTimestamp, F_OK, R_OK, W_OK, X_OK, constants2, promises2;
var init_fs = __esm({
  "node_modules/@jspm/core/nodelibs/browser/fs.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_44e51b61();
    init_assert();
    init_util();
    init_chunk_b4205b57();
    init_path();
    init_chunk_2eac56ff();
    init_events();
    init_chunk_4bd36a8f();
    init_stream();
    init_url();
    init_chunk_23dbec7b();
    init_chunk_6c718bbe();
    init_buffer();
    init_chunk_ce0fbc82();
    init_chunk_5decc758();
    init_chunk_4ccc3a29();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    exports$h = {};
    _dewExec$f2 = false;
    exports$g2 = {};
    _dewExec$e2 = false;
    exports$f2 = {};
    _dewExec$d2 = false;
    exports$e2 = {};
    _dewExec$c2 = false;
    exports$d2 = {};
    _dewExec$b2 = false;
    _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$c2 = {};
    _dewExec$a2 = false;
    exports$b2 = {};
    _dewExec$92 = false;
    exports$a2 = {};
    _dewExec$82 = false;
    _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$92 = {};
    _dewExec$72 = false;
    exports$82 = {};
    _dewExec$62 = false;
    exports$72 = {};
    _dewExec$52 = false;
    _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$62 = {};
    _dewExec$42 = false;
    exports$52 = {};
    _dewExec$32 = false;
    exports$42 = {};
    _dewExec$23 = false;
    _global5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$33 = {};
    _dewExec$13 = false;
    exports$23 = {};
    _dewExec8 = false;
    exports$16 = dew8();
    exports$16["__esModule"];
    exports$16["fs"];
    exports$16["createFsFromVolume"];
    exports$16["vol"];
    exports$16["Volume"];
    exports$16["semantic"];
    exports8 = dew$23();
    exports8["__esModule"];
    exports8["FSWatcher"];
    exports8["StatWatcher"];
    exports8["Volume"];
    exports8["toUnixTimestamp"];
    exports8["bufferToEncoding"];
    exports8["dataToBuffer"];
    exports8["dataToStr"];
    exports8["pathToSteps"];
    exports8["filenameToSteps"];
    exports8["pathToFilename"];
    exports8["flagsToNumber"];
    exports8["FLAGS"];
    exports8["ReadStream"];
    exports8["WriteStream"];
    ({ vol, createFsFromVolume } = exports$16);
    vol.fromNestedJSON({
      "/dev": { stdin: "", stdout: "", stderr: "" },
      "/usr/bin": {},
      "/home": {},
      "/tmp": {}
    });
    vol.releasedFds = [2, 1, 0];
    vol.openSync("/dev/stdin", "w");
    vol.openSync("/dev/stdout", "r");
    vol.openSync("/dev/stderr", "r");
    watchStdo("/dev/stdout", 1, console.log);
    watchStdo("/dev/stderr", 2, console.error);
    fs = createFsFromVolume(vol);
    fs.opendir = () => unimplemented2("opendir");
    fs.opendirSync = () => unimplemented2("opendirSync");
    fs.promises.opendir = () => unimplemented2("promises.opendir");
    fs.cp = () => unimplemented2("cp");
    fs.cpSync = () => unimplemented2("cpSync");
    fs.promises.cp = () => unimplemented2("promises.cp");
    fs.readv = () => unimplemented2("readv");
    fs.readvSync = () => unimplemented2("readvSync");
    fs.rm = () => unimplemented2("rm");
    fs.rmSync = () => unimplemented2("rmSync");
    fs.promises.rm = () => unimplemented2("promises.rm");
    fs.Dir = () => unimplemented2("Dir");
    fs.promises.watch = () => unimplemented2("promises.watch");
    fs.FileReadStream = fs.ReadStream;
    fs.FileWriteStream = fs.WriteStream;
    fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
    fs.readFile = wrapFsCallback(fs.readFile);
    fs.readFileSync = wrapFsSync(fs.readFileSync);
    ({
      appendFile,
      appendFileSync,
      access,
      accessSync,
      chown,
      chownSync,
      chmod,
      chmodSync,
      close,
      closeSync,
      copyFile,
      copyFileSync,
      cp,
      cpSync,
      createReadStream,
      createWriteStream,
      exists,
      existsSync,
      fchown,
      fchownSync,
      fchmod,
      fchmodSync,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      lchown,
      lchownSync,
      lchmod,
      lchmodSync,
      link,
      linkSync,
      lstat,
      lstatSync,
      mkdir,
      mkdirSync,
      mkdtemp,
      mkdtempSync,
      open,
      openSync,
      opendir,
      opendirSync,
      readdir,
      readdirSync,
      read,
      readSync,
      readv,
      readvSync,
      readFile,
      readFileSync,
      readlink,
      readlinkSync,
      realpath,
      realpathSync,
      rename,
      renameSync,
      rm,
      rmSync,
      rmdir,
      rmdirSync,
      stat,
      statSync,
      symlink,
      symlinkSync,
      truncate,
      truncateSync,
      unwatchFile,
      unlink,
      unlinkSync,
      utimes,
      utimesSync,
      watch,
      watchFile,
      writeFile,
      writeFileSync,
      write,
      writeSync,
      writev,
      writevSync,
      Dir,
      Dirent,
      Stats,
      ReadStream,
      WriteStream,
      FileReadStream,
      FileWriteStream,
      _toUnixTimestamp,
      constants: { F_OK, R_OK, W_OK, X_OK },
      constants: constants2,
      promises: promises2
    } = fs);
  }
});

// node_modules/@jspm/core/nodelibs/browser/constants.js
var constants_exports = {};
__export(constants_exports, {
  DH_CHECK_P_NOT_PRIME: () => DH_CHECK_P_NOT_PRIME,
  DH_CHECK_P_NOT_SAFE_PRIME: () => DH_CHECK_P_NOT_SAFE_PRIME,
  DH_NOT_SUITABLE_GENERATOR: () => DH_NOT_SUITABLE_GENERATOR,
  DH_UNABLE_TO_CHECK_GENERATOR: () => DH_UNABLE_TO_CHECK_GENERATOR,
  E2BIG: () => E2BIG,
  EACCES: () => EACCES,
  EADDRINUSE: () => EADDRINUSE,
  EADDRNOTAVAIL: () => EADDRNOTAVAIL,
  EAFNOSUPPORT: () => EAFNOSUPPORT,
  EAGAIN: () => EAGAIN,
  EALREADY: () => EALREADY,
  EBADF: () => EBADF,
  EBADMSG: () => EBADMSG,
  EBUSY: () => EBUSY,
  ECANCELED: () => ECANCELED,
  ECHILD: () => ECHILD,
  ECONNABORTED: () => ECONNABORTED,
  ECONNREFUSED: () => ECONNREFUSED,
  ECONNRESET: () => ECONNRESET,
  EDEADLK: () => EDEADLK,
  EDESTADDRREQ: () => EDESTADDRREQ,
  EDOM: () => EDOM,
  EDQUOT: () => EDQUOT,
  EEXIST: () => EEXIST,
  EFAULT: () => EFAULT,
  EFBIG: () => EFBIG,
  EHOSTUNREACH: () => EHOSTUNREACH,
  EIDRM: () => EIDRM,
  EILSEQ: () => EILSEQ,
  EINPROGRESS: () => EINPROGRESS,
  EINTR: () => EINTR,
  EINVAL: () => EINVAL,
  EIO: () => EIO,
  EISCONN: () => EISCONN,
  EISDIR: () => EISDIR,
  ELOOP: () => ELOOP,
  EMFILE: () => EMFILE,
  EMLINK: () => EMLINK,
  EMSGSIZE: () => EMSGSIZE,
  EMULTIHOP: () => EMULTIHOP,
  ENAMETOOLONG: () => ENAMETOOLONG,
  ENETDOWN: () => ENETDOWN,
  ENETRESET: () => ENETRESET,
  ENETUNREACH: () => ENETUNREACH,
  ENFILE: () => ENFILE,
  ENGINE_METHOD_ALL: () => ENGINE_METHOD_ALL,
  ENGINE_METHOD_CIPHERS: () => ENGINE_METHOD_CIPHERS,
  ENGINE_METHOD_DH: () => ENGINE_METHOD_DH,
  ENGINE_METHOD_DIGESTS: () => ENGINE_METHOD_DIGESTS,
  ENGINE_METHOD_DSA: () => ENGINE_METHOD_DSA,
  ENGINE_METHOD_ECDH: () => ENGINE_METHOD_ECDH,
  ENGINE_METHOD_ECDSA: () => ENGINE_METHOD_ECDSA,
  ENGINE_METHOD_NONE: () => ENGINE_METHOD_NONE,
  ENGINE_METHOD_PKEY_ASN1_METHS: () => ENGINE_METHOD_PKEY_ASN1_METHS,
  ENGINE_METHOD_PKEY_METHS: () => ENGINE_METHOD_PKEY_METHS,
  ENGINE_METHOD_RAND: () => ENGINE_METHOD_RAND,
  ENGINE_METHOD_STORE: () => ENGINE_METHOD_STORE,
  ENOBUFS: () => ENOBUFS,
  ENODATA: () => ENODATA,
  ENODEV: () => ENODEV,
  ENOENT: () => ENOENT,
  ENOEXEC: () => ENOEXEC,
  ENOLCK: () => ENOLCK,
  ENOLINK: () => ENOLINK,
  ENOMEM: () => ENOMEM,
  ENOMSG: () => ENOMSG,
  ENOPROTOOPT: () => ENOPROTOOPT,
  ENOSPC: () => ENOSPC,
  ENOSR: () => ENOSR,
  ENOSTR: () => ENOSTR,
  ENOSYS: () => ENOSYS,
  ENOTCONN: () => ENOTCONN,
  ENOTDIR: () => ENOTDIR,
  ENOTEMPTY: () => ENOTEMPTY,
  ENOTSOCK: () => ENOTSOCK,
  ENOTSUP: () => ENOTSUP,
  ENOTTY: () => ENOTTY,
  ENXIO: () => ENXIO,
  EOPNOTSUPP: () => EOPNOTSUPP,
  EOVERFLOW: () => EOVERFLOW,
  EPERM: () => EPERM,
  EPIPE: () => EPIPE,
  EPROTO: () => EPROTO,
  EPROTONOSUPPORT: () => EPROTONOSUPPORT,
  EPROTOTYPE: () => EPROTOTYPE,
  ERANGE: () => ERANGE,
  EROFS: () => EROFS,
  ESPIPE: () => ESPIPE,
  ESRCH: () => ESRCH,
  ESTALE: () => ESTALE,
  ETIME: () => ETIME,
  ETIMEDOUT: () => ETIMEDOUT,
  ETXTBSY: () => ETXTBSY,
  EWOULDBLOCK: () => EWOULDBLOCK,
  EXDEV: () => EXDEV,
  F_OK: () => F_OK2,
  NPN_ENABLED: () => NPN_ENABLED,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_EXCL: () => O_EXCL,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYMLINK: () => O_SYMLINK,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  POINT_CONVERSION_COMPRESSED: () => POINT_CONVERSION_COMPRESSED,
  POINT_CONVERSION_HYBRID: () => POINT_CONVERSION_HYBRID,
  POINT_CONVERSION_UNCOMPRESSED: () => POINT_CONVERSION_UNCOMPRESSED,
  RSA_NO_PADDING: () => RSA_NO_PADDING,
  RSA_PKCS1_OAEP_PADDING: () => RSA_PKCS1_OAEP_PADDING,
  RSA_PKCS1_PADDING: () => RSA_PKCS1_PADDING,
  RSA_PKCS1_PSS_PADDING: () => RSA_PKCS1_PSS_PADDING,
  RSA_SSLV23_PADDING: () => RSA_SSLV23_PADDING,
  RSA_X931_PADDING: () => RSA_X931_PADDING,
  R_OK: () => R_OK2,
  SIGABRT: () => SIGABRT,
  SIGALRM: () => SIGALRM,
  SIGBUS: () => SIGBUS,
  SIGCHLD: () => SIGCHLD,
  SIGCONT: () => SIGCONT,
  SIGFPE: () => SIGFPE,
  SIGHUP: () => SIGHUP,
  SIGILL: () => SIGILL,
  SIGINT: () => SIGINT,
  SIGIO: () => SIGIO,
  SIGIOT: () => SIGIOT,
  SIGKILL: () => SIGKILL,
  SIGPIPE: () => SIGPIPE,
  SIGPROF: () => SIGPROF,
  SIGQUIT: () => SIGQUIT,
  SIGSEGV: () => SIGSEGV,
  SIGSTOP: () => SIGSTOP,
  SIGSYS: () => SIGSYS,
  SIGTERM: () => SIGTERM,
  SIGTRAP: () => SIGTRAP,
  SIGTSTP: () => SIGTSTP,
  SIGTTIN: () => SIGTTIN,
  SIGTTOU: () => SIGTTOU,
  SIGURG: () => SIGURG,
  SIGUSR1: () => SIGUSR1,
  SIGUSR2: () => SIGUSR2,
  SIGVTALRM: () => SIGVTALRM,
  SIGWINCH: () => SIGWINCH,
  SIGXCPU: () => SIGXCPU,
  SIGXFSZ: () => SIGXFSZ,
  SSL_OP_ALL: () => SSL_OP_ALL,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: () => SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
  SSL_OP_CIPHER_SERVER_PREFERENCE: () => SSL_OP_CIPHER_SERVER_PREFERENCE,
  SSL_OP_CISCO_ANYCONNECT: () => SSL_OP_CISCO_ANYCONNECT,
  SSL_OP_COOKIE_EXCHANGE: () => SSL_OP_COOKIE_EXCHANGE,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: () => SSL_OP_CRYPTOPRO_TLSEXT_BUG,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: () => SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
  SSL_OP_EPHEMERAL_RSA: () => SSL_OP_EPHEMERAL_RSA,
  SSL_OP_LEGACY_SERVER_CONNECT: () => SSL_OP_LEGACY_SERVER_CONNECT,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: () => SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER,
  SSL_OP_MICROSOFT_SESS_ID_BUG: () => SSL_OP_MICROSOFT_SESS_ID_BUG,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: () => SSL_OP_MSIE_SSLV2_RSA_PADDING,
  SSL_OP_NETSCAPE_CA_DN_BUG: () => SSL_OP_NETSCAPE_CA_DN_BUG,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: () => SSL_OP_NETSCAPE_CHALLENGE_BUG,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: () => SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: () => SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG,
  SSL_OP_NO_COMPRESSION: () => SSL_OP_NO_COMPRESSION,
  SSL_OP_NO_QUERY_MTU: () => SSL_OP_NO_QUERY_MTU,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: () => SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
  SSL_OP_NO_SSLv2: () => SSL_OP_NO_SSLv2,
  SSL_OP_NO_SSLv3: () => SSL_OP_NO_SSLv3,
  SSL_OP_NO_TICKET: () => SSL_OP_NO_TICKET,
  SSL_OP_NO_TLSv1: () => SSL_OP_NO_TLSv1,
  SSL_OP_NO_TLSv1_1: () => SSL_OP_NO_TLSv1_1,
  SSL_OP_NO_TLSv1_2: () => SSL_OP_NO_TLSv1_2,
  SSL_OP_PKCS1_CHECK_1: () => SSL_OP_PKCS1_CHECK_1,
  SSL_OP_PKCS1_CHECK_2: () => SSL_OP_PKCS1_CHECK_2,
  SSL_OP_SINGLE_DH_USE: () => SSL_OP_SINGLE_DH_USE,
  SSL_OP_SINGLE_ECDH_USE: () => SSL_OP_SINGLE_ECDH_USE,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: () => SSL_OP_SSLEAY_080_CLIENT_DH_BUG,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: () => SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG,
  SSL_OP_TLS_BLOCK_PADDING_BUG: () => SSL_OP_TLS_BLOCK_PADDING_BUG,
  SSL_OP_TLS_D5_BUG: () => SSL_OP_TLS_D5_BUG,
  SSL_OP_TLS_ROLLBACK_BUG: () => SSL_OP_TLS_ROLLBACK_BUG,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_UDP_REUSEADDR: () => UV_UDP_REUSEADDR,
  W_OK: () => W_OK2,
  X_OK: () => X_OK2,
  default: () => constants3
});
var constants3, DH_CHECK_P_NOT_PRIME, DH_CHECK_P_NOT_SAFE_PRIME, DH_NOT_SUITABLE_GENERATOR, DH_UNABLE_TO_CHECK_GENERATOR, E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, EAFNOSUPPORT, EAGAIN, EALREADY, EBADF, EBADMSG, EBUSY, ECANCELED, ECHILD, ECONNABORTED, ECONNREFUSED, ECONNRESET, EDEADLK, EDESTADDRREQ, EDOM, EDQUOT, EEXIST, EFAULT, EFBIG, EHOSTUNREACH, EIDRM, EILSEQ, EINPROGRESS, EINTR, EINVAL, EIO, EISCONN, EISDIR, ELOOP, EMFILE, EMLINK, EMSGSIZE, EMULTIHOP, ENAMETOOLONG, ENETDOWN, ENETRESET, ENETUNREACH, ENFILE, ENGINE_METHOD_ALL, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DH, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_DSA, ENGINE_METHOD_ECDH, ENGINE_METHOD_ECDSA, ENGINE_METHOD_NONE, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_RAND, ENGINE_METHOD_STORE, ENOBUFS, ENODATA, ENODEV, ENOENT, ENOEXEC, ENOLCK, ENOLINK, ENOMEM, ENOMSG, ENOPROTOOPT, ENOSPC, ENOSR, ENOSTR, ENOSYS, ENOTCONN, ENOTDIR, ENOTEMPTY, ENOTSOCK, ENOTSUP, ENOTTY, ENXIO, EOPNOTSUPP, EOVERFLOW, EPERM, EPIPE, EPROTO, EPROTONOSUPPORT, EPROTOTYPE, ERANGE, EROFS, ESPIPE, ESRCH, ESTALE, ETIME, ETIMEDOUT, ETXTBSY, EWOULDBLOCK, EXDEV, F_OK2, NPN_ENABLED, O_APPEND, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYMLINK, O_SYNC, O_TRUNC, O_WRONLY, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_HYBRID, POINT_CONVERSION_UNCOMPRESSED, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_PKCS1_PADDING, RSA_PKCS1_PSS_PADDING, RSA_SSLV23_PADDING, RSA_X931_PADDING, R_OK2, SIGABRT, SIGALRM, SIGBUS, SIGCHLD, SIGCONT, SIGFPE, SIGHUP, SIGILL, SIGINT, SIGIO, SIGIOT, SIGKILL, SIGPIPE, SIGPROF, SIGQUIT, SIGSEGV, SIGSTOP, SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGUSR1, SIGUSR2, SIGVTALRM, SIGWINCH, SIGXCPU, SIGXFSZ, SSL_OP_ALL, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_EPHEMERAL_RSA, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER, SSL_OP_MICROSOFT_SESS_ID_BUG, SSL_OP_MSIE_SSLV2_RSA_PADDING, SSL_OP_NETSCAPE_CA_DN_BUG, SSL_OP_NETSCAPE_CHALLENGE_BUG, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, SSL_OP_NO_COMPRESSION, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_PKCS1_CHECK_1, SSL_OP_PKCS1_CHECK_2, SSL_OP_SINGLE_DH_USE, SSL_OP_SINGLE_ECDH_USE, SSL_OP_SSLEAY_080_CLIENT_DH_BUG, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG, SSL_OP_TLS_BLOCK_PADDING_BUG, SSL_OP_TLS_D5_BUG, SSL_OP_TLS_ROLLBACK_BUG, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK, S_IRGRP, S_IROTH, S_IRUSR, S_IRWXG, S_IRWXO, S_IRWXU, S_IWGRP, S_IWOTH, S_IWUSR, S_IXGRP, S_IXOTH, S_IXUSR, UV_UDP_REUSEADDR, W_OK2, X_OK2;
var init_constants = __esm({
  "node_modules/@jspm/core/nodelibs/browser/constants.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    constants3 = {
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFBLK": 24576,
      "S_IFIFO": 4096,
      "S_IFLNK": 40960,
      "S_IFSOCK": 49152,
      "O_CREAT": 512,
      "O_EXCL": 2048,
      "O_NOCTTY": 131072,
      "O_TRUNC": 1024,
      "O_APPEND": 8,
      "O_DIRECTORY": 1048576,
      "O_NOFOLLOW": 256,
      "O_SYNC": 128,
      "O_SYMLINK": 2097152,
      "O_NONBLOCK": 4,
      "S_IRWXU": 448,
      "S_IRUSR": 256,
      "S_IWUSR": 128,
      "S_IXUSR": 64,
      "S_IRWXG": 56,
      "S_IRGRP": 32,
      "S_IWGRP": 16,
      "S_IXGRP": 8,
      "S_IRWXO": 7,
      "S_IROTH": 4,
      "S_IWOTH": 2,
      "S_IXOTH": 1,
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 48,
      "EADDRNOTAVAIL": 49,
      "EAFNOSUPPORT": 47,
      "EAGAIN": 35,
      "EALREADY": 37,
      "EBADF": 9,
      "EBADMSG": 94,
      "EBUSY": 16,
      "ECANCELED": 89,
      "ECHILD": 10,
      "ECONNABORTED": 53,
      "ECONNREFUSED": 61,
      "ECONNRESET": 54,
      "EDEADLK": 11,
      "EDESTADDRREQ": 39,
      "EDOM": 33,
      "EDQUOT": 69,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 65,
      "EIDRM": 90,
      "EILSEQ": 92,
      "EINPROGRESS": 36,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 56,
      "EISDIR": 21,
      "ELOOP": 62,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 40,
      "EMULTIHOP": 95,
      "ENAMETOOLONG": 63,
      "ENETDOWN": 50,
      "ENETRESET": 52,
      "ENETUNREACH": 51,
      "ENFILE": 23,
      "ENOBUFS": 55,
      "ENODATA": 96,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 77,
      "ENOLINK": 97,
      "ENOMEM": 12,
      "ENOMSG": 91,
      "ENOPROTOOPT": 42,
      "ENOSPC": 28,
      "ENOSR": 98,
      "ENOSTR": 99,
      "ENOSYS": 78,
      "ENOTCONN": 57,
      "ENOTDIR": 20,
      "ENOTEMPTY": 66,
      "ENOTSOCK": 38,
      "ENOTSUP": 45,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 102,
      "EOVERFLOW": 84,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 100,
      "EPROTONOSUPPORT": 43,
      "EPROTOTYPE": 41,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ESTALE": 70,
      "ETIME": 101,
      "ETIMEDOUT": 60,
      "ETXTBSY": 26,
      "EWOULDBLOCK": 35,
      "EXDEV": 18,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGQUIT": 3,
      "SIGILL": 4,
      "SIGTRAP": 5,
      "SIGABRT": 6,
      "SIGIOT": 6,
      "SIGBUS": 10,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGUSR1": 30,
      "SIGSEGV": 11,
      "SIGUSR2": 31,
      "SIGPIPE": 13,
      "SIGALRM": 14,
      "SIGTERM": 15,
      "SIGCHLD": 20,
      "SIGCONT": 19,
      "SIGSTOP": 17,
      "SIGTSTP": 18,
      "SIGTTIN": 21,
      "SIGTTOU": 22,
      "SIGURG": 16,
      "SIGXCPU": 24,
      "SIGXFSZ": 25,
      "SIGVTALRM": 26,
      "SIGPROF": 27,
      "SIGWINCH": 28,
      "SIGIO": 23,
      "SIGSYS": 12,
      "SSL_OP_ALL": 2147486719,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 16777216,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_SINGLE_DH_USE": 1048576,
      "SSL_OP_SINGLE_ECDH_USE": 524288,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
      "SSL_OP_TLS_D5_BUG": 256,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_ECDH": 16,
      "ENGINE_METHOD_ECDSA": 32,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_STORE": 256,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "NPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_UDP_REUSEADDR": 4
    };
    DH_CHECK_P_NOT_PRIME = constants3.DH_CHECK_P_NOT_PRIME;
    DH_CHECK_P_NOT_SAFE_PRIME = constants3.DH_CHECK_P_NOT_SAFE_PRIME;
    DH_NOT_SUITABLE_GENERATOR = constants3.DH_NOT_SUITABLE_GENERATOR;
    DH_UNABLE_TO_CHECK_GENERATOR = constants3.DH_UNABLE_TO_CHECK_GENERATOR;
    E2BIG = constants3.E2BIG;
    EACCES = constants3.EACCES;
    EADDRINUSE = constants3.EADDRINUSE;
    EADDRNOTAVAIL = constants3.EADDRNOTAVAIL;
    EAFNOSUPPORT = constants3.EAFNOSUPPORT;
    EAGAIN = constants3.EAGAIN;
    EALREADY = constants3.EALREADY;
    EBADF = constants3.EBADF;
    EBADMSG = constants3.EBADMSG;
    EBUSY = constants3.EBUSY;
    ECANCELED = constants3.ECANCELED;
    ECHILD = constants3.ECHILD;
    ECONNABORTED = constants3.ECONNABORTED;
    ECONNREFUSED = constants3.ECONNREFUSED;
    ECONNRESET = constants3.ECONNRESET;
    EDEADLK = constants3.EDEADLK;
    EDESTADDRREQ = constants3.EDESTADDRREQ;
    EDOM = constants3.EDOM;
    EDQUOT = constants3.EDQUOT;
    EEXIST = constants3.EEXIST;
    EFAULT = constants3.EFAULT;
    EFBIG = constants3.EFBIG;
    EHOSTUNREACH = constants3.EHOSTUNREACH;
    EIDRM = constants3.EIDRM;
    EILSEQ = constants3.EILSEQ;
    EINPROGRESS = constants3.EINPROGRESS;
    EINTR = constants3.EINTR;
    EINVAL = constants3.EINVAL;
    EIO = constants3.EIO;
    EISCONN = constants3.EISCONN;
    EISDIR = constants3.EISDIR;
    ELOOP = constants3.ELOOP;
    EMFILE = constants3.EMFILE;
    EMLINK = constants3.EMLINK;
    EMSGSIZE = constants3.EMSGSIZE;
    EMULTIHOP = constants3.EMULTIHOP;
    ENAMETOOLONG = constants3.ENAMETOOLONG;
    ENETDOWN = constants3.ENETDOWN;
    ENETRESET = constants3.ENETRESET;
    ENETUNREACH = constants3.ENETUNREACH;
    ENFILE = constants3.ENFILE;
    ENGINE_METHOD_ALL = constants3.ENGINE_METHOD_ALL;
    ENGINE_METHOD_CIPHERS = constants3.ENGINE_METHOD_CIPHERS;
    ENGINE_METHOD_DH = constants3.ENGINE_METHOD_DH;
    ENGINE_METHOD_DIGESTS = constants3.ENGINE_METHOD_DIGESTS;
    ENGINE_METHOD_DSA = constants3.ENGINE_METHOD_DSA;
    ENGINE_METHOD_ECDH = constants3.ENGINE_METHOD_ECDH;
    ENGINE_METHOD_ECDSA = constants3.ENGINE_METHOD_ECDSA;
    ENGINE_METHOD_NONE = constants3.ENGINE_METHOD_NONE;
    ENGINE_METHOD_PKEY_ASN1_METHS = constants3.ENGINE_METHOD_PKEY_ASN1_METHS;
    ENGINE_METHOD_PKEY_METHS = constants3.ENGINE_METHOD_PKEY_METHS;
    ENGINE_METHOD_RAND = constants3.ENGINE_METHOD_RAND;
    ENGINE_METHOD_STORE = constants3.ENGINE_METHOD_STORE;
    ENOBUFS = constants3.ENOBUFS;
    ENODATA = constants3.ENODATA;
    ENODEV = constants3.ENODEV;
    ENOENT = constants3.ENOENT;
    ENOEXEC = constants3.ENOEXEC;
    ENOLCK = constants3.ENOLCK;
    ENOLINK = constants3.ENOLINK;
    ENOMEM = constants3.ENOMEM;
    ENOMSG = constants3.ENOMSG;
    ENOPROTOOPT = constants3.ENOPROTOOPT;
    ENOSPC = constants3.ENOSPC;
    ENOSR = constants3.ENOSR;
    ENOSTR = constants3.ENOSTR;
    ENOSYS = constants3.ENOSYS;
    ENOTCONN = constants3.ENOTCONN;
    ENOTDIR = constants3.ENOTDIR;
    ENOTEMPTY = constants3.ENOTEMPTY;
    ENOTSOCK = constants3.ENOTSOCK;
    ENOTSUP = constants3.ENOTSUP;
    ENOTTY = constants3.ENOTTY;
    ENXIO = constants3.ENXIO;
    EOPNOTSUPP = constants3.EOPNOTSUPP;
    EOVERFLOW = constants3.EOVERFLOW;
    EPERM = constants3.EPERM;
    EPIPE = constants3.EPIPE;
    EPROTO = constants3.EPROTO;
    EPROTONOSUPPORT = constants3.EPROTONOSUPPORT;
    EPROTOTYPE = constants3.EPROTOTYPE;
    ERANGE = constants3.ERANGE;
    EROFS = constants3.EROFS;
    ESPIPE = constants3.ESPIPE;
    ESRCH = constants3.ESRCH;
    ESTALE = constants3.ESTALE;
    ETIME = constants3.ETIME;
    ETIMEDOUT = constants3.ETIMEDOUT;
    ETXTBSY = constants3.ETXTBSY;
    EWOULDBLOCK = constants3.EWOULDBLOCK;
    EXDEV = constants3.EXDEV;
    F_OK2 = constants3.F_OK;
    NPN_ENABLED = constants3.NPN_ENABLED;
    O_APPEND = constants3.O_APPEND;
    O_CREAT = constants3.O_CREAT;
    O_DIRECTORY = constants3.O_DIRECTORY;
    O_EXCL = constants3.O_EXCL;
    O_NOCTTY = constants3.O_NOCTTY;
    O_NOFOLLOW = constants3.O_NOFOLLOW;
    O_NONBLOCK = constants3.O_NONBLOCK;
    O_RDONLY = constants3.O_RDONLY;
    O_RDWR = constants3.O_RDWR;
    O_SYMLINK = constants3.O_SYMLINK;
    O_SYNC = constants3.O_SYNC;
    O_TRUNC = constants3.O_TRUNC;
    O_WRONLY = constants3.O_WRONLY;
    POINT_CONVERSION_COMPRESSED = constants3.POINT_CONVERSION_COMPRESSED;
    POINT_CONVERSION_HYBRID = constants3.POINT_CONVERSION_HYBRID;
    POINT_CONVERSION_UNCOMPRESSED = constants3.POINT_CONVERSION_UNCOMPRESSED;
    RSA_NO_PADDING = constants3.RSA_NO_PADDING;
    RSA_PKCS1_OAEP_PADDING = constants3.RSA_PKCS1_OAEP_PADDING;
    RSA_PKCS1_PADDING = constants3.RSA_PKCS1_PADDING;
    RSA_PKCS1_PSS_PADDING = constants3.RSA_PKCS1_PSS_PADDING;
    RSA_SSLV23_PADDING = constants3.RSA_SSLV23_PADDING;
    RSA_X931_PADDING = constants3.RSA_X931_PADDING;
    R_OK2 = constants3.R_OK;
    SIGABRT = constants3.SIGABRT;
    SIGALRM = constants3.SIGALRM;
    SIGBUS = constants3.SIGBUS;
    SIGCHLD = constants3.SIGCHLD;
    SIGCONT = constants3.SIGCONT;
    SIGFPE = constants3.SIGFPE;
    SIGHUP = constants3.SIGHUP;
    SIGILL = constants3.SIGILL;
    SIGINT = constants3.SIGINT;
    SIGIO = constants3.SIGIO;
    SIGIOT = constants3.SIGIOT;
    SIGKILL = constants3.SIGKILL;
    SIGPIPE = constants3.SIGPIPE;
    SIGPROF = constants3.SIGPROF;
    SIGQUIT = constants3.SIGQUIT;
    SIGSEGV = constants3.SIGSEGV;
    SIGSTOP = constants3.SIGSTOP;
    SIGSYS = constants3.SIGSYS;
    SIGTERM = constants3.SIGTERM;
    SIGTRAP = constants3.SIGTRAP;
    SIGTSTP = constants3.SIGTSTP;
    SIGTTIN = constants3.SIGTTIN;
    SIGTTOU = constants3.SIGTTOU;
    SIGURG = constants3.SIGURG;
    SIGUSR1 = constants3.SIGUSR1;
    SIGUSR2 = constants3.SIGUSR2;
    SIGVTALRM = constants3.SIGVTALRM;
    SIGWINCH = constants3.SIGWINCH;
    SIGXCPU = constants3.SIGXCPU;
    SIGXFSZ = constants3.SIGXFSZ;
    SSL_OP_ALL = constants3.SSL_OP_ALL;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = constants3.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
    SSL_OP_CIPHER_SERVER_PREFERENCE = constants3.SSL_OP_CIPHER_SERVER_PREFERENCE;
    SSL_OP_CISCO_ANYCONNECT = constants3.SSL_OP_CISCO_ANYCONNECT;
    SSL_OP_COOKIE_EXCHANGE = constants3.SSL_OP_COOKIE_EXCHANGE;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = constants3.SSL_OP_CRYPTOPRO_TLSEXT_BUG;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = constants3.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
    SSL_OP_EPHEMERAL_RSA = constants3.SSL_OP_EPHEMERAL_RSA;
    SSL_OP_LEGACY_SERVER_CONNECT = constants3.SSL_OP_LEGACY_SERVER_CONNECT;
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = constants3.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
    SSL_OP_MICROSOFT_SESS_ID_BUG = constants3.SSL_OP_MICROSOFT_SESS_ID_BUG;
    SSL_OP_MSIE_SSLV2_RSA_PADDING = constants3.SSL_OP_MSIE_SSLV2_RSA_PADDING;
    SSL_OP_NETSCAPE_CA_DN_BUG = constants3.SSL_OP_NETSCAPE_CA_DN_BUG;
    SSL_OP_NETSCAPE_CHALLENGE_BUG = constants3.SSL_OP_NETSCAPE_CHALLENGE_BUG;
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = constants3.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = constants3.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
    SSL_OP_NO_COMPRESSION = constants3.SSL_OP_NO_COMPRESSION;
    SSL_OP_NO_QUERY_MTU = constants3.SSL_OP_NO_QUERY_MTU;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = constants3.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;
    SSL_OP_NO_SSLv2 = constants3.SSL_OP_NO_SSLv2;
    SSL_OP_NO_SSLv3 = constants3.SSL_OP_NO_SSLv3;
    SSL_OP_NO_TICKET = constants3.SSL_OP_NO_TICKET;
    SSL_OP_NO_TLSv1 = constants3.SSL_OP_NO_TLSv1;
    SSL_OP_NO_TLSv1_1 = constants3.SSL_OP_NO_TLSv1_1;
    SSL_OP_NO_TLSv1_2 = constants3.SSL_OP_NO_TLSv1_2;
    SSL_OP_PKCS1_CHECK_1 = constants3.SSL_OP_PKCS1_CHECK_1;
    SSL_OP_PKCS1_CHECK_2 = constants3.SSL_OP_PKCS1_CHECK_2;
    SSL_OP_SINGLE_DH_USE = constants3.SSL_OP_SINGLE_DH_USE;
    SSL_OP_SINGLE_ECDH_USE = constants3.SSL_OP_SINGLE_ECDH_USE;
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG = constants3.SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = constants3.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
    SSL_OP_TLS_BLOCK_PADDING_BUG = constants3.SSL_OP_TLS_BLOCK_PADDING_BUG;
    SSL_OP_TLS_D5_BUG = constants3.SSL_OP_TLS_D5_BUG;
    SSL_OP_TLS_ROLLBACK_BUG = constants3.SSL_OP_TLS_ROLLBACK_BUG;
    S_IFBLK = constants3.S_IFBLK;
    S_IFCHR = constants3.S_IFCHR;
    S_IFDIR = constants3.S_IFDIR;
    S_IFIFO = constants3.S_IFIFO;
    S_IFLNK = constants3.S_IFLNK;
    S_IFMT = constants3.S_IFMT;
    S_IFREG = constants3.S_IFREG;
    S_IFSOCK = constants3.S_IFSOCK;
    S_IRGRP = constants3.S_IRGRP;
    S_IROTH = constants3.S_IROTH;
    S_IRUSR = constants3.S_IRUSR;
    S_IRWXG = constants3.S_IRWXG;
    S_IRWXO = constants3.S_IRWXO;
    S_IRWXU = constants3.S_IRWXU;
    S_IWGRP = constants3.S_IWGRP;
    S_IWOTH = constants3.S_IWOTH;
    S_IWUSR = constants3.S_IWUSR;
    S_IXGRP = constants3.S_IXGRP;
    S_IXOTH = constants3.S_IXOTH;
    S_IXUSR = constants3.S_IXUSR;
    UV_UDP_REUSEADDR = constants3.UV_UDP_REUSEADDR;
    W_OK2 = constants3.W_OK;
    X_OK2 = constants3.X_OK;
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var constants4 = (init_constants(), __toCommonJS(constants_exports));
    var origCwd = process_exports.cwd;
    var cwd2 = null;
    var platform3 = process_exports.env.GRACEFUL_FS_PLATFORM || process_exports.platform;
    process_exports.cwd = function() {
      if (!cwd2)
        cwd2 = origCwd.call(process_exports);
      return cwd2;
    };
    try {
      process_exports.cwd();
    } catch (er) {
    }
    if (typeof process_exports.chdir === "function") {
      chdir2 = process_exports.chdir;
      process_exports.chdir = function(d6) {
        cwd2 = null;
        chdir2.call(process_exports, d6);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process_exports.chdir, chdir2);
    }
    var chdir2;
    module.exports = patch;
    function patch(fs2) {
      if (constants4.hasOwnProperty("O_SYMLINK") && process_exports.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path2, mode, cb) {
          if (cb)
            process_exports.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path2, uid, gid, cb) {
          if (cb)
            process_exports.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform3 === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename3(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename3, fs$rename);
          return rename3;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read2(fd, buffer2, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _4, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read2, fs$read);
        return read2;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
        return function(fd, buffer2, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path2, mode, callback) {
          fs3.open(
            path2,
            constants4.O_WRONLY | constants4.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path2, mode) {
          var fd = fs3.openSync(path2, constants4.O_WRONLY | constants4.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants4.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path2, at, mt, cb) {
            fs3.open(path2, constants4.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path2, at, mt) {
            var fd = fs3.openSync(path2, constants4.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process_exports.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process_exports.getuid || process_exports.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var Stream2 = (init_stream(), __toCommonJS(stream_exports)).Stream;
    module.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream: ReadStream2,
        WriteStream: WriteStream2
      };
      function ReadStream2(path2, options) {
        if (!(this instanceof ReadStream2))
          return new ReadStream2(path2, options);
        Stream2.call(this);
        var self2 = this;
        this.path = path2;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process_exports.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream2(path2, options) {
        if (!(this instanceof WriteStream2))
          return new WriteStream2(path2, options);
        Stream2.call(this);
        this.path = path2;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = clone;
    var getPrototypeOf2 = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf2(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = (init_fs(), __toCommonJS(fs_exports));
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = (init_util(), __toCommonJS(util_exports));
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop3() {
    }
    function publishQueue(context, queue3) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue3;
        }
      });
    }
    var debug = noop3;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process_exports.env.NODE_DEBUG || ""))
      debug = function() {
        var m6 = util.format.apply(util, arguments);
        m6 = "GFS4: " + m6.split(/\n/).join("\nGFS4: ");
        console.error(m6);
      };
    if (!fs2[gracefulQueue]) {
      queue2 = global[gracefulQueue] || [];
      publishQueue(fs2, queue2);
      fs2.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync2(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync2, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync2;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process_exports.env.NODE_DEBUG || "")) {
        process_exports.on("exit", function() {
          debug(fs2[gracefulQueue]);
          (init_assert(), __toCommonJS(assert_exports)).equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue2;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module.exports = patch(clone(fs2));
    if (process_exports.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream2;
      fs3.createWriteStream = createWriteStream2;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile3;
      function readFile3(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path2, options, cb);
        function go$readFile(path3, options2, cb2, startTime) {
          return fs$readFile(path3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile3;
      function writeFile3(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path2, data, options, cb);
        function go$writeFile(path3, data2, options2, cb2, startTime) {
          return fs$writeFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile3;
      function appendFile3(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path2, data, options, cb);
        function go$appendFile(path3, data2, options2, cb2, startTime) {
          return fs$appendFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile3;
      function copyFile3(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir3;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir3(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process_exports.version) ? function go$readdir2(path3, options2, cb2, startTime) {
          return fs$readdir(path3, fs$readdirCallback(
            path3,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path3, options2, cb2, startTime) {
          return fs$readdir(path3, options2, fs$readdirCallback(
            path3,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path2, options, cb);
        function fs$readdirCallback(path3, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path3, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process_exports.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream2 = legStreams.ReadStream;
        WriteStream2 = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream2.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream2.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream2;
        },
        set: function(val) {
          ReadStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream2;
        },
        set: function(val) {
          WriteStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream2 = ReadStream2;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream2;
        },
        set: function(val) {
          FileReadStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream2 = WriteStream2;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream2;
        },
        set: function(val) {
          FileWriteStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream2(path2, options) {
        if (this instanceof ReadStream2)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream2(path2, options) {
        if (this instanceof WriteStream2)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path2, options) {
        return new fs3.ReadStream(path2, options);
      }
      function createWriteStream2(path2, options) {
        return new fs3.WriteStream(path2, options);
      }
      var fs$open = fs3.open;
      fs3.open = open3;
      function open3(path2, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path2, flags, mode, cb);
        function go$open(path3, flags2, mode2, cb2, startTime) {
          return fs$open(path3, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i7 = 0; i7 < fs2[gracefulQueue].length; ++i7) {
        if (fs2[gracefulQueue][i7].length > 2) {
          fs2[gracefulQueue][i7][3] = now;
          fs2[gracefulQueue][i7][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.assign(exports10, fs2);
    api.forEach((method) => {
      exports10[method] = u7(fs2[method]);
    });
    exports10.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs2.exists(filename, resolve4);
      });
    };
    exports10.read = function(fd, buffer2, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer2, offset, length, position, callback);
      }
      return new Promise((resolve4, reject) => {
        fs2.read(fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
          if (err)
            return reject(err);
          resolve4({ bytesRead, buffer: buffer3 });
        });
      });
    };
    exports10.write = function(fd, buffer2, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer2, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs2.write(fd, buffer2, ...args, (err, bytesWritten, buffer3) => {
          if (err)
            return reject(err);
          resolve4({ bytesWritten, buffer: buffer3 });
        });
      });
    };
    exports10.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.readv(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve4({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports10.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve4({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs2.realpath.native === "function") {
      exports10.realpath.native = u7(fs2.realpath.native);
    } else {
      process_exports.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    module.exports.checkPath = function checkPath(pth) {
      if (process_exports.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults2, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs2.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs2.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u7(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromPromise;
    var fs2 = require_fs();
    function pathExists(path2) {
      return fs2.access(path2).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u7(pathExists),
      pathExistsSync: fs2.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    function utimesMillis(path2, atime, mtime, callback) {
      fs2.open(path2, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs2.futimes(fd, atime, mtime, (futimesErr) => {
          fs2.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path2, atime, mtime) {
      const fd = fs2.openSync(path2, "r+");
      fs2.futimesSync(fd, atime, mtime);
      return fs2.closeSync(fd);
    }
    module.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs2.stat(file, { bigint: true }) : (file) => fs2.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs2.statSync(file, { bigint: true }) : (file) => fs2.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path2.basename(src);
            const destBaseName = path2.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path2.basename(src);
          const destBaseName = path2.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path2.resolve(path2.dirname(src));
      const destParent = path2.resolve(path2.dirname(dest));
      if (destParent === srcParent || destParent === path2.parse(destParent).root)
        return cb();
      fs2.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path2.resolve(path2.dirname(src));
      const destParent = path2.resolve(path2.dirname(dest));
      if (destParent === srcParent || destParent === path2.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs2.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path2.resolve(src).split(path2.sep).filter((i7) => i7);
      const destArr = path2.resolve(dest).split(path2.sep).filter((i7) => i7);
      return srcArr.reduce((acc, cur, i7) => acc && destArr[i7] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat3 = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process_exports.arch === "ia32") {
        process_exports.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      stat3.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          runFilter(src, dest, opts, (err3, include) => {
            if (err3)
              return cb(err3);
            if (!include)
              return cb();
            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path2.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function runFilter(src, dest, opts, cb) {
      if (!opts.filter)
        return cb(null, true);
      Promise.resolve(opts.filter(src, dest)).then((include) => cb(null, include), (error) => cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat4 = opts.dereference ? fs2.stat : fs2.lstat;
      stat4(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile3(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs2.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile3(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile3(srcStat, src, dest, opts, cb) {
      fs2.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs2.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs2.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs2.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs2.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path2.join(src, item);
      const destItem = path2.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err)
          return cb(err);
        if (!include)
          return copyDirItems(items, src, dest, opts, cb);
        stat3.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
          if (err2)
            return cb(err2);
          const { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err3) => {
            if (err3)
              return cb(err3);
            return copyDirItems(items, src, dest, opts, cb);
          });
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs2.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path2.resolve(process_exports.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs2.symlink(resolvedSrc, dest, cb);
        } else {
          fs2.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs2.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path2.resolve(process_exports.cwd(), resolvedDest);
            }
            if (stat3.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (stat3.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs2.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs2.symlink(resolvedSrc, dest, cb);
      });
    }
    module.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat3 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process_exports.arch === "ia32") {
        process_exports.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat3.checkPathsSync(src, dest, "copy", opts);
      stat3.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path2.dirname(dest);
      if (!fs2.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync2 = opts.dereference ? fs2.statSync : fs2.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile3(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs2.unlinkSync(dest);
        return copyFile3(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile3(srcStat, src, dest, opts) {
      fs2.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs2.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs2.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs2.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path2.join(src, item);
      const destItem = path2.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat3.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs2.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path2.resolve(process_exports.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs2.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs2.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path2.resolve(process_exports.cwd(), resolvedDest);
        }
        if (stat3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs2.unlinkSync(dest);
      return fs2.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    module.exports = {
      copy: u7(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    var u7 = require_universalify().fromCallback;
    function remove(path2, callback) {
      fs2.rm(path2, { recursive: true, force: true }, callback);
    }
    function removeSync(path2) {
      fs2.rmSync(path2, { recursive: true, force: true });
    }
    module.exports = {
      remove: u7(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromPromise;
    var fs2 = require_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var mkdir3 = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u7(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs2.readdir(dir);
      } catch {
        return mkdir3.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path2.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs2.readdirSync(dir);
      } catch {
        return mkdir3.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path2.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    var path2 = (init_path(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var mkdir3 = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs2.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs2.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path2.dirname(file);
        fs2.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir3.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs2.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs2.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path2.dirname(file);
      try {
        if (!fs2.statSync(dir).isDirectory()) {
          fs2.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir3.mkdirsSync(dir);
        else
          throw err;
      }
      fs2.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u7(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    var path2 = (init_path(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var mkdir3 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs2.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs2.lstat(dstpath, (_4, dstStat) => {
        fs2.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path2.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir3.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs2.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs2.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path2.dirname(dstpath);
      const dirExists = fs2.existsSync(dir);
      if (dirExists)
        return fs2.linkSync(srcpath, dstpath);
      mkdir3.mkdirsSync(dir);
      return fs2.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u7(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path2.isAbsolute(srcpath)) {
        return fs2.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path2.dirname(dstpath);
        const relativeToDst = path2.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists3) => {
          if (err)
            return callback(err);
          if (exists3) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs2.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path2.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists3;
      if (path2.isAbsolute(srcpath)) {
        exists3 = fs2.existsSync(srcpath);
        if (!exists3)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path2.dirname(dstpath);
        const relativeToDst = path2.join(dstdir, srcpath);
        exists3 = fs2.existsSync(relativeToDst);
        if (exists3) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists3 = fs2.existsSync(srcpath);
          if (!exists3)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path2.relative(dstdir, srcpath)
          };
        }
      }
    }
    module.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    function symlinkType(srcpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      if (type2)
        return callback(null, type2);
      fs2.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type2 = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type2);
      });
    }
    function symlinkTypeSync(srcpath, type2) {
      let stats;
      if (type2)
        return type2;
      try {
        stats = fs2.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    var path2 = (init_path(), __toCommonJS(path_exports));
    var fs2 = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      fs2.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs2.stat(srcpath),
            fs2.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type2, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type2, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type2, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative2) => {
        if (err)
          return callback(err);
        srcpath = relative2.toDst;
        symlinkType(relative2.toCwd, type2, (err2, type3) => {
          if (err2)
            return callback(err2);
          const dir = path2.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs2.symlink(srcpath, dstpath, type3, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs2.symlink(srcpath, dstpath, type3, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type2) {
      let stats;
      try {
        stats = fs2.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs2.statSync(srcpath);
        const dstStat = fs2.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative2.toDst;
      type2 = symlinkTypeSync(relative2.toCwd, type2);
      const dir = path2.dirname(dstpath);
      const exists3 = fs2.existsSync(dir);
      if (exists3)
        return fs2.symlinkSync(srcpath, dstpath, type2);
      mkdirsSync(dir);
      return fs2.symlinkSync(srcpath, dstpath, type2);
    }
    module.exports = {
      createSymlink: u7(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    function stringify(obj, { EOL: EOL2 = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL2 : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL2) + EOF;
    }
    function stripBom(content) {
      if (Buffer2.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_4) {
      _fs = (init_fs(), __toCommonJS(fs_exports));
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs2.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile3 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs2.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs2.writeFile)(file, str, options);
    }
    var writeFile3 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs2.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile3,
      readFileSync: readFileSync2,
      writeFile: writeFile3,
      writeFileSync: writeFileSync2
    };
    module.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var mkdir3 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path2.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs2.writeFile(file, data, encoding, callback);
        mkdir3.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs2.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path2.dirname(file);
      if (fs2.existsSync(dir)) {
        return fs2.writeFileSync(file, ...args);
      }
      mkdir3.mkdirsSync(dir);
      fs2.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u7(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u7(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat3 = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat3.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path2.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path2.dirname(dest);
      const parsedPath = path2.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename3(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename3(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename3(src, dest, overwrite, cb);
      });
    }
    function rename3(src, dest, overwrite, cb) {
      fs2.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = require_graceful_fs();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat3 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat3.checkPathsSync(src, dest, "move", opts);
      stat3.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path2.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path2.dirname(dest);
      const parsedPath = path2.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename3(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename3(src, dest, overwrite);
      }
      if (fs2.existsSync(dest))
        throw new Error("dest already exists.");
      return rename3(src, dest, overwrite);
    }
    function rename3(src, dest, overwrite) {
      try {
        fs2.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var u7 = require_universalify().fromCallback;
    module.exports = {
      move: u7(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    function tryStringify(o9) {
      try {
        return JSON.stringify(o9);
      } catch (e10) {
        return '"[Circular]"';
      }
    }
    module.exports = format5;
    function format5(f7, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f7 === "object" && f7 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f7;
        var objects = new Array(len);
        objects[0] = ss(f7);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f7 !== "string") {
        return f7;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f7;
      var str = "";
      var a7 = 1 - offset;
      var lastPos = -1;
      var flen = f7 && f7.length || 0;
      for (var i7 = 0; i7 < flen; ) {
        if (f7.charCodeAt(i7) === 37 && i7 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f7.charCodeAt(i7 + 1)) {
            case 100:
            case 102:
              if (a7 >= argLen)
                break;
              if (args[a7] == null)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += Number(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 105:
              if (a7 >= argLen)
                break;
              if (args[a7] == null)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += Math.floor(Number(args[a7]));
              lastPos = i7 + 2;
              i7++;
              break;
            case 79:
            case 111:
            case 106:
              if (a7 >= argLen)
                break;
              if (args[a7] === void 0)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              var type2 = typeof args[a7];
              if (type2 === "string") {
                str += "'" + args[a7] + "'";
                lastPos = i7 + 2;
                i7++;
                break;
              }
              if (type2 === "function") {
                str += args[a7].name || "<anonymous>";
                lastPos = i7 + 2;
                i7++;
                break;
              }
              str += ss(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 115:
              if (a7 >= argLen)
                break;
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += String(args[a7]);
              lastPos = i7 + 2;
              i7++;
              break;
            case 37:
              if (lastPos < i7)
                str += f7.slice(lastPos, i7);
              str += "%";
              lastPos = i7 + 2;
              i7++;
              a7--;
              break;
          }
          ++a7;
        }
        ++i7;
      }
      if (lastPos === -1)
        return f7;
      else if (lastPos < flen) {
        str += f7.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var format5 = require_quick_format_unescaped();
    module.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k4) {
          return k4 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto === "function") {
        levels.forEach(function(level2) {
          proto[level2] = proto;
        });
      }
      if (opts.enabled === false || opts.browser.disabled)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger2 = Object.create(proto);
      if (!logger2.log)
        logger2.log = noop3;
      Object.defineProperty(logger2, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger2, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger2.levels = getLevels(opts);
      logger2.level = level;
      logger2.setMaxListeners = logger2.getMaxListeners = logger2.emit = logger2.addListener = logger2.on = logger2.prependListener = logger2.once = logger2.prependOnceListener = logger2.removeListener = logger2.removeAllListeners = logger2.listeners = logger2.listenerCount = logger2.eventNames = logger2.write = logger2.flush = noop3;
      logger2.serializers = serializers;
      logger2._serialize = serialize;
      logger2._stdErrSerialize = stdErrSerialize;
      logger2.child = child;
      if (transmit2)
        logger2._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(setOpts, logger2, "error", "log");
        set(setOpts, logger2, "fatal", "error");
        set(setOpts, logger2, "warn", "error");
        set(setOpts, logger2, "info", "log");
        set(setOpts, logger2, "debug", "log");
        set(setOpts, logger2, "trace", "log");
        customLevels.forEach(function(level3) {
          set(setOpts, logger2, level3, "log");
        });
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind2(parent, bindings, "error");
          this.fatal = bind2(parent, bindings, "fatal");
          this.warn = bind2(parent, bindings, "warn");
          this.info = bind2(parent, bindings, "info");
          this.debug = bind2(parent, bindings, "debug");
          this.trace = bind2(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger2;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set(opts, logger2, level, fallback) {
      const proto = Object.getPrototypeOf(logger2);
      logger2[level] = logger2.levelVal > logger2.levels.values[level] ? noop3 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop3;
      wrap(opts, logger2, level);
    }
    function wrap(opts, logger2, level) {
      if (!opts.transmit && logger2[level] === noop3)
        return;
      logger2[level] = function(write2) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i7 = 0; i7 < args.length; i7++)
            args[i7] = arguments[i7];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write2.call(proto, asObject(this, level, args, ts));
          else
            write2.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger2.level;
            const transmitValue = logger2.levels.values[transmitLevel];
            const methodValue = logger2.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: logger2.levels.values[opts.transmit.level || logger2.level],
              send: opts.transmit.send,
              val: logger2.levelVal
            }, args);
          }
        };
      }(logger2[level]);
    }
    function asObject(logger2, level, args, ts) {
      if (logger2._serialize)
        applySerializers(args, logger2._serialize, logger2.serializers, logger2._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o9 = {};
      if (ts) {
        o9.time = ts;
      }
      o9.level = logger2.levels.values[level];
      let lvl = (logger2._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o9, argsCloned.shift());
        }
        msg = argsCloned.length ? format5(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format5(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o9.msg = msg;
      return o9;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i7 in args) {
        if (stdErrSerialize && args[i7] instanceof Error) {
          args[i7] = pino2.stdSerializers.err(args[i7]);
        } else if (typeof args[i7] === "object" && !Array.isArray(args[i7])) {
          for (const k4 in args[i7]) {
            if (serialize && serialize.indexOf(k4) > -1 && k4 in serializers) {
              args[i7][k4] = serializers[k4](args[i7][k4]);
            }
          }
        }
      }
    }
    function bind2(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i7 = 1; i7 < args.length; i7++) {
          args[i7] = arguments[i7 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger2, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger2._logEvent.bindings;
      applySerializers(
        args,
        logger2._serialize || Object.keys(logger2.serializers),
        logger2.serializers,
        logger2._stdErrSerialize === void 0 ? true : logger2._stdErrSerialize
      );
      logger2._logEvent.ts = ts;
      logger2._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger2._logEvent.level.label = methodLevel;
      logger2._logEvent.level.value = methodValue;
      send(methodLevel, logger2._logEvent, val);
      logger2._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a7) {
      return a7;
    }
    function noop3() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o9) {
        return typeof o9 !== "undefined" && o9;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e10) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@jspm/core/nodelibs/browser/child_process.js
function unimplemented3() {
  throw new Error("Node.js child_process is not supported by JSPM core in the browser");
}
var init_child_process = __esm({
  "node_modules/@jspm/core/nodelibs/browser/child_process.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
  }
});

// node_modules/@jspm/core/nodelibs/browser/zlib.js
function dew$c3() {
  if (_dewExec$c3)
    return exports$d3;
  _dewExec$c3 = true;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  exports$d3 = ZStream;
  return exports$d3;
}
function dew$b3() {
  if (_dewExec$b3)
    return exports$c3;
  _dewExec$b3 = true;
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports$c3.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p7 in source) {
        if (_has(source, p7)) {
          obj[p7] = source[p7];
        }
      }
    }
    return obj;
  };
  exports$c3.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i7 = 0; i7 < len; i7++) {
        dest[dest_offs + i7] = src[src_offs + i7];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i7, l7, len, pos, chunk, result;
      len = 0;
      for (i7 = 0, l7 = chunks.length; i7 < l7; i7++) {
        len += chunks[i7].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i7 = 0, l7 = chunks.length; i7 < l7; i7++) {
        chunk = chunks[i7];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i7 = 0; i7 < len; i7++) {
        dest[dest_offs + i7] = src[src_offs + i7];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$c3.setTyped = function(on3) {
    if (on3) {
      exports$c3.Buf8 = Uint8Array;
      exports$c3.Buf16 = Uint16Array;
      exports$c3.Buf32 = Int32Array;
      exports$c3.assign(exports$c3, fnTyped);
    } else {
      exports$c3.Buf8 = Array;
      exports$c3.Buf16 = Array;
      exports$c3.Buf32 = Array;
      exports$c3.assign(exports$c3, fnUntyped);
    }
  };
  exports$c3.setTyped(TYPED_OK);
  return exports$c3;
}
function dew$a3() {
  if (_dewExec$a3)
    return exports$b3;
  _dewExec$a3 = true;
  var utils = dew$b3();
  var Z_FIXED2 = 4;
  var Z_BINARY2 = 0;
  var Z_TEXT2 = 1;
  var Z_UNKNOWN2 = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s6, w4) {
    s6.pending_buf[s6.pending++] = w4 & 255;
    s6.pending_buf[s6.pending++] = w4 >>> 8 & 255;
  }
  function send_bits(s6, value, length) {
    if (s6.bi_valid > Buf_size - length) {
      s6.bi_buf |= value << s6.bi_valid & 65535;
      put_short(s6, s6.bi_buf);
      s6.bi_buf = value >> Buf_size - s6.bi_valid;
      s6.bi_valid += length - Buf_size;
    } else {
      s6.bi_buf |= value << s6.bi_valid & 65535;
      s6.bi_valid += length;
    }
  }
  function send_code(s6, c7, tree) {
    send_bits(
      s6,
      tree[c7 * 2],
      tree[c7 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s6) {
    if (s6.bi_valid === 16) {
      put_short(s6, s6.bi_buf);
      s6.bi_buf = 0;
      s6.bi_valid = 0;
    } else if (s6.bi_valid >= 8) {
      s6.pending_buf[s6.pending++] = s6.bi_buf & 255;
      s6.bi_buf >>= 8;
      s6.bi_valid -= 8;
    }
  }
  function gen_bitlen(s6, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h8;
    var n9, m6;
    var bits;
    var xbits;
    var f7;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s6.bl_count[bits] = 0;
    }
    tree[s6.heap[s6.heap_max] * 2 + 1] = 0;
    for (h8 = s6.heap_max + 1; h8 < HEAP_SIZE; h8++) {
      n9 = s6.heap[h8];
      bits = tree[tree[n9 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n9 * 2 + 1] = bits;
      if (n9 > max_code) {
        continue;
      }
      s6.bl_count[bits]++;
      xbits = 0;
      if (n9 >= base) {
        xbits = extra[n9 - base];
      }
      f7 = tree[n9 * 2];
      s6.opt_len += f7 * (bits + xbits);
      if (has_stree) {
        s6.static_len += f7 * (stree[n9 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s6.bl_count[bits] === 0) {
        bits--;
      }
      s6.bl_count[bits]--;
      s6.bl_count[bits + 1] += 2;
      s6.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n9 = s6.bl_count[bits];
      while (n9 !== 0) {
        m6 = s6.heap[--h8];
        if (m6 > max_code) {
          continue;
        }
        if (tree[m6 * 2 + 1] !== bits) {
          s6.opt_len += (bits - tree[m6 * 2 + 1]) * tree[m6 * 2];
          tree[m6 * 2 + 1] = bits;
        }
        n9--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n9;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n9 = 0; n9 <= max_code; n9++) {
      var len = tree[n9 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n9 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n9;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n9 = 0; n9 < 1 << extra_lbits[code]; n9++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n9 = 0; n9 < 1 << extra_dbits[code]; n9++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n9 = 0; n9 < 1 << extra_dbits[code] - 7; n9++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n9 = 0;
    while (n9 <= 143) {
      static_ltree[n9 * 2 + 1] = 8;
      n9++;
      bl_count[8]++;
    }
    while (n9 <= 255) {
      static_ltree[n9 * 2 + 1] = 9;
      n9++;
      bl_count[9]++;
    }
    while (n9 <= 279) {
      static_ltree[n9 * 2 + 1] = 7;
      n9++;
      bl_count[7]++;
    }
    while (n9 <= 287) {
      static_ltree[n9 * 2 + 1] = 8;
      n9++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n9 = 0; n9 < D_CODES; n9++) {
      static_dtree[n9 * 2 + 1] = 5;
      static_dtree[n9 * 2] = bi_reverse(n9, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s6) {
    var n9;
    for (n9 = 0; n9 < L_CODES; n9++) {
      s6.dyn_ltree[n9 * 2] = 0;
    }
    for (n9 = 0; n9 < D_CODES; n9++) {
      s6.dyn_dtree[n9 * 2] = 0;
    }
    for (n9 = 0; n9 < BL_CODES; n9++) {
      s6.bl_tree[n9 * 2] = 0;
    }
    s6.dyn_ltree[END_BLOCK * 2] = 1;
    s6.opt_len = s6.static_len = 0;
    s6.last_lit = s6.matches = 0;
  }
  function bi_windup(s6) {
    if (s6.bi_valid > 8) {
      put_short(s6, s6.bi_buf);
    } else if (s6.bi_valid > 0) {
      s6.pending_buf[s6.pending++] = s6.bi_buf;
    }
    s6.bi_buf = 0;
    s6.bi_valid = 0;
  }
  function copy_block(s6, buf, len, header) {
    bi_windup(s6);
    if (header) {
      put_short(s6, len);
      put_short(s6, ~len);
    }
    utils.arraySet(s6.pending_buf, s6.window, buf, len, s6.pending);
    s6.pending += len;
  }
  function smaller(tree, n9, m6, depth) {
    var _n2 = n9 * 2;
    var _m2 = m6 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n9] <= depth[m6];
  }
  function pqdownheap(s6, tree, k4) {
    var v7 = s6.heap[k4];
    var j4 = k4 << 1;
    while (j4 <= s6.heap_len) {
      if (j4 < s6.heap_len && smaller(tree, s6.heap[j4 + 1], s6.heap[j4], s6.depth)) {
        j4++;
      }
      if (smaller(tree, v7, s6.heap[j4], s6.depth)) {
        break;
      }
      s6.heap[k4] = s6.heap[j4];
      k4 = j4;
      j4 <<= 1;
    }
    s6.heap[k4] = v7;
  }
  function compress_block(s6, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s6.last_lit !== 0) {
      do {
        dist = s6.pending_buf[s6.d_buf + lx * 2] << 8 | s6.pending_buf[s6.d_buf + lx * 2 + 1];
        lc = s6.pending_buf[s6.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s6, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s6, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s6, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s6, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s6, dist, extra);
          }
        }
      } while (lx < s6.last_lit);
    }
    send_code(s6, END_BLOCK, ltree);
  }
  function build_tree(s6, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n9, m6;
    var max_code = -1;
    var node;
    s6.heap_len = 0;
    s6.heap_max = HEAP_SIZE;
    for (n9 = 0; n9 < elems; n9++) {
      if (tree[n9 * 2] !== 0) {
        s6.heap[++s6.heap_len] = max_code = n9;
        s6.depth[n9] = 0;
      } else {
        tree[n9 * 2 + 1] = 0;
      }
    }
    while (s6.heap_len < 2) {
      node = s6.heap[++s6.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s6.depth[node] = 0;
      s6.opt_len--;
      if (has_stree) {
        s6.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n9 = s6.heap_len >> 1; n9 >= 1; n9--) {
      pqdownheap(s6, tree, n9);
    }
    node = elems;
    do {
      n9 = s6.heap[
        1
        /*SMALLEST*/
      ];
      s6.heap[
        1
        /*SMALLEST*/
      ] = s6.heap[s6.heap_len--];
      pqdownheap(
        s6,
        tree,
        1
        /*SMALLEST*/
      );
      m6 = s6.heap[
        1
        /*SMALLEST*/
      ];
      s6.heap[--s6.heap_max] = n9;
      s6.heap[--s6.heap_max] = m6;
      tree[node * 2] = tree[n9 * 2] + tree[m6 * 2];
      s6.depth[node] = (s6.depth[n9] >= s6.depth[m6] ? s6.depth[n9] : s6.depth[m6]) + 1;
      tree[n9 * 2 + 1] = tree[m6 * 2 + 1] = node;
      s6.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s6,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s6.heap_len >= 2);
    s6.heap[--s6.heap_max] = s6.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s6, desc);
    gen_codes(tree, max_code, s6.bl_count);
  }
  function scan_tree(s6, tree, max_code) {
    var n9;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n9 = 0; n9 <= max_code; n9++) {
      curlen = nextlen;
      nextlen = tree[(n9 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s6.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s6.bl_tree[curlen * 2]++;
        }
        s6.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s6.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s6.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s6, tree, max_code) {
    var n9;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n9 = 0; n9 <= max_code; n9++) {
      curlen = nextlen;
      nextlen = tree[(n9 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s6, curlen, s6.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s6, curlen, s6.bl_tree);
          count--;
        }
        send_code(s6, REP_3_6, s6.bl_tree);
        send_bits(s6, count - 3, 2);
      } else if (count <= 10) {
        send_code(s6, REPZ_3_10, s6.bl_tree);
        send_bits(s6, count - 3, 3);
      } else {
        send_code(s6, REPZ_11_138, s6.bl_tree);
        send_bits(s6, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s6) {
    var max_blindex;
    scan_tree(s6, s6.dyn_ltree, s6.l_desc.max_code);
    scan_tree(s6, s6.dyn_dtree, s6.d_desc.max_code);
    build_tree(s6, s6.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s6.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s6.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s6, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s6, lcodes - 257, 5);
    send_bits(s6, dcodes - 1, 5);
    send_bits(s6, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(
        s6,
        s6.bl_tree[bl_order[rank] * 2 + 1],
        3
      );
    }
    send_tree(s6, s6.dyn_ltree, lcodes - 1);
    send_tree(s6, s6.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s6) {
    var black_mask = 4093624447;
    var n9;
    for (n9 = 0; n9 <= 31; n9++, black_mask >>>= 1) {
      if (black_mask & 1 && s6.dyn_ltree[n9 * 2] !== 0) {
        return Z_BINARY2;
      }
    }
    if (s6.dyn_ltree[9 * 2] !== 0 || s6.dyn_ltree[10 * 2] !== 0 || s6.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT2;
    }
    for (n9 = 32; n9 < LITERALS; n9++) {
      if (s6.dyn_ltree[n9 * 2] !== 0) {
        return Z_TEXT2;
      }
    }
    return Z_BINARY2;
  }
  var static_init_done = false;
  function _tr_init(s6) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s6.l_desc = new TreeDesc(s6.dyn_ltree, static_l_desc);
    s6.d_desc = new TreeDesc(s6.dyn_dtree, static_d_desc);
    s6.bl_desc = new TreeDesc(s6.bl_tree, static_bl_desc);
    s6.bi_buf = 0;
    s6.bi_valid = 0;
    init_block(s6);
  }
  function _tr_stored_block(s6, buf, stored_len, last) {
    send_bits(s6, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s6, buf, stored_len, true);
  }
  function _tr_align(s6) {
    send_bits(s6, STATIC_TREES << 1, 3);
    send_code(s6, END_BLOCK, static_ltree);
    bi_flush(s6);
  }
  function _tr_flush_block(s6, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s6.level > 0) {
      if (s6.strm.data_type === Z_UNKNOWN2) {
        s6.strm.data_type = detect_data_type(s6);
      }
      build_tree(s6, s6.l_desc);
      build_tree(s6, s6.d_desc);
      max_blindex = build_bl_tree(s6);
      opt_lenb = s6.opt_len + 3 + 7 >>> 3;
      static_lenb = s6.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s6, buf, stored_len, last);
    } else if (s6.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
      send_bits(s6, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s6, static_ltree, static_dtree);
    } else {
      send_bits(s6, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s6, s6.l_desc.max_code + 1, s6.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s6, s6.dyn_ltree, s6.dyn_dtree);
    }
    init_block(s6);
    if (last) {
      bi_windup(s6);
    }
  }
  function _tr_tally(s6, dist, lc) {
    s6.pending_buf[s6.d_buf + s6.last_lit * 2] = dist >>> 8 & 255;
    s6.pending_buf[s6.d_buf + s6.last_lit * 2 + 1] = dist & 255;
    s6.pending_buf[s6.l_buf + s6.last_lit] = lc & 255;
    s6.last_lit++;
    if (dist === 0) {
      s6.dyn_ltree[lc * 2]++;
    } else {
      s6.matches++;
      dist--;
      s6.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s6.dyn_dtree[d_code(dist) * 2]++;
    }
    return s6.last_lit === s6.lit_bufsize - 1;
  }
  exports$b3._tr_init = _tr_init;
  exports$b3._tr_stored_block = _tr_stored_block;
  exports$b3._tr_flush_block = _tr_flush_block;
  exports$b3._tr_tally = _tr_tally;
  exports$b3._tr_align = _tr_align;
  return exports$b3;
}
function dew$93() {
  if (_dewExec$93)
    return exports$a3;
  _dewExec$93 = true;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n9 = 0;
    while (len !== 0) {
      n9 = len > 2e3 ? 2e3 : len;
      len -= n9;
      do {
        s1 = s1 + buf[pos++] | 0;
        s22 = s22 + s1 | 0;
      } while (--n9);
      s1 %= 65521;
      s22 %= 65521;
    }
    return s1 | s22 << 16 | 0;
  }
  exports$a3 = adler32;
  return exports$a3;
}
function dew$83() {
  if (_dewExec$83)
    return exports$93;
  _dewExec$83 = true;
  function makeTable() {
    var c7, table = [];
    for (var n9 = 0; n9 < 256; n9++) {
      c7 = n9;
      for (var k4 = 0; k4 < 8; k4++) {
        c7 = c7 & 1 ? 3988292384 ^ c7 >>> 1 : c7 >>> 1;
      }
      table[n9] = c7;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t9 = crcTable, end = pos + len;
    crc ^= -1;
    for (var i7 = pos; i7 < end; i7++) {
      crc = crc >>> 8 ^ t9[(crc ^ buf[i7]) & 255];
    }
    return crc ^ -1;
  }
  exports$93 = crc32;
  return exports$93;
}
function dew$73() {
  if (_dewExec$73)
    return exports$83;
  _dewExec$73 = true;
  exports$83 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return exports$83;
}
function dew$63() {
  if (_dewExec$63)
    return exports$73;
  _dewExec$63 = true;
  var utils = dew$b3();
  var trees = dew$a3();
  var adler32 = dew$93();
  var crc32 = dew$83();
  var msg = dew$73();
  var Z_NO_FLUSH2 = 0;
  var Z_PARTIAL_FLUSH2 = 1;
  var Z_FULL_FLUSH2 = 3;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFAULT_COMPRESSION2 = -1;
  var Z_FILTERED2 = 1;
  var Z_HUFFMAN_ONLY2 = 2;
  var Z_RLE2 = 3;
  var Z_FIXED2 = 4;
  var Z_DEFAULT_STRATEGY2 = 0;
  var Z_UNKNOWN2 = 2;
  var Z_DEFLATED2 = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f7) {
    return (f7 << 1) - (f7 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s6 = strm.state;
    var len = s6.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s6.pending_buf, s6.pending_out, len, strm.next_out);
    strm.next_out += len;
    s6.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s6.pending -= len;
    if (s6.pending === 0) {
      s6.pending_out = 0;
    }
  }
  function flush_block_only(s6, last) {
    trees._tr_flush_block(s6, s6.block_start >= 0 ? s6.block_start : -1, s6.strstart - s6.block_start, last);
    s6.block_start = s6.strstart;
    flush_pending(s6.strm);
  }
  function put_byte(s6, b5) {
    s6.pending_buf[s6.pending++] = b5;
  }
  function putShortMSB(s6, b5) {
    s6.pending_buf[s6.pending++] = b5 >>> 8 & 255;
    s6.pending_buf[s6.pending++] = b5 & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s6, cur_match) {
    var chain_length = s6.max_chain_length;
    var scan = s6.strstart;
    var match;
    var len;
    var best_len = s6.prev_length;
    var nice_match = s6.nice_match;
    var limit = s6.strstart > s6.w_size - MIN_LOOKAHEAD ? s6.strstart - (s6.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s6.window;
    var wmask = s6.w_mask;
    var prev = s6.prev;
    var strend = s6.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s6.prev_length >= s6.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s6.lookahead) {
      nice_match = s6.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s6.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s6.lookahead) {
      return best_len;
    }
    return s6.lookahead;
  }
  function fill_window(s6) {
    var _w_size = s6.w_size;
    var p7, n9, m6, more, str;
    do {
      more = s6.window_size - s6.lookahead - s6.strstart;
      if (s6.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s6.window, s6.window, _w_size, _w_size, 0);
        s6.match_start -= _w_size;
        s6.strstart -= _w_size;
        s6.block_start -= _w_size;
        n9 = s6.hash_size;
        p7 = n9;
        do {
          m6 = s6.head[--p7];
          s6.head[p7] = m6 >= _w_size ? m6 - _w_size : 0;
        } while (--n9);
        n9 = _w_size;
        p7 = n9;
        do {
          m6 = s6.prev[--p7];
          s6.prev[p7] = m6 >= _w_size ? m6 - _w_size : 0;
        } while (--n9);
        more += _w_size;
      }
      if (s6.strm.avail_in === 0) {
        break;
      }
      n9 = read_buf(s6.strm, s6.window, s6.strstart + s6.lookahead, more);
      s6.lookahead += n9;
      if (s6.lookahead + s6.insert >= MIN_MATCH) {
        str = s6.strstart - s6.insert;
        s6.ins_h = s6.window[str];
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + 1]) & s6.hash_mask;
        while (s6.insert) {
          s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + MIN_MATCH - 1]) & s6.hash_mask;
          s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = str;
          str++;
          s6.insert--;
          if (s6.lookahead + s6.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s6.lookahead < MIN_LOOKAHEAD && s6.strm.avail_in !== 0);
  }
  function deflate_stored(s6, flush) {
    var max_block_size = 65535;
    if (max_block_size > s6.pending_buf_size - 5) {
      max_block_size = s6.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s6.lookahead <= 1) {
        fill_window(s6);
        if (s6.lookahead === 0 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      s6.strstart += s6.lookahead;
      s6.lookahead = 0;
      var max_start = s6.block_start + max_block_size;
      if (s6.strstart === 0 || s6.strstart >= max_start) {
        s6.lookahead = s6.strstart - max_start;
        s6.strstart = max_start;
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s6.strstart - s6.block_start >= s6.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.strstart > s6.block_start) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s6, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s6.lookahead < MIN_LOOKAHEAD) {
        fill_window(s6);
        if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s6.lookahead >= MIN_MATCH) {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
        hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = s6.strstart;
      }
      if (hash_head !== 0 && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
        s6.match_length = longest_match(s6, hash_head);
      }
      if (s6.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s6, s6.strstart - s6.match_start, s6.match_length - MIN_MATCH);
        s6.lookahead -= s6.match_length;
        if (s6.match_length <= s6.max_lazy_match && s6.lookahead >= MIN_MATCH) {
          s6.match_length--;
          do {
            s6.strstart++;
            s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
            hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = s6.strstart;
          } while (--s6.match_length !== 0);
          s6.strstart++;
        } else {
          s6.strstart += s6.match_length;
          s6.match_length = 0;
          s6.ins_h = s6.window[s6.strstart];
          s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + 1]) & s6.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
      }
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s6, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s6.lookahead < MIN_LOOKAHEAD) {
        fill_window(s6);
        if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s6.lookahead >= MIN_MATCH) {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
        hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = s6.strstart;
      }
      s6.prev_length = s6.match_length;
      s6.prev_match = s6.match_start;
      s6.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s6.prev_length < s6.max_lazy_match && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
        s6.match_length = longest_match(s6, hash_head);
        if (s6.match_length <= 5 && (s6.strategy === Z_FILTERED2 || s6.match_length === MIN_MATCH && s6.strstart - s6.match_start > 4096)) {
          s6.match_length = MIN_MATCH - 1;
        }
      }
      if (s6.prev_length >= MIN_MATCH && s6.match_length <= s6.prev_length) {
        max_insert = s6.strstart + s6.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s6, s6.strstart - 1 - s6.prev_match, s6.prev_length - MIN_MATCH);
        s6.lookahead -= s6.prev_length - 1;
        s6.prev_length -= 2;
        do {
          if (++s6.strstart <= max_insert) {
            s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[s6.strstart + MIN_MATCH - 1]) & s6.hash_mask;
            hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = s6.strstart;
          }
        } while (--s6.prev_length !== 0);
        s6.match_available = 0;
        s6.match_length = MIN_MATCH - 1;
        s6.strstart++;
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s6.match_available) {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
        if (bflush) {
          flush_block_only(s6, false);
        }
        s6.strstart++;
        s6.lookahead--;
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s6.match_available = 1;
        s6.strstart++;
        s6.lookahead--;
      }
    }
    if (s6.match_available) {
      bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
      s6.match_available = 0;
    }
    s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s6, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s6.window;
    for (; ; ) {
      if (s6.lookahead <= MAX_MATCH) {
        fill_window(s6);
        if (s6.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s6.lookahead === 0) {
          break;
        }
      }
      s6.match_length = 0;
      if (s6.lookahead >= MIN_MATCH && s6.strstart > 0) {
        scan = s6.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s6.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s6.match_length = MAX_MATCH - (strend - scan);
          if (s6.match_length > s6.lookahead) {
            s6.match_length = s6.lookahead;
          }
        }
      }
      if (s6.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s6, 1, s6.match_length - MIN_MATCH);
        s6.lookahead -= s6.match_length;
        s6.strstart += s6.match_length;
        s6.match_length = 0;
      } else {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
      }
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s6, flush) {
    var bflush;
    for (; ; ) {
      if (s6.lookahead === 0) {
        fill_window(s6);
        if (s6.lookahead === 0) {
          if (flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s6.match_length = 0;
      bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
      s6.lookahead--;
      s6.strstart++;
      if (bflush) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s6.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s6, true);
      if (s6.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s6.last_lit) {
      flush_block_only(s6, false);
      if (s6.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s6) {
    s6.window_size = 2 * s6.w_size;
    zero(s6.head);
    s6.max_lazy_match = configuration_table[s6.level].max_lazy;
    s6.good_match = configuration_table[s6.level].good_length;
    s6.nice_match = configuration_table[s6.level].nice_length;
    s6.max_chain_length = configuration_table[s6.level].max_chain;
    s6.strstart = 0;
    s6.block_start = 0;
    s6.lookahead = 0;
    s6.insert = 0;
    s6.match_length = s6.prev_length = MIN_MATCH - 1;
    s6.match_available = 0;
    s6.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s6;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN2;
    s6 = strm.state;
    s6.pending = 0;
    s6.pending_out = 0;
    if (s6.wrap < 0) {
      s6.wrap = -s6.wrap;
    }
    s6.status = s6.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s6.wrap === 2 ? 0 : 1;
    s6.last_flush = Z_NO_FLUSH2;
    trees._tr_init(s6);
    return Z_OK2;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK2) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR2;
    }
    strm.state.gzhead = head;
    return Z_OK2;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION2) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
      return err(strm, Z_STREAM_ERROR2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s6 = new DeflateState();
    strm.state = s6;
    s6.strm = strm;
    s6.wrap = wrap;
    s6.gzhead = null;
    s6.w_bits = windowBits;
    s6.w_size = 1 << s6.w_bits;
    s6.w_mask = s6.w_size - 1;
    s6.hash_bits = memLevel + 7;
    s6.hash_size = 1 << s6.hash_bits;
    s6.hash_mask = s6.hash_size - 1;
    s6.hash_shift = ~~((s6.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s6.window = new utils.Buf8(s6.w_size * 2);
    s6.head = new utils.Buf16(s6.hash_size);
    s6.prev = new utils.Buf16(s6.w_size);
    s6.lit_bufsize = 1 << memLevel + 6;
    s6.pending_buf_size = s6.lit_bufsize * 4;
    s6.pending_buf = new utils.Buf8(s6.pending_buf_size);
    s6.d_buf = 1 * s6.lit_bufsize;
    s6.l_buf = (1 + 2) * s6.lit_bufsize;
    s6.level = level;
    s6.strategy = strategy;
    s6.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED2, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY2);
  }
  function deflate2(strm, flush) {
    var old_flush, s6;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
    }
    s6 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s6.status === FINISH_STATE && flush !== Z_FINISH2) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
    }
    s6.strm = strm;
    old_flush = s6.last_flush;
    s6.last_flush = flush;
    if (s6.status === INIT_STATE) {
      if (s6.wrap === 2) {
        strm.adler = 0;
        put_byte(s6, 31);
        put_byte(s6, 139);
        put_byte(s6, 8);
        if (!s6.gzhead) {
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, 0);
          put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2 ? 4 : 0);
          put_byte(s6, OS_CODE);
          s6.status = BUSY_STATE;
        } else {
          put_byte(s6, (s6.gzhead.text ? 1 : 0) + (s6.gzhead.hcrc ? 2 : 0) + (!s6.gzhead.extra ? 0 : 4) + (!s6.gzhead.name ? 0 : 8) + (!s6.gzhead.comment ? 0 : 16));
          put_byte(s6, s6.gzhead.time & 255);
          put_byte(s6, s6.gzhead.time >> 8 & 255);
          put_byte(s6, s6.gzhead.time >> 16 & 255);
          put_byte(s6, s6.gzhead.time >> 24 & 255);
          put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2 ? 4 : 0);
          put_byte(s6, s6.gzhead.os & 255);
          if (s6.gzhead.extra && s6.gzhead.extra.length) {
            put_byte(s6, s6.gzhead.extra.length & 255);
            put_byte(s6, s6.gzhead.extra.length >> 8 & 255);
          }
          if (s6.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending, 0);
          }
          s6.gzindex = 0;
          s6.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED2 + (s6.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s6.strategy >= Z_HUFFMAN_ONLY2 || s6.level < 2) {
          level_flags = 0;
        } else if (s6.level < 6) {
          level_flags = 1;
        } else if (s6.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s6.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s6.status = BUSY_STATE;
        putShortMSB(s6, header);
        if (s6.strstart !== 0) {
          putShortMSB(s6, strm.adler >>> 16);
          putShortMSB(s6, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s6.status === EXTRA_STATE) {
      if (s6.gzhead.extra) {
        beg = s6.pending;
        while (s6.gzindex < (s6.gzhead.extra.length & 65535)) {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              break;
            }
          }
          put_byte(s6, s6.gzhead.extra[s6.gzindex] & 255);
          s6.gzindex++;
        }
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (s6.gzindex === s6.gzhead.extra.length) {
          s6.gzindex = 0;
          s6.status = NAME_STATE;
        }
      } else {
        s6.status = NAME_STATE;
      }
    }
    if (s6.status === NAME_STATE) {
      if (s6.gzhead.name) {
        beg = s6.pending;
        do {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s6.gzindex < s6.gzhead.name.length) {
            val = s6.gzhead.name.charCodeAt(s6.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s6, val);
        } while (val !== 0);
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (val === 0) {
          s6.gzindex = 0;
          s6.status = COMMENT_STATE;
        }
      } else {
        s6.status = COMMENT_STATE;
      }
    }
    if (s6.status === COMMENT_STATE) {
      if (s6.gzhead.comment) {
        beg = s6.pending;
        do {
          if (s6.pending === s6.pending_buf_size) {
            if (s6.gzhead.hcrc && s6.pending > beg) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s6.pending;
            if (s6.pending === s6.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s6.gzindex < s6.gzhead.comment.length) {
            val = s6.gzhead.comment.charCodeAt(s6.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s6, val);
        } while (val !== 0);
        if (s6.gzhead.hcrc && s6.pending > beg) {
          strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
        }
        if (val === 0) {
          s6.status = HCRC_STATE;
        }
      } else {
        s6.status = HCRC_STATE;
      }
    }
    if (s6.status === HCRC_STATE) {
      if (s6.gzhead.hcrc) {
        if (s6.pending + 2 > s6.pending_buf_size) {
          flush_pending(strm);
        }
        if (s6.pending + 2 <= s6.pending_buf_size) {
          put_byte(s6, strm.adler & 255);
          put_byte(s6, strm.adler >> 8 & 255);
          strm.adler = 0;
          s6.status = BUSY_STATE;
        }
      } else {
        s6.status = BUSY_STATE;
      }
    }
    if (s6.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s6.last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH2) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (s6.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (strm.avail_in !== 0 || s6.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s6.status !== FINISH_STATE) {
      var bstate = s6.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff(s6, flush) : s6.strategy === Z_RLE2 ? deflate_rle(s6, flush) : configuration_table[s6.level].func(s6, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s6.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH2) {
          trees._tr_align(s6);
        } else if (flush !== Z_BLOCK2) {
          trees._tr_stored_block(s6, 0, 0, false);
          if (flush === Z_FULL_FLUSH2) {
            zero(s6.head);
            if (s6.lookahead === 0) {
              s6.strstart = 0;
              s6.block_start = 0;
              s6.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush !== Z_FINISH2) {
      return Z_OK2;
    }
    if (s6.wrap <= 0) {
      return Z_STREAM_END2;
    }
    if (s6.wrap === 2) {
      put_byte(s6, strm.adler & 255);
      put_byte(s6, strm.adler >> 8 & 255);
      put_byte(s6, strm.adler >> 16 & 255);
      put_byte(s6, strm.adler >> 24 & 255);
      put_byte(s6, strm.total_in & 255);
      put_byte(s6, strm.total_in >> 8 & 255);
      put_byte(s6, strm.total_in >> 16 & 255);
      put_byte(s6, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s6, strm.adler >>> 16);
      putShortMSB(s6, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s6.wrap > 0) {
      s6.wrap = -s6.wrap;
    }
    return s6.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR2) : Z_OK2;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s6;
    var str, n9;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    s6 = strm.state;
    wrap = s6.wrap;
    if (wrap === 2 || wrap === 1 && s6.status !== INIT_STATE || s6.lookahead) {
      return Z_STREAM_ERROR2;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s6.wrap = 0;
    if (dictLength >= s6.w_size) {
      if (wrap === 0) {
        zero(s6.head);
        s6.strstart = 0;
        s6.block_start = 0;
        s6.insert = 0;
      }
      tmpDict = new utils.Buf8(s6.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s6.w_size, s6.w_size, 0);
      dictionary = tmpDict;
      dictLength = s6.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s6);
    while (s6.lookahead >= MIN_MATCH) {
      str = s6.strstart;
      n9 = s6.lookahead - (MIN_MATCH - 1);
      do {
        s6.ins_h = (s6.ins_h << s6.hash_shift ^ s6.window[str + MIN_MATCH - 1]) & s6.hash_mask;
        s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
        s6.head[s6.ins_h] = str;
        str++;
      } while (--n9);
      s6.strstart = str;
      s6.lookahead = MIN_MATCH - 1;
      fill_window(s6);
    }
    s6.strstart += s6.lookahead;
    s6.block_start = s6.strstart;
    s6.insert = s6.lookahead;
    s6.lookahead = 0;
    s6.match_length = s6.prev_length = MIN_MATCH - 1;
    s6.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s6.wrap = wrap;
    return Z_OK2;
  }
  exports$73.deflateInit = deflateInit;
  exports$73.deflateInit2 = deflateInit2;
  exports$73.deflateReset = deflateReset;
  exports$73.deflateResetKeep = deflateResetKeep;
  exports$73.deflateSetHeader = deflateSetHeader;
  exports$73.deflate = deflate2;
  exports$73.deflateEnd = deflateEnd;
  exports$73.deflateSetDictionary = deflateSetDictionary;
  exports$73.deflateInfo = "pako deflate (from Nodeca project)";
  return exports$73;
}
function dew$53() {
  if (_dewExec$53)
    return exports$63;
  _dewExec$53 = true;
  var BAD = 30;
  var TYPE2 = 12;
  exports$63 = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE2;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return exports$63;
}
function dew$43() {
  if (_dewExec$43)
    return exports$53;
  _dewExec$43 = true;
  var utils = dew$b3();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  exports$53 = function inflate_table(type2, lens, lens_index, codes2, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return exports$53;
}
function dew$33() {
  if (_dewExec$33)
    return exports$43;
  _dewExec$33 = true;
  var utils = dew$b3();
  var adler32 = dew$93();
  var crc32 = dew$83();
  var inflate_fast = dew$53();
  var inflate_table = dew$43();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_TREES2 = 6;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_NEED_DICT2 = 2;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFLATED2 = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE2 = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q3) {
    return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK2;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR2;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK2) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate2(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n9;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.mode === TYPE2) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK2;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE2;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE2;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT2;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE2;
          case TYPE2:
            if (flush === Z_BLOCK2 || flush === Z_TREES2) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES2) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE2;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n9 = here_bits + 2;
                  while (bits < n9) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n9 = here_bits + 3;
                  while (bits < n9) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n9 = here_bits + 7;
                  while (bits < n9) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {
              bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE2) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE2;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n9 = state.extra;
              while (bits < n9) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n9 = state.extra;
              while (bits < n9) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END2;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR2;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR2;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH2)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
        ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
      ret = Z_BUF_ERROR2;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK2;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR2;
    }
    state.head = head;
    head.done = false;
    return Z_OK2;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR2;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR2;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK2;
  }
  exports$43.inflateReset = inflateReset;
  exports$43.inflateReset2 = inflateReset2;
  exports$43.inflateResetKeep = inflateResetKeep;
  exports$43.inflateInit = inflateInit;
  exports$43.inflateInit2 = inflateInit2;
  exports$43.inflate = inflate2;
  exports$43.inflateEnd = inflateEnd;
  exports$43.inflateGetHeader = inflateGetHeader;
  exports$43.inflateSetDictionary = inflateSetDictionary;
  exports$43.inflateInfo = "pako inflate (from Nodeca project)";
  return exports$43;
}
function dew$24() {
  if (_dewExec$24)
    return exports$34;
  _dewExec$24 = true;
  exports$34 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return exports$34;
}
function dew$14() {
  if (_dewExec$14)
    return exports$24;
  _dewExec$14 = true;
  var Buffer3 = buffer.Buffer;
  var process$1 = process2;
  var assert2 = et;
  var Zstream = dew$c3();
  var zlib_deflate = dew$63();
  var zlib_inflate = dew$33();
  var constants4 = dew$24();
  for (var key in constants4) {
    exports$24[key] = constants4[key];
  }
  exports$24.NONE = 0;
  exports$24.DEFLATE = 1;
  exports$24.INFLATE = 2;
  exports$24.GZIP = 3;
  exports$24.GUNZIP = 4;
  exports$24.DEFLATERAW = 5;
  exports$24.INFLATERAW = 6;
  exports$24.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib2(mode) {
    if (typeof mode !== "number" || mode < exports$24.DEFLATE || mode > exports$24.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib2.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports$24.UNZIP);
    if (this.mode === exports$24.DEFLATE || this.mode === exports$24.GZIP || this.mode === exports$24.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports$24.INFLATE || this.mode === exports$24.GUNZIP || this.mode === exports$24.INFLATERAW || this.mode === exports$24.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports$24.NONE;
    this.dictionary = null;
  };
  Zlib2.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports$24.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports$24.Z_NO_FLUSH && flush !== exports$24.Z_PARTIAL_FLUSH && flush !== exports$24.Z_SYNC_FLUSH && flush !== exports$24.Z_FULL_FLUSH && flush !== exports$24.Z_FINISH && flush !== exports$24.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer3.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    process$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib2.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib2.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports$24.DEFLATE:
      case exports$24.GZIP:
      case exports$24.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports$24.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports$24.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports$24.GUNZIP;
            } else {
              this.mode = exports$24.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports$24.INFLATE:
      case exports$24.GUNZIP:
      case exports$24.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports$24.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports$24.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports$24.Z_DATA_ERROR) {
            this.err = exports$24.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports$24.GUNZIP && this.err === exports$24.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib2.prototype._checkError = function() {
    switch (this.err) {
      case exports$24.Z_OK:
      case exports$24.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports$24.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports$24.Z_STREAM_END:
        break;
      case exports$24.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib2.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports$24.Z_FILTERED || strategy === exports$24.Z_HUFFMAN_ONLY || strategy === exports$24.Z_RLE || strategy === exports$24.Z_FIXED || strategy === exports$24.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib2.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib2.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib2.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports$24.Z_NO_FLUSH;
    this.err = exports$24.Z_OK;
    if (this.mode === exports$24.GZIP || this.mode === exports$24.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports$24.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports$24.DEFLATERAW || this.mode === exports$24.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports$24.DEFLATE:
      case exports$24.GZIP:
      case exports$24.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports$24.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports$24.INFLATE:
      case exports$24.GUNZIP:
      case exports$24.INFLATERAW:
      case exports$24.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports$24.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib2.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports$24.Z_OK;
    switch (this.mode) {
      case exports$24.DEFLATE:
      case exports$24.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports$24.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib2.prototype._reset = function() {
    this.err = exports$24.Z_OK;
    switch (this.mode) {
      case exports$24.DEFLATE:
      case exports$24.DEFLATERAW:
      case exports$24.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports$24.INFLATE:
      case exports$24.INFLATERAW:
      case exports$24.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports$24.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports$24.Zlib = Zlib2;
  return exports$24;
}
function dew9() {
  if (_dewExec9)
    return exports$17;
  _dewExec9 = true;
  var process$1 = process2;
  var Buffer3 = buffer.Buffer;
  var Transform2 = exports6.Transform;
  var binding2 = dew$14();
  var util = X;
  var assert2 = et.ok;
  var kMaxLength2 = buffer.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength2.toString(16) + " bytes";
  binding2.Z_MIN_WINDOWBITS = 8;
  binding2.Z_MAX_WINDOWBITS = 15;
  binding2.Z_DEFAULT_WINDOWBITS = 15;
  binding2.Z_MIN_CHUNK = 64;
  binding2.Z_MAX_CHUNK = Infinity;
  binding2.Z_DEFAULT_CHUNK = 16 * 1024;
  binding2.Z_MIN_MEMLEVEL = 1;
  binding2.Z_MAX_MEMLEVEL = 9;
  binding2.Z_DEFAULT_MEMLEVEL = 8;
  binding2.Z_MIN_LEVEL = -1;
  binding2.Z_MAX_LEVEL = 9;
  binding2.Z_DEFAULT_LEVEL = binding2.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding2);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports$17, bkey, {
        enumerable: true,
        value: binding2[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding2.Z_OK,
    Z_STREAM_END: binding2.Z_STREAM_END,
    Z_NEED_DICT: binding2.Z_NEED_DICT,
    Z_ERRNO: binding2.Z_ERRNO,
    Z_STREAM_ERROR: binding2.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding2.Z_DATA_ERROR,
    Z_MEM_ERROR: binding2.Z_MEM_ERROR,
    Z_BUF_ERROR: binding2.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding2.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports$17, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports$17.Deflate = Deflate2;
  exports$17.Inflate = Inflate2;
  exports$17.Gzip = Gzip2;
  exports$17.Gunzip = Gunzip2;
  exports$17.DeflateRaw = DeflateRaw2;
  exports$17.InflateRaw = InflateRaw2;
  exports$17.Unzip = Unzip2;
  exports$17.createDeflate = function(o9) {
    return new Deflate2(o9);
  };
  exports$17.createInflate = function(o9) {
    return new Inflate2(o9);
  };
  exports$17.createDeflateRaw = function(o9) {
    return new DeflateRaw2(o9);
  };
  exports$17.createInflateRaw = function(o9) {
    return new InflateRaw2(o9);
  };
  exports$17.createGzip = function(o9) {
    return new Gzip2(o9);
  };
  exports$17.createGunzip = function(o9) {
    return new Gunzip2(o9);
  };
  exports$17.createUnzip = function(o9) {
    return new Unzip2(o9);
  };
  exports$17.deflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Deflate2(opts), buffer2, callback);
  };
  exports$17.deflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Deflate2(opts), buffer2);
  };
  exports$17.gzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gzip2(opts), buffer2, callback);
  };
  exports$17.gzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gzip2(opts), buffer2);
  };
  exports$17.deflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new DeflateRaw2(opts), buffer2, callback);
  };
  exports$17.deflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new DeflateRaw2(opts), buffer2);
  };
  exports$17.unzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Unzip2(opts), buffer2, callback);
  };
  exports$17.unzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Unzip2(opts), buffer2);
  };
  exports$17.inflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Inflate2(opts), buffer2, callback);
  };
  exports$17.inflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Inflate2(opts), buffer2);
  };
  exports$17.gunzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gunzip2(opts), buffer2, callback);
  };
  exports$17.gunzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gunzip2(opts), buffer2);
  };
  exports$17.inflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new InflateRaw2(opts), buffer2, callback);
  };
  exports$17.inflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new InflateRaw2(opts), buffer2);
  };
  function zlibBuffer(engine, buffer2, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError);
    engine.on("end", onEnd);
    engine.end(buffer2);
    flow();
    function flow() {
      var chunk;
      while (null !== (chunk = engine.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine.once("readable", flow);
    }
    function onError(err) {
      engine.removeListener("end", onEnd);
      engine.removeListener("readable", flow);
      callback(err);
    }
    function onEnd() {
      var buf;
      var err = null;
      if (nread >= kMaxLength2) {
        err = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer3.concat(buffers, nread);
      }
      buffers = [];
      engine.close();
      callback(err, buf);
    }
  }
  function zlibBufferSync(engine, buffer2) {
    if (typeof buffer2 === "string")
      buffer2 = Buffer3.from(buffer2);
    if (!Buffer3.isBuffer(buffer2))
      throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer2, flushFlag);
  }
  function Deflate2(opts) {
    if (!(this instanceof Deflate2))
      return new Deflate2(opts);
    Zlib2.call(this, opts, binding2.DEFLATE);
  }
  function Inflate2(opts) {
    if (!(this instanceof Inflate2))
      return new Inflate2(opts);
    Zlib2.call(this, opts, binding2.INFLATE);
  }
  function Gzip2(opts) {
    if (!(this instanceof Gzip2))
      return new Gzip2(opts);
    Zlib2.call(this, opts, binding2.GZIP);
  }
  function Gunzip2(opts) {
    if (!(this instanceof Gunzip2))
      return new Gunzip2(opts);
    Zlib2.call(this, opts, binding2.GUNZIP);
  }
  function DeflateRaw2(opts) {
    if (!(this instanceof DeflateRaw2))
      return new DeflateRaw2(opts);
    Zlib2.call(this, opts, binding2.DEFLATERAW);
  }
  function InflateRaw2(opts) {
    if (!(this instanceof InflateRaw2))
      return new InflateRaw2(opts);
    Zlib2.call(this, opts, binding2.INFLATERAW);
  }
  function Unzip2(opts) {
    if (!(this instanceof Unzip2))
      return new Unzip2(opts);
    Zlib2.call(this, opts, binding2.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding2.Z_NO_FLUSH || flag === binding2.Z_PARTIAL_FLUSH || flag === binding2.Z_SYNC_FLUSH || flag === binding2.Z_FULL_FLUSH || flag === binding2.Z_FINISH || flag === binding2.Z_BLOCK;
  }
  function Zlib2(opts, mode) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || exports$17.Z_DEFAULT_CHUNK;
    Transform2.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
      throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || binding2.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding2.Z_FINISH;
    if (opts.chunkSize) {
      if (opts.chunkSize < exports$17.Z_MIN_CHUNK || opts.chunkSize > exports$17.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts.chunkSize);
      }
    }
    if (opts.windowBits) {
      if (opts.windowBits < exports$17.Z_MIN_WINDOWBITS || opts.windowBits > exports$17.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts.windowBits);
      }
    }
    if (opts.level) {
      if (opts.level < exports$17.Z_MIN_LEVEL || opts.level > exports$17.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts.level);
      }
    }
    if (opts.memLevel) {
      if (opts.memLevel < exports$17.Z_MIN_MEMLEVEL || opts.memLevel > exports$17.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts.memLevel);
      }
    }
    if (opts.strategy) {
      if (opts.strategy != exports$17.Z_FILTERED && opts.strategy != exports$17.Z_HUFFMAN_ONLY && opts.strategy != exports$17.Z_RLE && opts.strategy != exports$17.Z_FIXED && opts.strategy != exports$17.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts.strategy);
      }
    }
    if (opts.dictionary) {
      if (!Buffer3.isBuffer(opts.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding2.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports$17.codes[errno];
      self2.emit("error", error);
    };
    var level = exports$17.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number")
      level = opts.level;
    var strategy = exports$17.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number")
      strategy = opts.strategy;
    this._handle.init(opts.windowBits || exports$17.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports$17.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer3.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib2, Transform2);
  Zlib2.prototype.params = function(level, strategy, callback) {
    if (level < exports$17.Z_MIN_LEVEL || level > exports$17.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports$17.Z_FILTERED && strategy != exports$17.Z_HUFFMAN_ONLY && strategy != exports$17.Z_RLE && strategy != exports$17.Z_FIXED && strategy != exports$17.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding2.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback)
            callback();
        }
      });
    } else {
      process$1.nextTick(callback);
    }
  };
  Zlib2.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib2.prototype._flush = function(callback) {
    this._transform(Buffer3.alloc(0), "", callback);
  };
  Zlib2.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding2.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback)
        process$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback)
        this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer3.alloc(0), "", callback);
    }
  };
  Zlib2.prototype.close = function(callback) {
    _close(this, callback);
    process$1.nextTick(emitCloseNT, this);
  };
  function _close(engine, callback) {
    if (callback)
      process$1.nextTick(callback);
    if (!engine._handle)
      return;
    engine._handle.close();
    engine._handle = null;
  }
  function emitCloseNT(self2) {
    self2.emit("close");
  }
  Zlib2.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer3.isBuffer(chunk))
      return cb(new Error("invalid input"));
    if (!this._handle)
      return cb(new Error("zlib binding closed"));
    if (last)
      flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding2.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib2.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength2) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer3.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError)
        return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer3.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async)
          return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async)
        return false;
      cb();
    }
  };
  util.inherits(Deflate2, Zlib2);
  util.inherits(Inflate2, Zlib2);
  util.inherits(Gzip2, Zlib2);
  util.inherits(Gunzip2, Zlib2);
  util.inherits(DeflateRaw2, Zlib2);
  util.inherits(InflateRaw2, Zlib2);
  util.inherits(Unzip2, Zlib2);
  return exports$17;
}
var exports$d3, _dewExec$c3, exports$c3, _dewExec$b3, exports$b3, _dewExec$a3, exports$a3, _dewExec$93, exports$93, _dewExec$83, exports$83, _dewExec$73, exports$73, _dewExec$63, exports$63, _dewExec$53, exports$53, _dewExec$43, exports$43, _dewExec$33, exports$34, _dewExec$24, exports$24, _dewExec$14, exports$17, _dewExec9, exports9, createGzip;
var init_zlib = __esm({
  "node_modules/@jspm/core/nodelibs/browser/zlib.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_chunk_44e51b61();
    init_stream();
    init_assert();
    init_chunk_2eac56ff();
    init_util();
    init_chunk_6c718bbe();
    init_chunk_b4205b57();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_5decc758();
    init_chunk_4ccc3a29();
    init_events();
    exports$d3 = {};
    _dewExec$c3 = false;
    exports$c3 = {};
    _dewExec$b3 = false;
    exports$b3 = {};
    _dewExec$a3 = false;
    exports$a3 = {};
    _dewExec$93 = false;
    exports$93 = {};
    _dewExec$83 = false;
    exports$83 = {};
    _dewExec$73 = false;
    exports$73 = {};
    _dewExec$63 = false;
    exports$63 = {};
    _dewExec$53 = false;
    exports$53 = {};
    _dewExec$43 = false;
    exports$43 = {};
    _dewExec$33 = false;
    exports$34 = {};
    _dewExec$24 = false;
    exports$24 = {};
    _dewExec$14 = false;
    exports$17 = {};
    _dewExec9 = false;
    exports9 = dew9();
    exports9["codes"];
    exports9["Deflate"];
    exports9["Inflate"];
    exports9["Gzip"];
    exports9["Gunzip"];
    exports9["DeflateRaw"];
    exports9["InflateRaw"];
    exports9["Unzip"];
    exports9["createDeflate"];
    exports9["createInflate"];
    exports9["createDeflateRaw"];
    exports9["createInflateRaw"];
    exports9["createGzip"];
    exports9["createGunzip"];
    exports9["createUnzip"];
    exports9["deflate"];
    exports9["deflateSync"];
    exports9["gzip"];
    exports9["gzipSync"];
    exports9["deflateRaw"];
    exports9["deflateRawSync"];
    exports9["unzip"];
    exports9["unzipSync"];
    exports9["inflate"];
    exports9["inflateSync"];
    exports9["gunzip"];
    exports9["gunzipSync"];
    exports9["inflateRaw"];
    exports9["inflateRawSync"];
    exports9.Deflate;
    exports9.DeflateRaw;
    exports9.Gunzip;
    exports9.Gzip;
    exports9.Inflate;
    exports9.InflateRaw;
    exports9.Unzip;
    exports9.Z_BEST_COMPRESSION;
    exports9.Z_BEST_SPEED;
    exports9.Z_BINARY;
    exports9.Z_BLOCK;
    exports9.Z_BUF_ERROR;
    exports9.Z_DATA_ERROR;
    exports9.Z_DEFAULT_CHUNK;
    exports9.Z_DEFAULT_COMPRESSION;
    exports9.Z_DEFAULT_LEVEL;
    exports9.Z_DEFAULT_MEMLEVEL;
    exports9.Z_DEFAULT_STRATEGY;
    exports9.Z_DEFAULT_WINDOWBITS;
    exports9.Z_DEFLATED;
    exports9.Z_ERRNO;
    exports9.Z_FILTERED;
    exports9.Z_FINISH;
    exports9.Z_FIXED;
    exports9.Z_FULL_FLUSH;
    exports9.Z_HUFFMAN_ONLY;
    exports9.Z_MAX_CHUNK;
    exports9.Z_MAX_LEVEL;
    exports9.Z_MAX_MEMLEVEL;
    exports9.Z_MAX_WINDOWBITS;
    exports9.Z_MIN_CHUNK;
    exports9.Z_MIN_LEVEL;
    exports9.Z_MIN_MEMLEVEL;
    exports9.Z_MIN_WINDOWBITS;
    exports9.Z_NEED_DICT;
    exports9.Z_NO_COMPRESSION;
    exports9.Z_NO_FLUSH;
    exports9.Z_OK;
    exports9.Z_PARTIAL_FLUSH;
    exports9.Z_RLE;
    exports9.Z_STREAM_END;
    exports9.Z_STREAM_ERROR;
    exports9.Z_SYNC_FLUSH;
    exports9.Z_TEXT;
    exports9.Z_TREES;
    exports9.Z_UNKNOWN;
    exports9.Zlib;
    exports9.codes;
    exports9.createDeflate;
    exports9.createDeflateRaw;
    exports9.createGunzip;
    createGzip = exports9.createGzip;
    exports9.createInflate;
    exports9.createInflateRaw;
    exports9.createUnzip;
    exports9.deflate;
    exports9.deflateRaw;
    exports9.deflateRawSync;
    exports9.deflateSync;
    exports9.gunzip;
    exports9.gunzipSync;
    exports9.gzip;
    exports9.gzipSync;
    exports9.inflate;
    exports9.inflateRaw;
    exports9.inflateRawSync;
    exports9.inflateSync;
    exports9.unzip;
    exports9.unzipSync;
  }
});

// node_modules/@jspm/core/nodelibs/browser/fs/promises.js
var access2, copyFile2, cp2, open2, opendir2, rename2, truncate2, rm2, rmdir2, mkdir2, readdir2, readlink2, symlink2, lstat2, stat2, link2, unlink2, chmod2, lchmod2, lchown2, chown2, utimes2, realpath2, mkdtemp2, writeFile2, appendFile2, readFile2, watch2;
var init_promises = __esm({
  "node_modules/@jspm/core/nodelibs/browser/fs/promises.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_fs();
    init_fs();
    init_chunk_44e51b61();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_2eac56ff();
    init_chunk_4ccc3a29();
    init_assert();
    init_util();
    init_path();
    init_chunk_23dbec7b();
    init_events();
    init_stream();
    init_chunk_6c718bbe();
    init_url();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_buffer();
    ({
      access: access2,
      copyFile: copyFile2,
      cp: cp2,
      open: open2,
      opendir: opendir2,
      rename: rename2,
      truncate: truncate2,
      rm: rm2,
      rmdir: rmdir2,
      mkdir: mkdir2,
      readdir: readdir2,
      readlink: readlink2,
      symlink: symlink2,
      lstat: lstat2,
      stat: stat2,
      link: link2,
      unlink: unlink2,
      chmod: chmod2,
      lchmod: lchmod2,
      lchown: lchown2,
      chown: chown2,
      utimes: utimes2,
      realpath: realpath2,
      mkdtemp: mkdtemp2,
      writeFile: writeFile2,
      appendFile: appendFile2,
      readFile: readFile2,
      watch: watch2
    } = promises2);
  }
});

// node_modules/rotating-file-stream/dist/es/index.js
var es_exports = {};
__export(es_exports, {
  RotatingFileStream: () => RotatingFileStream,
  RotatingFileStreamError: () => RotatingFileStreamError,
  createStream: () => createStream
});
async function exists2(filename) {
  return new Promise((resolve4) => access(filename, constants2.F_OK, (error) => resolve4(!error)));
}
function buildNumberCheck(field) {
  return (type2, options, value) => {
    const converted = parseInt(value, 10);
    if (type2 !== "number" || converted !== value || converted <= 0)
      throw new Error(`'${field}' option must be a positive integer number`);
  };
}
function buildStringCheck(field, check) {
  return (type2, options, value) => {
    if (type2 !== "string")
      throw new Error(`Don't know how to handle 'options.${field}' type: ${type2}`);
    options[field] = check(value);
  };
}
function checkMeasure(value, what, units) {
  const ret = {};
  ret.num = parseInt(value, 10);
  if (isNaN(ret.num))
    throw new Error(`Unknown 'options.${what}' format: ${value}`);
  if (ret.num <= 0)
    throw new Error(`A positive integer number is expected for 'options.${what}'`);
  ret.unit = value.replace(/^[ 0]*/g, "").substr((ret.num + "").length, 1);
  if (ret.unit.length === 0)
    throw new Error(`Missing unit for 'options.${what}'`);
  if (!units[ret.unit])
    throw new Error(`Unknown 'options.${what}' unit: ${ret.unit}`);
  return ret;
}
function checkIntervalUnit(ret, unit, amount) {
  if (parseInt(amount / ret.num, 10) * ret.num !== amount)
    throw new Error(`An integer divider of ${amount} is expected as ${unit} for 'options.interval'`);
}
function checkInterval(value) {
  const ret = checkMeasure(value, "interval", intervalUnits);
  switch (ret.unit) {
    case "h":
      checkIntervalUnit(ret, "hours", 24);
      break;
    case "m":
      checkIntervalUnit(ret, "minutes", 60);
      break;
    case "s":
      checkIntervalUnit(ret, "seconds", 60);
      break;
  }
  return ret;
}
function checkSize(value) {
  const ret = checkMeasure(value, "size", sizeUnits);
  if (ret.unit === "K")
    return ret.num * 1024;
  if (ret.unit === "M")
    return ret.num * 1048576;
  if (ret.unit === "G")
    return ret.num * 1073741824;
  return ret.num;
}
function checkOpts(options) {
  const ret = {};
  for (const opt in options) {
    const value = options[opt];
    const type2 = typeof value;
    if (!(opt in checks))
      throw new Error(`Unknown option: ${opt}`);
    ret[opt] = options[opt];
    checks[opt](type2, ret, value);
  }
  if (!ret.path)
    ret.path = "";
  if (!ret.interval) {
    delete ret.immutable;
    delete ret.initialRotation;
    delete ret.intervalBoundary;
  }
  if (ret.rotate) {
    delete ret.history;
    delete ret.immutable;
    delete ret.maxFiles;
    delete ret.maxSize;
    delete ret.intervalBoundary;
  }
  if (ret.immutable)
    delete ret.compress;
  if (!ret.intervalBoundary)
    delete ret.initialRotation;
  return ret;
}
function createClassical(filename, compress, omitExtension) {
  return (index) => index ? `${filename}.${index}${compress && !omitExtension ? ".gz" : ""}` : filename;
}
function createGenerator(filename, compress, omitExtension) {
  const pad = (num) => (num > 9 ? "" : "0") + num;
  return (time, index) => {
    if (!time)
      return filename;
    const month = time.getFullYear() + "" + pad(time.getMonth() + 1);
    const day = pad(time.getDate());
    const hour = pad(time.getHours());
    const minute = pad(time.getMinutes());
    return month + day + "-" + hour + minute + "-" + pad(index) + "-" + filename + (compress && !omitExtension ? ".gz" : "");
  };
}
function createStream(filename, options) {
  if (typeof options === "undefined")
    options = {};
  else if (typeof options !== "object")
    throw new Error(`The "options" argument must be of type object. Received type ${typeof options}`);
  const opts = checkOpts(options);
  const { compress, omitExtension } = opts;
  let generator;
  if (typeof filename === "string")
    generator = options.rotate ? createClassical(filename, compress !== void 0, omitExtension) : createGenerator(filename, compress !== void 0, omitExtension);
  else if (typeof filename === "function")
    generator = filename;
  else
    throw new Error(`The "filename" argument must be one of type string or function. Received type ${typeof filename}`);
  return new RotatingFileStream(generator, opts);
}
var RotatingFileStreamError, RotatingFileStream, intervalUnits, sizeUnits, checks;
var init_es = __esm({
  "node_modules/rotating-file-stream/dist/es/index.js"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    init_child_process();
    init_zlib();
    init_stream();
    init_fs();
    init_promises();
    init_path();
    init_util();
    RotatingFileStreamError = class extends Error {
      constructor() {
        super("Too many destination file attempts");
        __publicField(this, "code", "RFS-TOO-MANY");
      }
    };
    RotatingFileStream = class extends Writable {
      constructor(generator, options) {
        const { encoding, history, maxFiles, maxSize, path: path2 } = options;
        super({ decodeStrings: true, defaultEncoding: encoding });
        __publicField(this, "createGzip");
        __publicField(this, "exec");
        __publicField(this, "file");
        __publicField(this, "filename");
        __publicField(this, "finished");
        __publicField(this, "fsCreateReadStream");
        __publicField(this, "fsCreateWriteStream");
        __publicField(this, "fsOpen");
        __publicField(this, "fsReadFile");
        __publicField(this, "fsStat");
        __publicField(this, "fsUnlink");
        __publicField(this, "generator");
        __publicField(this, "initPromise");
        __publicField(this, "last");
        __publicField(this, "maxTimeout");
        __publicField(this, "next");
        __publicField(this, "options");
        __publicField(this, "prev");
        __publicField(this, "rotation");
        __publicField(this, "size");
        __publicField(this, "stdout");
        __publicField(this, "timeout");
        __publicField(this, "timeoutPromise");
        this.createGzip = createGzip;
        this.exec = unimplemented3;
        this.filename = path2 + generator(null);
        this.fsCreateReadStream = createReadStream;
        this.fsCreateWriteStream = createWriteStream;
        this.fsOpen = open2;
        this.fsReadFile = readFile2;
        this.fsStat = stat2;
        this.fsUnlink = unlink2;
        this.generator = generator;
        this.maxTimeout = 2147483640;
        this.options = options;
        this.stdout = process_exports.stdout;
        if (maxFiles || maxSize)
          options.history = path2 + (history ? history : this.generator(null) + ".txt");
        this.on("close", () => this.finished ? null : this.emit("finish"));
        this.on("finish", () => this.finished = this.clear());
        (async () => {
          try {
            this.initPromise = this.init();
            await this.initPromise;
            delete this.initPromise;
          } catch (e10) {
          }
        })();
      }
      _destroy(error, callback) {
        this.refinal(error, callback);
      }
      _final(callback) {
        this.refinal(void 0, callback);
      }
      _write(chunk, encoding, callback) {
        this.rewrite([{ chunk, encoding }], 0, callback);
      }
      _writev(chunks, callback) {
        this.rewrite(chunks, 0, callback);
      }
      async refinal(error, callback) {
        try {
          this.clear();
          if (this.initPromise)
            await this.initPromise;
          if (this.timeoutPromise)
            await this.timeoutPromise;
          await this.reclose();
        } catch (e10) {
          return callback(error || e10);
        }
        callback(error);
      }
      async rewrite(chunks, index, callback) {
        const { size, teeToStdout } = this.options;
        try {
          if (this.initPromise)
            await this.initPromise;
          if (this.timeoutPromise)
            await this.timeoutPromise;
          for (let i7 = 0; i7 < chunks.length; ++i7) {
            const { chunk } = chunks[i7];
            this.size += chunk.length;
            await this.file.write(chunk);
            if (teeToStdout && !this.stdout.destroyed)
              this.stdout.write(chunk);
            if (size && this.size >= size)
              await this.rotate();
          }
        } catch (e10) {
          return callback(e10);
        }
        callback();
      }
      async init() {
        const { immutable, initialRotation, interval, size } = this.options;
        if (immutable)
          return new Promise((resolve4, reject) => process_exports.nextTick(() => this.immutate(true).then(resolve4).catch(reject)));
        let stats;
        try {
          stats = await stat2(this.filename);
        } catch (e10) {
          if (e10.code !== "ENOENT")
            throw e10;
          return this.reopen(0);
        }
        if (!stats.isFile())
          throw new Error(`Can't write on: ${this.filename} (it is not a file)`);
        if (initialRotation) {
          this.intervalBounds(this.now());
          const prev = this.prev;
          this.intervalBounds(new Date(stats.mtime.getTime()));
          if (prev !== this.prev)
            return this.rotate();
        }
        this.size = stats.size;
        if (!size || stats.size < size)
          return this.reopen(stats.size);
        if (interval)
          this.intervalBounds(this.now());
        return this.rotate();
      }
      async makePath(name3) {
        return mkdir2(name3.split(sep).slice(0, -1).join(sep), { recursive: true });
      }
      async reopen(size) {
        let file;
        try {
          file = await open2(this.filename, "a", this.options.mode);
        } catch (e10) {
          if (e10.code !== "ENOENT")
            throw e10;
          await this.makePath(this.filename);
          file = await open2(this.filename, "a", this.options.mode);
        }
        this.file = file;
        this.size = size;
        this.interval();
        this.emit("open", this.filename);
      }
      async reclose() {
        const { file } = this;
        if (!file)
          return;
        delete this.file;
        return file.close();
      }
      now() {
        return /* @__PURE__ */ new Date();
      }
      async rotate() {
        const { immutable, rotate } = this.options;
        this.size = 0;
        this.rotation = this.now();
        this.clear();
        this.emit("rotation");
        await this.reclose();
        if (rotate)
          return this.classical();
        if (immutable)
          return this.immutate(false);
        return this.move();
      }
      async findName() {
        const { interval, path: path2, intervalBoundary } = this.options;
        for (let index = 1; index < 1e3; ++index) {
          const filename = path2 + this.generator(interval && intervalBoundary ? new Date(this.prev) : this.rotation, index);
          if (!await exists2(filename))
            return filename;
        }
        throw new RotatingFileStreamError();
      }
      async move() {
        const { compress } = this.options;
        const filename = await this.findName();
        await this.touch(filename);
        if (compress)
          await this.compress(filename);
        else
          await rename2(this.filename, filename);
        return this.rotated(filename);
      }
      async touch(filename) {
        let file;
        try {
          file = await this.fsOpen(filename, "a");
        } catch (e10) {
          if (e10.code !== "ENOENT")
            throw e10;
          await this.makePath(filename);
          file = await open2(filename, "a");
        }
        await file.close();
        return this.unlink(filename);
      }
      async classical() {
        const { compress, path: path2, rotate } = this.options;
        let rotatedName = "";
        for (let count = rotate; count > 0; --count) {
          const currName = path2 + this.generator(count);
          const prevName = count === 1 ? this.filename : path2 + this.generator(count - 1);
          if (!await exists2(prevName))
            continue;
          if (!rotatedName)
            rotatedName = currName;
          if (count === 1 && compress)
            await this.compress(currName);
          else {
            try {
              await rename2(prevName, currName);
            } catch (e10) {
              if (e10.code !== "ENOENT")
                throw e10;
              await this.makePath(currName);
              await rename2(prevName, currName);
            }
          }
        }
        return this.rotated(rotatedName);
      }
      clear() {
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        return true;
      }
      intervalBoundsBig(now) {
        const year = now.getFullYear();
        let month = now.getMonth();
        let day = now.getDate();
        let hours = now.getHours();
        const { num, unit } = this.options.interval;
        if (unit === "M") {
          day = 1;
          hours = 0;
        } else if (unit === "d")
          hours = 0;
        else
          hours = parseInt(hours / num, 10) * num;
        this.prev = new Date(year, month, day, hours, 0, 0, 0).getTime();
        if (unit === "M")
          month += num;
        else if (unit === "d")
          day += num;
        else
          hours += num;
        this.next = new Date(year, month, day, hours, 0, 0, 0).getTime();
      }
      intervalBounds(now) {
        const unit = this.options.interval.unit;
        if (unit === "M" || unit === "d" || unit === "h")
          this.intervalBoundsBig(now);
        else {
          let period = 1e3 * this.options.interval.num;
          if (unit === "m")
            period *= 60;
          this.prev = parseInt(now.getTime() / period, 10) * period;
          this.next = this.prev + period;
        }
        return new Date(this.prev);
      }
      interval() {
        if (!this.options.interval)
          return;
        this.intervalBounds(this.now());
        const set = async () => {
          const time = this.next - this.now().getTime();
          if (time <= 0) {
            try {
              this.timeoutPromise = this.rotate();
              await this.timeoutPromise;
              delete this.timeoutPromise;
            } catch (e10) {
            }
          } else {
            this.timeout = setTimeout(set, time > this.maxTimeout ? this.maxTimeout : time);
            this.timeout.unref();
          }
        };
        set();
      }
      async compress(filename) {
        const { compress } = this.options;
        if (typeof compress === "function") {
          await new Promise((resolve4, reject) => {
            this.exec(compress(this.filename, filename), (error, stdout2, stderr2) => {
              this.emit("external", stdout2, stderr2);
              error ? reject(error) : resolve4();
            });
          });
        } else
          await this.gzip(filename);
        return this.unlink(this.filename);
      }
      async gzip(filename) {
        const { mode } = this.options;
        const options = mode ? { mode } : {};
        const inp = this.fsCreateReadStream(this.filename, {});
        const out = this.fsCreateWriteStream(filename, options);
        const zip = this.createGzip();
        return new Promise((resolve4, reject) => {
          [inp, out, zip].map((stream2) => stream2.once("error", reject));
          out.once("finish", resolve4);
          inp.pipe(zip).pipe(out);
        });
      }
      async rotated(filename) {
        const { maxFiles, maxSize } = this.options;
        if (maxFiles || maxSize)
          await this.history(filename);
        this.emit("rotated", filename);
        return this.reopen(0);
      }
      async history(filename) {
        const { history, maxFiles, maxSize } = this.options;
        const res = [];
        let files = [filename];
        try {
          const content = await this.fsReadFile(history, "utf8");
          files = [...content.toString().split("\n"), filename];
        } catch (e10) {
          if (e10.code !== "ENOENT")
            throw e10;
        }
        for (const file of files) {
          if (file) {
            try {
              const stats = await this.fsStat(file);
              if (stats.isFile()) {
                res.push({
                  name: file,
                  size: stats.size,
                  time: stats.ctime.getTime()
                });
              } else
                this.emit("warning", new Error(`File '${file}' contained in history is not a regular file`));
            } catch (e10) {
              if (e10.code !== "ENOENT")
                throw e10;
            }
          }
        }
        res.sort((a7, b5) => a7.time - b5.time);
        if (maxFiles) {
          while (res.length > maxFiles) {
            const file = res.shift();
            await this.unlink(file.name);
            this.emit("removed", file.name, true);
          }
        }
        if (maxSize) {
          while (res.reduce((size, file) => size + file.size, 0) > maxSize) {
            const file = res.shift();
            await this.unlink(file.name);
            this.emit("removed", file.name, false);
          }
        }
        await writeFile2(history, res.map((e10) => e10.name).join("\n") + "\n", "utf-8");
        this.emit("history");
      }
      async immutate(first) {
        const { size } = this.options;
        const now = this.now();
        for (let index = 1; index < 1e3; ++index) {
          let fileSize = 0;
          let stats = void 0;
          this.filename = this.options.path + this.generator(now, index);
          try {
            stats = await this.fsStat(this.filename);
          } catch (e10) {
            if (e10.code !== "ENOENT")
              throw e10;
          }
          if (stats) {
            fileSize = stats.size;
            if (!stats.isFile())
              throw new Error(`Can't write on: '${this.filename}' (it is not a file)`);
            if (size && fileSize >= size)
              continue;
          }
          if (first) {
            this.last = this.filename;
            return this.reopen(fileSize);
          }
          await this.rotated(this.last);
          this.last = this.filename;
          return;
        }
        throw new RotatingFileStreamError();
      }
      async unlink(filename) {
        try {
          await this.fsUnlink(filename);
        } catch (e10) {
          if (e10.code !== "ENOENT")
            throw e10;
          this.emit("warning", e10);
        }
      }
    };
    intervalUnits = { M: true, d: true, h: true, m: true, s: true };
    sizeUnits = { B: true, G: true, K: true, M: true };
    checks = {
      encoding: (type2, options, value) => new TextDecoder3(value),
      immutable: () => {
      },
      initialRotation: () => {
      },
      interval: buildStringCheck("interval", checkInterval),
      intervalBoundary: () => {
      },
      maxFiles: buildNumberCheck("maxFiles"),
      maxSize: buildStringCheck("maxSize", checkSize),
      mode: () => {
      },
      omitExtension: () => {
      },
      rotate: buildNumberCheck("rotate"),
      size: buildStringCheck("size", checkSize),
      teeToStdout: () => {
      },
      compress: (type2, options, value) => {
        if (!value)
          throw new Error("A value for 'options.compress' must be specified");
        if (type2 === "boolean")
          return options.compress = (source, dest) => `cat ${source} | gzip -c9 > ${dest}`;
        if (type2 === "function")
          return;
        if (type2 !== "string")
          throw new Error(`Don't know how to handle 'options.compress' type: ${type2}`);
        if (value !== "gzip")
          throw new Error(`Don't know how to handle compression method: ${value}`);
      },
      history: (type2) => {
        if (type2 !== "string")
          throw new Error(`Don't know how to handle 'options.history' type: ${type2}`);
      },
      path: (type2, options, value) => {
        if (type2 !== "string")
          throw new Error(`Don't know how to handle 'options.path' type: ${type2}`);
        if (value[value.length - 1] !== sep)
          options.path = value + sep;
      }
    };
  }
});

// src/logger.ts
var logger_exports = {};
__export(logger_exports, {
  allLoggers: () => allLoggers,
  rootLogger: () => rootLogger
});
var import_pino, stream, rootLogger, allLoggers;
var init_logger = __esm({
  "src/logger.ts"() {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    import_pino = __toESM(require_browser2());
    init_env();
    stream = isBrowser ? null : (
      /**
       * Default rotating file locate at `~/.tabby/agent-logs/`.
       */
      (init_es(), __toCommonJS(es_exports)).createStream("tabby-agent.log", {
        path: (init_path(), __toCommonJS(path_exports)).join((init_os(), __toCommonJS(os_exports)).homedir(), ".tabby", "agent-logs"),
        size: "10M",
        interval: "1d"
      })
    );
    rootLogger = !!stream ? (0, import_pino.default)(stream) : (0, import_pino.default)();
    allLoggers = [rootLogger];
    rootLogger.onChild = (child) => {
      allLoggers.push(child);
    };
  }
});

// node_modules/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/toml/lib/parser.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function() {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function SyntaxError2(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError2, Error);
      function parse3(input) {
        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c1 = function() {
          return nodes;
        }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name3) {
          addNode(node("ObjectPath", name3, line, column));
        }, peg$c12 = function(name3) {
          addNode(node("ArrayPath", name3, line, column));
        }, peg$c13 = function(parts, name3) {
          return parts.concat(name3);
        }, peg$c14 = function(name3) {
          return [name3];
        }, peg$c15 = function(name3) {
          return name3;
        }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
          addNode(node("Assign", value, line, column, key));
        }, peg$c21 = function(chars) {
          return chars.join("");
        }, peg$c22 = function(node2) {
          return node2.value;
        }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
          return node("String", chars.join(""), line, column);
        }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
          return char;
        }, peg$c34 = function(char) {
          return char;
        }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
          return "";
        }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
          return node("Float", parseFloat(left + "e" + right), line, column);
        }, peg$c43 = function(text2) {
          return node("Float", parseFloat(text2), line, column);
        }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
          return digits.join("");
        }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
          return "-" + digits.join("");
        }, peg$c50 = function(text2) {
          return node("Integer", parseInt(text2, 10), line, column);
        }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
          return node("Boolean", true, line, column);
        }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
          return node("Boolean", false, line, column);
        }, peg$c57 = function() {
          return node("Array", [], line, column);
        }, peg$c58 = function(value) {
          return node("Array", value ? [value] : [], line, column);
        }, peg$c59 = function(values) {
          return node("Array", values, line, column);
        }, peg$c60 = function(values, value) {
          return node("Array", values.concat(value), line, column);
        }, peg$c61 = function(value) {
          return value;
        }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
          return node("InlineTable", values, line, column);
        }, peg$c69 = function(key, value) {
          return node("InlineTableValue", value, line, column, key);
        }, peg$c70 = function(digits) {
          return "." + digits;
        }, peg$c71 = function(date) {
          return date.join("");
        }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
          return time.join("");
        }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time) {
          return node("Date", /* @__PURE__ */ new Date(date + "T" + time + "Z"), line, column);
        }, peg$c80 = function(date, time) {
          return node("Date", /* @__PURE__ */ new Date(date + "T" + time), line, column);
        }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
          return "";
        }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d6) {
          return d6.join("");
        }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
          return '"';
        }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
          return "\\";
        }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
          return "\b";
        }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
          return "	";
        }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
          return "\n";
        }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
          return "\f";
        }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
          return "\r";
        }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
          return convertCodePoint(digits.join(""));
        }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p7, ch;
            for (p7 = startPos; p7 < endPos; p7++) {
              ch = input.charAt(p7);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, pos) {
          function cleanupExpected(expected3) {
            var i7 = 1;
            expected3.sort(function(a7, b5) {
              if (a7.description < b5.description) {
                return -1;
              } else if (a7.description > b5.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i7 < expected3.length) {
              if (expected3[i7 - 1] === expected3[i7]) {
                expected3.splice(i7, 1);
              } else {
                i7++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s6) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s6.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i7;
            for (i7 = 0; i7 < expected3.length; i7++) {
              expectedDescs[i7] = expected3[i7].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new SyntaxError2(
            message !== null ? message : buildMessage(expected2, found),
            expected2,
            found,
            pos,
            posDetails.line,
            posDetails.column
          );
        }
        function peg$parsestart() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 0, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseline();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseline();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1();
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseline() {
          var s0, s1, s22, s32, s42, s52, s6;
          var key = peg$currPos * 49 + 1, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseexpression();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s52 = peg$parsecomment();
                while (s52 !== peg$FAILED) {
                  s42.push(s52);
                  s52 = peg$parsecomment();
                }
                if (s42 !== peg$FAILED) {
                  s52 = [];
                  s6 = peg$parseNL();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s52.push(s6);
                      s6 = peg$parseNL();
                    }
                  } else {
                    s52 = peg$c2;
                  }
                  if (s52 === peg$FAILED) {
                    s52 = peg$parseEOF();
                  }
                  if (s52 !== peg$FAILED) {
                    s1 = [s1, s22, s32, s42, s52];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parseS();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseNL();
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$parseNL();
                }
              } else {
                s22 = peg$c2;
              }
              if (s22 === peg$FAILED) {
                s22 = peg$parseEOF();
              }
              if (s22 !== peg$FAILED) {
                s1 = [s1, s22];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseexpression() {
          var s0;
          var key = peg$currPos * 49 + 2, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsecomment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepath();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetablearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parseassignment();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s22, s32, s42, s52;
          var key = peg$currPos * 49 + 3, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s52 = peg$parseNL();
            if (s52 === peg$FAILED) {
              s52 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s52 === peg$FAILED) {
              s42 = peg$c5;
            } else {
              peg$currPos = s42;
              s42 = peg$c2;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s52 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s52 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s52 !== peg$FAILED) {
                s42 = [s42, s52];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$c2;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s52 = peg$parseNL();
              if (s52 === peg$FAILED) {
                s52 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s52 === peg$FAILED) {
                s42 = peg$c5;
              } else {
                peg$currPos = s42;
                s42 = peg$c2;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s52 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s52 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s52 !== peg$FAILED) {
                  s42 = [s42, s52];
                  s32 = s42;
                } else {
                  peg$currPos = s32;
                  s32 = peg$c2;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
            }
            if (s22 !== peg$FAILED) {
              s1 = [s1, s22];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1, s22, s32, s42, s52;
          var key = peg$currPos * 49 + 4, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parsetable_key();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s52 = peg$parseS();
                while (s52 !== peg$FAILED) {
                  s42.push(s52);
                  s52 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s52 = peg$c9;
                    peg$currPos++;
                  } else {
                    s52 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s52 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11(s32);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetablearray() {
          var s0, s1, s22, s32, s42, s52, s6, s7;
          var key = peg$currPos * 49 + 5, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s22 = peg$c7;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                s42 = peg$parsetable_key();
                if (s42 !== peg$FAILED) {
                  s52 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s52.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s52 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s6 = peg$c9;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s7 = peg$c9;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c12(s42);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 6, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsedot_ended_table_key_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parsedot_ended_table_key_part();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsetable_key_part();
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s1, s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetable_key_part();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c14(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key_part() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 7, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsequoted_key();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedot_ended_table_key_part() {
          var s0, s1, s22, s32, s42, s52, s6;
          var key = peg$currPos * 49 + 8, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s52 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s52.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s52 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsequoted_key();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s42 = peg$c16;
                    peg$currPos++;
                  } else {
                    s42 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s42 !== peg$FAILED) {
                    s52 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s52.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s52 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s22);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseassignment() {
          var s0, s1, s22, s32, s42, s52;
          var key = peg$currPos * 49 + 9, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsekey();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s32 = peg$c18;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s52 = peg$parseS();
                while (s52 !== peg$FAILED) {
                  s42.push(s52);
                  s52 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  s52 = peg$parsevalue();
                  if (s52 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s52);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequoted_key();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseS();
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parseS();
              }
              if (s22 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s32 = peg$c18;
                  peg$currPos++;
                } else {
                  s32 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s32 !== peg$FAILED) {
                  s42 = [];
                  s52 = peg$parseS();
                  while (s52 !== peg$FAILED) {
                    s42.push(s52);
                    s52 = peg$parseS();
                  }
                  if (s42 !== peg$FAILED) {
                    s52 = peg$parsevalue();
                    if (s52 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s52);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsekey() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 10, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseASCII_BASIC();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseASCII_BASIC();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsequoted_key() {
          var s0, s1;
          var key = peg$currPos * 49 + 11, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedouble_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesingle_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsevalue() {
          var s0;
          var key = peg$currPos * 49 + 12, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedatetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefloat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinteger();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsearray();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseinline_table();
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring() {
          var s0;
          var key = peg$currPos * 49 + 13, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsedouble_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_quoted_single_line_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_multiline_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_single_line_string();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_multiline_string() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 14, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 === peg$FAILED) {
              s22 = peg$c25;
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsemultiline_string_char();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsemultiline_string_char();
              }
              if (s32 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s42 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_single_line_string() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 15, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parsestring_char();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsestring_char();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s32 = peg$c27;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_multiline_string() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 16, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 === peg$FAILED) {
              s22 = peg$c25;
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsemultiline_literal_char();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsemultiline_literal_char();
              }
              if (s32 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c29) {
                  s42 = peg$c29;
                  peg$currPos += 3;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_single_line_string() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 17, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c31;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseliteral_char();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseliteral_char();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s32 = peg$c31;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 18, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s22 = peg$c27;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            peg$silentFails--;
            if (s22 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseliteral_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 19, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 39) {
            s22 = peg$c31;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          peg$silentFails--;
          if (s22 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 20, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemultiline_string_delim();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s22 = peg$c23;
                peg$currPos += 3;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              peg$silentFails--;
              if (s22 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s22 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c34(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_delim() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 21, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseNLS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseNLS();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_literal_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 22, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s22 = peg$c29;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          peg$silentFails--;
          if (s22 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 23, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger_text();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 101) {
              s22 = peg$c38;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c39);
              }
            }
            if (s22 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 69) {
                s22 = peg$c40;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c41);
                }
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseinteger_text();
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c42(s1, s32);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat_text() {
          var s0, s1, s22, s32, s42, s52;
          var key = peg$currPos * 49 + 24, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseDIGITS();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s42 = peg$c16;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s42 !== peg$FAILED) {
                s52 = peg$parseDIGITS();
                if (s52 !== peg$FAILED) {
                  s32 = [s32, s42, s52];
                  s22 = s32;
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$currPos;
              s32 = peg$parseDIGITS();
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s52 = peg$parseDIGITS();
                  if (s52 !== peg$FAILED) {
                    s32 = [s32, s42, s52];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger() {
          var s0, s1;
          var key = peg$currPos * 49 + 25, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseinteger_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger_text() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 26, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s42 = peg$c16;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s42 === peg$FAILED) {
                s32 = peg$c5;
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseDIGIT_OR_UNDER();
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                s32 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s42 === peg$FAILED) {
                  s32 = peg$c5;
                } else {
                  peg$currPos = s32;
                  s32 = peg$c2;
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseboolean() {
          var s0, s1;
          var key = peg$currPos * 49 + 27, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c53();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c54) {
              s1 = peg$c54;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c56();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 28, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parsearray_sep();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsearray_sep();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s32 = peg$c9;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c57();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsearray_value();
              if (s22 === peg$FAILED) {
                s22 = peg$c25;
              }
              if (s22 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s32 = peg$c9;
                  peg$currPos++;
                } else {
                  s32 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$parsearray_value_list();
                if (s32 !== peg$FAILED) {
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parsearray_value_list();
                  }
                } else {
                  s22 = peg$c2;
                }
                if (s22 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s32 = peg$c9;
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s32 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c59(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parsearray_value_list();
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parsearray_value_list();
                    }
                  } else {
                    s22 = peg$c2;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsearray_value();
                    if (s32 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s42 = peg$c9;
                        peg$currPos++;
                      } else {
                        s42 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s42 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s22, s32);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 29, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsearray_sep();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsevalue();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsearray_sep();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsearray_sep();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value_list() {
          var s0, s1, s22, s32, s42, s52, s6;
          var key = peg$currPos * 49 + 30, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsearray_sep();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsevalue();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsearray_sep();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsearray_sep();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c62;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s52 = [];
                  s6 = peg$parsearray_sep();
                  while (s6 !== peg$FAILED) {
                    s52.push(s6);
                    s6 = peg$parsearray_sep();
                  }
                  if (s52 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c61(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_sep() {
          var s0;
          var key = peg$currPos * 49 + 31, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table() {
          var s0, s1, s22, s32, s42, s52;
          var key = peg$currPos * 49 + 32, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c64;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseinline_table_assignment();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseinline_table_assignment();
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s52 = peg$parseS();
                while (s52 !== peg$FAILED) {
                  s42.push(s52);
                  s52 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s52 = peg$c66;
                    peg$currPos++;
                  } else {
                    s52 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c67);
                    }
                  }
                  if (s52 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s32);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table_assignment() {
          var s0, s1, s22, s32, s42, s52, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 33, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s42 = peg$c18;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s52 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s52.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s52 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s8 = peg$c62;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c69(s22, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsekey();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s42 = peg$c18;
                    peg$currPos++;
                  } else {
                    s42 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s42 !== peg$FAILED) {
                    s52 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s52.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s52 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s22, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesecfragment() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 34, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseDIGITS();
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c70(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedate() {
          var s0, s1, s22, s32, s42, s52, s6, s7, s8, s9, s10, s11;
          var key = peg$currPos * 49 + 35, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseDIGIT_OR_UNDER();
              if (s42 !== peg$FAILED) {
                s52 = peg$parseDIGIT_OR_UNDER();
                if (s52 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s6 = peg$c47;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDIGIT_OR_UNDER();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s9 = peg$c47;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseDIGIT_OR_UNDER();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseDIGIT_OR_UNDER();
                            if (s11 !== peg$FAILED) {
                              s22 = [s22, s32, s42, s52, s6, s7, s8, s9, s10, s11];
                              s1 = s22;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c71(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime() {
          var s0, s1, s22, s32, s42, s52, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 36, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c72;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s42 !== peg$FAILED) {
                s52 = peg$parseDIGIT_OR_UNDER();
                if (s52 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            s22 = [s22, s32, s42, s52, s6, s7, s8, s9, s10];
                            s1 = s22;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime_with_offset() {
          var s0, s1, s22, s32, s42, s52, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
          var key = peg$currPos * 49 + 37, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c72;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s42 !== peg$FAILED) {
                s52 = peg$parseDIGIT_OR_UNDER();
                if (s52 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                              s11 = peg$c47;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                              }
                            }
                            if (s11 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 43) {
                                s11 = peg$c44;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c45);
                                }
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseDIGIT_OR_UNDER();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseDIGIT_OR_UNDER();
                                if (s13 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 58) {
                                    s14 = peg$c72;
                                    peg$currPos++;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c73);
                                    }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseDIGIT_OR_UNDER();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parseDIGIT_OR_UNDER();
                                      if (s16 !== peg$FAILED) {
                                        s22 = [s22, s32, s42, s52, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                        s1 = s22;
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedatetime() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 38, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s22 = peg$c75;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parsetime();
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 90) {
                  s42 = peg$c77;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c78);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c79(s1, s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s22 = peg$c75;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s22 !== peg$FAILED) {
                s32 = peg$parsetime_with_offset();
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseS() {
          var s0;
          var key = peg$currPos * 49 + 39, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c81.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNL() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 40, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c83;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 13) {
              s1 = peg$c85;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s22 = peg$c83;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s22 !== peg$FAILED) {
                s1 = [s1, s22];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNLS() {
          var s0;
          var key = peg$currPos * 49 + 41, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseS();
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key = peg$currPos * 49 + 42, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = peg$c5;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          var key = peg$currPos * 49 + 43, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c87.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGIT_OR_UNDER() {
          var s0, s1;
          var key = peg$currPos * 49 + 44, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c89.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c91;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c93();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseASCII_BASIC() {
          var s0;
          var key = peg$currPos * 49 + 45, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGITS() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 46, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c96(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED() {
          var s0, s1;
          var key = peg$currPos * 49 + 47, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c99();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c100) {
              s1 = peg$c100;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c102();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c103) {
                s1 = peg$c103;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c105();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                  s1 = peg$c106;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c107);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c108();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c111();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c113);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c114();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c115) {
                        s1 = peg$c115;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c116);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c117();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseESCAPED_UNICODE();
                      }
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED_UNICODE() {
          var s0, s1, s22, s32, s42, s52, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 48, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseHEX();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseHEX();
              if (s42 !== peg$FAILED) {
                s52 = peg$parseHEX();
                if (s52 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s32 = [s32, s42, s52, s6, s7, s8, s9, s10];
                            s22 = s32;
                          } else {
                            peg$currPos = s22;
                            s22 = peg$c2;
                          }
                        } else {
                          peg$currPos = s22;
                          s22 = peg$c2;
                        }
                      } else {
                        peg$currPos = s22;
                        s22 = peg$c2;
                      }
                    } else {
                      peg$currPos = s22;
                      s22 = peg$c2;
                    }
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c121) {
              s1 = peg$c121;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$currPos;
              s32 = peg$parseHEX();
              if (s32 !== peg$FAILED) {
                s42 = peg$parseHEX();
                if (s42 !== peg$FAILED) {
                  s52 = peg$parseHEX();
                  if (s52 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s32 = [s32, s42, s52, s6];
                      s22 = s32;
                    } else {
                      peg$currPos = s22;
                      s22 = peg$c2;
                    }
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        var nodes = [];
        function genError(err, line2, col) {
          var ex = new Error(err);
          ex.line = line2;
          ex.column = col;
          throw ex;
        }
        function addNode(node2) {
          nodes.push(node2);
        }
        function node(type2, value, line2, column2, key) {
          var obj = { type: type2, value, line: line2(), column: column2() };
          if (key)
            obj.key = key;
          return obj;
        }
        function convertCodePoint(str, line2, col) {
          var num = parseInt("0x" + str);
          if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
            genError("Invalid Unicode escape code: " + str, line2, col);
          } else {
            return fromCodePoint(num);
          }
        }
        function fromCodePoint() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += String.fromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError: SyntaxError2,
        parse: parse3
      };
    }();
  }
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/toml/lib/compiler.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    function compile(nodes) {
      var assignedPaths = [];
      var valueAssignments = [];
      var currentPath = "";
      var data = /* @__PURE__ */ Object.create(null);
      var context = data;
      return reduce(nodes);
      function reduce(nodes2) {
        var node;
        for (var i7 = 0; i7 < nodes2.length; i7++) {
          node = nodes2[i7];
          switch (node.type) {
            case "Assign":
              assign(node);
              break;
            case "ObjectPath":
              setPath(node);
              break;
            case "ArrayPath":
              addTableArray(node);
              break;
          }
        }
        return data;
      }
      function genError(err, line, col) {
        var ex = new Error(err);
        ex.line = line;
        ex.column = col;
        throw ex;
      }
      function assign(node) {
        var key = node.key;
        var value = node.value;
        var line = node.line;
        var column = node.column;
        var fullPath;
        if (currentPath) {
          fullPath = currentPath + "." + key;
        } else {
          fullPath = key;
        }
        if (typeof context[key] !== "undefined") {
          genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
        }
        context[key] = reduceValueNode(value);
        if (!pathAssigned(fullPath)) {
          assignedPaths.push(fullPath);
          valueAssignments.push(fullPath);
        }
      }
      function pathAssigned(path2) {
        return assignedPaths.indexOf(path2) !== -1;
      }
      function reduceValueNode(node) {
        if (node.type === "Array") {
          return reduceArrayWithTypeChecking(node.value);
        } else if (node.type === "InlineTable") {
          return reduceInlineTableNode(node.value);
        } else {
          return node.value;
        }
      }
      function reduceInlineTableNode(values) {
        var obj = /* @__PURE__ */ Object.create(null);
        for (var i7 = 0; i7 < values.length; i7++) {
          var val = values[i7];
          if (val.value.type === "InlineTable") {
            obj[val.key] = reduceInlineTableNode(val.value.value);
          } else if (val.type === "InlineTableValue") {
            obj[val.key] = reduceValueNode(val.value);
          }
        }
        return obj;
      }
      function setPath(node) {
        var path2 = node.value;
        var quotedPath = path2.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (pathAssigned(quotedPath)) {
          genError("Cannot redefine existing key '" + path2 + "'.", line, column);
        }
        assignedPaths.push(quotedPath);
        context = deepRef(data, path2, /* @__PURE__ */ Object.create(null), line, column);
        currentPath = path2;
      }
      function addTableArray(node) {
        var path2 = node.value;
        var quotedPath = path2.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (!pathAssigned(quotedPath)) {
          assignedPaths.push(quotedPath);
        }
        assignedPaths = assignedPaths.filter(function(p7) {
          return p7.indexOf(quotedPath) !== 0;
        });
        assignedPaths.push(quotedPath);
        context = deepRef(data, path2, [], line, column);
        currentPath = quotedPath;
        if (context instanceof Array) {
          var newObj = /* @__PURE__ */ Object.create(null);
          context.push(newObj);
          context = newObj;
        } else {
          genError("Cannot redefine existing key '" + path2 + "'.", line, column);
        }
      }
      function deepRef(start, keys, value, line, column) {
        var traversed = [];
        var traversedPath = "";
        keys.join(".");
        var ctx = start;
        for (var i7 = 0; i7 < keys.length; i7++) {
          var key = keys[i7];
          traversed.push(key);
          traversedPath = traversed.join(".");
          if (typeof ctx[key] === "undefined") {
            if (i7 === keys.length - 1) {
              ctx[key] = value;
            } else {
              ctx[key] = /* @__PURE__ */ Object.create(null);
            }
          } else if (i7 !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
            genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
          }
          ctx = ctx[key];
          if (ctx instanceof Array && ctx.length && i7 < keys.length - 1) {
            ctx = ctx[ctx.length - 1];
          }
        }
        return ctx;
      }
      function reduceArrayWithTypeChecking(array) {
        var firstType = null;
        for (var i7 = 0; i7 < array.length; i7++) {
          var node = array[i7];
          if (firstType === null) {
            firstType = node.type;
          } else {
            if (node.type !== firstType) {
              genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
            }
          }
        }
        return array.map(reduceValueNode);
      }
      function quoteDottedString(str) {
        if (str.indexOf(".") > -1) {
          return '"' + str + '"';
        } else {
          return str;
        }
      }
    }
    module.exports = {
      compile
    };
  }
});

// node_modules/toml/index.js
var require_toml = __commonJS({
  "node_modules/toml/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var parser = require_parser();
    var compiler = require_compiler();
    module.exports = {
      parse: function(input) {
        var nodes = parser.parse(input.toString());
        return compiler.compile(nodes);
      }
    };
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path2.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var win322 = process_exports.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports10.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports10.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports10.isRegexChar = (str) => str.length === 1 && exports10.hasRegexChars(str);
    exports10.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports10.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports10.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports10.supportsLookbehinds = () => {
      const segs = process_exports.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports10.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path2.sep === "\\";
    };
    exports10.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports10.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports10.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports10.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append2 = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append2}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished2 = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH2) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished2 = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished2 = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished2 = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH2) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished2 === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished2 = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH2) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished2 = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished2 = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished2 = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished2 = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished2 = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished2 = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n9 = prevIndex ? prevIndex + 1 : start;
          const i7 = slashes[idx];
          const value = input.slice(n9, i7);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i7;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var constants4 = require_constants();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants4;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v7) => utils.escapeRegex(v7)).join("..");
      }
      return value;
    };
    var syntaxError = (type2, char) => {
      return `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils.isWindows(options);
      const PLATFORM_CHARS = constants4.globChars(win322);
      const EXTGLOB_CHARS = constants4.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n9 = 1) => input[state.index + n9];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type2) => {
        state[type2]++;
        stack.push(type2);
      };
      const decrement = (type2) => {
        state[type2]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type2, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m6, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m6;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m6 : `\\${m6}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m6) => {
              return m6.length % 2 === 0 ? "\\\\" : m6 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open3 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open3);
          push(open3);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i7 = arr.length - 1; i7 >= 0; i7--) {
              tokens.pop();
              if (arr[i7].type === "brace") {
                break;
              }
              if (arr[i7].type !== "dots") {
                range.unshift(arr[i7].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t9 of toks) {
              state.output += t9.output || t9.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants4.globChars(win322);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse3;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var scan = require_scan();
    var parse3 = require_parse();
    var utils = require_utils3();
    var constants4 = require_constants();
    var isObject4 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject4(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
        const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format5 = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format5 ? format5(input) : input;
      if (match === false) {
        output = format5 ? format5(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix2);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix2 = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p7) => picomatch.parse(p7, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants4;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = require_picomatch();
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = (init_fs(), __toCommonJS(fs_exports));
    var { Readable: Readable2 } = (init_stream(), __toCommonJS(stream_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify: promisify3 } = (init_util(), __toCommonJS(util_exports));
    var picomatch = require_picomatch2();
    var readdir3 = promisify3(fs2.readdir);
    var stat3 = promisify3(fs2.stat);
    var lstat3 = promisify3(fs2.lstat);
    var realpath3 = promisify3(fs2.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min] = process_exports.versions.node.split(".").slice(0, 2).map((n9) => Number.parseInt(n9, 10));
    var wantBigintFsStats = process_exports.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter2) => {
      if (filter2 === void 0)
        return;
      if (typeof filter2 === "function")
        return filter2;
      if (typeof filter2 === "string") {
        const glob = picomatch(filter2.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f7) => f7(entry.basename)) && !negative.some((f7) => f7(entry.basename));
          }
          return (entry) => !negative.some((f7) => f7(entry.basename));
        }
        return (entry) => positive.some((f7) => f7(entry.basename));
      }
    };
    var ReaddirpStream = class extends Readable2 {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path2) => true,
          directoryFilter: (path2) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark || 4096
        });
        const opts = { ...ReaddirpStream.defaultOptions, ...options };
        const { root, type: type2 } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat3 : stat3;
        if (wantBigintFsStats) {
          this._stat = (path2) => statMethod(path2, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type2);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type2);
        this._wantsEverything = type2 === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = "Dirent" in fs2 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path2, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path2));
              for (const entry of await Promise.all(slice)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path2, depth) {
        let files;
        try {
          files = await readdir3(path2, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path: path2 };
      }
      async _formatEntry(dirent, path2) {
        let entry;
        try {
          const basename2 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path2, basename2));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename: basename2 };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath3(full);
            const entryRealPathStats = await lstat3(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root, options = {}) => {
      let type2 = options.entryType || options.type;
      if (type2 === "both")
        type2 = FILE_DIR_TYPE;
      if (type2)
        options.type = type2;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type2 && !ALL_TYPES.includes(type2)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve4, reject) => {
        const files = [];
        readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve4(files)).on("error", (error) => reject(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module.exports = readdirp;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function(path2, stripTrailing) {
      if (typeof path2 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path2 === "\\" || path2 === "/")
        return "/";
      var len = path2.length;
      if (len <= 1)
        return path2;
      var prefix = "";
      if (len > 4 && path2[3] === "\\") {
        var ch = path2[2];
        if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
          path2 = path2.slice(2);
          prefix = "//";
        }
      }
      var segs = path2.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    Object.defineProperty(exports10, "__esModule", { value: true });
    var picomatch = require_picomatch2();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path2 = normalizePath(_path, false);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path2)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path2].concat(args.slice(1));
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path2)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options === "boolean" ? { returnIndex: options } : options;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module.exports = anymatch;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close2 = chars[open3];
          if (close2) {
            var n9 = str.indexOf(close2, index);
            if (n9 !== -1) {
              index = n9 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close2 = chars[open3];
          if (close2) {
            var n9 = str.indexOf(close2, index);
            if (n9 !== -1) {
              index = n9 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isGlob = require_is_glob();
    var pathPosixDirname = (init_path(), __toCommonJS(path_exports)).posix.dirname;
    var isWin32 = (init_os(), __toCommonJS(os_exports)).platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports10.find = (node, type2) => node.nodes.find((node2) => node2.type === type2);
    exports10.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports10.isInteger(min) || !exports10.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports10.escapeNode = (block, n9 = 0, type2) => {
      let node = block.nodes[n9];
      if (!node)
        return;
      if (type2 && node.type === type2 || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports10.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports10.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports10.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports10.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports10.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i7 = 0; i7 < arr.length; i7++) {
          let ele = arr[i7];
          Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var utils = require_utils4();
    module.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var isNumber4 = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber4(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber4(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a7 = Math.min(min, max);
      let b5 = Math.max(min, max);
      if (Math.abs(a7 - b5) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a: a7, b: b5 };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a7 < 0) {
        let newMin = b5 < 0 ? Math.abs(b5) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a7), state, opts);
        a7 = state.a = 0;
      }
      if (b5 >= 0) {
        positives = splitToPatterns(a7, b5, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false) || [];
      let intersected = filterPatterns(neg, pos, "-?", true) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i7 = 0; i7 < digits; i7++) {
        let [startDigit, stopDigit] = zipped[i7];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i7 = 0; i7 < ranges.length; i7++) {
        let max2 = ranges[i7];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a7, b5) {
      let arr = [];
      for (let i7 = 0; i7 < a7.length; i7++)
        arr.push([a7[i7], b5[i7]]);
      return arr;
    }
    function compare(a7, b5) {
      return a7 > b5 ? 1 : b5 > a7 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a7, b5, options) {
      return `[${a7}${b5 - a7 === 1 ? "" : "-"}${b5}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var util = (init_util(), __toCommonJS(util_exports));
    var toRegexRange = require_to_regex_range();
    var isObject4 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber4 = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a7, b5) => a7 < b5 ? -1 : a7 > b5 ? 1 : 0);
      parts.positives.sort((a7, b5) => a7 < b5 ? -1 : a7 > b5 ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a7, b5, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a7, b5, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a7);
      if (a7 === b5)
        return start;
      let stop = String.fromCharCode(b5);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a7 = Number(start);
      let b5 = Number(end);
      if (!Number.isInteger(a7) || !Number.isInteger(b5)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a7 === 0)
        a7 = 0;
      if (b5 === 0)
        b5 = 0;
      let descending = a7 > b5;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format5 = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a7 >= b5 : a7 <= b5) {
        if (options.toRegex === true && step > 1) {
          push(a7);
        } else {
          range.push(pad(format5(a7, index), maxLen, toNumber));
        }
        a7 = descending ? a7 - step : a7 + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber4(start) && start.length > 1 || !isNumber4(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format5 = options.transform || ((val) => String.fromCharCode(val));
      let a7 = `${start}`.charCodeAt(0);
      let b5 = `${end}`.charCodeAt(0);
      let descending = a7 > b5;
      let min = Math.min(a7, b5);
      let max = Math.max(a7, b5);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a7 >= b5 : a7 <= b5) {
        range.push(format5(a7, index));
        a7 = descending ? a7 - step : a7 + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject4(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber4(step)) {
        if (step != null && !isObject4(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber4(start) && isNumber4(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fill = require_fill_range();
    var utils = require_utils4();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils4();
    var append2 = (queue2 = "", stash = "", enclose = false) => {
      let result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append2(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append2(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p7 = parent;
        let q3 = parent.queue;
        while (p7.type !== "brace" && p7.type !== "root" && p7.parent) {
          p7 = p7.parent;
          q3 = p7.queue;
        }
        if (node.invalid || node.dollar) {
          q3.push(append2(q3.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q3.push(append2(q3.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q3.push(append2(q3.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue2 = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i7 = 0; i7 < node.nodes.length; i7++) {
          let child = node.nodes[i7];
          if (child.type === "comma" && node.type === "brace") {
            if (i7 === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q3.push(append2(q3.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append2(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue2;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse3 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open3 = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open3) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type2 = "close";
          block = stack.pop();
          block.close = true;
          push({ type: type2, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open3 = block.nodes.shift();
            block.nodes = [open3, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse3;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse3 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse3(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports10, module) {
    module.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module.exports = (filePath) => extensions.has(path2.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/chokidar/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/chokidar/lib/constants.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var { sep: sep2 } = (init_path(), __toCommonJS(path_exports));
    var { platform: platform3 } = process_exports;
    var os = (init_os(), __toCommonJS(os_exports));
    exports10.EV_ALL = "all";
    exports10.EV_READY = "ready";
    exports10.EV_ADD = "add";
    exports10.EV_CHANGE = "change";
    exports10.EV_ADD_DIR = "addDir";
    exports10.EV_UNLINK = "unlink";
    exports10.EV_UNLINK_DIR = "unlinkDir";
    exports10.EV_RAW = "raw";
    exports10.EV_ERROR = "error";
    exports10.STR_DATA = "data";
    exports10.STR_END = "end";
    exports10.STR_CLOSE = "close";
    exports10.FSEVENT_CREATED = "created";
    exports10.FSEVENT_MODIFIED = "modified";
    exports10.FSEVENT_DELETED = "deleted";
    exports10.FSEVENT_MOVED = "moved";
    exports10.FSEVENT_CLONED = "cloned";
    exports10.FSEVENT_UNKNOWN = "unknown";
    exports10.FSEVENT_TYPE_FILE = "file";
    exports10.FSEVENT_TYPE_DIRECTORY = "directory";
    exports10.FSEVENT_TYPE_SYMLINK = "symlink";
    exports10.KEY_LISTENERS = "listeners";
    exports10.KEY_ERR = "errHandlers";
    exports10.KEY_RAW = "rawEmitters";
    exports10.HANDLER_KEYS = [exports10.KEY_LISTENERS, exports10.KEY_ERR, exports10.KEY_RAW];
    exports10.DOT_SLASH = `.${sep2}`;
    exports10.BACK_SLASH_RE = /\\/g;
    exports10.DOUBLE_SLASH_RE = /\/\//;
    exports10.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports10.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports10.REPLACER_RE = /^\.[/\\]/;
    exports10.SLASH = "/";
    exports10.SLASH_SLASH = "//";
    exports10.BRACE_START = "{";
    exports10.BANG = "!";
    exports10.ONE_DOT = ".";
    exports10.TWO_DOTS = "..";
    exports10.STAR = "*";
    exports10.GLOBSTAR = "**";
    exports10.ROOT_GLOBSTAR = "/**/*";
    exports10.SLASH_GLOBSTAR = "/**";
    exports10.DIR_SUFFIX = "Dir";
    exports10.ANYMATCH_OPTS = { dot: true };
    exports10.STRING_TYPE = "string";
    exports10.FUNCTION_TYPE = "function";
    exports10.EMPTY_STR = "";
    exports10.EMPTY_FN = () => {
    };
    exports10.IDENTITY_FN = (val) => val;
    exports10.isWindows = platform3 === "win32";
    exports10.isMacos = platform3 === "darwin";
    exports10.isLinux = platform3 === "linux";
    exports10.isIBMi = os.type() === "OS400";
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify: promisify3 } = (init_util(), __toCommonJS(util_exports));
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows: isWindows2,
      isLinux,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants3();
    var THROTTLE_MODE_WATCH = "watch";
    var open3 = promisify3(fs2.open);
    var stat3 = promisify3(fs2.stat);
    var lstat3 = promisify3(fs2.lstat);
    var close2 = promisify3(fs2.close);
    var fsrealpath = promisify3(fs2.realpath);
    var statMethods = { lstat: lstat3, stat: stat3 };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path2, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path2);
        emitRaw(rawEvent, evPath, { watchedPath: path2 });
        if (evPath && path2 !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path2, evPath),
            KEY_LISTENERS,
            sysPath.join(path2, evPath)
          );
        }
      };
      try {
        return fs2.watch(path2, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type2, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type2], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path2, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path2,
          options,
          listener,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path2,
          options,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows2 && error.code === "EPERM") {
            try {
              const fd = await open3(path2, "r");
              await close2(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path2, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        cont.listeners;
        cont.rawEmitters;
        fs2.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: fs2.watchFile(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path2, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs2.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path2, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path2);
        const basename2 = sysPath.basename(path2);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath.resolve(path2);
        const options = { persistent: opts.persistent };
        if (!listener)
          listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path2, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path2, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname2 = sysPath.dirname(file);
        const basename2 = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname2);
        let prevStats = stats;
        if (parent.has(basename2))
          return;
        const listener = async (path2, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat3(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path2);
                prevStats = newStats2;
                this.fsw._addPathCloser(path2, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname2, basename2);
            }
          } else if (parent.has(basename2)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0))
            return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry, directory, path2, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path2);
          } catch (e10) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path2, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path2, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream2 = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          const item = entry.path;
          let path2 = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path2, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path2 = sysPath.join(dir, sysPath.relative(dir, path2));
            this._addToNodeFs(path2, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise(
          (resolve4) => stream2.once(STR_END, () => {
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve4();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream2 = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath3) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath3)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path2, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path2) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path2, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path2.includes(STAR) && !path2.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path2);
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path2, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path2), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path2, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path2;
          }
        }
      }
    };
    module.exports = NodeFsHandler;
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var fs2 = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify: promisify3 } = (init_util(), __toCommonJS(util_exports));
    var fsevents;
    try {
      fsevents = __require("fsevents");
    } catch (error) {
      if (process_exports.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    if (fsevents) {
      const mtch = process_exports.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants3();
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat3 = promisify3(fs2.stat);
    var lstat3 = promisify3(fs2.lstat);
    var realpath3 = promisify3(fs2.realpath);
    var statMethods = { stat: stat3, lstat: lstat3 };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path2, callback) => {
      const stop = fsevents.watch(path2, callback);
      return { stop };
    };
    function setFSEventsListener(path2, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path2);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path2) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path2) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path2, root) => {
      let i7 = 0;
      while (!path2.indexOf(root) && (path2 = sysPath.dirname(path2)) !== root)
        i7++;
      return i7;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path2, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path2, stats)) {
          ipaths.add(path2);
          if (stats && stats.isDirectory()) {
            ipaths.add(path2 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path2);
        ipaths.delete(path2 + ROOT_GLOBSTAR);
      }
      addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat3(path2);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path2))
          return;
        if (event === EV_UNLINK) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path2);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path2, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path2);
          if (eventName === EV_ADD_DIR)
            this._addToFsEvents(path2, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path2 = transform(sysPath.join(
            watchPath,
            sysPath.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path2))
            return;
          const parent = sysPath.dirname(path2);
          const item = sysPath.basename(path2);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path2 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat3(path2);
              } catch (error) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path2, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath3(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path2) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path2.replace(linkTarget, linkPath);
            } else if (path2 !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path2);
            }
            return transform(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        if (isDir)
          this.fsw._getWatchedDir(pp);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
      initWatch(realPath, path2, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path2, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path2, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path2);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path2), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry))
                return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform === FUNCTION_TYPE) {
            this.initWatch(void 0, path2, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath3(wh.watchPath);
            } catch (e10) {
            }
            this.initWatch(realPath, path2, wh, processPath);
          }
        }
      }
    };
    module.exports = FsEventsHandler;
    module.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var { EventEmitter: EventEmitter2 } = (init_events(), __toCommonJS(events_exports));
    var fs2 = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify: promisify3 } = (init_util(), __toCommonJS(util_exports));
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows2,
      isMacos,
      isIBMi
    } = require_constants3();
    var stat3 = promisify3(fs2.stat);
    var readdir3 = promisify3(fs2.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p7) => typeof p7 === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path2) => toUnix(sysPath.normalize(toUnix(path2)));
    var normalizeIgnored = (cwd2 = EMPTY_STR) => (path2) => {
      if (typeof path2 !== STRING_TYPE)
        return path2;
      return normalizePathToUnix(sysPath.isAbsolute(path2) ? path2 : sysPath.join(cwd2, path2));
    };
    var getAbsolutePath = (path2, cwd2) => {
      if (sysPath.isAbsolute(path2)) {
        return path2;
      }
      if (path2.startsWith(BANG)) {
        return BANG + sysPath.join(cwd2, path2.slice(1));
      }
      return sysPath.join(cwd2, path2);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir3(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path2, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path2 = path2.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path2;
        if (path2 === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path2, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path2);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
        );
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path2) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path2.includes(BRACE_START) ? braces.expand(path2) : [path2];
        expandedPath.forEach((path3) => {
          parts.push(sysPath.relative(this.watchPath, path3).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i7) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i7] || anymatch(part, entryParts[0][i7], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter2 {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process_exports.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process_exports.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process_exports.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd: cwd2, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd2) {
          paths = paths.map((path2) => {
            const absPath = getAbsolutePath(path2, cwd2);
            if (disableGlobbing || !isGlob(path2)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path2) => {
          if (path2.startsWith(BANG)) {
            this._ignoredPaths.add(path2.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path2);
          this._ignoredPaths.delete(path2 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path2) => this._fsEventsHandler._addToFsEvents(path2));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path2) => {
              const res = await this._nodeFsHandler._addToNodeFs(path2, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd: cwd2 } = this.options;
        paths.forEach((path2) => {
          if (!sysPath.isAbsolute(path2) && !this._closers.has(path2)) {
            if (cwd2)
              path2 = sysPath.join(cwd2, path2);
            path2 = sysPath.resolve(path2);
          }
          this._closePath(path2);
          this._ignoredPaths.add(path2);
          if (this._watched.has(path2)) {
            this._ignoredPaths.add(path2 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream2) => stream2.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path2, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows2)
          path2 = sysPath.normalize(path2);
        if (opts.cwd)
          path2 = sysPath.relative(opts.cwd, path2);
        const args = [event, path2];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path2))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path2, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path3) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path3);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path2)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path2);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path2, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path2, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path2) : path2;
          let stats;
          try {
            stats = await stat3(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path2, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path2);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path2);
          const count = item ? item.count : 0;
          action.delete(path2);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path2, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path2, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path2;
        if (this.options.cwd && !sysPath.isAbsolute(path2)) {
          fullPath = sysPath.join(this.options.cwd, path2);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs2.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path2)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path2).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path2);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path2);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path2)) {
          this._pendingWrites.set(path2, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path2);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path2, stats) {
        if (this.options.atomic && DOT_RE.test(path2))
          return true;
        if (!this._userIgnored) {
          const { cwd: cwd2 } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd2));
          const paths = arrify(ignored).filter((path3) => typeof path3 === STRING_TYPE && !isGlob(path3)).map((path3) => path3 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd2)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path2, stats]);
      }
      _isntIgnored(path2, stat4) {
        return !this._isIgnored(path2, stat4);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path2, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path2) ? path2 : globParent(path2);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path2, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory) {
        const path2 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path2);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path2) || this._watched.has(fullPath);
        if (!this._throttle("remove", path2, 100))
          return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path2);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path2, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path2;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path2);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path2);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path2))
          this._emit(eventName, path2);
        if (!this.options.useFsEvents) {
          this._closePath(path2);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path2) {
        this._closeFile(path2);
        const dir = sysPath.dirname(path2);
        this._getWatchedDir(dir).remove(sysPath.basename(path2));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path2) {
        const closers = this._closers.get(path2);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path2);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path2, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path2);
        if (!list) {
          list = [];
          this._closers.set(path2, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream2 = readdirp(root, options);
        this._streams.add(stream2);
        stream2.once(STR_CLOSE, () => {
          stream2 = void 0;
        });
        stream2.once(STR_END, () => {
          if (stream2) {
            this._streams.delete(stream2);
            stream2 = void 0;
          }
        });
        return stream2;
      }
    };
    exports10.FSWatcher = FSWatcher;
    var watch3 = (paths, options) => {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    };
    exports10.watch = watch3;
  }
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    !function(e10) {
      var t9;
      "object" == typeof exports10 ? module.exports = e10() : "function" == typeof define && define.amd ? define(e10) : ("undefined" != typeof window ? t9 = window : "undefined" != typeof global ? t9 = global : "undefined" != typeof self && (t9 = self), t9.objectHash = e10());
    }(function() {
      return function r10(o9, i7, u7) {
        function s6(n9, e11) {
          if (!i7[n9]) {
            if (!o9[n9]) {
              var t9 = "function" == typeof __require && __require;
              if (!e11 && t9)
                return t9(n9, true);
              if (a7)
                return a7(n9, true);
              throw new Error("Cannot find module '" + n9 + "'");
            }
            e11 = i7[n9] = { exports: {} };
            o9[n9][0].call(e11.exports, function(e12) {
              var t10 = o9[n9][1][e12];
              return s6(t10 || e12);
            }, e11, e11.exports, r10, o9, i7, u7);
          }
          return i7[n9].exports;
        }
        for (var a7 = "function" == typeof __require && __require, e10 = 0; e10 < u7.length; e10++)
          s6(u7[e10]);
        return s6;
      }({ 1: [function(w4, b5, m6) {
        !function(e10, n9, s6, c7, d6, h8, p7, g5, y6) {
          var r10 = w4("crypto");
          function t9(e11, t10) {
            t10 = u7(e11, t10);
            var n10;
            return void 0 === (n10 = "passthrough" !== t10.algorithm ? r10.createHash(t10.algorithm) : new l7()).write && (n10.write = n10.update, n10.end = n10.update), f7(t10, n10).dispatch(e11), n10.update || n10.end(""), n10.digest ? n10.digest("buffer" === t10.encoding ? void 0 : t10.encoding) : (e11 = n10.read(), "buffer" !== t10.encoding ? e11.toString(t10.encoding) : e11);
          }
          (m6 = b5.exports = t9).sha1 = function(e11) {
            return t9(e11);
          }, m6.keys = function(e11) {
            return t9(e11, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m6.MD5 = function(e11) {
            return t9(e11, { algorithm: "md5", encoding: "hex" });
          }, m6.keysMD5 = function(e11) {
            return t9(e11, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o9 = r10.getHashes ? r10.getHashes().slice() : ["sha1", "md5"], i7 = (o9.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u7(e11, t10) {
            var n10 = {};
            if (n10.algorithm = (t10 = t10 || {}).algorithm || "sha1", n10.encoding = t10.encoding || "hex", n10.excludeValues = !!t10.excludeValues, n10.algorithm = n10.algorithm.toLowerCase(), n10.encoding = n10.encoding.toLowerCase(), n10.ignoreUnknown = true === t10.ignoreUnknown, n10.respectType = false !== t10.respectType, n10.respectFunctionNames = false !== t10.respectFunctionNames, n10.respectFunctionProperties = false !== t10.respectFunctionProperties, n10.unorderedArrays = true === t10.unorderedArrays, n10.unorderedSets = false !== t10.unorderedSets, n10.unorderedObjects = false !== t10.unorderedObjects, n10.replacer = t10.replacer || void 0, n10.excludeKeys = t10.excludeKeys || void 0, void 0 === e11)
              throw new Error("Object argument required.");
            for (var r11 = 0; r11 < o9.length; ++r11)
              o9[r11].toLowerCase() === n10.algorithm.toLowerCase() && (n10.algorithm = o9[r11]);
            if (-1 === o9.indexOf(n10.algorithm))
              throw new Error('Algorithm "' + n10.algorithm + '"  not supported. supported values: ' + o9.join(", "));
            if (-1 === i7.indexOf(n10.encoding) && "passthrough" !== n10.algorithm)
              throw new Error('Encoding "' + n10.encoding + '"  not supported. supported values: ' + i7.join(", "));
            return n10;
          }
          function a7(e11) {
            if ("function" == typeof e11)
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e11));
          }
          function f7(o10, t10, i8) {
            i8 = i8 || [];
            function u8(e11) {
              return t10.update ? t10.update(e11, "utf8") : t10.write(e11, "utf8");
            }
            return { dispatch: function(e11) {
              return this["_" + (null === (e11 = o10.replacer ? o10.replacer(e11) : e11) ? "null" : typeof e11)](e11);
            }, _object: function(t11) {
              var n10, e11 = Object.prototype.toString.call(t11), r11 = /\[object (.*)\]/i.exec(e11);
              r11 = (r11 = r11 ? r11[1] : "unknown:[" + e11 + "]").toLowerCase();
              if (0 <= (e11 = i8.indexOf(t11)))
                return this.dispatch("[CIRCULAR:" + e11 + "]");
              if (i8.push(t11), void 0 !== s6 && s6.isBuffer && s6.isBuffer(t11))
                return u8("buffer:"), u8(t11);
              if ("object" === r11 || "function" === r11 || "asyncfunction" === r11)
                return e11 = Object.keys(t11), o10.unorderedObjects && (e11 = e11.sort()), false === o10.respectType || a7(t11) || e11.splice(0, 0, "prototype", "__proto__", "constructor"), o10.excludeKeys && (e11 = e11.filter(function(e12) {
                  return !o10.excludeKeys(e12);
                })), u8("object:" + e11.length + ":"), n10 = this, e11.forEach(function(e12) {
                  n10.dispatch(e12), u8(":"), o10.excludeValues || n10.dispatch(t11[e12]), u8(",");
                });
              if (!this["_" + r11]) {
                if (o10.ignoreUnknown)
                  return u8("[" + r11 + "]");
                throw new Error('Unknown object type "' + r11 + '"');
              }
              this["_" + r11](t11);
            }, _array: function(e11, t11) {
              t11 = void 0 !== t11 ? t11 : false !== o10.unorderedArrays;
              var n10 = this;
              if (u8("array:" + e11.length + ":"), !t11 || e11.length <= 1)
                return e11.forEach(function(e12) {
                  return n10.dispatch(e12);
                });
              var r11 = [], t11 = e11.map(function(e12) {
                var t12 = new l7(), n11 = i8.slice();
                return f7(o10, t12, n11).dispatch(e12), r11 = r11.concat(n11.slice(i8.length)), t12.read().toString();
              });
              return i8 = i8.concat(r11), t11.sort(), this._array(t11, false);
            }, _date: function(e11) {
              return u8("date:" + e11.toJSON());
            }, _symbol: function(e11) {
              return u8("symbol:" + e11.toString());
            }, _error: function(e11) {
              return u8("error:" + e11.toString());
            }, _boolean: function(e11) {
              return u8("bool:" + e11.toString());
            }, _string: function(e11) {
              u8("string:" + e11.length + ":"), u8(e11.toString());
            }, _function: function(e11) {
              u8("fn:"), a7(e11) ? this.dispatch("[native]") : this.dispatch(e11.toString()), false !== o10.respectFunctionNames && this.dispatch("function-name:" + String(e11.name)), o10.respectFunctionProperties && this._object(e11);
            }, _number: function(e11) {
              return u8("number:" + e11.toString());
            }, _xml: function(e11) {
              return u8("xml:" + e11.toString());
            }, _null: function() {
              return u8("Null");
            }, _undefined: function() {
              return u8("Undefined");
            }, _regexp: function(e11) {
              return u8("regex:" + e11.toString());
            }, _uint8array: function(e11) {
              return u8("uint8array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _uint8clampedarray: function(e11) {
              return u8("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _int8array: function(e11) {
              return u8("int8array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _uint16array: function(e11) {
              return u8("uint16array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _int16array: function(e11) {
              return u8("int16array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _uint32array: function(e11) {
              return u8("uint32array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _int32array: function(e11) {
              return u8("int32array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _float32array: function(e11) {
              return u8("float32array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _float64array: function(e11) {
              return u8("float64array:"), this.dispatch(Array.prototype.slice.call(e11));
            }, _arraybuffer: function(e11) {
              return u8("arraybuffer:"), this.dispatch(new Uint8Array(e11));
            }, _url: function(e11) {
              return u8("url:" + e11.toString());
            }, _map: function(e11) {
              u8("map:");
              e11 = Array.from(e11);
              return this._array(e11, false !== o10.unorderedSets);
            }, _set: function(e11) {
              u8("set:");
              e11 = Array.from(e11);
              return this._array(e11, false !== o10.unorderedSets);
            }, _file: function(e11) {
              return u8("file:"), this.dispatch([e11.name, e11.size, e11.type, e11.lastModfied]);
            }, _blob: function() {
              if (o10.ignoreUnknown)
                return u8("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u8("domwindow");
            }, _bigint: function(e11) {
              return u8("bigint:" + e11.toString());
            }, _process: function() {
              return u8("process");
            }, _timer: function() {
              return u8("timer");
            }, _pipe: function() {
              return u8("pipe");
            }, _tcp: function() {
              return u8("tcp");
            }, _udp: function() {
              return u8("udp");
            }, _tty: function() {
              return u8("tty");
            }, _statwatcher: function() {
              return u8("statwatcher");
            }, _securecontext: function() {
              return u8("securecontext");
            }, _connection: function() {
              return u8("connection");
            }, _zlib: function() {
              return u8("zlib");
            }, _context: function() {
              return u8("context");
            }, _nodescript: function() {
              return u8("nodescript");
            }, _httpparser: function() {
              return u8("httpparser");
            }, _dataview: function() {
              return u8("dataview");
            }, _signal: function() {
              return u8("signal");
            }, _fsevent: function() {
              return u8("fsevent");
            }, _tlswrap: function() {
              return u8("tlswrap");
            } };
          }
          function l7() {
            return { buf: "", write: function(e11) {
              this.buf += e11;
            }, end: function(e11) {
              this.buf += e11;
            }, read: function() {
              return this.buf;
            } };
          }
          m6.writeToStream = function(e11, t10, n10) {
            return void 0 === n10 && (n10 = t10, t10 = {}), f7(t10 = u7(e11, t10), n10).dispatch(e11);
          };
        }.call(this, w4("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e10, t9, f7) {
        !function(e11, t10, n9, r10, o9, i7, u7, s6, a7) {
          !function(e12) {
            var a8 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t11 = "+".charCodeAt(0), n10 = "/".charCodeAt(0), r11 = "0".charCodeAt(0), o10 = "a".charCodeAt(0), i8 = "A".charCodeAt(0), u8 = "-".charCodeAt(0), s7 = "_".charCodeAt(0);
            function f8(e13) {
              e13 = e13.charCodeAt(0);
              return e13 === t11 || e13 === u8 ? 62 : e13 === n10 || e13 === s7 ? 63 : e13 < r11 ? -1 : e13 < r11 + 10 ? e13 - r11 + 26 + 26 : e13 < i8 + 26 ? e13 - i8 : e13 < o10 + 26 ? e13 - o10 + 26 : void 0;
            }
            e12.toByteArray = function(e13) {
              var t12, n11;
              if (0 < e13.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r12 = e13.length, r12 = "=" === e13.charAt(r12 - 2) ? 2 : "=" === e13.charAt(r12 - 1) ? 1 : 0, o11 = new a8(3 * e13.length / 4 - r12), i9 = 0 < r12 ? e13.length - 4 : e13.length, u9 = 0;
              function s8(e14) {
                o11[u9++] = e14;
              }
              for (t12 = 0; t12 < i9; t12 += 4, 0)
                s8((16711680 & (n11 = f8(e13.charAt(t12)) << 18 | f8(e13.charAt(t12 + 1)) << 12 | f8(e13.charAt(t12 + 2)) << 6 | f8(e13.charAt(t12 + 3)))) >> 16), s8((65280 & n11) >> 8), s8(255 & n11);
              return 2 == r12 ? s8(255 & (n11 = f8(e13.charAt(t12)) << 2 | f8(e13.charAt(t12 + 1)) >> 4)) : 1 == r12 && (s8((n11 = f8(e13.charAt(t12)) << 10 | f8(e13.charAt(t12 + 1)) << 4 | f8(e13.charAt(t12 + 2)) >> 2) >> 8 & 255), s8(255 & n11)), o11;
            }, e12.fromByteArray = function(e13) {
              var t12, n11, r12, o11, i9 = e13.length % 3, u9 = "";
              function s8(e14) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e14);
              }
              for (t12 = 0, r12 = e13.length - i9; t12 < r12; t12 += 3)
                n11 = (e13[t12] << 16) + (e13[t12 + 1] << 8) + e13[t12 + 2], u9 += s8((o11 = n11) >> 18 & 63) + s8(o11 >> 12 & 63) + s8(o11 >> 6 & 63) + s8(63 & o11);
              switch (i9) {
                case 1:
                  u9 = (u9 += s8((n11 = e13[e13.length - 1]) >> 2)) + s8(n11 << 4 & 63) + "==";
                  break;
                case 2:
                  u9 = (u9 = (u9 += s8((n11 = (e13[e13.length - 2] << 8) + e13[e13.length - 1]) >> 10)) + s8(n11 >> 4 & 63)) + s8(n11 << 2 & 63) + "=";
              }
              return u9;
            };
          }(void 0 === f7 ? this.base64js = {} : f7);
        }.call(this, e10("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e10("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O5, e10, H3) {
        !function(e11, n9, f7, r10, h8, p7, g5, y6, w4) {
          var a7 = O5("base64-js"), i7 = O5("ieee754");
          function f7(e12, t10, n10) {
            if (!(this instanceof f7))
              return new f7(e12, t10, n10);
            var r11, o10, i8, u8, s7 = typeof e12;
            if ("base64" === t10 && "string" == s7)
              for (e12 = (u8 = e12).trim ? u8.trim() : u8.replace(/^\s+|\s+$/g, ""); e12.length % 4 != 0; )
                e12 += "=";
            if ("number" == s7)
              r11 = j4(e12);
            else if ("string" == s7)
              r11 = f7.byteLength(e12, t10);
            else {
              if ("object" != s7)
                throw new Error("First argument needs to be a number, array or string.");
              r11 = j4(e12.length);
            }
            if (f7._useTypedArrays ? o10 = f7._augment(new Uint8Array(r11)) : ((o10 = this).length = r11, o10._isBuffer = true), f7._useTypedArrays && "number" == typeof e12.byteLength)
              o10._set(e12);
            else if (C4(u8 = e12) || f7.isBuffer(u8) || u8 && "object" == typeof u8 && "number" == typeof u8.length)
              for (i8 = 0; i8 < r11; i8++)
                f7.isBuffer(e12) ? o10[i8] = e12.readUInt8(i8) : o10[i8] = e12[i8];
            else if ("string" == s7)
              o10.write(e12, 0, t10);
            else if ("number" == s7 && !f7._useTypedArrays && !n10)
              for (i8 = 0; i8 < r11; i8++)
                o10[i8] = 0;
            return o10;
          }
          function b5(e12, t10, n10, r11) {
            return f7._charsWritten = c7(function(e13) {
              for (var t11 = [], n11 = 0; n11 < e13.length; n11++)
                t11.push(255 & e13.charCodeAt(n11));
              return t11;
            }(t10), e12, n10, r11);
          }
          function m6(e12, t10, n10, r11) {
            return f7._charsWritten = c7(function(e13) {
              for (var t11, n11, r12 = [], o10 = 0; o10 < e13.length; o10++)
                n11 = e13.charCodeAt(o10), t11 = n11 >> 8, n11 = n11 % 256, r12.push(n11), r12.push(t11);
              return r12;
            }(t10), e12, n10, r11);
          }
          function v7(e12, t10, n10) {
            var r11 = "";
            n10 = Math.min(e12.length, n10);
            for (var o10 = t10; o10 < n10; o10++)
              r11 += String.fromCharCode(e12[o10]);
            return r11;
          }
          function o9(e12, t10, n10, r11) {
            r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(null != t10, "missing offset"), d6(t10 + 1 < e12.length, "Trying to read beyond buffer length"));
            var o10, r11 = e12.length;
            if (!(r11 <= t10))
              return n10 ? (o10 = e12[t10], t10 + 1 < r11 && (o10 |= e12[t10 + 1] << 8)) : (o10 = e12[t10] << 8, t10 + 1 < r11 && (o10 |= e12[t10 + 1])), o10;
          }
          function u7(e12, t10, n10, r11) {
            r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(null != t10, "missing offset"), d6(t10 + 3 < e12.length, "Trying to read beyond buffer length"));
            var o10, r11 = e12.length;
            if (!(r11 <= t10))
              return n10 ? (t10 + 2 < r11 && (o10 = e12[t10 + 2] << 16), t10 + 1 < r11 && (o10 |= e12[t10 + 1] << 8), o10 |= e12[t10], t10 + 3 < r11 && (o10 += e12[t10 + 3] << 24 >>> 0)) : (t10 + 1 < r11 && (o10 = e12[t10 + 1] << 16), t10 + 2 < r11 && (o10 |= e12[t10 + 2] << 8), t10 + 3 < r11 && (o10 |= e12[t10 + 3]), o10 += e12[t10] << 24 >>> 0), o10;
          }
          function _4(e12, t10, n10, r11) {
            if (r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(null != t10, "missing offset"), d6(t10 + 1 < e12.length, "Trying to read beyond buffer length")), !(e12.length <= t10))
              return r11 = o9(e12, t10, n10, true), 32768 & r11 ? -1 * (65535 - r11 + 1) : r11;
          }
          function E4(e12, t10, n10, r11) {
            if (r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(null != t10, "missing offset"), d6(t10 + 3 < e12.length, "Trying to read beyond buffer length")), !(e12.length <= t10))
              return r11 = u7(e12, t10, n10, true), 2147483648 & r11 ? -1 * (4294967295 - r11 + 1) : r11;
          }
          function I4(e12, t10, n10, r11) {
            return r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(t10 + 3 < e12.length, "Trying to read beyond buffer length")), i7.read(e12, t10, n10, 23, 4);
          }
          function A4(e12, t10, n10, r11) {
            return r11 || (d6("boolean" == typeof n10, "missing or invalid endian"), d6(t10 + 7 < e12.length, "Trying to read beyond buffer length")), i7.read(e12, t10, n10, 52, 8);
          }
          function s6(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 1 < e12.length, "trying to write beyond buffer length"), Y4(t10, 65535));
            o10 = e12.length;
            if (!(o10 <= n10))
              for (var i8 = 0, u8 = Math.min(o10 - n10, 2); i8 < u8; i8++)
                e12[n10 + i8] = (t10 & 255 << 8 * (r11 ? i8 : 1 - i8)) >>> 8 * (r11 ? i8 : 1 - i8);
          }
          function l7(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 3 < e12.length, "trying to write beyond buffer length"), Y4(t10, 4294967295));
            o10 = e12.length;
            if (!(o10 <= n10))
              for (var i8 = 0, u8 = Math.min(o10 - n10, 4); i8 < u8; i8++)
                e12[n10 + i8] = t10 >>> 8 * (r11 ? i8 : 3 - i8) & 255;
          }
          function B4(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 1 < e12.length, "Trying to write beyond buffer length"), F4(t10, 32767, -32768)), e12.length <= n10 || s6(e12, 0 <= t10 ? t10 : 65535 + t10 + 1, n10, r11, o10);
          }
          function L4(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 3 < e12.length, "Trying to write beyond buffer length"), F4(t10, 2147483647, -2147483648)), e12.length <= n10 || l7(e12, 0 <= t10 ? t10 : 4294967295 + t10 + 1, n10, r11, o10);
          }
          function U4(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 3 < e12.length, "Trying to write beyond buffer length"), D4(t10, 34028234663852886e22, -34028234663852886e22)), e12.length <= n10 || i7.write(e12, t10, n10, r11, 23, 4);
          }
          function x4(e12, t10, n10, r11, o10) {
            o10 || (d6(null != t10, "missing value"), d6("boolean" == typeof r11, "missing or invalid endian"), d6(null != n10, "missing offset"), d6(n10 + 7 < e12.length, "Trying to write beyond buffer length"), D4(t10, 17976931348623157e292, -17976931348623157e292)), e12.length <= n10 || i7.write(e12, t10, n10, r11, 52, 8);
          }
          H3.Buffer = f7, H3.SlowBuffer = f7, H3.INSPECT_MAX_BYTES = 50, f7.poolSize = 8192, f7._useTypedArrays = function() {
            try {
              var e12 = new ArrayBuffer(0), t10 = new Uint8Array(e12);
              return t10.foo = function() {
                return 42;
              }, 42 === t10.foo() && "function" == typeof t10.subarray;
            } catch (e13) {
              return false;
            }
          }(), f7.isEncoding = function(e12) {
            switch (String(e12).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f7.isBuffer = function(e12) {
            return !(null == e12 || !e12._isBuffer);
          }, f7.byteLength = function(e12, t10) {
            var n10;
            switch (e12 += "", t10 || "utf8") {
              case "hex":
                n10 = e12.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n10 = T5(e12).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n10 = e12.length;
                break;
              case "base64":
                n10 = M4(e12).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n10 = 2 * e12.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n10;
          }, f7.concat = function(e12, t10) {
            if (d6(C4(e12), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e12.length)
              return new f7(0);
            if (1 === e12.length)
              return e12[0];
            if ("number" != typeof t10)
              for (o10 = t10 = 0; o10 < e12.length; o10++)
                t10 += e12[o10].length;
            for (var n10 = new f7(t10), r11 = 0, o10 = 0; o10 < e12.length; o10++) {
              var i8 = e12[o10];
              i8.copy(n10, r11), r11 += i8.length;
            }
            return n10;
          }, f7.prototype.write = function(e12, t10, n10, r11) {
            isFinite(t10) ? isFinite(n10) || (r11 = n10, n10 = void 0) : (a8 = r11, r11 = t10, t10 = n10, n10 = a8), t10 = Number(t10) || 0;
            var o10, i8, u8, s7, a8 = this.length - t10;
            switch ((!n10 || a8 < (n10 = Number(n10))) && (n10 = a8), r11 = String(r11 || "utf8").toLowerCase()) {
              case "hex":
                o10 = function(e13, t11, n11, r12) {
                  n11 = Number(n11) || 0;
                  var o11 = e13.length - n11;
                  (!r12 || o11 < (r12 = Number(r12))) && (r12 = o11), d6((o11 = t11.length) % 2 == 0, "Invalid hex string"), o11 / 2 < r12 && (r12 = o11 / 2);
                  for (var i9 = 0; i9 < r12; i9++) {
                    var u9 = parseInt(t11.substr(2 * i9, 2), 16);
                    d6(!isNaN(u9), "Invalid hex string"), e13[n11 + i9] = u9;
                  }
                  return f7._charsWritten = 2 * i9, i9;
                }(this, e12, t10, n10);
                break;
              case "utf8":
              case "utf-8":
                i8 = this, u8 = t10, s7 = n10, o10 = f7._charsWritten = c7(T5(e12), i8, u8, s7);
                break;
              case "ascii":
              case "binary":
                o10 = b5(this, e12, t10, n10);
                break;
              case "base64":
                i8 = this, u8 = t10, s7 = n10, o10 = f7._charsWritten = c7(M4(e12), i8, u8, s7);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o10 = m6(this, e12, t10, n10);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o10;
          }, f7.prototype.toString = function(e12, t10, n10) {
            var r11, o10, i8, u8, s7 = this;
            if (e12 = String(e12 || "utf8").toLowerCase(), t10 = Number(t10) || 0, (n10 = void 0 !== n10 ? Number(n10) : s7.length) === t10)
              return "";
            switch (e12) {
              case "hex":
                r11 = function(e13, t11, n11) {
                  var r12 = e13.length;
                  (!t11 || t11 < 0) && (t11 = 0);
                  (!n11 || n11 < 0 || r12 < n11) && (n11 = r12);
                  for (var o11 = "", i9 = t11; i9 < n11; i9++)
                    o11 += k4(e13[i9]);
                  return o11;
                }(s7, t10, n10);
                break;
              case "utf8":
              case "utf-8":
                r11 = function(e13, t11, n11) {
                  var r12 = "", o11 = "";
                  n11 = Math.min(e13.length, n11);
                  for (var i9 = t11; i9 < n11; i9++)
                    e13[i9] <= 127 ? (r12 += N4(o11) + String.fromCharCode(e13[i9]), o11 = "") : o11 += "%" + e13[i9].toString(16);
                  return r12 + N4(o11);
                }(s7, t10, n10);
                break;
              case "ascii":
              case "binary":
                r11 = v7(s7, t10, n10);
                break;
              case "base64":
                o10 = s7, u8 = n10, r11 = 0 === (i8 = t10) && u8 === o10.length ? a7.fromByteArray(o10) : a7.fromByteArray(o10.slice(i8, u8));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r11 = function(e13, t11, n11) {
                  for (var r12 = e13.slice(t11, n11), o11 = "", i9 = 0; i9 < r12.length; i9 += 2)
                    o11 += String.fromCharCode(r12[i9] + 256 * r12[i9 + 1]);
                  return o11;
                }(s7, t10, n10);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r11;
          }, f7.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f7.prototype.copy = function(e12, t10, n10, r11) {
            if (t10 = t10 || 0, (r11 = r11 || 0 === r11 ? r11 : this.length) !== (n10 = n10 || 0) && 0 !== e12.length && 0 !== this.length) {
              d6(n10 <= r11, "sourceEnd < sourceStart"), d6(0 <= t10 && t10 < e12.length, "targetStart out of bounds"), d6(0 <= n10 && n10 < this.length, "sourceStart out of bounds"), d6(0 <= r11 && r11 <= this.length, "sourceEnd out of bounds"), r11 > this.length && (r11 = this.length);
              var o10 = (r11 = e12.length - t10 < r11 - n10 ? e12.length - t10 + n10 : r11) - n10;
              if (o10 < 100 || !f7._useTypedArrays)
                for (var i8 = 0; i8 < o10; i8++)
                  e12[i8 + t10] = this[i8 + n10];
              else
                e12._set(this.subarray(n10, n10 + o10), t10);
            }
          }, f7.prototype.slice = function(e12, t10) {
            var n10 = this.length;
            if (e12 = S4(e12, n10, 0), t10 = S4(t10, n10, n10), f7._useTypedArrays)
              return f7._augment(this.subarray(e12, t10));
            for (var r11 = t10 - e12, o10 = new f7(r11, void 0, true), i8 = 0; i8 < r11; i8++)
              o10[i8] = this[i8 + e12];
            return o10;
          }, f7.prototype.get = function(e12) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e12);
          }, f7.prototype.set = function(e12, t10) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e12, t10);
          }, f7.prototype.readUInt8 = function(e12, t10) {
            if (t10 || (d6(null != e12, "missing offset"), d6(e12 < this.length, "Trying to read beyond buffer length")), !(e12 >= this.length))
              return this[e12];
          }, f7.prototype.readUInt16LE = function(e12, t10) {
            return o9(this, e12, true, t10);
          }, f7.prototype.readUInt16BE = function(e12, t10) {
            return o9(this, e12, false, t10);
          }, f7.prototype.readUInt32LE = function(e12, t10) {
            return u7(this, e12, true, t10);
          }, f7.prototype.readUInt32BE = function(e12, t10) {
            return u7(this, e12, false, t10);
          }, f7.prototype.readInt8 = function(e12, t10) {
            if (t10 || (d6(null != e12, "missing offset"), d6(e12 < this.length, "Trying to read beyond buffer length")), !(e12 >= this.length))
              return 128 & this[e12] ? -1 * (255 - this[e12] + 1) : this[e12];
          }, f7.prototype.readInt16LE = function(e12, t10) {
            return _4(this, e12, true, t10);
          }, f7.prototype.readInt16BE = function(e12, t10) {
            return _4(this, e12, false, t10);
          }, f7.prototype.readInt32LE = function(e12, t10) {
            return E4(this, e12, true, t10);
          }, f7.prototype.readInt32BE = function(e12, t10) {
            return E4(this, e12, false, t10);
          }, f7.prototype.readFloatLE = function(e12, t10) {
            return I4(this, e12, true, t10);
          }, f7.prototype.readFloatBE = function(e12, t10) {
            return I4(this, e12, false, t10);
          }, f7.prototype.readDoubleLE = function(e12, t10) {
            return A4(this, e12, true, t10);
          }, f7.prototype.readDoubleBE = function(e12, t10) {
            return A4(this, e12, false, t10);
          }, f7.prototype.writeUInt8 = function(e12, t10, n10) {
            n10 || (d6(null != e12, "missing value"), d6(null != t10, "missing offset"), d6(t10 < this.length, "trying to write beyond buffer length"), Y4(e12, 255)), t10 >= this.length || (this[t10] = e12);
          }, f7.prototype.writeUInt16LE = function(e12, t10, n10) {
            s6(this, e12, t10, true, n10);
          }, f7.prototype.writeUInt16BE = function(e12, t10, n10) {
            s6(this, e12, t10, false, n10);
          }, f7.prototype.writeUInt32LE = function(e12, t10, n10) {
            l7(this, e12, t10, true, n10);
          }, f7.prototype.writeUInt32BE = function(e12, t10, n10) {
            l7(this, e12, t10, false, n10);
          }, f7.prototype.writeInt8 = function(e12, t10, n10) {
            n10 || (d6(null != e12, "missing value"), d6(null != t10, "missing offset"), d6(t10 < this.length, "Trying to write beyond buffer length"), F4(e12, 127, -128)), t10 >= this.length || (0 <= e12 ? this.writeUInt8(e12, t10, n10) : this.writeUInt8(255 + e12 + 1, t10, n10));
          }, f7.prototype.writeInt16LE = function(e12, t10, n10) {
            B4(this, e12, t10, true, n10);
          }, f7.prototype.writeInt16BE = function(e12, t10, n10) {
            B4(this, e12, t10, false, n10);
          }, f7.prototype.writeInt32LE = function(e12, t10, n10) {
            L4(this, e12, t10, true, n10);
          }, f7.prototype.writeInt32BE = function(e12, t10, n10) {
            L4(this, e12, t10, false, n10);
          }, f7.prototype.writeFloatLE = function(e12, t10, n10) {
            U4(this, e12, t10, true, n10);
          }, f7.prototype.writeFloatBE = function(e12, t10, n10) {
            U4(this, e12, t10, false, n10);
          }, f7.prototype.writeDoubleLE = function(e12, t10, n10) {
            x4(this, e12, t10, true, n10);
          }, f7.prototype.writeDoubleBE = function(e12, t10, n10) {
            x4(this, e12, t10, false, n10);
          }, f7.prototype.fill = function(e12, t10, n10) {
            if (t10 = t10 || 0, n10 = n10 || this.length, d6("number" == typeof (e12 = "string" == typeof (e12 = e12 || 0) ? e12.charCodeAt(0) : e12) && !isNaN(e12), "value is not a number"), d6(t10 <= n10, "end < start"), n10 !== t10 && 0 !== this.length) {
              d6(0 <= t10 && t10 < this.length, "start out of bounds"), d6(0 <= n10 && n10 <= this.length, "end out of bounds");
              for (var r11 = t10; r11 < n10; r11++)
                this[r11] = e12;
            }
          }, f7.prototype.inspect = function() {
            for (var e12 = [], t10 = this.length, n10 = 0; n10 < t10; n10++)
              if (e12[n10] = k4(this[n10]), n10 === H3.INSPECT_MAX_BYTES) {
                e12[n10 + 1] = "...";
                break;
              }
            return "<Buffer " + e12.join(" ") + ">";
          }, f7.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f7._useTypedArrays)
              return new f7(this).buffer;
            for (var e12 = new Uint8Array(this.length), t10 = 0, n10 = e12.length; t10 < n10; t10 += 1)
              e12[t10] = this[t10];
            return e12.buffer;
          };
          var t9 = f7.prototype;
          function S4(e12, t10, n10) {
            return "number" != typeof e12 ? n10 : t10 <= (e12 = ~~e12) ? t10 : 0 <= e12 || 0 <= (e12 += t10) ? e12 : 0;
          }
          function j4(e12) {
            return (e12 = ~~Math.ceil(+e12)) < 0 ? 0 : e12;
          }
          function C4(e12) {
            return (Array.isArray || function(e13) {
              return "[object Array]" === Object.prototype.toString.call(e13);
            })(e12);
          }
          function k4(e12) {
            return e12 < 16 ? "0" + e12.toString(16) : e12.toString(16);
          }
          function T5(e12) {
            for (var t10 = [], n10 = 0; n10 < e12.length; n10++) {
              var r11 = e12.charCodeAt(n10);
              if (r11 <= 127)
                t10.push(e12.charCodeAt(n10));
              else
                for (var o10 = n10, i8 = (55296 <= r11 && r11 <= 57343 && n10++, encodeURIComponent(e12.slice(o10, n10 + 1)).substr(1).split("%")), u8 = 0; u8 < i8.length; u8++)
                  t10.push(parseInt(i8[u8], 16));
            }
            return t10;
          }
          function M4(e12) {
            return a7.toByteArray(e12);
          }
          function c7(e12, t10, n10, r11) {
            for (var o10 = 0; o10 < r11 && !(o10 + n10 >= t10.length || o10 >= e12.length); o10++)
              t10[o10 + n10] = e12[o10];
            return o10;
          }
          function N4(e12) {
            try {
              return decodeURIComponent(e12);
            } catch (e13) {
              return String.fromCharCode(65533);
            }
          }
          function Y4(e12, t10) {
            d6("number" == typeof e12, "cannot write a non-number as a number"), d6(0 <= e12, "specified a negative value for writing an unsigned value"), d6(e12 <= t10, "value is larger than maximum value for type"), d6(Math.floor(e12) === e12, "value has a fractional component");
          }
          function F4(e12, t10, n10) {
            d6("number" == typeof e12, "cannot write a non-number as a number"), d6(e12 <= t10, "value larger than maximum allowed value"), d6(n10 <= e12, "value smaller than minimum allowed value"), d6(Math.floor(e12) === e12, "value has a fractional component");
          }
          function D4(e12, t10, n10) {
            d6("number" == typeof e12, "cannot write a non-number as a number"), d6(e12 <= t10, "value larger than maximum allowed value"), d6(n10 <= e12, "value smaller than minimum allowed value");
          }
          function d6(e12, t10) {
            if (!e12)
              throw new Error(t10 || "Failed assertion");
          }
          f7._augment = function(e12) {
            return e12._isBuffer = true, e12._get = e12.get, e12._set = e12.set, e12.get = t9.get, e12.set = t9.set, e12.write = t9.write, e12.toString = t9.toString, e12.toLocaleString = t9.toString, e12.toJSON = t9.toJSON, e12.copy = t9.copy, e12.slice = t9.slice, e12.readUInt8 = t9.readUInt8, e12.readUInt16LE = t9.readUInt16LE, e12.readUInt16BE = t9.readUInt16BE, e12.readUInt32LE = t9.readUInt32LE, e12.readUInt32BE = t9.readUInt32BE, e12.readInt8 = t9.readInt8, e12.readInt16LE = t9.readInt16LE, e12.readInt16BE = t9.readInt16BE, e12.readInt32LE = t9.readInt32LE, e12.readInt32BE = t9.readInt32BE, e12.readFloatLE = t9.readFloatLE, e12.readFloatBE = t9.readFloatBE, e12.readDoubleLE = t9.readDoubleLE, e12.readDoubleBE = t9.readDoubleBE, e12.writeUInt8 = t9.writeUInt8, e12.writeUInt16LE = t9.writeUInt16LE, e12.writeUInt16BE = t9.writeUInt16BE, e12.writeUInt32LE = t9.writeUInt32LE, e12.writeUInt32BE = t9.writeUInt32BE, e12.writeInt8 = t9.writeInt8, e12.writeInt16LE = t9.writeInt16LE, e12.writeInt16BE = t9.writeInt16BE, e12.writeInt32LE = t9.writeInt32LE, e12.writeInt32BE = t9.writeInt32BE, e12.writeFloatLE = t9.writeFloatLE, e12.writeFloatBE = t9.writeFloatBE, e12.writeDoubleLE = t9.writeDoubleLE, e12.writeDoubleBE = t9.writeDoubleBE, e12.fill = t9.fill, e12.inspect = t9.inspect, e12.toArrayBuffer = t9.toArrayBuffer, e12;
          };
        }.call(this, O5("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O5("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c7, d6, e10) {
        !function(e11, t9, a7, n9, r10, o9, i7, u7, s6) {
          var a7 = c7("buffer").Buffer, f7 = 4, l7 = new a7(f7);
          l7.fill(0);
          d6.exports = { hash: function(e12, t10, n10, r11) {
            for (var o10 = t10(function(e13, t11) {
              e13.length % f7 != 0 && (n11 = e13.length + (f7 - e13.length % f7), e13 = a7.concat([e13, l7], n11));
              for (var n11, r12 = [], o11 = t11 ? e13.readInt32BE : e13.readInt32LE, i9 = 0; i9 < e13.length; i9 += f7)
                r12.push(o11.call(e13, i9));
              return r12;
            }(e12 = a7.isBuffer(e12) ? e12 : new a7(e12), r11), 8 * e12.length), t10 = r11, i8 = new a7(n10), u8 = t10 ? i8.writeInt32BE : i8.writeInt32LE, s7 = 0; s7 < o10.length; s7++)
              u8.call(i8, o10[s7], 4 * s7, true);
            return i8;
          } };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v7, e10, _4) {
        !function(l7, c7, u7, d6, h8, p7, g5, y6, w4) {
          var u7 = v7("buffer").Buffer, e11 = v7("./sha"), t9 = v7("./sha256"), n9 = v7("./rng"), b5 = { sha1: e11, sha256: t9, md5: v7("./md5") }, s6 = 64, a7 = new u7(s6);
          function r10(e12, n10) {
            var r11 = b5[e12 = e12 || "sha1"], o10 = [];
            return r11 || i7("algorithm:", e12, "is not yet supported"), { update: function(e13) {
              return u7.isBuffer(e13) || (e13 = new u7(e13)), o10.push(e13), e13.length, this;
            }, digest: function(e13) {
              var t10 = u7.concat(o10), t10 = n10 ? function(e14, t11, n11) {
                u7.isBuffer(t11) || (t11 = new u7(t11)), u7.isBuffer(n11) || (n11 = new u7(n11)), t11.length > s6 ? t11 = e14(t11) : t11.length < s6 && (t11 = u7.concat([t11, a7], s6));
                for (var r12 = new u7(s6), o11 = new u7(s6), i8 = 0; i8 < s6; i8++)
                  r12[i8] = 54 ^ t11[i8], o11[i8] = 92 ^ t11[i8];
                return n11 = e14(u7.concat([r12, n11])), e14(u7.concat([o11, n11]));
              }(r11, n10, t10) : r11(t10);
              return o10 = null, e13 ? t10.toString(e13) : t10;
            } };
          }
          function i7() {
            var e12 = [].slice.call(arguments).join(" ");
            throw new Error([e12, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a7.fill(0), _4.createHash = function(e12) {
            return r10(e12);
          }, _4.createHmac = r10, _4.randomBytes = function(e12, t10) {
            if (!t10 || !t10.call)
              return new u7(n9(e12));
            try {
              t10.call(this, void 0, new u7(n9(e12)));
            } catch (e13) {
              t10(e13);
            }
          };
          var o9, f7 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m6 = function(e12) {
            _4[e12] = function() {
              i7("sorry,", e12, "is not implemented yet");
            };
          };
          for (o9 in f7)
            m6(f7[o9]);
        }.call(this, v7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w4, b5, e10) {
        !function(e11, r10, o9, i7, u7, a7, f7, l7, y6) {
          var t9 = w4("./helpers");
          function n9(e12, t10) {
            e12[t10 >> 5] |= 128 << t10 % 32, e12[14 + (t10 + 64 >>> 9 << 4)] = t10;
            for (var n10 = 1732584193, r11 = -271733879, o10 = -1732584194, i8 = 271733878, u8 = 0; u8 < e12.length; u8 += 16) {
              var s7 = n10, a8 = r11, f8 = o10, l8 = i8, n10 = c7(n10, r11, o10, i8, e12[u8 + 0], 7, -680876936), i8 = c7(i8, n10, r11, o10, e12[u8 + 1], 12, -389564586), o10 = c7(o10, i8, n10, r11, e12[u8 + 2], 17, 606105819), r11 = c7(r11, o10, i8, n10, e12[u8 + 3], 22, -1044525330);
              n10 = c7(n10, r11, o10, i8, e12[u8 + 4], 7, -176418897), i8 = c7(i8, n10, r11, o10, e12[u8 + 5], 12, 1200080426), o10 = c7(o10, i8, n10, r11, e12[u8 + 6], 17, -1473231341), r11 = c7(r11, o10, i8, n10, e12[u8 + 7], 22, -45705983), n10 = c7(n10, r11, o10, i8, e12[u8 + 8], 7, 1770035416), i8 = c7(i8, n10, r11, o10, e12[u8 + 9], 12, -1958414417), o10 = c7(o10, i8, n10, r11, e12[u8 + 10], 17, -42063), r11 = c7(r11, o10, i8, n10, e12[u8 + 11], 22, -1990404162), n10 = c7(n10, r11, o10, i8, e12[u8 + 12], 7, 1804603682), i8 = c7(i8, n10, r11, o10, e12[u8 + 13], 12, -40341101), o10 = c7(o10, i8, n10, r11, e12[u8 + 14], 17, -1502002290), n10 = d6(n10, r11 = c7(r11, o10, i8, n10, e12[u8 + 15], 22, 1236535329), o10, i8, e12[u8 + 1], 5, -165796510), i8 = d6(i8, n10, r11, o10, e12[u8 + 6], 9, -1069501632), o10 = d6(o10, i8, n10, r11, e12[u8 + 11], 14, 643717713), r11 = d6(r11, o10, i8, n10, e12[u8 + 0], 20, -373897302), n10 = d6(n10, r11, o10, i8, e12[u8 + 5], 5, -701558691), i8 = d6(i8, n10, r11, o10, e12[u8 + 10], 9, 38016083), o10 = d6(o10, i8, n10, r11, e12[u8 + 15], 14, -660478335), r11 = d6(r11, o10, i8, n10, e12[u8 + 4], 20, -405537848), n10 = d6(n10, r11, o10, i8, e12[u8 + 9], 5, 568446438), i8 = d6(i8, n10, r11, o10, e12[u8 + 14], 9, -1019803690), o10 = d6(o10, i8, n10, r11, e12[u8 + 3], 14, -187363961), r11 = d6(r11, o10, i8, n10, e12[u8 + 8], 20, 1163531501), n10 = d6(n10, r11, o10, i8, e12[u8 + 13], 5, -1444681467), i8 = d6(i8, n10, r11, o10, e12[u8 + 2], 9, -51403784), o10 = d6(o10, i8, n10, r11, e12[u8 + 7], 14, 1735328473), n10 = h8(n10, r11 = d6(r11, o10, i8, n10, e12[u8 + 12], 20, -1926607734), o10, i8, e12[u8 + 5], 4, -378558), i8 = h8(i8, n10, r11, o10, e12[u8 + 8], 11, -2022574463), o10 = h8(o10, i8, n10, r11, e12[u8 + 11], 16, 1839030562), r11 = h8(r11, o10, i8, n10, e12[u8 + 14], 23, -35309556), n10 = h8(n10, r11, o10, i8, e12[u8 + 1], 4, -1530992060), i8 = h8(i8, n10, r11, o10, e12[u8 + 4], 11, 1272893353), o10 = h8(o10, i8, n10, r11, e12[u8 + 7], 16, -155497632), r11 = h8(r11, o10, i8, n10, e12[u8 + 10], 23, -1094730640), n10 = h8(n10, r11, o10, i8, e12[u8 + 13], 4, 681279174), i8 = h8(i8, n10, r11, o10, e12[u8 + 0], 11, -358537222), o10 = h8(o10, i8, n10, r11, e12[u8 + 3], 16, -722521979), r11 = h8(r11, o10, i8, n10, e12[u8 + 6], 23, 76029189), n10 = h8(n10, r11, o10, i8, e12[u8 + 9], 4, -640364487), i8 = h8(i8, n10, r11, o10, e12[u8 + 12], 11, -421815835), o10 = h8(o10, i8, n10, r11, e12[u8 + 15], 16, 530742520), n10 = p7(n10, r11 = h8(r11, o10, i8, n10, e12[u8 + 2], 23, -995338651), o10, i8, e12[u8 + 0], 6, -198630844), i8 = p7(i8, n10, r11, o10, e12[u8 + 7], 10, 1126891415), o10 = p7(o10, i8, n10, r11, e12[u8 + 14], 15, -1416354905), r11 = p7(r11, o10, i8, n10, e12[u8 + 5], 21, -57434055), n10 = p7(n10, r11, o10, i8, e12[u8 + 12], 6, 1700485571), i8 = p7(i8, n10, r11, o10, e12[u8 + 3], 10, -1894986606), o10 = p7(o10, i8, n10, r11, e12[u8 + 10], 15, -1051523), r11 = p7(r11, o10, i8, n10, e12[u8 + 1], 21, -2054922799), n10 = p7(n10, r11, o10, i8, e12[u8 + 8], 6, 1873313359), i8 = p7(i8, n10, r11, o10, e12[u8 + 15], 10, -30611744), o10 = p7(o10, i8, n10, r11, e12[u8 + 6], 15, -1560198380), r11 = p7(r11, o10, i8, n10, e12[u8 + 13], 21, 1309151649), n10 = p7(n10, r11, o10, i8, e12[u8 + 4], 6, -145523070), i8 = p7(i8, n10, r11, o10, e12[u8 + 11], 10, -1120210379), o10 = p7(o10, i8, n10, r11, e12[u8 + 2], 15, 718787259), r11 = p7(r11, o10, i8, n10, e12[u8 + 9], 21, -343485551), n10 = g5(n10, s7), r11 = g5(r11, a8), o10 = g5(o10, f8), i8 = g5(i8, l8);
            }
            return Array(n10, r11, o10, i8);
          }
          function s6(e12, t10, n10, r11, o10, i8) {
            return g5((t10 = g5(g5(t10, e12), g5(r11, i8))) << o10 | t10 >>> 32 - o10, n10);
          }
          function c7(e12, t10, n10, r11, o10, i8, u8) {
            return s6(t10 & n10 | ~t10 & r11, e12, t10, o10, i8, u8);
          }
          function d6(e12, t10, n10, r11, o10, i8, u8) {
            return s6(t10 & r11 | n10 & ~r11, e12, t10, o10, i8, u8);
          }
          function h8(e12, t10, n10, r11, o10, i8, u8) {
            return s6(t10 ^ n10 ^ r11, e12, t10, o10, i8, u8);
          }
          function p7(e12, t10, n10, r11, o10, i8, u8) {
            return s6(n10 ^ (t10 | ~r11), e12, t10, o10, i8, u8);
          }
          function g5(e12, t10) {
            var n10 = (65535 & e12) + (65535 & t10);
            return (e12 >> 16) + (t10 >> 16) + (n10 >> 16) << 16 | 65535 & n10;
          }
          b5.exports = function(e12) {
            return t9.hash(e12, n9, 16);
          };
        }.call(this, w4("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e10, l7, t9) {
        !function(e11, t10, n9, r10, o9, i7, u7, s6, f7) {
          l7.exports = function(e12) {
            for (var t11, n10 = new Array(e12), r11 = 0; r11 < e12; r11++)
              0 == (3 & r11) && (t11 = 4294967296 * Math.random()), n10[r11] = t11 >>> ((3 & r11) << 3) & 255;
            return n10;
          };
        }.call(this, e10("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e10("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c7, d6, e10) {
        !function(e11, t9, n9, r10, o9, s6, a7, f7, l7) {
          var i7 = c7("./helpers");
          function u7(l8, c8) {
            l8[c8 >> 5] |= 128 << 24 - c8 % 32, l8[15 + (c8 + 64 >> 9 << 4)] = c8;
            for (var e12, t10, n10, r11 = Array(80), o10 = 1732584193, i8 = -271733879, u8 = -1732584194, s7 = 271733878, d7 = -1009589776, h8 = 0; h8 < l8.length; h8 += 16) {
              for (var p7 = o10, g5 = i8, y6 = u8, w4 = s7, b5 = d7, a8 = 0; a8 < 80; a8++) {
                r11[a8] = a8 < 16 ? l8[h8 + a8] : v7(r11[a8 - 3] ^ r11[a8 - 8] ^ r11[a8 - 14] ^ r11[a8 - 16], 1);
                var f8 = m6(m6(v7(o10, 5), (f8 = i8, t10 = u8, n10 = s7, (e12 = a8) < 20 ? f8 & t10 | ~f8 & n10 : !(e12 < 40) && e12 < 60 ? f8 & t10 | f8 & n10 | t10 & n10 : f8 ^ t10 ^ n10)), m6(m6(d7, r11[a8]), (e12 = a8) < 20 ? 1518500249 : e12 < 40 ? 1859775393 : e12 < 60 ? -1894007588 : -899497514)), d7 = s7, s7 = u8, u8 = v7(i8, 30), i8 = o10, o10 = f8;
              }
              o10 = m6(o10, p7), i8 = m6(i8, g5), u8 = m6(u8, y6), s7 = m6(s7, w4), d7 = m6(d7, b5);
            }
            return Array(o10, i8, u8, s7, d7);
          }
          function m6(e12, t10) {
            var n10 = (65535 & e12) + (65535 & t10);
            return (e12 >> 16) + (t10 >> 16) + (n10 >> 16) << 16 | 65535 & n10;
          }
          function v7(e12, t10) {
            return e12 << t10 | e12 >>> 32 - t10;
          }
          d6.exports = function(e12) {
            return i7.hash(e12, u7, 20, true);
          };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c7, d6, e10) {
        !function(e11, t9, n9, r10, u7, s6, a7, f7, l7) {
          function b5(e12, t10) {
            var n10 = (65535 & e12) + (65535 & t10);
            return (e12 >> 16) + (t10 >> 16) + (n10 >> 16) << 16 | 65535 & n10;
          }
          function o9(e12, l8) {
            var c8, d7 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t10 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n10 = new Array(64);
            e12[l8 >> 5] |= 128 << 24 - l8 % 32, e12[15 + (l8 + 64 >> 9 << 4)] = l8;
            for (var r11, o10, h8 = 0; h8 < e12.length; h8 += 16) {
              for (var i8 = t10[0], u8 = t10[1], s7 = t10[2], p7 = t10[3], a8 = t10[4], g5 = t10[5], y6 = t10[6], w4 = t10[7], f8 = 0; f8 < 64; f8++)
                n10[f8] = f8 < 16 ? e12[f8 + h8] : b5(b5(b5((o10 = n10[f8 - 2], m6(o10, 17) ^ m6(o10, 19) ^ v7(o10, 10)), n10[f8 - 7]), (o10 = n10[f8 - 15], m6(o10, 7) ^ m6(o10, 18) ^ v7(o10, 3))), n10[f8 - 16]), c8 = b5(b5(b5(b5(w4, m6(o10 = a8, 6) ^ m6(o10, 11) ^ m6(o10, 25)), a8 & g5 ^ ~a8 & y6), d7[f8]), n10[f8]), r11 = b5(m6(r11 = i8, 2) ^ m6(r11, 13) ^ m6(r11, 22), i8 & u8 ^ i8 & s7 ^ u8 & s7), w4 = y6, y6 = g5, g5 = a8, a8 = b5(p7, c8), p7 = s7, s7 = u8, u8 = i8, i8 = b5(c8, r11);
              t10[0] = b5(i8, t10[0]), t10[1] = b5(u8, t10[1]), t10[2] = b5(s7, t10[2]), t10[3] = b5(p7, t10[3]), t10[4] = b5(a8, t10[4]), t10[5] = b5(g5, t10[5]), t10[6] = b5(y6, t10[6]), t10[7] = b5(w4, t10[7]);
            }
            return t10;
          }
          var i7 = c7("./helpers"), m6 = function(e12, t10) {
            return e12 >>> t10 | e12 << 32 - t10;
          }, v7 = function(e12, t10) {
            return e12 >>> t10;
          };
          d6.exports = function(e12) {
            return i7.hash(e12, o9, 32, true);
          };
        }.call(this, c7("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c7("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e10, t9, f7) {
        !function(e11, t10, n9, r10, o9, i7, u7, s6, a7) {
          f7.read = function(e12, t11, n10, r11, o10) {
            var i8, u8, l7 = 8 * o10 - r11 - 1, c7 = (1 << l7) - 1, d6 = c7 >> 1, s7 = -7, a8 = n10 ? o10 - 1 : 0, f8 = n10 ? -1 : 1, o10 = e12[t11 + a8];
            for (a8 += f8, i8 = o10 & (1 << -s7) - 1, o10 >>= -s7, s7 += l7; 0 < s7; i8 = 256 * i8 + e12[t11 + a8], a8 += f8, s7 -= 8)
              ;
            for (u8 = i8 & (1 << -s7) - 1, i8 >>= -s7, s7 += r11; 0 < s7; u8 = 256 * u8 + e12[t11 + a8], a8 += f8, s7 -= 8)
              ;
            if (0 === i8)
              i8 = 1 - d6;
            else {
              if (i8 === c7)
                return u8 ? NaN : 1 / 0 * (o10 ? -1 : 1);
              u8 += Math.pow(2, r11), i8 -= d6;
            }
            return (o10 ? -1 : 1) * u8 * Math.pow(2, i8 - r11);
          }, f7.write = function(e12, t11, l7, n10, r11, c7) {
            var o10, i8, u8 = 8 * c7 - r11 - 1, s7 = (1 << u8) - 1, a8 = s7 >> 1, d6 = 23 === r11 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f8 = n10 ? 0 : c7 - 1, h8 = n10 ? 1 : -1, c7 = t11 < 0 || 0 === t11 && 1 / t11 < 0 ? 1 : 0;
            for (t11 = Math.abs(t11), isNaN(t11) || t11 === 1 / 0 ? (i8 = isNaN(t11) ? 1 : 0, o10 = s7) : (o10 = Math.floor(Math.log(t11) / Math.LN2), t11 * (n10 = Math.pow(2, -o10)) < 1 && (o10--, n10 *= 2), 2 <= (t11 += 1 <= o10 + a8 ? d6 / n10 : d6 * Math.pow(2, 1 - a8)) * n10 && (o10++, n10 /= 2), s7 <= o10 + a8 ? (i8 = 0, o10 = s7) : 1 <= o10 + a8 ? (i8 = (t11 * n10 - 1) * Math.pow(2, r11), o10 += a8) : (i8 = t11 * Math.pow(2, a8 - 1) * Math.pow(2, r11), o10 = 0)); 8 <= r11; e12[l7 + f8] = 255 & i8, f8 += h8, i8 /= 256, r11 -= 8)
              ;
            for (o10 = o10 << r11 | i8, u8 += r11; 0 < u8; e12[l7 + f8] = 255 & o10, f8 += h8, o10 /= 256, u8 -= 8)
              ;
            e12[l7 + f8 - h8] |= 128 * c7;
          };
        }.call(this, e10("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e10("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e10, h8, t9) {
        !function(e11, t10, n9, r10, o9, f7, l7, c7, d6) {
          var i7, u7, s6;
          function a7() {
          }
          (e11 = h8.exports = {}).nextTick = (u7 = "undefined" != typeof window && window.setImmediate, s6 = "undefined" != typeof window && window.postMessage && window.addEventListener, u7 ? function(e12) {
            return window.setImmediate(e12);
          } : s6 ? (i7 = [], window.addEventListener("message", function(e12) {
            var t11 = e12.source;
            t11 !== window && null !== t11 || "process-tick" !== e12.data || (e12.stopPropagation(), 0 < i7.length && i7.shift()());
          }, true), function(e12) {
            i7.push(e12), window.postMessage("process-tick", "*");
          }) : function(e12) {
            setTimeout(e12, 0);
          }), e11.title = "browser", e11.browser = true, e11.env = {}, e11.argv = [], e11.on = a7, e11.addListener = a7, e11.once = a7, e11.off = a7, e11.removeListener = a7, e11.removeAllListeners = a7, e11.emit = a7, e11.binding = function(e12) {
            throw new Error("process.binding is not supported");
          }, e11.cwd = function() {
            return "/";
          }, e11.chdir = function(e12) {
            throw new Error("process.chdir is not supported");
          };
        }.call(this, e10("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e10("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/object-sizeof/byte_size.js
var require_byte_size = __commonJS({
  "node_modules/object-sizeof/byte_size.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    module.exports = {
      STRING: 2,
      BOOLEAN: 4,
      BYTES: 4,
      NUMBER: 8,
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.byteLength = byteLength;
    exports10.toByteArray = toByteArray;
    exports10.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    var i7;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    exports10.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e10, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer2[offset + i7];
      i7 += d6;
      e10 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e10 = e10 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e10 & (1 << -nBits) - 1;
      e10 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e10 === 0) {
        e10 = 1 - eBias;
      } else if (e10 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e10 = e10 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e10 - mLen);
    };
    exports10.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e10, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e10 = eMax;
      } else {
        e10 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e10)) < 1) {
          e10--;
          c7 *= 2;
        }
        if (e10 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e10++;
          c7 /= 2;
        }
        if (e10 + eBias >= eMax) {
          m6 = 0;
          e10 = eMax;
        } else if (e10 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e10 = e10 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e10 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e10 = e10 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e10 & 255, i7 += d6, e10 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d6] |= s6 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports10) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports10.Buffer = Buffer3;
    exports10.SlowBuffer = SlowBuffer;
    exports10.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports10.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e10) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b5 = fromObject(value);
      if (b5)
        return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer4(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a7, b5) {
      if (isInstance(a7, Uint8Array))
        a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array))
        b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
      if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a7 === b5)
        return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b5, n9, m6) {
      const i7 = b5[n9];
      b5[n9] = b5[m6];
      b5[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString3() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b5) {
      if (!Buffer3.isBuffer(b5))
        throw new TypeError("Argument must be a Buffer");
      if (this === b5)
        return true;
      return Buffer3.compare(this, b5) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports10.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read2(arr, i7 + j4) !== read2(val, j4)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name3) {
        if (name3) {
          return `${name3} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E4(
      "ERR_INVALID_ARG_TYPE",
      function(name3, actual) {
        return `The "${name3}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E4(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n9 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n9} and < 2${n9} ** ${(byteLength2 + 1) * 8}${n9}`;
          } else {
            range = `>= -(2${n9} ** ${(byteLength2 + 1) * 8 - 1}${n9}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n9}`;
          }
        } else {
          range = `>= ${min}${n9} and <= ${max}${n9}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name3) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet[i7] + alphabet[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/object-sizeof/indexv2.js
var require_indexv2 = __commonJS({
  "node_modules/object-sizeof/indexv2.js"(exports10, module) {
    init_global();
    init_dirname();
    init_filename();
    init_buffer2();
    init_process2();
    var ECMA_SIZES = require_byte_size();
    var Buffer3 = require_buffer().Buffer;
    function preciseStringSizeNode(str) {
      return 12 + 4 * Math.ceil(str.length / 4);
    }
    function isNodeEnvironment() {
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        return false;
      }
      return true;
    }
    function objectSizeComplex(obj) {
      let totalSize = 0;
      const errorIndication = -1;
      try {
        let potentialConversion = obj;
        if (obj instanceof Map) {
          potentialConversion = Object.fromEntries(obj);
        } else if (obj instanceof Set) {
          potentialConversion = Array.from(obj);
        }
        if (obj instanceof Int8Array) {
          return obj.length * ECMA_SIZES.Int8Array;
        } else if (obj instanceof Uint8Array || obj instanceof Uint8ClampedArray) {
          return obj.length * ECMA_SIZES.Uint8Array;
        } else if (obj instanceof Int16Array) {
          return obj.length * ECMA_SIZES.Int16Array;
        } else if (obj instanceof Uint16Array) {
          return obj.length * ECMA_SIZES.Uint16Array;
        } else if (obj instanceof Int32Array) {
          return obj.length * ECMA_SIZES.Int32Array;
        } else if (obj instanceof Uint32Array) {
          return obj.length * ECMA_SIZES.Uint32Array;
        } else if (obj instanceof Float32Array) {
          return obj.length * ECMA_SIZES.Float32Array;
        } else if (obj instanceof Float64Array) {
          return obj.length * ECMA_SIZES.Float64Array;
        }
        const objectToString = JSON.stringify(potentialConversion);
        const buffer2 = new Buffer3.from(objectToString);
        totalSize = buffer2.byteLength;
      } catch (ex) {
        console.error("Error detected, return " + errorIndication, ex);
        return errorIndication;
      }
      return totalSize;
    }
    function objectSizeSimple(obj) {
      const objectList = [];
      const stack = [obj];
      let bytes = 0;
      while (stack.length) {
        const value = stack.pop();
        if (typeof value === "boolean") {
          bytes += ECMA_SIZES.BYTES;
        } else if (typeof value === "string") {
          if (isNodeEnvironment()) {
            bytes += preciseStringSizeNode(value);
          } else {
            bytes += value.length * ECMA_SIZES.STRING;
          }
        } else if (typeof value === "number") {
          bytes += ECMA_SIZES.NUMBER;
        } else if (typeof value === "symbol") {
          const isGlobalSymbol = Symbol.keyFor && Symbol.keyFor(obj);
          if (isGlobalSymbol) {
            bytes += Symbol.keyFor(obj).length * ECMA_SIZES.STRING;
          } else {
            bytes += (obj.toString().length - 8) * ECMA_SIZES.STRING;
          }
        } else if (typeof value === "bigint") {
          bytes += Buffer3.from(value.toString()).byteLength;
        } else if (typeof value === "function") {
          bytes += value.toString().length;
        } else if (typeof value === "object" && objectList.indexOf(value) === -1) {
          objectList.push(value);
          for (const i7 in value) {
            stack.push(value[i7]);
          }
        }
      }
      return bytes;
    }
    module.exports = function(obj) {
      let totalSize = 0;
      if (obj !== null && typeof obj === "object") {
        totalSize = objectSizeComplex(obj);
      } else {
        totalSize = objectSizeSimple(obj);
      }
      return totalSize;
    };
  }
});

// src/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/TabbyAgent.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_events();

// node_modules/uuid/dist/esm-browser/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/rng.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var byteToHex = [];
for (let i7 = 0; i7 < 256; ++i7) {
  byteToHex.push((i7 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/v4.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/native.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i7 = 0; i7 < 16; ++i7) {
      buf[offset + i7] = rnds[i7];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/TabbyAgent.ts
var import_deep_equal = __toESM(require_deep_equal());
var import_deepmerge = __toESM(require_cjs());

// src/generated/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/TabbyApi.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/core/AxiosHttpRequest.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/generated/core/BaseHttpRequest.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var BaseHttpRequest = class {
  constructor(config2) {
    this.config = config2;
  }
};

// src/generated/core/request.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/axios.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/utils.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/bind.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i7;
  let l7;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i7 = 0, l7 = obj.length; i7 < l7; i7++) {
      fn.call(null, obj[i7], i7, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i7 = 0; i7 < len; i7++) {
      key = keys[i7];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i7 = keys.length;
  let _key;
  while (i7-- > 0) {
    _key = keys[i7];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i7 = 0, l7 = arguments.length; i7 < l7; i7++) {
    arguments[i7] && forEach(arguments[i7], assignValue);
  }
  return result;
}
var extend = (a7, b5, thisArg, { allOwnKeys } = {}) => {
  forEach(b5, (val, key) => {
    if (thisArg && isFunction(val)) {
      a7[key] = bind(val, thisArg);
    } else {
      a7[key] = val;
    }
  }, { allOwnKeys });
  return a7;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i7;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i7 = props.length;
    while (i7-- > 0) {
      prop = props[i7];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i7 = thing.length;
  if (!isNumber(i7))
    return null;
  const arr = new Array(i7);
  while (i7-- > 0) {
    arr[i7] = thing[i7];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m6, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name3) => {
    if (reducer(descriptor, name3, obj) !== false) {
      reducedDescriptors[name3] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name3) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name3) !== -1) {
      return false;
    }
    const value = obj[name3];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name3 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i7) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i7] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i7 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i7] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/Axios.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/buildURL.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/toFormData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/AxiosError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function AxiosError(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i7) {
    token = removeBrackets(token);
    return !dots && i7 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer2.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name3, value) {
  this._pairs.push([name3, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h8) {
      if (h8 !== null) {
        fn(h8);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/core/dispatchRequest.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/transformData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/defaults/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/defaults/transitional.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/browser/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function parsePropPath(name3) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name3).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i7;
  const len = keys.length;
  let key;
  for (i7 = 0; i7 < len; i7++) {
    key = keys[i7];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name3 = path2[index++];
    const isNumericKey = Number.isFinite(+name3);
    const isLast = index >= path2.length;
    name3 = !name3 && utils_default.isArray(target) ? target.length : name3;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name3)) {
        target[name3] = [target[name3], value];
      } else {
        target[name3] = value;
      }
      return !isNumericKey;
    }
    if (!target[name3] || !utils_default.isObject(target[name3])) {
      target[name3] = [];
    }
    const result = buildPath(path2, value, target[name3], index);
    if (result && utils_default.isArray(target[name3])) {
      target[name3] = arrayToObject(target[name3]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name3, value) => {
      buildPath(parsePropPath(name3), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e10) {
      if (e10.name !== "SyntaxError") {
        throw e10;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default.isFormData(data);
    if (isFormData3) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e10) {
        if (strictJSONParsing) {
          if (e10.name === "SyntaxError") {
            throw AxiosError_default.from(e10, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e10;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/core/AxiosHeaders.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/parseHeaders.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i7;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i7 = line.indexOf(":");
    key = line.substring(0, i7).trim().toLowerCase();
    val = line.substring(i7 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w4, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i7 = keys.length;
    let deleted = false;
    while (i7--) {
      const key = keys[i7];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format5) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format5 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function CanceledError(message, config2, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/adapters/adapters.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/adapters/xhr.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/core/settle.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function settle(resolve4, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve4(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var cookies_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name3, value, expires, path2, domain2, secure) {
        const cookie = [];
        cookie.push(name3 + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils_default.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name3) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name3 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name3) {
        this.write(name3, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// node_modules/axios/lib/core/buildFullPath.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/parseProtocol.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i7 = tail;
    let bytesCount = 0;
    while (i7 !== head) {
      bytesCount += bytes[i7++];
      i7 = i7 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e10) => {
    const loaded = e10.loaded;
    const total = e10.lengthComputable ? e10.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e10
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve4, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders_default.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData)) {
      if (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve2(value) {
        resolve4(value);
        done();
      }, function _reject2(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitional_default;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin_default(fullPath)) && config2.xsrfCookieName && cookies_default.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e10) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i7 = 0; i7 < length; i7++) {
      nameOrAdapter = adapters[i7];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a7, b5, caseless) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(a7, b5, caseless);
    } else if (!utils_default.isUndefined(a7)) {
      return getMergedValue(void 0, a7, caseless);
    }
  }
  function valueFromConfig2(a7, b5) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(void 0, b5);
    }
  }
  function defaultToConfig2(a7, b5) {
    if (!utils_default.isUndefined(b5)) {
      return getMergedValue(void 0, b5);
    } else if (!utils_default.isUndefined(a7)) {
      return getMergedValue(void 0, a7);
    }
  }
  function mergeDirectKeys(a7, b5, prop) {
    if (prop in config2) {
      return getMergedValue(a7, b5);
    } else if (prop in config1) {
      return getMergedValue(void 0, a7);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a7, b5) => mergeDeepProperties(headersToObject(a7), headersToObject(b5), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/validator.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/axios/lib/env/data.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var VERSION = "1.4.0";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i7) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i7 < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version4, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version4 ? " in " + version4 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version4 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version4 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i7 = keys.length;
  while (i7-- > 0) {
    const opt = keys[i7];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i7 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i7 < len) {
        promise = promise.then(chain[i7++], chain[i7++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i7 = 0;
    while (i7 < len) {
      const onFulfilled = requestInterceptorChain[i7++];
      const onRejected = requestInterceptorChain[i7++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i7 = 0;
    len = responseInterceptorChain.length;
    while (i7 < len) {
      promise = promise.then(responseInterceptorChain[i7++], responseInterceptorChain[i7++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve4) {
      resolvePromise = resolve4;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i7 = token._listeners.length;
      while (i7-- > 0) {
        token._listeners[i7](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve2;
      const promise = new Promise((resolve4) => {
        token.subscribe(resolve4);
        _resolve2 = resolve4;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve2);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c7) {
      cancel = c7;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises3) {
  return Promise.all(promises3);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// src/generated/core/request.ts
var import_form_data = __toESM(require_browser());

// src/generated/core/ApiError.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var ApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request2;
  }
};

// src/generated/core/CancelablePromise.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var _isResolved, _isRejected, _isCancelled, _cancelHandlers, _promise, _resolve, _reject;
var CancelablePromise = class {
  constructor(executor) {
    __privateAdd(this, _isResolved, void 0);
    __privateAdd(this, _isRejected, void 0);
    __privateAdd(this, _isCancelled, void 0);
    __privateAdd(this, _cancelHandlers, void 0);
    __privateAdd(this, _promise, void 0);
    __privateAdd(this, _resolve, void 0);
    __privateAdd(this, _reject, void 0);
    __privateSet(this, _isResolved, false);
    __privateSet(this, _isRejected, false);
    __privateSet(this, _isCancelled, false);
    __privateSet(this, _cancelHandlers, []);
    __privateSet(this, _promise, new Promise((resolve4, reject) => {
      __privateSet(this, _resolve, resolve4);
      __privateSet(this, _reject, reject);
      const onResolve = (value) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isResolved, true);
        (_a = __privateGet(this, _resolve)) == null ? void 0 : _a.call(this, value);
      };
      const onReject = (reason) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isRejected, true);
        (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, reason);
      };
      const onCancel = (cancelHandler) => {
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateGet(this, _cancelHandlers).push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => __privateGet(this, _isResolved)
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => __privateGet(this, _isRejected)
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => __privateGet(this, _isCancelled)
      });
      return executor(onResolve, onReject, onCancel);
    }));
  }
  get [Symbol.toStringTag]() {
    return "Cancellable Promise";
  }
  then(onFulfilled, onRejected) {
    return __privateGet(this, _promise).then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return __privateGet(this, _promise).catch(onRejected);
  }
  finally(onFinally) {
    return __privateGet(this, _promise).finally(onFinally);
  }
  cancel() {
    var _a;
    if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
      return;
    }
    __privateSet(this, _isCancelled, true);
    if (__privateGet(this, _cancelHandlers).length) {
      try {
        for (const cancelHandler of __privateGet(this, _cancelHandlers)) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    __privateGet(this, _cancelHandlers).length = 0;
    (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, new CancelError("Request aborted"));
  }
  get isCancelled() {
    return __privateGet(this, _isCancelled);
  }
};
_isResolved = new WeakMap();
_isRejected = new WeakMap();
_isCancelled = new WeakMap();
_cancelHandlers = new WeakMap();
_promise = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();

// src/generated/core/request.ts
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString2 = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString2(value) && value !== "";
};
var isBlob2 = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData2 = (value) => {
  return value instanceof import_form_data.default;
};
var isSuccess = (status) => {
  return status >= 200 && status < 300;
};
var base64 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer2.from(str).toString("base64");
  }
};
var getQueryString = (params) => {
  const qs = [];
  const append2 = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process3 = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v7) => {
          process3(key, v7);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k4, v7]) => {
          process3(`${key}[${k4}]`, v7);
        });
      } else {
        append2(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process3(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config2, options) => {
  const encoder = config2.ENCODE_PATH || encodeURI;
  const path2 = options.url.replace("{api-version}", config2.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config2.BASE}${path2}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new import_form_data.default();
    const process3 = (key, value) => {
      if (isString2(value) || isBlob2(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_4, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v7) => process3(key, v7));
      } else {
        process3(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config2, options, formData) => {
  const token = await resolve(options, config2.TOKEN);
  const username = await resolve(options, config2.USERNAME);
  const password = await resolve(options, config2.PASSWORD);
  const additionalHeaders = await resolve(options, config2.HEADERS);
  const formHeaders = typeof formData?.getHeaders === "function" && formData?.getHeaders() || {};
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers,
    ...formHeaders
  }).filter(([_4, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob2(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString2(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData2(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return headers;
};
var getRequestBody = (options) => {
  if (options.body) {
    return options.body;
  }
  return void 0;
};
var sendRequest = async (config2, options, url, body, formData, headers, onCancel) => {
  const source = axios_default.CancelToken.source();
  const requestConfig = {
    url,
    headers,
    data: body ?? formData,
    method: options.method,
    withCredentials: config2.WITH_CREDENTIALS,
    cancelToken: source.token
  };
  onCancel(() => source.cancel("The user aborted a request."));
  try {
    return await axios_default.request(requestConfig);
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers[responseHeader];
    if (isString2(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = (response) => {
  if (response.status !== 204) {
    return response.data;
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config2, options) => {
  return new CancelablePromise(async (resolve4, reject, onCancel) => {
    try {
      const url = getUrl(config2, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config2, options, formData);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config2, options, url, body, formData, headers, onCancel);
        const responseBody = getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: isSuccess(response.status),
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes(options, result);
        resolve4(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// src/generated/core/AxiosHttpRequest.ts
var AxiosHttpRequest = class extends BaseHttpRequest {
  constructor(config2) {
    super(config2);
  }
  /**
   * Request method
   * @param options The request options from the service
   * @returns CancelablePromise<T>
   * @throws ApiError
   */
  request(options) {
    return request(this.config, options);
  }
};

// src/generated/services/V1Service.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var V1Service = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * @param requestBody
   * @returns CompletionResponse Success
   * @throws ApiError
   */
  completion(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/v1/completions",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        400: `Bad Request`
      }
    });
  }
  /**
   * @param requestBody
   * @returns any Success
   * @throws ApiError
   */
  event(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/v1/events",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        400: `Bad Request`
      }
    });
  }
  /**
   * @returns HealthState Success
   * @throws ApiError
   */
  health() {
    return this.httpRequest.request({
      method: "POST",
      url: "/v1/health"
    });
  }
};

// src/generated/TabbyApi.ts
var TabbyApi = class {
  constructor(config2, HttpRequest = AxiosHttpRequest) {
    this.request = new HttpRequest({
      BASE: config2?.BASE ?? "https://playground.app.tabbyml.com/tabby",
      VERSION: config2?.VERSION ?? "0.1.0",
      WITH_CREDENTIALS: config2?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config2?.CREDENTIALS ?? "include",
      TOKEN: config2?.TOKEN,
      USERNAME: config2?.USERNAME,
      PASSWORD: config2?.PASSWORD,
      HEADERS: config2?.HEADERS,
      ENCODE_PATH: config2?.ENCODE_PATH
    });
    this.v1 = new V1Service(this.request);
  }
};

// src/generated/core/OpenAPI.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/utils.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function splitLines(input) {
  return input.match(/.*(?:$|\r?\n)/g).filter(Boolean);
}
function splitWords(input) {
  return input.match(/\w+|\W+/g).filter(Boolean);
}
function isBlank(input) {
  return input.trim().length === 0;
}
function cancelable(promise, cancel) {
  return new CancelablePromise((resolve4, reject, onCancel) => {
    promise.then((resp) => {
      resolve4(resp);
    }).catch((err) => {
      reject(err);
    });
    onCancel(() => {
      cancel();
    });
  });
}

// src/Auth.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_events();

// node_modules/jwt-decode/build/jwt-decode.esm.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function e2(e10) {
  this.message = e10;
}
e2.prototype = new Error(), e2.prototype.name = "InvalidCharacterError";
var r2 = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r10) {
  var t9 = String(r10).replace(/=+$/, "");
  if (t9.length % 4 == 1)
    throw new e2("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n9, o9, a7 = 0, i7 = 0, c7 = ""; o9 = t9.charAt(i7++); ~o9 && (n9 = a7 % 4 ? 64 * n9 + o9 : o9, a7++ % 4) ? c7 += String.fromCharCode(255 & n9 >> (-2 * a7 & 6)) : 0)
    o9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o9);
  return c7;
};
function t2(e10) {
  var t9 = e10.replace(/-/g, "+").replace(/_/g, "/");
  switch (t9.length % 4) {
    case 0:
      break;
    case 2:
      t9 += "==";
      break;
    case 3:
      t9 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e11) {
      return decodeURIComponent(r2(e11).replace(/(.)/g, function(e12, r10) {
        var t10 = r10.charCodeAt(0).toString(16).toUpperCase();
        return t10.length < 2 && (t10 = "0" + t10), "%" + t10;
      }));
    }(t9);
  } catch (e11) {
    return r2(t9);
  }
}
function n2(e10) {
  this.message = e10;
}
function o2(e10, r10) {
  if ("string" != typeof e10)
    throw new n2("Invalid token specified");
  var o9 = true === (r10 = r10 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t2(e10.split(".")[o9]));
  } catch (e11) {
    throw new n2("Invalid token specified: " + e11.message);
  }
}
n2.prototype = new Error(), n2.prototype.name = "InvalidTokenError";
var jwt_decode_esm_default = o2;

// src/cloud/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/cloud/CloudApi.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/cloud/services/ApiService.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var ApiService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * @returns DeviceTokenResponse Success
   * @throws ApiError
   */
  deviceToken(body) {
    return this.httpRequest.request({
      method: "POST",
      url: "/device-token",
      body
    });
  }
  /**
   * @param code
   * @returns DeviceTokenAcceptResponse Success
   * @throws ApiError
   */
  deviceTokenAccept(query) {
    return this.httpRequest.request({
      method: "POST",
      url: "/device-token/accept",
      query
    });
  }
  /**
   * @param token
   * @returns DeviceTokenRefreshResponse Success
   * @throws ApiError
   */
  deviceTokenRefresh(token) {
    return this.httpRequest.request({
      method: "POST",
      url: "/device-token/refresh",
      headers: { Authorization: `Bearer ${token}` }
    });
  }
  /**
   * @param body object for anonymous usage tracking
   */
  usage(body) {
    return this.httpRequest.request({
      method: "POST",
      url: "/usage",
      body
    });
  }
};

// src/cloud/CloudApi.ts
var CloudApi = class {
  constructor(config2, HttpRequest = AxiosHttpRequest) {
    this.request = new HttpRequest({
      BASE: config2?.BASE ?? "https://app.tabbyml.com/api",
      VERSION: config2?.VERSION ?? "0.0.0",
      WITH_CREDENTIALS: config2?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config2?.CREDENTIALS ?? "include",
      TOKEN: config2?.TOKEN,
      USERNAME: config2?.USERNAME,
      PASSWORD: config2?.PASSWORD,
      HEADERS: config2?.HEADERS,
      ENCODE_PATH: config2?.ENCODE_PATH
    });
    this.api = new ApiService(this.request);
  }
};

// src/cloud/models/DeviceTokenResponse.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/cloud/models/DeviceTokenAcceptResponse.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/dataStore.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_env();
var dataStore = isBrowser ? null : (() => {
  const dataFile = (init_path(), __toCommonJS(path_exports)).join((init_os(), __toCommonJS(os_exports)).homedir(), ".tabby", "agent", "data.json");
  const fs2 = require_lib();
  return {
    data: {},
    load: async function() {
      this.data = await fs2.readJson(dataFile, { throws: false }) || {};
    },
    save: async function() {
      await fs2.outputJson(dataFile, this.data);
    }
  };
})();

// src/Auth.ts
init_logger();
var _Auth = class extends EventEmitter {
  constructor(options) {
    super();
    this.logger = rootLogger.child({ component: "Auth" });
    this.dataStore = null;
    this.refreshTokenTimer = null;
    this.authApi = null;
    this.jwt = null;
    this.endpoint = options.endpoint;
    this.dataStore = options.dataStore || dataStore;
    this.authApi = new CloudApi();
    this.scheduleRefreshToken();
  }
  static async create(options) {
    const auth = new _Auth(options);
    await auth.load();
    return auth;
  }
  get token() {
    return this.jwt?.token;
  }
  get user() {
    return this.jwt?.payload.email;
  }
  async load() {
    if (!this.dataStore)
      return;
    try {
      await this.dataStore.load();
      const storedJwt = this.dataStore.data["auth"]?.[this.endpoint]?.jwt;
      if (typeof storedJwt === "string" && this.jwt?.token !== storedJwt) {
        this.logger.debug({ storedJwt }, "Load jwt from data store.");
        const jwt = {
          token: storedJwt,
          payload: jwt_decode_esm_default(storedJwt)
        };
        if (jwt.payload.exp * 1e3 - Date.now() < _Auth.tokenStrategy.refresh.beforeExpire) {
          this.jwt = await this.refreshToken(jwt, _Auth.tokenStrategy.refresh.whenLoaded);
          await this.save();
        } else {
          this.jwt = jwt;
        }
      }
    } catch (error) {
      this.logger.debug({ error }, "Error when loading auth");
    }
  }
  async save() {
    if (!this.dataStore)
      return;
    try {
      if (this.jwt) {
        if (this.dataStore.data["auth"]?.[this.endpoint]?.jwt === this.jwt.token)
          return;
        this.dataStore.data["auth"] = { ...this.dataStore.data["auth"], [this.endpoint]: { jwt: this.jwt.token } };
      } else {
        if (typeof this.dataStore.data["auth"]?.[this.endpoint] === "undefined")
          return;
        delete this.dataStore.data["auth"][this.endpoint];
      }
      await this.dataStore.save();
      this.logger.debug("Save changes to data store.");
    } catch (error) {
      this.logger.error({ error }, "Error when saving auth");
    }
  }
  async reset() {
    if (this.jwt) {
      this.jwt = null;
      await this.save();
    }
  }
  requestAuthUrl() {
    return new CancelablePromise(async (resolve4, reject, onCancel) => {
      let apiRequest;
      onCancel(() => {
        apiRequest?.cancel();
      });
      try {
        await this.reset();
        if (onCancel.isCancelled)
          return;
        this.logger.debug("Start to request device token");
        apiRequest = this.authApi.api.deviceToken({ auth_url: this.endpoint });
        const deviceToken = await apiRequest;
        this.logger.debug({ deviceToken }, "Request device token response");
        const authUrl = new URL(_Auth.authPageUrl);
        authUrl.searchParams.append("code", deviceToken.data.code);
        resolve4({ authUrl: authUrl.toString(), code: deviceToken.data.code });
      } catch (error) {
        this.logger.error({ error }, "Error when requesting token");
        reject(error);
      }
    });
  }
  pollingToken(code) {
    return new CancelablePromise((resolve4, reject, onCancel) => {
      let apiRequest;
      const timer = setInterval(async () => {
        try {
          apiRequest = this.authApi.api.deviceTokenAccept({ code });
          const response = await apiRequest;
          this.logger.debug({ response }, "Poll jwt response");
          this.jwt = {
            token: response.data.jwt,
            payload: jwt_decode_esm_default(response.data.jwt)
          };
          super.emit("updated", this.jwt);
          await this.save();
          clearInterval(timer);
          resolve4(true);
        } catch (error) {
          if (error instanceof ApiError && [400, 401, 403, 405].indexOf(error.status) !== -1) {
            this.logger.debug({ error }, "Expected error when polling jwt");
          } else {
            this.logger.error({ error }, "Error when polling jwt");
          }
        }
      }, _Auth.tokenStrategy.polling.interval);
      setTimeout(() => {
        clearInterval(timer);
        reject(new Error("Timeout when polling token"));
      }, _Auth.tokenStrategy.polling.timeout);
      onCancel(() => {
        apiRequest?.cancel();
        clearInterval(timer);
      });
    });
  }
  async refreshToken(jwt, options = { maxTry: 1, retryDelay: 1e3 }, retry = 0) {
    try {
      this.logger.debug({ retry }, "Start to refresh token");
      const refreshedJwt = await this.authApi.api.deviceTokenRefresh(jwt.token);
      this.logger.debug({ refreshedJwt }, "Refresh token response");
      return {
        token: refreshedJwt.data.jwt,
        payload: jwt_decode_esm_default(refreshedJwt.data.jwt)
      };
    } catch (error) {
      if (error instanceof ApiError && [400, 401, 403, 405].indexOf(error.status) !== -1) {
        this.logger.debug({ error }, "Error when refreshing jwt");
      } else {
        this.logger.error({ error }, "Unknown error when refreshing jwt");
        if (retry < options.maxTry) {
          this.logger.debug(`Retry refreshing jwt after ${options.retryDelay}ms`);
          await new Promise((resolve4) => setTimeout(resolve4, options.retryDelay));
          return this.refreshToken(jwt, options, retry + 1);
        }
      }
      throw { ...error, retry };
    }
  }
  scheduleRefreshToken() {
    this.refreshTokenTimer = setInterval(async () => {
      if (!this.jwt) {
        return null;
      }
      if (this.jwt.payload.exp * 1e3 - Date.now() < _Auth.tokenStrategy.refresh.beforeExpire) {
        try {
          this.jwt = await this.refreshToken(this.jwt, _Auth.tokenStrategy.refresh.whenScheduled);
          super.emit("updated", this.jwt);
          await this.save();
        } catch (error) {
          this.logger.error({ error }, "Error when refreshing jwt");
        }
      } else {
        this.logger.debug("Check token, still valid");
      }
    }, _Auth.tokenStrategy.refresh.interval);
  }
};
var Auth = _Auth;
Auth.authPageUrl = "https://app.tabbyml.com/account/device-token";
Auth.tokenStrategy = {
  polling: {
    // polling token after auth url generated
    interval: 5e3,
    // polling token every 5 seconds
    timeout: 5 * 60 * 1e3
    // stop polling after trying for 5 min
  },
  refresh: {
    // check token every 15 min, refresh token if it expires in 30 min
    interval: 15 * 60 * 1e3,
    beforeExpire: 30 * 60 * 1e3,
    whenLoaded: {
      // after token loaded from data store, refresh token if it is about to expire or has expired
      maxTry: 5,
      // keep loading time not too long
      retryDelay: 1e3
      // retry after 1 seconds
    },
    whenScheduled: {
      // if running until token is about to expire, refresh token as scheduled
      maxTry: 60,
      retryDelay: 30 * 1e3
      // retry after 30 seconds
    }
  }
};

// src/AgentConfig.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_env();
var defaultAgentConfig = {
  server: {
    endpoint: "http://localhost:8080"
  },
  logs: {
    level: "silent"
  },
  anonymousUsageTracking: {
    disable: false
  }
};
var userAgentConfig = isBrowser ? null : (() => {
  const EventEmitter2 = (init_events(), __toCommonJS(events_exports));
  const fs2 = require_lib();
  const toml = require_toml();
  const chokidar = require_chokidar();
  class ConfigFile extends EventEmitter2 {
    constructor(filepath) {
      super();
      this.data = {};
      this.watcher = null;
      this.logger = (init_logger(), __toCommonJS(logger_exports)).rootLogger.child({ component: "ConfigFile" });
      this.filepath = filepath;
    }
    get config() {
      return this.data;
    }
    async load() {
      try {
        const fileContent = await fs2.readFile(this.filepath, "utf8");
        this.data = toml.parse(fileContent);
        super.emit("updated", this.data);
      } catch (error) {
        this.logger.error({ error }, "Failed to load config file");
      }
    }
    watch() {
      this.watcher = chokidar.watch(this.filepath, {
        interval: 1e3
      });
      this.watcher.on("add", this.load.bind(this));
      this.watcher.on("change", this.load.bind(this));
    }
  }
  const configFile = (init_path(), __toCommonJS(path_exports)).join((init_os(), __toCommonJS(os_exports)).homedir(), ".tabby", "agent", "config.toml");
  return new ConfigFile(configFile);
})();

// src/CompletionCache.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// node_modules/lru-cache/dist/mjs/index.js
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process_exports === "object" && !!process_exports ? process_exports : {};
var emitWarning2 = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_4, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning2("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var isPosInt = (n9) => n9 && n9 === Math.floor(n9) && n9 > 0 && isFinite(n9);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s6 = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s6;
  }
  push(n9) {
    this.heap[this.length++] = n9;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var Stack = _Stack;
_constructing = new WeakMap();
// private constructor
__privateAdd(Stack, _constructing, false);
var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
var _LRUCache = class {
  constructor(options) {
    __privateAdd(this, _initializeTTLTracking);
    __privateAdd(this, _initializeSizeTracking);
    __privateAdd(this, _indexes);
    __privateAdd(this, _rindexes);
    __privateAdd(this, _isValidIndex);
    __privateAdd(this, _evict);
    __privateAdd(this, _backgroundFetch);
    __privateAdd(this, _isBackgroundFetch);
    __privateAdd(this, _connect);
    __privateAdd(this, _moveToTail);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _dispose, void 0);
    __privateAdd(this, _disposeAfter, void 0);
    __privateAdd(this, _fetchMethod, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _calculatedSize, void 0);
    __privateAdd(this, _keyMap, void 0);
    __privateAdd(this, _keyList, void 0);
    __privateAdd(this, _valList, void 0);
    __privateAdd(this, _next, void 0);
    __privateAdd(this, _prev, void 0);
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _free, void 0);
    __privateAdd(this, _disposed, void 0);
    __privateAdd(this, _sizes, void 0);
    __privateAdd(this, _starts, void 0);
    __privateAdd(this, _ttls, void 0);
    __privateAdd(this, _hasDispose, void 0);
    __privateAdd(this, _hasFetchMethod, void 0);
    __privateAdd(this, _hasDisposeAfter, void 0);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning2(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c7) {
    return {
      // properties
      starts: __privateGet(c7, _starts),
      ttls: __privateGet(c7, _ttls),
      sizes: __privateGet(c7, _sizes),
      keyMap: __privateGet(c7, _keyMap),
      keyList: __privateGet(c7, _keyList),
      valList: __privateGet(c7, _valList),
      next: __privateGet(c7, _next),
      prev: __privateGet(c7, _prev),
      get head() {
        return __privateGet(c7, _head);
      },
      get tail() {
        return __privateGet(c7, _tail);
      },
      free: __privateGet(c7, _free),
      // methods
      isBackgroundFetch: (p7) => {
        var _a;
        return __privateMethod(_a = c7, _isBackgroundFetch, isBackgroundFetch_fn).call(_a, p7);
      },
      backgroundFetch: (k4, index, options, context) => {
        var _a;
        return __privateMethod(_a = c7, _backgroundFetch, backgroundFetch_fn).call(_a, k4, index, options, context);
      },
      moveToTail: (index) => {
        var _a;
        return __privateMethod(_a = c7, _moveToTail, moveToTail_fn).call(_a, index);
      },
      indexes: (options) => {
        var _a;
        return __privateMethod(_a = c7, _indexes, indexes_fn).call(_a, options);
      },
      rindexes: (options) => {
        var _a;
        return __privateMethod(_a = c7, _rindexes, rindexes_fn).call(_a, options);
      },
      isStale: (index) => {
        var _a;
        return __privateGet(_a = c7, _isStale).call(_a, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i7] !== void 0 && __privateGet(this, _keyList)[i7] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield [__privateGet(this, _keyList)[i7], __privateGet(this, _valList)[i7]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i7] !== void 0 && __privateGet(this, _keyList)[i7] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield [__privateGet(this, _keyList)[i7], __privateGet(this, _valList)[i7]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i7];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield k4;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const k4 = __privateGet(this, _keyList)[i7];
      if (k4 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield k4;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      if (v7 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield __privateGet(this, _valList)[i7];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      if (v7 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i7])) {
        yield __privateGet(this, _valList)[i7];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i7], this)) {
        return this.get(__privateGet(this, _keyList)[i7], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i7], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i7], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i7 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i7)) {
        this.delete(__privateGet(this, _keyList)[i7]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i7 of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i7];
      const v7 = __privateGet(this, _valList)[i7];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i7];
        const age = perf.now() - __privateGet(this, _starts)[i7];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i7];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k4, v7, setOptions = {}) {
    var _a, _b;
    if (v7 === void 0) {
      this.delete(k4);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k4, v7, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k4);
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k4);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k4;
      __privateGet(this, _valList)[index] = v7;
      __privateGet(this, _keyMap).set(k4, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v7 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, oldVal, k4, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            __privateGet(this, _disposed)?.push([oldVal, k4, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size, status);
        __privateGet(this, _valList)[index] = v7;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _evict, evict_fn).call(this, true);
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_a = __privateGet(this, _disposeAfter)) == null ? void 0 : _a.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k4, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0) {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) && v7.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k4, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index))) {
      const v7 = __privateGet(this, _valList)[index];
      return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7) ? v7.__staleWhileFetching : v7;
    }
  }
  async fetch(k4, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k4, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k4);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p7 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index, options, context);
      return p7.__returned = p7;
    } else {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
        const stale = allowStale && v7.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v7.__staleWhileFetching : v7.__returned = v7;
      }
      const isStale = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v7;
      }
      const p7 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k4, index, options, context);
      const hasStale = p7.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p7.__staleWhileFetching : p7.__returned = p7;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k4, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k4);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k4);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k4) {
    var _a, _b;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index = __privateGet(this, _keyMap).get(k4);
      if (index !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index);
          const v7 = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
            v7.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              __privateGet(this, _disposed)?.push([v7, k4, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k4);
          __privateGet(this, _keyList)[index] = void 0;
          __privateGet(this, _valList)[index] = void 0;
          if (index === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index]);
          } else if (index === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index]);
          } else {
            __privateGet(this, _next)[__privateGet(this, _prev)[index]] = __privateGet(this, _next)[index];
            __privateGet(this, _prev)[__privateGet(this, _next)[index]] = __privateGet(this, _prev)[index];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a, _b;
    for (const index of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      const v7 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
        v7.__abortController.abort(new Error("deleted"));
      } else {
        const k4 = __privateGet(this, _keyList)[index];
        if (__privateGet(this, _hasDispose)) {
          (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v7, k4, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt?.shift()) {
        (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
      }
    }
  }
};
var LRUCache = _LRUCache;
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_initializeTTLTracking = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t9 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          this.delete(__privateGet(this, _keyList)[index]);
        }
      }, ttl + 1);
      if (t9.unref) {
        t9.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n9 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n9;
      const t9 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t9.unref) {
        t9.unref();
      }
    }
    return n9;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (ttl === 0 || start === 0) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index) => {
    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
_initializeSizeTracking = new WeakSet();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k4, v7, size, sizeCalculation) => {
    if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v7, k4);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index, size, status) => {
    sizes[index] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _evict, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
_indexes = new WeakSet();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i7 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i7)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i7)) {
        yield i7;
      }
      if (i7 === __privateGet(this, _head)) {
        break;
      } else {
        i7 = __privateGet(this, _prev)[i7];
      }
    }
  }
};
_rindexes = new WeakSet();
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i7 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i7)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i7)) {
        yield i7;
      }
      if (i7 === __privateGet(this, _tail)) {
        break;
      } else {
        i7 = __privateGet(this, _next)[i7];
      }
    }
  }
};
_isValidIndex = new WeakSet();
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
_evict = new WeakSet();
evict_fn = function(free) {
  var _a;
  const head = __privateGet(this, _head);
  const k4 = __privateGet(this, _keyList)[head];
  const v7 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
    v7.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v7, k4, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      __privateGet(this, _disposed)?.push([v7, k4, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k4);
  __privateWrapper(this, _size)._--;
  return head;
};
_backgroundFetch = new WeakSet();
backgroundFetch_fn = function(k4, index, options, context) {
  const v7 = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v7)) {
    return v7;
  }
  const ac = new AC();
  const { signal } = options;
  signal?.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v8, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v8 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p7;
    if (__privateGet(this, _valList)[index] === p7) {
      if (v8 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          this.delete(k4);
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k4, v8, fetchOpts.options);
      }
    }
    return v8;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p7;
    if (__privateGet(this, _valList)[index] === p7) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        this.delete(k4);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a;
    const fmp = (_a = __privateGet(this, _fetchMethod)) == null ? void 0 : _a.call(this, k4, v7, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v8) => res(v8), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res();
        if (options.allowStaleOnFetchAbort) {
          res = (v8) => cb(v8, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p7 = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p7, {
    __abortController: ac,
    __staleWhileFetching: v7,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k4, bf, { ...fetchOpts.options, status: void 0 });
    index = __privateGet(this, _keyMap).get(k4);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
_isBackgroundFetch = new WeakSet();
isBackgroundFetch_fn = function(p7) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b5 = p7;
  return !!b5 && b5 instanceof Promise && b5.hasOwnProperty("__staleWhileFetching") && b5.__abortController instanceof AC;
};
_connect = new WeakSet();
connect_fn = function(p7, n9) {
  __privateGet(this, _prev)[n9] = p7;
  __privateGet(this, _next)[p7] = n9;
};
_moveToTail = new WeakSet();
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};

// src/CompletionCache.ts
var import_object_hash = __toESM(require_object_hash());
var import_object_sizeof = __toESM(require_indexv2());
init_logger();
var CompletionCache = class {
  constructor() {
    this.logger = rootLogger.child({ component: "CompletionCache" });
    this.options = {
      maxSize: 1 * 1024 * 1024,
      // 1MB
      partiallyAcceptedCacheGeneration: {
        enabled: true,
        perCharacter: {
          lines: 1,
          words: 10,
          max: 30
        },
        perWord: {
          lines: 1,
          max: 20
        },
        perLine: {
          max: 3
        }
      }
    };
    this.cache = new LRUCache({
      maxSize: this.options.maxSize,
      sizeCalculation: import_object_sizeof.default
    });
  }
  has(key) {
    return this.cache.has(this.hash(key));
  }
  set(key, value) {
    for (const entry of this.createCacheEntries(key, value)) {
      this.logger.debug({ entry }, "Setting cache entry");
      this.cache.set(this.hash(entry.key), entry.value);
    }
    this.logger.debug({ size: this.cache.calculatedSize }, "Cache size");
  }
  get(key) {
    return this.cache.get(this.hash(key));
  }
  hash(key) {
    return (0, import_object_hash.default)(key);
  }
  createCacheEntries(key, value) {
    const list = [{ key, value }];
    if (this.options.partiallyAcceptedCacheGeneration.enabled) {
      const entries = value.choices.map((choice) => {
        return this.calculatePartiallyAcceptedPositions(choice.text).map((position) => {
          return {
            prefix: choice.text.slice(0, position),
            suffix: choice.text.slice(position),
            choiceIndex: choice.index
          };
        });
      }).flat().reduce((grouped, entry) => {
        grouped[entry.prefix] = grouped[entry.prefix] || [];
        grouped[entry.prefix].push({ suffix: entry.suffix, choiceIndex: entry.choiceIndex });
        return grouped;
      }, {});
      for (const prefix in entries) {
        const cacheKey = {
          ...key,
          text: key.text.slice(0, key.position) + prefix + key.text.slice(key.position),
          position: key.position + prefix.length
        };
        const cacheValue = {
          ...value,
          choices: entries[prefix].map((choice) => {
            return {
              index: choice.choiceIndex,
              text: choice.suffix
            };
          })
        };
        list.push({
          key: cacheKey,
          value: cacheValue
        });
      }
    }
    return list;
  }
  calculatePartiallyAcceptedPositions(completion) {
    const positions = [];
    const option = this.options.partiallyAcceptedCacheGeneration;
    const lines = splitLines(completion);
    let index = 0;
    let offset = 0;
    while (index < lines.length - 1 && index < option.perLine.max) {
      offset += lines[index].length;
      positions.push(offset);
      index++;
    }
    const words = lines.slice(0, option.perWord.lines).map(splitWords).flat();
    index = 0;
    offset = 0;
    while (index < words.length && index < option.perWord.max) {
      offset += words[index].length;
      positions.push(offset);
      index++;
    }
    const characters = lines.slice(0, option.perCharacter.lines).map(splitWords).flat().slice(0, option.perCharacter.words).join("");
    offset = 1;
    while (offset < characters.length && offset < option.perCharacter.max) {
      positions.push(offset);
      offset++;
    }
    return positions.filter((v7, i7, arr) => arr.indexOf(v7) === i7).sort((a7, b5) => a7 - b5);
  }
};

// src/postprocess/index.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// src/postprocess/filter.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
init_logger();
var logger = rootLogger.child({ component: "Postprocess" });
var applyFilter = (filter2) => {
  return async (response) => {
    response.choices = (await Promise.all(
      response.choices.map(async (choice) => {
        choice.text = await filter2(choice.text);
        return choice;
      })
    )).filter(Boolean);
    return response;
  };
};

// src/postprocess/limitScopeByIndentation.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
function calcIndentLevel(line) {
  return line.match(/^[ \t]*/)?.[0]?.length || 0;
}
function isIndentBlockClosingAllowed(currentIndentLevel, suffixLines) {
  let index = 1;
  while (index < suffixLines.length && isBlank(suffixLines[index])) {
    index++;
  }
  if (index >= suffixLines.length) {
    return true;
  } else {
    const indentLevel = calcIndentLevel(suffixLines[index]);
    return indentLevel < currentIndentLevel;
  }
}
function isOpeningIndentBlock(lines, index) {
  if (index >= lines.length - 1) {
    return false;
  }
  return calcIndentLevel(lines[index]) < calcIndentLevel(lines[index + 1]);
}
var limitScopeByIndentation = (context) => {
  return (input) => {
    const prefix = context.text.slice(0, context.position);
    const suffix = context.text.slice(context.position);
    const prefixLines = splitLines(prefix);
    const suffixLines = splitLines(suffix);
    const inputLines = splitLines(input);
    const currentIndentLevel = calcIndentLevel(prefixLines[prefixLines.length - 1]);
    let index;
    for (index = 1; index < inputLines.length; index++) {
      if (isBlank(inputLines[index])) {
        continue;
      }
      const indentLevel = calcIndentLevel(inputLines[index]);
      if (indentLevel < currentIndentLevel) {
        if (isIndentBlockClosingAllowed(currentIndentLevel, suffixLines) && !isOpeningIndentBlock(inputLines, index)) {
          index++;
        }
        break;
      }
    }
    if (index < inputLines.length) {
      logger.debug({ input, prefix, suffix, scopeEndAt: index }, "Remove content out of scope");
      return inputLines.slice(0, index).join("").trimEnd();
    }
    return input;
  };
};

// src/postprocess/removeOverlapping.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var removeOverlapping = (context) => {
  return (input) => {
    const suffix = context.text.slice(context.position);
    for (let index = Math.max(0, input.length - suffix.length); index < input.length; index++) {
      if (input.slice(index) === suffix.slice(0, input.length - index)) {
        logger.debug({ input, suffix, overlappedAt: index }, "Remove overlapped content");
        return input.slice(0, index);
      }
    }
    return input;
  };
};

// src/postprocess/dropBlank.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var dropBlank = () => {
  return (input) => {
    return isBlank(input) ? null : input;
  };
};

// src/postprocess/index.ts
async function postprocess(request2, response) {
  return new Promise((resolve4) => resolve4(response)).then(applyFilter(limitScopeByIndentation(request2))).then(applyFilter(removeOverlapping(request2))).then(applyFilter(dropBlank()));
}

// src/TabbyAgent.ts
init_logger();

// src/AnonymousUsageLogger.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();

// package.json
var name2 = "tabby-agent";
var version3 = "0.0.1";

// src/AnonymousUsageLogger.ts
init_env();
init_logger();
var AnonymousUsageLogger = class {
  constructor() {
    this.anonymousUsageTrackingApi = new CloudApi();
    this.logger = rootLogger.child({ component: "AnonymousUsage" });
    this.systemData = {
      agent: `${name2}, ${version3}`,
      browser: isBrowser ? navigator?.userAgent || "browser" : void 0,
      node: isBrowser ? void 0 : `${process_exports.version} ${process_exports.platform} ${(init_os(), __toCommonJS(os_exports)).arch()} ${(init_os(), __toCommonJS(os_exports)).release()}`
    };
    this.dataStore = null;
  }
  static async create(options) {
    const logger2 = new AnonymousUsageLogger();
    logger2.dataStore = options.dataStore || dataStore;
    await logger2.checkAnonymousId();
    return logger2;
  }
  async checkAnonymousId() {
    if (this.dataStore) {
      try {
        await this.dataStore.load();
      } catch (error) {
        this.logger.debug({ error }, "Error when loading anonymousId");
      }
      if (typeof this.dataStore.data["anonymousId"] === "string") {
        this.anonymousId = this.dataStore.data["anonymousId"];
      } else {
        this.anonymousId = v4_default();
        this.dataStore.data["anonymousId"] = this.anonymousId;
        try {
          await this.dataStore.save();
        } catch (error) {
          this.logger.debug({ error }, "Error when saving anonymousId");
        }
      }
    } else {
      this.anonymousId = v4_default();
    }
  }
  async event(event, data) {
    if (this.disabled) {
      return;
    }
    await this.anonymousUsageTrackingApi.api.usage({
      distinctId: this.anonymousId,
      event,
      properties: {
        ...this.systemData,
        ...data
      }
    }).catch((error) => {
      this.logger.error({ error }, "Error when sending anonymous usage data");
    });
  }
};

// src/TabbyAgent.ts
var _TabbyAgent = class extends EventEmitter {
  constructor() {
    super();
    this.logger = rootLogger.child({ component: "TabbyAgent" });
    this.config = defaultAgentConfig;
    this.userConfig = {};
    // config from `~/.tabby/agent/config.toml`
    this.clientConfig = {};
    // config from `initialize` and `updateConfig` method
    this.status = "notInitialized";
    this.dataStore = null;
    this.completionCache = new CompletionCache();
    // 30s
    this.tryingConnectTimer = null;
    this.tryingConnectTimer = setInterval(async () => {
      if (this.status === "disconnected") {
        this.logger.debug("Trying to connect...");
        await this.healthCheck();
      }
    }, _TabbyAgent.tryConnectInterval);
  }
  static async create(options) {
    const agent = new _TabbyAgent();
    agent.dataStore = options?.dataStore;
    agent.anonymousUsageLogger = await AnonymousUsageLogger.create({ dataStore: options?.dataStore });
    if (userAgentConfig) {
      await userAgentConfig.load();
      agent.userConfig = userAgentConfig.config;
      userAgentConfig.on("updated", async (config2) => {
        agent.userConfig = config2;
        await agent.applyConfig();
      });
      userAgentConfig.watch();
    }
    return agent;
  }
  async applyConfig() {
    this.config = import_deepmerge.default.all([defaultAgentConfig, this.userConfig, this.clientConfig]);
    allLoggers.forEach((logger2) => logger2.level = this.config.logs.level);
    this.anonymousUsageLogger.disabled = this.config.anonymousUsageTracking.disable;
    if (this.config.server.endpoint !== this.auth?.endpoint) {
      this.auth = await Auth.create({ endpoint: this.config.server.endpoint, dataStore: this.dataStore });
      this.auth.on("updated", this.setupApi.bind(this));
    }
    await this.setupApi();
  }
  async setupApi() {
    this.api = new TabbyApi({
      BASE: this.config.server.endpoint.replace(/\/+$/, ""),
      // remove trailing slash
      TOKEN: this.auth?.token
    });
    await this.healthCheck();
  }
  changeStatus(status) {
    if (this.status != status) {
      this.status = status;
      const event = { event: "statusChanged", status };
      this.logger.debug({ event }, "Status changed");
      super.emit("statusChanged", event);
    }
  }
  callApi(api, request2) {
    this.logger.debug({ api: api.name, request: request2 }, "API request");
    const promise = api.call(this.api.v1, request2);
    return cancelable(
      promise.then((response) => {
        this.logger.debug({ api: api.name, response }, "API response");
        this.changeStatus("ready");
        return response;
      }).catch((error) => {
        if (!!error.isCancelled) {
          this.logger.debug({ api: api.name, error }, "API request canceled");
        } else if (error.name === "ApiError" && [401, 403, 405].indexOf(error.status) !== -1) {
          this.logger.debug({ api: api.name, error }, "API unauthorized");
          this.changeStatus("unauthorized");
        } else if (error.name === "ApiError") {
          this.logger.error({ api: api.name, error }, "API error");
          this.changeStatus("disconnected");
        } else {
          this.logger.error({ api: api.name, error }, "API request failed with unknown error");
          this.changeStatus("disconnected");
        }
        throw error;
      }),
      () => {
        promise.cancel();
      }
    );
  }
  healthCheck() {
    return this.callApi(this.api.v1.health, {}).catch(() => {
    });
  }
  createSegments(request2) {
    const maxPrefixLines = request2.maxPrefixLines;
    const maxSuffixLines = request2.maxSuffixLines;
    const prefix = request2.text.slice(0, request2.position);
    const prefixLines = splitLines(prefix);
    const suffix = request2.text.slice(request2.position);
    const suffixLines = splitLines(suffix);
    return {
      prefix: prefixLines.slice(Math.max(prefixLines.length - maxPrefixLines, 0)).join(""),
      suffix: suffixLines.slice(0, maxSuffixLines).join("")
    };
  }
  async initialize(options) {
    if (options.client) {
      allLoggers.forEach((logger2) => logger2.setBindings?.({ client: options.client }));
    }
    if (options.config) {
      this.clientConfig = (0, import_deepmerge.default)(this.clientConfig, options.config);
    }
    await this.applyConfig();
    if (this.status === "unauthorized") {
      const event = { event: "authRequired", server: this.config.server };
      super.emit("authRequired", event);
    }
    await this.anonymousUsageLogger.event("AgentInitialized", {
      client: options.client
    });
    this.logger.debug({ options }, "Initialized");
    return this.status !== "notInitialized";
  }
  async updateConfig(config2) {
    const mergedConfig = (0, import_deepmerge.default)(this.clientConfig, config2);
    if (!(0, import_deep_equal.default)(this.clientConfig, mergedConfig)) {
      const serverUpdated = !(0, import_deep_equal.default)(this.config.server, mergedConfig.server);
      this.clientConfig = mergedConfig;
      await this.applyConfig();
      const event = { event: "configUpdated", config: this.config };
      this.logger.debug({ event }, "Config updated");
      super.emit("configUpdated", event);
      if (serverUpdated && this.status === "unauthorized") {
        const event2 = { event: "authRequired", server: this.config.server };
        super.emit("authRequired", event2);
      }
    }
    return true;
  }
  getConfig() {
    return this.config;
  }
  getStatus() {
    return this.status;
  }
  requestAuthUrl() {
    if (this.status === "notInitialized") {
      return cancelable(Promise.reject("Agent is not initialized"), () => {
      });
    }
    return new CancelablePromise(async (resolve4, reject, onCancel) => {
      let request2;
      onCancel(() => {
        request2?.cancel();
      });
      await this.healthCheck();
      if (onCancel.isCancelled)
        return;
      if (this.status === "unauthorized") {
        request2 = this.auth.requestAuthUrl();
        resolve4(request2);
      }
      resolve4(null);
    });
  }
  waitForAuthToken(code) {
    if (this.status === "notInitialized") {
      return cancelable(Promise.reject("Agent is not initialized"), () => {
      });
    }
    const polling = this.auth.pollingToken(code);
    return cancelable(
      polling.then(() => {
        return this.setupApi();
      }),
      () => {
        polling.cancel();
      }
    );
  }
  getCompletions(request2) {
    if (this.status === "notInitialized") {
      return cancelable(Promise.reject("Agent is not initialized"), () => {
      });
    }
    if (this.completionCache.has(request2)) {
      this.logger.debug({ request: request2 }, "Completion cache hit");
      return new CancelablePromise((resolve4) => {
        resolve4(this.completionCache.get(request2));
      });
    }
    const segments = this.createSegments(request2);
    if (isBlank(segments.prefix)) {
      this.logger.debug("Segment prefix is blank, returning empty completion response");
      return new CancelablePromise((resolve4) => {
        resolve4({
          id: "agent-" + v4_default(),
          choices: []
        });
      });
    }
    const promise = this.callApi(this.api.v1.completion, {
      language: request2.language,
      segments,
      user: this.auth?.user
    });
    return cancelable(
      promise.then((response) => {
        this.completionCache.set(request2, response);
        return response;
      }).then((response) => {
        return postprocess(request2, response);
      }),
      () => {
        promise.cancel();
      }
    );
  }
  postEvent(request2) {
    if (this.status === "notInitialized") {
      return cancelable(Promise.reject("Agent is not initialized"), () => {
      });
    }
    return this.callApi(this.api.v1.event, request2);
  }
};
var TabbyAgent = _TabbyAgent;
TabbyAgent.tryConnectInterval = 1e3 * 30;

// src/Agent.ts
init_global();
init_dirname();
init_filename();
init_buffer2();
init_process2();
var agentEventNames = ["statusChanged", "configUpdated", "authRequired"];
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

export { CancelablePromise, TabbyAgent, agentEventNames };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map