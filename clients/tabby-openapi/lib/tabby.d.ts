/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


import { ChatCompletionRequest, ChatCompletionChunk, ChatCompletionRequestMessage } from './openai';

export interface paths {
    "/v1/chat/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["chat_completions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["completion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1beta/server_setting": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Choice: {
            /** Format: int32 */
            index: number;
            text: string;
        };
        CodeSearchDocument: {
            body: string;
            filepath: string;
            git_url: string;
            language: string;
            start_line: number;
        };
        CodeSearchHit: {
            scores: components["schemas"]["CodeSearchScores"];
            doc: components["schemas"]["CodeSearchDocument"];
        };
        CodeSearchQuery: {
            git_url: string;
            filepath?: string | null;
            language?: string | null;
            content: string;
        };
        CodeSearchScores: {
            /**
             * Format: float
             * @description Reciprocal rank fusion score: https://www.elastic.co/guide/en/elasticsearch/reference/current/rrf.html
             */
            rrf: number;
            /** Format: float */
            bm25: number;
            /** Format: float */
            embedding: number;
        };
        /** @example {
         *       "language": "python",
         *       "segments": {
         *         "prefix": "def fib(n):\n    ",
         *         "suffix": "\n        return fib(n - 1) + fib(n - 2)"
         *       }
         *     } */
        CompletionRequest: {
            /**
             * @description Language identifier, full list is maintained at
             *     https://code.visualstudio.com/docs/languages/identifiers
             * @example python
             */
            language?: string | null;
            segments?: components["schemas"]["Segments"] | null;
            /** @description A unique identifier representing your end-user, which can help Tabby to monitor & generating
             *     reports. */
            user?: string | null;
            debug_options?: components["schemas"]["DebugOptions"] | null;
            /**
             * Format: float
             * @description The temperature parameter for the model, used to tune variance and "creativity" of the model output
             */
            temperature?: number | null;
            /**
             * Format: int64
             * @description The seed used for randomly selecting tokens
             */
            seed?: number | null;
        };
        /** @example {
         *       "choices": [
         *         {
         *           "index": 0,
         *           "text": "string"
         *         }
         *       ],
         *       "id": "string"
         *     } */
        CompletionResponse: {
            id: string;
            choices: components["schemas"]["Choice"][];
            debug_data?: components["schemas"]["DebugData"] | null;
        };
        DebugData: {
            snippets?: components["schemas"]["Snippet"][] | null;
            prompt?: string | null;
        };
        DebugOptions: {
            /** @description When `raw_prompt` is specified, it will be passed directly to the inference engine for completion. `segments` field in `CompletionRequest` will be ignored.
             *
             *     This is useful for certain requests that aim to test the tabby's e2e quality. */
            raw_prompt?: string | null;
            /** @description When true, returns `snippets` in `debug_data`. */
            return_snippets?: boolean;
            /** @description When true, returns `prompt` in `debug_data`. */
            return_prompt?: boolean;
            /** @description When true, disable retrieval augmented code completion. */
            disable_retrieval_augmented_code_completion?: boolean;
        };
        /** @description A snippet of declaration code that is relevant to the current completion request. */
        Declaration: {
            /** @description Filepath of the file where the snippet is from.
             *     - When the file belongs to the same workspace as the current file,
             *     this is a relative filepath, use the same rule as [Segments::filepath].
             *     - When the file located outside the workspace, such as in a dependency package,
             *     this is a file URI with an absolute filepath. */
            filepath: string;
            /** @description Body of the snippet. */
            body: string;
        };
        DocSearchDocument: {
            title: string;
            link: string;
            snippet: string;
        };
        DocSearchHit: {
            /** Format: float */
            score: number;
            doc: components["schemas"]["DocSearchDocument"];
        };
        HealthState: {
            model?: string | null;
            chat_model?: string | null;
            chat_device?: string | null;
            device: string;
            arch: string;
            cpu_info: string;
            cpu_count: number;
            cuda_devices: string[];
            version: components["schemas"]["Version"];
            webserver?: boolean | null;
        };
        LogEventRequest: {
            /**
             * @description Event type, should be `view`, `select` or `dismiss`.
             * @example view
             */
            type: string;
            completion_id: string;
            /** Format: int32 */
            choice_index: number;
            view_id?: string | null;
            /** Format: int32 */
            elapsed?: number | null;
        };
        Segments: {
            /** @description Content that appears before the cursor in the editor window. */
            prefix: string;
            /** @description Content that appears after the cursor in the editor window. */
            suffix?: string | null;
            /** @description The relative path of the file that is being edited.
             *     - When [Segments::git_url] is set, this is the path of the file in the git repository.
             *     - When [Segments::git_url] is empty, this is the path of the file in the workspace. */
            filepath?: string | null;
            /** @description The remote URL of the current git repository.
             *     Leave this empty if the file is not in a git repository,
             *     or the git repository does not have a remote URL. */
            git_url?: string | null;
            /** @description The relevant declaration code snippets provided by the editor's LSP,
             *     contain declarations of symbols extracted from [Segments::prefix]. */
            declarations?: components["schemas"]["Declaration"][] | null;
            /** @description The relevant code snippets extracted from recently edited files.
             *     These snippets are selected from candidates found within code chunks
             *     based on the edited location.
             *     The current editing file is excluded from the search candidates.
             *
             *     When provided alongside [Segments::declarations], the snippets have
             *     already been deduplicated to ensure no duplication with entries
             *     in [Segments::declarations].
             *
             *     Sorted in descending order of [Snippet::score]. */
            relevant_snippets_from_changed_files?: components["schemas"]["Snippet"][] | null;
            /** @description The relevant code snippets extracted from recently opened files. These snippets are selected from candidates found within code chunks based on the last visited location. Current Active file is excluded from the search candidates. When provided with [Segments::relevant_snippets_from_changed_files], the snippets have already been deduplicated to ensure no duplication with entries in [Segments::relevant_snippets_from_changed_files]. */
            relevant_snippets_from_recently_opened_files?: components["schemas"]["Snippet"][] | null;
            /** @description Clipboard content when requesting code completion. */
            clipboard?: string | null;
        };
        ServerSetting: {
            disable_client_side_telemetry: boolean;
        };
        Snippet: {
            filepath: string;
            body: string;
            /** Format: float */
            score: number;
        };
        Version: {
            build_date: string;
            build_timestamp: string;
            git_sha: string;
            git_describe: string;
        };
        ChatCompletionRequest: ChatCompletionRequest;
        ChatCompletionChunk: ChatCompletionChunk;
        ChatCompletionRequestMessage: ChatCompletionRequestMessage;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    chat_completions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatCompletionRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": components["schemas"]["ChatCompletionChunk"];
                };
            };
            /** @description When chat model is not specified, the endpoint returns 405 Method Not Allowed */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description When the prompt is malformed, the endpoint returns 422 Unprocessable Entity */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    completion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CompletionRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompletionResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    event: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LogEventRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthState"];
                };
            };
        };
    };
    config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerSetting"];
                };
            };
        };
    };
}
