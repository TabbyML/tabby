/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


import { ChatCompletionRequest, ChatCompletionChunk, ChatCompletionRequestMessage } from './openai';

export interface paths {
    "/v1/chat/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["chat_completions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["completion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1beta/server_setting": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Choice: {
            /** Format: int32 */
            index: number;
            text: string;
            edit_range?: components["schemas"]["EditRange"] | null;
        };
        /** @example {
         *       "language": "python",
         *       "segments": {
         *         "prefix": "def fib(n):\n    ",
         *         "suffix": "\n        return fib(n - 1) + fib(n - 2)"
         *       }
         *     } */
        CompletionRequest: {
            /**
             * @description Language identifier, full list is maintained at
             *     https://code.visualstudio.com/docs/languages/identifiers
             * @example python
             */
            language?: string | null;
            segments?: components["schemas"]["Segments"] | null;
            /** @description A unique identifier representing your end-user, which can help Tabby to monitor & generating
             *     reports. */
            user?: string | null;
            debug_options?: components["schemas"]["DebugOptions"] | null;
            /**
             * Format: float
             * @description The temperature parameter for the model, used to tune variance and "creativity" of the model output
             */
            temperature?: number | null;
            /**
             * Format: int64
             * @description The seed used for randomly selecting tokens
             */
            seed?: number | null;
            /** @description The mode for completion. Use 'standard' for normal code completions or 'next_edit_suggestion'
             *     to predict the next edit the user will make. */
            mode?: string;
        };
        /** @example {
         *       "choices": [
         *         {
         *           "index": 0,
         *           "text": "string"
         *         }
         *       ],
         *       "id": "string"
         *     } */
        CompletionResponse: {
            id: string;
            choices: components["schemas"]["Choice"][];
            debug_data?: components["schemas"]["DebugData"] | null;
        };
        /** @description Current version of the code after all edits */
        CurrentVersion: {
            /** @description Current content after all edits */
            content: string;
            cursor_position: components["schemas"]["CursorPosition"];
        };
        /** @description Cursor position in the current version */
        CursorPosition: {
            /**
             * Format: int32
             * @description Line number (0-based)
             */
            line: number;
            /**
             * Format: int32
             * @description Character position within the line (0-based)
             */
            character: number;
        };
        DebugData: {
            snippets?: components["schemas"]["Snippet"][] | null;
            prompt?: string | null;
        };
        DebugOptions: {
            /** @description When `raw_prompt` is specified, it will be passed directly to the inference engine for completion. `segments` field in `CompletionRequest` will be ignored.
             *
             *     This is useful for certain requests that aim to test the tabby's e2e quality. */
            raw_prompt?: string | null;
            /** @description When true, returns `snippets` in `debug_data`. */
            return_snippets?: boolean;
            /** @description When true, returns `prompt` in `debug_data`. */
            return_prompt?: boolean;
            /** @description When true, disable retrieval augmented code completion. */
            disable_retrieval_augmented_code_completion?: boolean;
        };
        /** @description A snippet of declaration code that is relevant to the current completion request. */
        Declaration: {
            /** @description Filepath of the file where the snippet is from.
             *     - When the file belongs to the same workspace as the current file,
             *     this is a relative filepath, use the same rule as [Segments::filepath].
             *     - When the file located outside the workspace, such as in a dependency package,
             *     this is a file URI with an absolute filepath. */
            filepath: string;
            /** @description Body of the snippet. */
            body: string;
        };
        /** @description Contains information about edit history for next edit suggestion mode */
        EditHistory: {
            /** @description Original code content before edits */
            original_code: string;
            /** @description Unified git-style diff of all edits made to the file */
            edits_diff: string;
            current_version: components["schemas"]["CurrentVersion"];
        };
        /** @description Range information for next edit suggestion mode */
        EditRange: {
            /**
             * Format: int32
             * @description Start line of the edit (0-based)
             */
            start_line: number;
            /**
             * Format: int32
             * @description Start character position within the line (0-based)
             */
            start_character: number;
            /**
             * Format: int32
             * @description End line of the edit (0-based)
             */
            end_line: number;
            /**
             * Format: int32
             * @description End character position within the line (0-based)
             */
            end_character: number;
        };
        HealthState: {
            model?: string | null;
            chat_model?: string | null;
            chat_device?: string | null;
            device: string;
            arch: string;
            cpu_info: string;
            cpu_count: number;
            cuda_devices: string[];
            version: components["schemas"]["Version"];
            webserver?: boolean | null;
        };
        LogEventRequest: {
            /**
             * @description Event type, should be `view`, `select` or `dismiss`.
             * @example view
             */
            type: string;
            completion_id: string;
            /** Format: int32 */
            choice_index: number;
            view_id?: string | null;
            /** Format: int32 */
            elapsed?: number | null;
        };
        Segments: {
            /** @description Content that appears before the cursor in the editor window. */
            prefix: string;
            /** @description Content that appears after the cursor in the editor window. */
            suffix?: string | null;
            /** @description The relative path of the file that is being edited.
             *     - When [Segments::git_url] is set, this is the path of the file in the git repository.
             *     - When [Segments::git_url] is empty, this is the path of the file in the workspace. */
            filepath?: string | null;
            /** @description The remote URL of the current git repository.
             *     Leave this empty if the file is not in a git repository,
             *     or the git repository does not have a remote URL. */
            git_url?: string | null;
            /** @description The relevant declaration code snippets provided by the editor's LSP,
             *     contain declarations of symbols extracted from [Segments::prefix]. */
            declarations?: components["schemas"]["Declaration"][] | null;
            /** @description The relevant code snippets extracted from recently edited files.
             *     These snippets are selected from candidates found within code chunks
             *     based on the edited location.
             *     The current editing file is excluded from the search candidates.
             *
             *     When provided alongside [Segments::declarations], the snippets have
             *     already been deduplicated to ensure no duplication with entries
             *     in [Segments::declarations].
             *
             *     Sorted in descending order of [Snippet::score]. */
            relevant_snippets_from_changed_files?: components["schemas"]["Snippet"][] | null;
            /** @description The relevant code snippets extracted from recently opened files.
             *     These snippets are selected from candidates found within code chunks
             *     based on the last visited location.
             *
             *     Current Active file is excluded from the search candidates.
             *     When provided with [Segments::relevant_snippets_from_changed_files], the snippets have
             *     already been deduplicated to ensure no duplication with entries
             *     in [Segments::relevant_snippets_from_changed_files]. */
            relevant_snippets_from_recently_opened_files?: components["schemas"]["Snippet"][] | null;
            /** @description Clipboard content when requesting code completion. */
            clipboard?: string | null;
            edit_history?: components["schemas"]["EditHistory"] | null;
        };
        ServerSetting: {
            disable_client_side_telemetry: boolean;
        };
        Snippet: {
            filepath: string;
            body: string;
            /** Format: float */
            score: number;
        };
        Version: {
            build_date: string;
            build_timestamp: string;
            git_sha: string;
            git_describe: string;
        };
        ChatCompletionRequest: ChatCompletionRequest;
        ChatCompletionChunk: ChatCompletionChunk;
        ChatCompletionRequestMessage: ChatCompletionRequestMessage;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    chat_completions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatCompletionRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": components["schemas"]["ChatCompletionChunk"];
                };
            };
            /** @description When chat model is not specified, the endpoint returns 405 Method Not Allowed */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description When the prompt is malformed, the endpoint returns 422 Unprocessable Entity */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    completion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CompletionRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompletionResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    event: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LogEventRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthState"];
                };
            };
        };
    };
    config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerSetting"];
                };
            };
        };
    };
}
