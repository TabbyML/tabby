{"language": "csharp", "segments": {"prefix": "using LassoProcessManager.Models.Rules;\nusing Newtonsoft.Json;\nusing ProcessManager.Models.Configs;\nusing System.Reflection;\n\nnamespace ProcessManager.Providers\n{\n    public class ConfigProvider : IConfigProvider\n    {\n        private const string ConfigFileName = \"Config.json\";\n        private ManagerConfig managerConfig;\n\n        private ILogProvider LogProvider { get; set; }\n\n        public ConfigProvider(ILogProvider logProvider)\n            => this.LogProvider = logProvider;\n\n        public ManagerConfig GetManagerConfig()\n        {\n            if (managerConfig != null)\n                return managerConfig;\n\n            string configPath = GetConfigFilePath();\n            try\n            {\n                managerConfig = JsonConvert.DeserializeObject<ManagerConfig>(File.ReadAllText(GetConfigFilePath()));\n                return managerConfig;\n            }\n            catch\n            {\n                LogProvider.Log($\"Failed to load config at '{configPath}'.\");\n            }\n\n            return null;\n        }\n\n        public List<BaseRule> GetRules()\n        {\n            List<BaseRule> rules = new List<BaseRule>();\n            rules.AddRange(managerConfig.ProcessRules);\n            rules.AddRange(managerConfig.FolderRules);\n\n            return rules;\n        }\n\n        public Dictionary<string, ", "suffix": "\n            Dictionary<string, LassoProfile> lassoProfiles = new Dictionary<string, LassoProfile>();\n\n            // Load lasso profiles\n            foreach (var profile in managerConfig.Profiles)\n            {\n                if (!lassoProfiles.ContainsKey(profile.Name))\n                {\n                    lassoProfiles.Add(profile.Name, profile);\n                }\n            }\n\n            return lassoProfiles;\n        }\n\n        private string GetConfigFilePath()\n            => Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), ConfigFileName);\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// ProcessManager/Providers/IConfigProvider.cs\n//         ManagerConfig GetManagerConfig();\n//         /// <summary>\n//         /// Geth the list of lasso rules.\n//         /// </summary>\n//         /// <returns></returns>\n//         List<BaseRule> GetRules();\n//         Dictionary<string, LassoProfile> GetLassoProfiles();\n//     }\n// }\n\n// the below code fragment can be found in:\n// ProcessManager/Models/Configs/ManagerConfig.cs\n//         public ProcessRule[] ProcessRules { get; set; }\n//         /// <summary>\n//         /// List of folders rules.\n//         /// </summary>\n//         public FolderRule[] FolderRules { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// ProcessManager/Managers/LassoManager.cs\n//         public void Dispose()\n//         {\n//             if (processStartEvent != null) \n//             {\n//                 processStartEvent.EventArrived -= ProcessStartEvent_EventArrived;\n//                 processStartEvent.Dispose();\n//                 processStartEvent = null;\n//             }\n//         }\n//         public bool Setup()\n\n// the below code fragment can be found in:\n// ProcessManager/Managers/LassoManager.cs\n//         {\n//             int failCount = 0;\n//             Dictionary<string, int> successCount = new Dictionary<string, int>();\n//             foreach (var process in Process.GetProcesses())\n//             {\n//                 LassoProfile lassoProfile = GetLassoProfileForProcess(process);\n//                 bool success = TrySetProcessProfile(process, lassoProfile, out string profileName);\n//                 if (success)\n//                 {\n//                     if (!successCount.ContainsKey(profileName))\n\n", "list": [{"retrieved_chunk": "        ManagerConfig GetManagerConfig();\n        /// <summary>\n        /// Geth the list of lasso rules.\n        /// </summary>\n        /// <returns></returns>\n        List<BaseRule> GetRules();\n        Dictionary<string, LassoProfile> GetLassoProfiles();\n    }\n}", "filename": "ProcessManager/Providers/IConfigProvider.cs", "score": 22.799994275269317}, {"retrieved_chunk": "        public ProcessRule[] ProcessRules { get; set; }\n        /// <summary>\n        /// List of folders rules.\n        /// </summary>\n        public FolderRule[] FolderRules { get; set; }\n    }\n}", "filename": "ProcessManager/Models/Configs/ManagerConfig.cs", "score": 20.728193497923062}, {"retrieved_chunk": "        public void Dispose()\n        {\n            if (processStartEvent != null) \n            {\n                processStartEvent.EventArrived -= ProcessStartEvent_EventArrived;\n                processStartEvent.Dispose();\n                processStartEvent = null;\n            }\n        }\n        public bool Setup()", "filename": "ProcessManager/Managers/LassoManager.cs", "score": 14.506247294243275}, {"retrieved_chunk": "        {\n            int failCount = 0;\n            Dictionary<string, int> successCount = new Dictionary<string, int>();\n            foreach (var process in Process.GetProcesses())\n            {\n                LassoProfile lassoProfile = GetLassoProfileForProcess(process);\n                bool success = TrySetProcessProfile(process, lassoProfile, out string profileName);\n                if (success)\n                {\n                    if (!successCount.ContainsKey(profileName))", "filename": "ProcessManager/Managers/LassoManager.cs", "score": 11.789149115850975}]}}, "groundtruth": "LassoProfile> GetLassoProfiles()\n        {", "metadata": {"task_id": "project_cc_csharp/27", "repository": "kenshinakh1-LassoProcessManager-bcc481f", "file": "ProcessManager/Providers/ConfigProvider.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 45, "right_context_start_lineno": 47}}
{"language": "csharp", "segments": {"prefix": "//#define PRINT_DEBUG\n\nusing System;\nusing System.IO;\nusing Godot;\nusing Mono.Unix;\nusing Directory = System.IO.Directory;\nusing Environment = System.Environment;\nusing File = System.IO.File;\nusing Path = System.IO.Path;\n\nnamespace GodotLauncher\n{\n\tpublic class DataPaths\n\t{\n\t\tstatic string AppDataPath => Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);\n\t\tstatic string BasePath => Path.Combine(AppDataPath, \"ReadyToLaunch\");\n\t\tpublic static string platformOverride;\n\n\n\t\tpublic static string SanitizeProjectPath(string path)\n\t\t{\n\t\t\tif (File.Exists(path))\n\t\t\t{\n\t\t\t\tpath = new FileInfo(path).DirectoryName;\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\n\t\tpublic static void EnsureProjectExists(string path)\n\t\t{\n\t\t\tvar filePath = Path.Combine(path, \"project.godot\");\n\t\t\tif (!File.Exists(filePath)) File.WriteAllText(filePath, \"\");\n\t\t}\n\n\n\t\tpublic static string GetExecutablePath(InstallerEntryData installerEntryData)\n\t\t{\n\t\t\tstring platformName = GetPlatformName();\n\t\t\tstring path = Path.Combine(BasePath, platformName, installerEntryData.BuildType, installerEntryData.version);\n\n\t\t\tpath = Path.Combine(path, installerEntryData.ExecutableName);\n\n\t\t\treturn path;\n\t\t}\n\n\n\t\tpublic static string GetPlatformName()\n\t\t{\n\t\t\tif (!string.IsNullOrEmpty(platformOverride)) return platformOverride;\n\t\t\treturn OS.GetName();\n\t\t}\n\n\n\t\tpublic static void WriteFile(string fileName, byte[] data)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Writing: \" + path);\n\t\t\t#endif\n\t\t\tFile.WriteAllBytes(path, data);\n\t\t}\n\n\n\t\tpublic static void WriteFile(string fileName, string data)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Writing: \" + path);\n\t\t\t#endif\n\t\t\tFile.WriteAllText(path, data);\n\t\t}\n\n\n\t\tpublic static string ReadFile(string fileName, string defaultData = null)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\tif (File.Exists(path))\n\t\t\t{\n\t\t\t\t#if PRINT_DEBUG\n\t\t\t\tGD.Print(\"Reading: \" + path);\n\t\t\t\t#endif\n\t\t\t\treturn File.ReadAllText(path);\n\t\t\t}\n\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"File not found: \" + path);\n\t\t\t#endif\n\t\t\treturn defaultData;\n\t\t}\n\n\n\t\tpublic static bool ExecutableExists(", "suffix": "\n\t\t\tstring path = GetExecutablePath(installerEntryData);\n\t\t\tbool exists = File.Exists(path);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Checking if path exists: \" + path + \" exists=\" + exists);\n\t\t\t#endif\n\t\t\treturn exists;\n\t\t}\n\n\n\t\tpublic static void ExtractArchive(string fileName, InstallerEntryData installerEntryData)\n\t\t{\n\t\t\tstring source = Path.Combine(BasePath, fileName);\n\t\t\tstring dest = Path.Combine(BasePath, GetPlatformName(), installerEntryData.BuildType, installerEntryData.version);\n\t\t\tif (!Directory.Exists(dest)) System.IO.Compression.ZipFile.ExtractToDirectory(source, dest);\n\t\t\tFile.Delete(source);\n\t\t}\n\n\n\t\tpublic static void DeleteVersion(string version, string buildType)\n\t\t{\n\t\t\tDirectory.Delete(Path.Combine(BasePath, GetPlatformName(), buildType, version), true);\n\t\t}\n\n\n\t\tpublic static void LaunchGodot(InstallerEntryData installerEntryData, string arguments = \"\")\n\t\t{\n\t\t\tstring path = GetExecutablePath(installerEntryData);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Launching: \" + path);\n\t\t\t#endif\n\t\t\tif (!OS.GetName().Equals(\"Windows\"))\n\t\t\t{\n\t\t\t\tvar unixFile = new UnixFileInfo(path);\n\t\t\t\tunixFile.FileAccessPermissions |= FileAccessPermissions.UserExecute\n\t\t\t\t\t\t\t\t\t\t\t\t  | FileAccessPermissions.GroupExecute\n\t\t\t\t\t\t\t\t\t\t\t\t  | FileAccessPermissions.OtherExecute;\n\t\t\t}\n\n\t\t\tusing var process = new System.Diagnostics.Process();\n\t\t\tprocess.StartInfo.FileName = path;\n\t\t\tprocess.StartInfo.WorkingDirectory = BasePath;\n\t\t\tprocess.StartInfo.Arguments = arguments;\n\t\t\tprocess.Start();\n\t\t}\n\n\n\t\tpublic static void CreateInstallationDirectory()\n\t\t{\n\t\t\tMoveOldInstallationDirectory(\"ReadyForLaunch\");\n\t\t\tMoveOldInstallationDirectory(\"GodotLauncher\");\n\t\t\tDirectory.CreateDirectory(BasePath);\n\t\t}\n\n\n\t\tstatic void MoveOldInstallationDirectory(string oldName)\n\t\t{\n\t\t\tvar oldPath = Path.Combine(AppDataPath, oldName);\n\t\t\tif (!Directory.Exists(oldPath) || Directory.Exists(BasePath))\n\t\t\t\treturn;\n\t\t\tDirectory.Move(oldPath, BasePath);\n\t\t}\n\n\n\t\tpublic static void ShowInFolder(string filePath)\n\t\t{\n\t\t\tfilePath = \"\\\"\" + filePath + \"\\\"\";\n\t\t\tswitch (OS.GetName())\n\t\t\t{\n\t\t\t\tcase \"Linux\":\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"xdg-open\", filePath);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Windows\":\n\t\t\t\t\tstring argument = \"/select, \" + filePath;\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"explorer.exe\", argument);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"macOS\":\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"open\", filePath);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Exception(\"OS not defined! \" + OS.GetName());\n\t\t\t}\n\t\t}\n\t}\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// godot-project/Scripts/DataManagement/LauncherManager.cs\n// \t\t\t\t\tBuildProjectsList();\n// \t\t\t\t\tif (entry.version.StartsWith(\"1.\") || entry.version.StartsWith(\"2.\"))\n// \t\t\t\t\t{\n// \t\t\t\t\t\tLaunchInstaller(entry);\n// \t\t\t\t\t\treturn;\n// \t\t\t\t\t}\n// \t\t\t\t\tvar additionalFlags = run ? \"\" : \"-e\";\n// \t\t\t\t\tDataPaths.LaunchGodot(entry, additionalFlags + \" --path \\\"\" + path + \"\\\"\");\n// \t\t\t\t\t//OS.WindowMinimized = config.minimizeOnLaunch;\n// \t\t\t\t\treturn;\n\n// the below code fragment can be found in:\n// godot-project/Scripts/DataManagement/FileHelper.cs\n// \t{\n// \t\tGD.Print(\"*********** Delete file!\");\n// \t}\n// \tprivate static void CreateDirectoryForUser(string directory)\n// \t{\n// \t\tvar path = Path.Combine(BasePath, directory);\n// \t\tif (!DirAccess.DirExistsAbsolute(path))\n// \t\t{\n// \t\t\tDirAccess.MakeDirRecursiveAbsolute(path);\n// \t\t}\n\n// the below code fragment can be found in:\n// godot-project/Scripts/DataManagement/LauncherManager.cs\n// \t\t\t\ttimestamp = DateTime.UtcNow.Ticks\n// \t\t\t};\n// \t\t\tprojectEntries.Add(project);\n// \t\t\tLaunchProject(directoryPath, false);\n// \t\t}\n// \t\tvoid _onFilesDropped(string[] files)\n// \t\t{\n// \t\t\tfor (int i = 0; i < files.Length; i++)\n// \t\t\t{\n// \t\t\t\tstring path = DataPaths.SanitizeProjectPath(files[i]);\n\n// the below code fragment can be found in:\n// godot-project/Scripts/DataManagement/FileHelper.cs\n// \t}\n// \tpublic static void WriteUserText(string path, string json)\n// \t{\n// \t\tWriteAllText(PathCombine(BasePath, path), json);\n// \t}\n// \tpublic static bool UserFileExists(string path)\n// \t{\n// \t\treturn FileExists(PathCombine(BasePath, path));\n// \t}\n// \tpublic static void Delete(string path)\n\n// the below code fragment can be found in:\n// godot-project/Scripts/DataManagement/LauncherManager.cs\n// \t\t\t\tInstallVersion(versionKey);\n// \t\t\t}\n// \t\t\tSaveProjectsList();\n// \t\t\tBuildProjectsList();\n// \t\t}\n// \t\tvoid SaveConfig()\n// \t\t{\n// \t\t\tvar json = DataBuilder.GetConfigJson(config);\n// \t\t\tDataPaths.WriteFile(ConfigFileName, json);\n// \t\t}\n\n", "list": [{"retrieved_chunk": "\t\t\t\t\tBuildProjectsList();\n\t\t\t\t\tif (entry.version.StartsWith(\"1.\") || entry.version.StartsWith(\"2.\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tLaunchInstaller(entry);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar additionalFlags = run ? \"\" : \"-e\";\n\t\t\t\t\tDataPaths.LaunchGodot(entry, additionalFlags + \" --path \\\"\" + path + \"\\\"\");\n\t\t\t\t\t//OS.WindowMinimized = config.minimizeOnLaunch;\n\t\t\t\t\treturn;", "filename": "godot-project/Scripts/DataManagement/LauncherManager.cs", "score": 29.431886867394642}, {"retrieved_chunk": "\t{\n\t\tGD.Print(\"*********** Delete file!\");\n\t}\n\tprivate static void CreateDirectoryForUser(string directory)\n\t{\n\t\tvar path = Path.Combine(BasePath, directory);\n\t\tif (!DirAccess.DirExistsAbsolute(path))\n\t\t{\n\t\t\tDirAccess.MakeDirRecursiveAbsolute(path);\n\t\t}", "filename": "godot-project/Scripts/DataManagement/FileHelper.cs", "score": 16.13486385582849}, {"retrieved_chunk": "\t\t\t\ttimestamp = DateTime.UtcNow.Ticks\n\t\t\t};\n\t\t\tprojectEntries.Add(project);\n\t\t\tLaunchProject(directoryPath, false);\n\t\t}\n\t\tvoid _onFilesDropped(string[] files)\n\t\t{\n\t\t\tfor (int i = 0; i < files.Length; i++)\n\t\t\t{\n\t\t\t\tstring path = DataPaths.SanitizeProjectPath(files[i]);", "filename": "godot-project/Scripts/DataManagement/LauncherManager.cs", "score": 14.892200276853623}, {"retrieved_chunk": "\t}\n\tpublic static void WriteUserText(string path, string json)\n\t{\n\t\tWriteAllText(PathCombine(BasePath, path), json);\n\t}\n\tpublic static bool UserFileExists(string path)\n\t{\n\t\treturn FileExists(PathCombine(BasePath, path));\n\t}\n\tpublic static void Delete(string path)", "filename": "godot-project/Scripts/DataManagement/FileHelper.cs", "score": 13.921454071982678}, {"retrieved_chunk": "\t\t\t\tInstallVersion(versionKey);\n\t\t\t}\n\t\t\tSaveProjectsList();\n\t\t\tBuildProjectsList();\n\t\t}\n\t\tvoid SaveConfig()\n\t\t{\n\t\t\tvar json = DataBuilder.GetConfigJson(config);\n\t\t\tDataPaths.WriteFile(ConfigFileName, json);\n\t\t}", "filename": "godot-project/Scripts/DataManagement/LauncherManager.cs", "score": 13.535088476589515}]}}, "groundtruth": "InstallerEntryData installerEntryData)\n\t\t{", "metadata": {"task_id": "project_cc_csharp/55", "repository": "NathanWarden-ready-to-launch-58eba6d", "file": "godot-project/Scripts/DataManagement/DataPaths.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 94, "right_context_start_lineno": 96}}
{"language": "csharp", "segments": {"prefix": "using Newtonsoft.Json;\n\nnamespace DotNetDevBadgeWeb.Model\n{\n    public class UserSummary\n    {\n        [", "suffix": " get; set; }\n\n        [JsonProperty(\"likes_received\")]\n        public int LikesReceived { get; set; }\n\n        [JsonProperty(\"topics_entered\")]\n        public int TopicsEntered { get; set; }\n\n        [JsonProperty(\"posts_read_count\")]\n        public int PostsReadCount { get; set; }\n\n        [JsonProperty(\"days_visited\")]\n        public int DaysVisited { get; set; }\n\n        [JsonProperty(\"topic_count\")]\n        public int TopicCount { get; set; }\n\n        [JsonProperty(\"post_count\")]\n        public int PostCount { get; set; }\n\n        [JsonProperty(\"time_read\")]\n        public int TimeRead { get; set; }\n\n        [JsonProperty(\"recent_time_read\")]\n        public int RecentTimeRead { get; set; }\n\n        [JsonProperty(\"bookmark_count\")]\n        public int BookmarkCount { get; set; }\n\n        [JsonProperty(\"can_see_summary_stats\")]\n        public bool CanSeeSummaryStats { get; set; }\n\n        [JsonProperty(\"solved_count\")]\n        public int SolvedCount { get; set; }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// src/dotnetdev-badge/dotnetdev-badge.web/Core/Provider/ForumDataProvider.cs\n//         private const string BADGE_URL = \"https://forum.dotnetdev.kr/user-badges/{0}.json?grouped=true\";\n//         private const string SUMMARY_URL = \"https://forum.dotnetdev.kr/u/{0}/summary.json\";\n//         private readonly IHttpClientFactory _httpClientFactory;\n//         public ForumDataProvider(IHttpClientFactory httpClientFactory)\n//         {\n//             _httpClientFactory = httpClientFactory;\n//         }\n//         private async Task<string> GetResponseStringAsync(Uri uri, CancellationToken token)\n//         {\n//             using HttpClient client = _httpClientFactory.CreateClient();\n\n// the below code fragment can be found in:\n// src/dotnetdev-badge/dotnetdev-badge.web/Model/User.cs\n//         public string Username { get; set; }\n//         [JsonProperty(\"name\")]\n//         public string Name { get; set; }\n//         [JsonProperty(\"avatar_template\")]\n//         public string AvatarTemplate { get; set; }\n//         [JsonProperty(\"flair_name\")]\n//         public object FlairName { get; set; }\n//         [JsonProperty(\"trust_level\")]\n//         public int TrustLevel { get; set; }\n//         [JsonProperty(\"admin\")]\n\n// the below code fragment can be found in:\n// src/dotnetdev-badge/dotnetdev-badge.web/Interfaces/IProvider.cs\n// \ufeffusing DotNetDevBadgeWeb.Model;\n// namespace DotNetDevBadgeWeb.Interfaces\n// {\n//     public interface IProvider\n//     {\n//         Task<(UserSummary summary, User user)> GetUserInfoAsync(string id, CancellationToken token);\n//         Task<(byte[] avatar, UserSummary summary, User user)> GetUserInfoWithAvatarAsync(string id, CancellationToken token);\n//         Task<(int gold, int silver, int bronze)> GetBadgeCountAsync(string id, CancellationToken token);\n//     }\n// }\n\n// the below code fragment can be found in:\n// src/dotnetdev-badge/dotnetdev-badge.web/Core/Badge/BadgeCreatorV1.cs\n//         private const float TEXT_MAX_WIDTH = LOGO_X - TEXT_X - 10;\n//         private readonly IProvider _forumProvider;\n//         private readonly IMeasureTextV1 _measureTextV1;\n//         public BadgeCreatorV1(IProvider forumProvider, IMeasureTextV1 measureTextV1)\n//         {\n//             _forumProvider = forumProvider;\n//             _measureTextV1 = measureTextV1;\n//         }\n//         public async Task<string> GetSmallBadge(string id, ETheme theme, CancellationToken token)\n//         {\n\n// the below code fragment can be found in:\n// src/dotnetdev-badge/dotnetdev-badge.web/Endpoints/Badge/BadgeEndpoints.cs\n//         {\n//             app.UseMiddleware<BadgeIdValidatorMiddleware>();\n//             app.MapBadgeEndpointsV1();\n//             return app;\n//         }\n//         internal static WebApplication MapBadgeEndpointsV1(this WebApplication app)\n//         {\n//             app.MapGet(\"/api/v1/badge/small\", async (HttpContext context, [FromQuery] string id, [FromQuery] ETheme? theme, IBadgeV1 badge, CancellationToken token) =>\n//             {\n//                 string response = await badge.GetSmallBadge(id, theme ?? ETheme.Light, token);\n\n", "list": [{"retrieved_chunk": "        private const string BADGE_URL = \"https://forum.dotnetdev.kr/user-badges/{0}.json?grouped=true\";\n        private const string SUMMARY_URL = \"https://forum.dotnetdev.kr/u/{0}/summary.json\";\n        private readonly IHttpClientFactory _httpClientFactory;\n        public ForumDataProvider(IHttpClientFactory httpClientFactory)\n        {\n            _httpClientFactory = httpClientFactory;\n        }\n        private async Task<string> GetResponseStringAsync(Uri uri, CancellationToken token)\n        {\n            using HttpClient client = _httpClientFactory.CreateClient();", "filename": "src/dotnetdev-badge/dotnetdev-badge.web/Core/Provider/ForumDataProvider.cs", "score": 20.998481641894454}, {"retrieved_chunk": "        public string Username { get; set; }\n        [JsonProperty(\"name\")]\n        public string Name { get; set; }\n        [JsonProperty(\"avatar_template\")]\n        public string AvatarTemplate { get; set; }\n        [JsonProperty(\"flair_name\")]\n        public object FlairName { get; set; }\n        [JsonProperty(\"trust_level\")]\n        public int TrustLevel { get; set; }\n        [JsonProperty(\"admin\")]", "filename": "src/dotnetdev-badge/dotnetdev-badge.web/Model/User.cs", "score": 20.73346729938653}, {"retrieved_chunk": "\ufeffusing DotNetDevBadgeWeb.Model;\nnamespace DotNetDevBadgeWeb.Interfaces\n{\n    public interface IProvider\n    {\n        Task<(UserSummary summary, User user)> GetUserInfoAsync(string id, CancellationToken token);\n        Task<(byte[] avatar, UserSummary summary, User user)> GetUserInfoWithAvatarAsync(string id, CancellationToken token);\n        Task<(int gold, int silver, int bronze)> GetBadgeCountAsync(string id, CancellationToken token);\n    }\n}", "filename": "src/dotnetdev-badge/dotnetdev-badge.web/Interfaces/IProvider.cs", "score": 12.088199207115517}, {"retrieved_chunk": "        private const float TEXT_MAX_WIDTH = LOGO_X - TEXT_X - 10;\n        private readonly IProvider _forumProvider;\n        private readonly IMeasureTextV1 _measureTextV1;\n        public BadgeCreatorV1(IProvider forumProvider, IMeasureTextV1 measureTextV1)\n        {\n            _forumProvider = forumProvider;\n            _measureTextV1 = measureTextV1;\n        }\n        public async Task<string> GetSmallBadge(string id, ETheme theme, CancellationToken token)\n        {", "filename": "src/dotnetdev-badge/dotnetdev-badge.web/Core/Badge/BadgeCreatorV1.cs", "score": 10.738553623860039}, {"retrieved_chunk": "        {\n            app.UseMiddleware<BadgeIdValidatorMiddleware>();\n            app.MapBadgeEndpointsV1();\n            return app;\n        }\n        internal static WebApplication MapBadgeEndpointsV1(this WebApplication app)\n        {\n            app.MapGet(\"/api/v1/badge/small\", async (HttpContext context, [FromQuery] string id, [FromQuery] ETheme? theme, IBadgeV1 badge, CancellationToken token) =>\n            {\n                string response = await badge.GetSmallBadge(id, theme ?? ETheme.Light, token);", "filename": "src/dotnetdev-badge/dotnetdev-badge.web/Endpoints/Badge/BadgeEndpoints.cs", "score": 7.998097817927588}]}}, "groundtruth": "JsonProperty(\"likes_given\")]\n        public int LikesGiven {", "metadata": {"task_id": "project_cc_csharp/48", "repository": "chanos-dev-dotnetdev-badge-5740a40", "file": "src/dotnetdev-badge/dotnetdev-badge.web/Model/UserSummary.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 6, "right_context_start_lineno": 8}}
{"language": "csharp", "segments": {"prefix": "using System.Collections.Generic;\n\nnamespace JdeJabali.JXLDataTableExtractor.JXLExtractedData\n{\n    public class JXLDataExtracted\n    {\n        public List<", "suffix": " get; set; } = new List<JXLWorkbookData>();\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// JdeJabali.JXLDataTableExtractor/DataExtraction/DataReader.cs\n//     {\n//         public List<string> Workbooks { get; set; } = new List<string>();\n//         public int SearchLimitRow { get; set; }\n//         public int SearchLimitColumn { get; set; }\n//         public List<int> WorksheetIndexes { get; set; } = new List<int>();\n//         public List<string> Worksheets { get; set; } = new List<string>();\n//         public bool ReadAllWorksheets { get; set; }\n//         public List<HeaderToSearch> HeadersToSearch { get; set; } = new List<HeaderToSearch>();\n//         public DataTable GetDataTable()\n//         {\n\n// the below code fragment can be found in:\n// JdeJabali.JXLDataTableExtractor/DataTableExtractor.cs\n//     public class DataTableExtractor :\n//         IDataTableExtractorConfiguration,\n//         IDataTableExtractorWorkbookConfiguration,\n//         IDataTableExtractorSearchConfiguration,\n//         IDataTableExtractorWorksheetConfiguration\n//     {\n//         private bool _readAllWorksheets;\n//         private int _searchLimitRow;\n//         private int _searchLimitColumn;\n//         private readonly List<string> _workbooks = new List<string>();\n\n// the below code fragment can be found in:\n// JdeJabali.JXLDataTableExtractor/JXLExtractedData/JXLWorksheetData.cs\n// \ufeffusing System.Collections.Generic;\n// namespace JdeJabali.JXLDataTableExtractor.JXLExtractedData\n// {\n//     public class JXLWorksheetData\n//     {\n//         public string WorksheetName { get; set; } = string.Empty;\n//         public List<JXLExtractedRow> Rows { get; set; } = new List<JXLExtractedRow>();\n//     }\n// }\n\n// the below code fragment can be found in:\n// JdeJabali.JXLDataTableExtractor/JXLExtractedData/JXLExtractedRow.cs\n// \ufeffusing System.Collections.Generic;\n// namespace JdeJabali.JXLDataTableExtractor.JXLExtractedData\n// {\n//     public class JXLExtractedRow\n//     {\n//         public Dictionary<string, string> Columns { get; set; } = new Dictionary<string, string>();\n//     }\n// }\n\n// the below code fragment can be found in:\n// JdeJabali.JXLDataTableExtractor/Configuration/IDataExtraction.cs\n//         /// <returns></returns>\n//         /// <exception cref=\"InvalidOperationException\"/>\n//         List<JXLWorkbookData> GetWorkbooksData();\n//         /// <summary>\n//         /// Only retrieves the extracted rows from all the workbooks and worksheets.\n//         /// </summary>\n//         /// <returns></returns>\n//         /// <exception cref=\"InvalidOperationException\"/>\n//         List<JXLExtractedRow> GetExtractedRows();\n//         /// <summary>    \n\n", "list": [{"retrieved_chunk": "    {\n        public List<string> Workbooks { get; set; } = new List<string>();\n        public int SearchLimitRow { get; set; }\n        public int SearchLimitColumn { get; set; }\n        public List<int> WorksheetIndexes { get; set; } = new List<int>();\n        public List<string> Worksheets { get; set; } = new List<string>();\n        public bool ReadAllWorksheets { get; set; }\n        public List<HeaderToSearch> HeadersToSearch { get; set; } = new List<HeaderToSearch>();\n        public DataTable GetDataTable()\n        {", "filename": "JdeJabali.JXLDataTableExtractor/DataExtraction/DataReader.cs", "score": 21.880390238660006}, {"retrieved_chunk": "    public class DataTableExtractor :\n        IDataTableExtractorConfiguration,\n        IDataTableExtractorWorkbookConfiguration,\n        IDataTableExtractorSearchConfiguration,\n        IDataTableExtractorWorksheetConfiguration\n    {\n        private bool _readAllWorksheets;\n        private int _searchLimitRow;\n        private int _searchLimitColumn;\n        private readonly List<string> _workbooks = new List<string>();", "filename": "JdeJabali.JXLDataTableExtractor/DataTableExtractor.cs", "score": 20.597128248615988}, {"retrieved_chunk": "\ufeffusing System.Collections.Generic;\nnamespace JdeJabali.JXLDataTableExtractor.JXLExtractedData\n{\n    public class JXLWorksheetData\n    {\n        public string WorksheetName { get; set; } = string.Empty;\n        public List<JXLExtractedRow> Rows { get; set; } = new List<JXLExtractedRow>();\n    }\n}", "filename": "JdeJabali.JXLDataTableExtractor/JXLExtractedData/JXLWorksheetData.cs", "score": 20.44056373724002}, {"retrieved_chunk": "\ufeffusing System.Collections.Generic;\nnamespace JdeJabali.JXLDataTableExtractor.JXLExtractedData\n{\n    public class JXLExtractedRow\n    {\n        public Dictionary<string, string> Columns { get; set; } = new Dictionary<string, string>();\n    }\n}", "filename": "JdeJabali.JXLDataTableExtractor/JXLExtractedData/JXLExtractedRow.cs", "score": 20.174278440276893}, {"retrieved_chunk": "        /// <returns></returns>\n        /// <exception cref=\"InvalidOperationException\"/>\n        List<JXLWorkbookData> GetWorkbooksData();\n        /// <summary>\n        /// Only retrieves the extracted rows from all the workbooks and worksheets.\n        /// </summary>\n        /// <returns></returns>\n        /// <exception cref=\"InvalidOperationException\"/>\n        List<JXLExtractedRow> GetExtractedRows();\n        /// <summary>    ", "filename": "JdeJabali.JXLDataTableExtractor/Configuration/IDataExtraction.cs", "score": 19.028401583774812}]}}, "groundtruth": "JXLWorkbookData> WorkbooksData {", "metadata": {"task_id": "project_cc_csharp/50", "repository": "JdeJabali-JXLDataTableExtractor-90a12f4", "file": "JdeJabali.JXLDataTableExtractor/JXLExtractedData/JXLDataExtracted.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 6, "right_context_start_lineno": 7}}
{"language": "csharp", "segments": {"prefix": "using System.Net.WebSockets;\nusing System.Text;\nusing Microsoft.AspNetCore.Http;\nusing Newtonsoft.Json;\n\nnamespace TraTech.WebSocketHub\n{\n    public class WebSocketHubMiddleware<TKey>\n            where TKey : notnull\n    {\n        private readonly IServiceProvider _serviceProvider;\n        private readonly RequestDelegate _next;\n        private readonly Func<HttpContext, bool> _acceptIf;\n        private readonly WebSocketHub<TKey> _webSocketHub;\n        private readonly Func<HttpContext, TKey> _keyGenerator;\n        private readonly byte[] _receiveBuffer;\n\n        public WebSocketHubMiddleware(IServiceProvider serviceProvider, RequestDelegate next, ", "suffix": "\n            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));\n            _next = next ?? throw new ArgumentNullException(nameof(next));\n            _acceptIf = acceptIf ?? throw new ArgumentNullException(nameof(acceptIf));\n            _webSocketHub = webSocketHub ?? throw new ArgumentNullException(nameof(webSocketHub));\n            _keyGenerator = keyGenerator ?? throw new ArgumentNullException(nameof(keyGenerator));\n            _receiveBuffer = new byte[_webSocketHub.Options.ReceiveBufferSize];\n        }\n\n        public async Task Invoke(HttpContext httpContext)\n        {\n\n            if (httpContext.WebSockets.IsWebSocketRequest && _acceptIf(httpContext))\n            {\n                try\n                {\n                    WebSocket webSocket = await httpContext.WebSockets.AcceptWebSocketAsync();\n\n                    var key = _keyGenerator(httpContext);\n                    _webSocketHub.Add(key, webSocket);\n\n                    while (webSocket.State == WebSocketState.Open || webSocket.State == WebSocketState.CloseSent)\n                    {\n                        try\n                        {\n                            WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(_receiveBuffer), CancellationToken.None);\n                            string request = Encoding.UTF8.GetString(_receiveBuffer, 0, result.Count);\n\n                            if (result.MessageType == WebSocketMessageType.Close)\n                            {\n                                break;\n                            }\n\n                            Message? serializedRequest = _webSocketHub.DeserializeMessage(request);\n                            if (serializedRequest == null) { throw new NullReferenceException(nameof(serializedRequest)); }\n\n                            Type? handlerType = await _webSocketHub.Options.WebSocketRequestHandler.GetHandlerAsync(serializedRequest.Type);\n                            if (handlerType == null) { throw new NullReferenceException(nameof(handlerType)); }\n\n                            if (_serviceProvider.GetService(handlerType) is not IWebSocketRequestHandler service) { throw new NullReferenceException(nameof(service)); }\n\n                            await service.HandleRequestAsync(\n                                JsonConvert.SerializeObject(key, _webSocketHub.Options.JsonSerializerSettings),\n                                JsonConvert.SerializeObject(serializedRequest.Payload, _webSocketHub.Options.JsonSerializerSettings)\n                            );\n                        }\n                        catch (Exception exp)\n                        {\n                            Console.WriteLine(exp.ToString());\n                            continue;\n                        }\n                    }\n\n                    await _webSocketHub.RemoveAsync(key, webSocket);\n                }\n                catch (Exception exp)\n                {\n                    Console.WriteLine(exp.ToString());\n                }\n            }\n            else\n            {\n                await _next(httpContext);\n            }\n        }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// src/ExampleWebApplication/Controllers/WebSocket2Controller.cs\n//         public WebSocket2Controller(WebSocketHub<SocketUser> webSocketHub)\n//         {\n//             _webSocketHub = webSocketHub;\n//         }\n//         [HttpGet(\"GetSocketListWithSelector\")]\n//         public IActionResult GetSocketListWithSelector(int id)\n//         {\n//             var socketListOfUser = _webSocketHub.GetSocketList((key) => key.Id == id);\n//             return Ok(socketListOfUser);\n//         }\n\n// the below code fragment can be found in:\n// src/ExampleWebApplication/Controllers/WebSocket1Controller.cs\n//         {\n//             _webSocketHub = webSocketHub;\n//         }\n//         [HttpGet(\"GetSocketList\")]\n//         public IActionResult GetSocketList(int id)\n//         {\n//             var socketListOfUser = _webSocketHub.GetSocketList(id);\n//             return Ok(socketListOfUser);\n//         }\n//         [HttpGet(\"GetSocketListWithSelector\")]\n\n// the below code fragment can be found in:\n// src/WebSocketHub/Core/src/WebSocketRequestHandlerProvider.cs\n//         /// Attempts to add a WebSocket request handler of type THandler for the specified message type to the handler type map.\n//         /// </summary>\n//         /// <typeparam name=\"THandler\">The type of WebSocket request handler to add.</typeparam>\n//         /// <param name=\"messageType\">The message type associated with the WebSocket request handler.</param>\n//         /// <returns>true if the WebSocket request handler was added to the handler type map; otherwise, false.</returns>\n//         /// <exception cref=\"InvalidOperationException\">Thrown when <typeparamref name=\"THandler\"/> is not assignable from IWebSocketRequestHandler.</exception>\n//         /// <remarks>\n//         /// This method attempts to add a WebSocket request handler of type THandler for the specified message type to the handler type map. The THandler type must implement the IWebSocketRequestHandler interface and have a public constructor. If the message type is already associated with a WebSocket request handler type, this method returns false. Otherwise, it adds the message type and WebSocket request handler type to the handler type map and returns true.\n//         /// </remarks>\n//         public bool TryAddHandler<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] THandler>(string messageType)\n\n// the below code fragment can be found in:\n// src/WebSocketHub/Core/src/WebSocketHub.cs\n//         public WebSocketHub(IOptions<WebSocketHubOptions> options)\n//         {\n//             if (options == null) throw new ArgumentNullException(nameof(options));\n//             Options = options.Value;\n//             _webSocketDictionary = new();\n//         }\n//         /// <summary>\n//         /// Encodes the specified Message object into a UTF-8 encoded byte array.\n//         /// </summary>\n//         /// <param name=\"message\">The Message object to encode.</param>\n\n// the below code fragment can be found in:\n// src/WebSocketHub/Core/src/WebSocketHub.cs\n//         private static readonly Func<WebSocket, bool> _openSocketSelector = socket => socket.State == WebSocketState.Open;\n//         public WebSocketHubOptions Options { get; private set; }\n//         /// <summary>\n//         /// Initializes a new instance of the WebSocketHub class with the specified options.\n//         /// </summary>\n//         /// <param name=\"options\">The options to configure the WebSocketHub.</param>\n//         /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"options\"/> is null.</exception>\n//         /// <remarks>\n//         /// This constructor initializes a new instance of the WebSocketHub class with the specified options. It also initializes an empty WebSocket dictionary.\n//         /// </remarks>\n\n", "list": [{"retrieved_chunk": "        public WebSocket2Controller(WebSocketHub<SocketUser> webSocketHub)\n        {\n            _webSocketHub = webSocketHub;\n        }\n        [HttpGet(\"GetSocketListWithSelector\")]\n        public IActionResult GetSocketListWithSelector(int id)\n        {\n            var socketListOfUser = _webSocketHub.GetSocketList((key) => key.Id == id);\n            return Ok(socketListOfUser);\n        }", "filename": "src/ExampleWebApplication/Controllers/WebSocket2Controller.cs", "score": 45.19935267420081}, {"retrieved_chunk": "        {\n            _webSocketHub = webSocketHub;\n        }\n        [HttpGet(\"GetSocketList\")]\n        public IActionResult GetSocketList(int id)\n        {\n            var socketListOfUser = _webSocketHub.GetSocketList(id);\n            return Ok(socketListOfUser);\n        }\n        [HttpGet(\"GetSocketListWithSelector\")]", "filename": "src/ExampleWebApplication/Controllers/WebSocket1Controller.cs", "score": 45.02333198140999}, {"retrieved_chunk": "        /// Attempts to add a WebSocket request handler of type THandler for the specified message type to the handler type map.\n        /// </summary>\n        /// <typeparam name=\"THandler\">The type of WebSocket request handler to add.</typeparam>\n        /// <param name=\"messageType\">The message type associated with the WebSocket request handler.</param>\n        /// <returns>true if the WebSocket request handler was added to the handler type map; otherwise, false.</returns>\n        /// <exception cref=\"InvalidOperationException\">Thrown when <typeparamref name=\"THandler\"/> is not assignable from IWebSocketRequestHandler.</exception>\n        /// <remarks>\n        /// This method attempts to add a WebSocket request handler of type THandler for the specified message type to the handler type map. The THandler type must implement the IWebSocketRequestHandler interface and have a public constructor. If the message type is already associated with a WebSocket request handler type, this method returns false. Otherwise, it adds the message type and WebSocket request handler type to the handler type map and returns true.\n        /// </remarks>\n        public bool TryAddHandler<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] THandler>(string messageType)", "filename": "src/WebSocketHub/Core/src/WebSocketRequestHandlerProvider.cs", "score": 38.98487610590298}, {"retrieved_chunk": "        public WebSocketHub(IOptions<WebSocketHubOptions> options)\n        {\n            if (options == null) throw new ArgumentNullException(nameof(options));\n            Options = options.Value;\n            _webSocketDictionary = new();\n        }\n        /// <summary>\n        /// Encodes the specified Message object into a UTF-8 encoded byte array.\n        /// </summary>\n        /// <param name=\"message\">The Message object to encode.</param>", "filename": "src/WebSocketHub/Core/src/WebSocketHub.cs", "score": 37.98681211524358}, {"retrieved_chunk": "        private static readonly Func<WebSocket, bool> _openSocketSelector = socket => socket.State == WebSocketState.Open;\n        public WebSocketHubOptions Options { get; private set; }\n        /// <summary>\n        /// Initializes a new instance of the WebSocketHub class with the specified options.\n        /// </summary>\n        /// <param name=\"options\">The options to configure the WebSocketHub.</param>\n        /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"options\"/> is null.</exception>\n        /// <remarks>\n        /// This constructor initializes a new instance of the WebSocketHub class with the specified options. It also initializes an empty WebSocket dictionary.\n        /// </remarks>", "filename": "src/WebSocketHub/Core/src/WebSocketHub.cs", "score": 31.71651588733243}]}}, "groundtruth": "WebSocketHub<TKey> webSocketHub, Func<HttpContext, bool> acceptIf, Func<HttpContext, TKey> keyGenerator)\n        {", "metadata": {"task_id": "project_cc_csharp/68", "repository": "TRA-Tech-dotnet-websocket-9049854", "file": "src/WebSocketHub/Core/src/WebSocketHubMiddleware.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 17, "right_context_start_lineno": 19}}
{"language": "csharp", "segments": {"prefix": "using System.Text;\nusing System.Net;\nusing Microsoft.Extensions.Caching.Memory;\nusing Serilog;\nusing Serilog.Events;\nusing Iced.Intel;\nusing static Iced.Intel.AssemblerRegisters;\n\nnamespace OGXbdmDumper\n{\n    public class Xbox : IDisposable\n    {\n        #region Properties\n\n        private bool _disposed;\n\n        private const int _cacheDuration = 1;   // in minutes\n\n        private readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions { ExpirationScanFrequency = TimeSpan.FromMinutes(_cacheDuration) });\n\n        private bool? _hasFastGetmem;\n\n        public ScratchBuffer StaticScratch;\n\n        public bool HasFastGetmem\n        {\n            get\n            {\n                if (_hasFastGetmem == null)\n                {\n                    try\n                    {\n                        long testAddress = 0x10000;\n                        if (IsValidAddress(testAddress))\n                        {\n                            Session.SendCommandStrict(\"getmem2 addr={0} length=1\", testAddress.ToHexString());\n                            Session.ClearReceiveBuffer();\n                            _hasFastGetmem = true;\n                            Log.Information(\"Fast getmem support detected.\");\n                        }                      \n                        else _hasFastGetmem = false;\n                    }\n                    catch\n                    {\n                        _hasFastGetmem = false;\n                    }\n                }\n                return _hasFastGetmem.Value;\n            }\n        }\n\n        /// <summary>\n        /// Determines whether precautions (usually at the expense of performance) should be taken to prevent crashing the xbox.\n        /// </summary>\n        public bool SafeMode { get; set; } = true;\n\n        public bool IsConnected => Session.IsConnected;\n\n        public int SendTimeout { get => Session.SendTimeout; set => Session.SendTimeout = value; }\n\n        public int ReceiveTimeout { get => Session.ReceiveTimeout; set => Session.ReceiveTimeout = value; }\n\n        public Connection Session { get; private set; } = new Connection();\n\n        public ConnectionInfo? ConnectionInfo { get; protected set; }\n\n        /// <summary>\n        /// The Xbox memory stream.\n        /// </summary>\n        public XboxMemoryStream Memory { get; private set; }\n\n        public Kernel Kernel { get; private set; }\n\n        public List<Module> Modules => GetModules();\n\n        public List<", "suffix": "\n\n        public Version Version => GetVersion();\n\n        #endregion\n\n        #region Connection\n\n        public void Connect(string host, int port = 731)\n        {\n            _cache.Clear();\n            ConnectionInfo = Session.Connect(host, port);\n\n            // init subsystems\n            Memory = new XboxMemoryStream(this);\n            Kernel = new Kernel(this);\n            StaticScratch = new ScratchBuffer(this);\n\n            Log.Information(\"Loaded Modules:\");\n            foreach (var module in Modules)\n            {\n                Log.Information(\"\\t{0} ({1})\", module.Name, module.TimeStamp);\n            }\n\n            Log.Information(\"Xbdm Version {0}\", Version);\n            Log.Information(\"Kernel Version {0}\", Kernel.Version);\n\n            // enable remote code execution and use the remainder reloc section as scratch\n            PatchXbdm(this);\n        }\n\n        public void Disconnect()\n        {\n            Session.Disconnect();\n            ConnectionInfo = null;\n            _cache.Clear();\n        }\n\n        public List<ConnectionInfo> Discover(int timeout = 500)\n        {\n            return ConnectionInfo.DiscoverXbdm(731, timeout);\n        }\n\n        public void Connect(IPEndPoint endpoint)\n        {\n            Connect(endpoint.Address.ToString(), endpoint.Port);\n        }\n\n        public void Connect(int timeout = 500)\n        {\n            Connect(Discover(timeout).First().Endpoint);\n        }\n\n        #endregion\n\n        #region Memory\n\n        public bool IsValidAddress(long address)\n        {\n            try\n            {\n                Session.SendCommandStrict(\"getmem addr={0} length=1\", address.ToHexString());\n                return \"??\" != Session.ReceiveMultilineResponse()[0];\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        public void ReadMemory(long address, Span<byte> buffer)\n        {\n            if (HasFastGetmem && !SafeMode)\n            {\n                Session.SendCommandStrict(\"getmem2 addr={0} length={1}\", address.ToHexString(), buffer.Length);\n                Session.Read(buffer);\n                if (Log.IsEnabled(LogEventLevel.Verbose))\n                {\n                    Log.Verbose(buffer.ToHexString());\n                }\n            }\n            else if (!SafeMode)\n            {\n                // custom getmem2\n                Session.SendCommandStrict(\"funccall type=1 addr={0} length={1}\", address, buffer.Length);\n                Session.ReadExactly(buffer);\n                if (Log.IsEnabled(LogEventLevel.Verbose))\n                {\n                    Log.Verbose(buffer.ToHexString());\n                }\n            }\n            else\n            {\n                Session.SendCommandStrict(\"getmem addr={0} length={1}\", address.ToHexString(), buffer.Length);\n\n                int bytesRead = 0;\n                string hexString;\n                while ((hexString = Session.ReceiveLine()) != \".\")\n                {\n                    Span<byte> slice = buffer.Slice(bytesRead, hexString.Length / 2);\n                    slice.FromHexString(hexString);\n                    bytesRead += slice.Length;\n                }\n            }\n        }\n\n        public void ReadMemory(long address, byte[] buffer, int offset, int count)\n        {\n            ReadMemory(address, buffer.AsSpan(offset, count));\n        }\n\n        public void ReadMemory(long address, int count, Stream destination)\n        {\n            // argument checks\n            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (destination == null) throw new ArgumentNullException(nameof(destination));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (count > 0)\n            {\n                int bytesToRead = Math.Min(buffer.Length, count);\n\n                Span<byte> slice = buffer.Slice(0, bytesToRead);\n                ReadMemory(address, slice);\n                destination.Write(slice);\n\n                count -= bytesToRead;\n                address += (uint)bytesToRead;\n            }\n        }\n\n        public void WriteMemory(long address, ReadOnlySpan<byte> buffer)\n        {\n            const int maxBytesPerLine = 240;\n            int totalWritten = 0;\n\n            while (totalWritten < buffer.Length)\n            {\n                ReadOnlySpan<byte> slice = buffer.Slice(totalWritten, Math.Min(maxBytesPerLine, buffer.Length - totalWritten));\n                Session.SendCommandStrict(\"setmem addr={0} data={1}\", (address + totalWritten).ToHexString(), slice.ToHexString());\n                totalWritten += slice.Length;\n            }\n        }\n\n        public void WriteMemory(long address, byte[] buffer, int offset, int count)\n        {\n            WriteMemory(address, buffer.AsSpan(offset, count));\n        }\n\n        public void WriteMemory(long address, int count, Stream source)\n        {\n            // argument checks\n            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (source == null) throw new ArgumentNullException(nameof(source));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (count > 0)\n            {\n                int bytesRead = source.Read(buffer.Slice(0, Math.Min(buffer.Length, count)));\n                WriteMemory(address, buffer.Slice(0, bytesRead));\n\n                count -= bytesRead;\n                address += bytesRead;\n            }\n        }\n\n        #endregion\n\n        #region Process\n\n        public List<Thread> GetThreads()\n        {\n            List<Thread> threads = new List<Thread>();\n\n            Session.SendCommandStrict(\"threads\");\n            foreach (var threadId in Session.ReceiveMultilineResponse())\n            {\n                Session.SendCommandStrict(\"threadinfo thread={0}\", threadId);\n                var info = Connection.ParseKvpResponse(string.Join(Environment.NewLine, Session.ReceiveMultilineResponse()));\n\n                threads.Add(new Thread\n                {\n                    Id = Convert.ToInt32(threadId),\n                    Suspend = (int)(uint)info[\"suspend\"], // initially -1 in earlier xbdm versions, 0 in later ones\n                    Priority = (int)(uint)info[\"priority\"],\n                    TlsBase = (uint)info[\"tlsbase\"],\n\n                    // optional depending on xbdm version\n                    Start = info.ContainsKey(\"start\") ? (uint)info[\"start\"] : 0,\n                    Base = info.ContainsKey(\"base\") ? (uint)info[\"base\"] : 0,\n                    Limit = info.ContainsKey(\"limit\") ? (uint)info[\"limit\"] : 0,\n                    CreationTime = DateTime.FromFileTime(\n                        (info.ContainsKey(\"createhi\") ? (((long)(uint)info[\"createhi\"]) << 32) : 0) |\n                        (info.ContainsKey(\"createlo\") ? (uint)info[\"createlo\"] : 0))\n                });\n            }\n\n            return threads;\n        }\n\n        public List<Module> GetModules()\n        {\n            List<Module> modules = new List<Module>();\n\n            Session.SendCommandStrict(\"modules\");\n            foreach (var moduleResponse in Session.ReceiveMultilineResponse())\n            {\n                var moduleInfo = Connection.ParseKvpResponse(moduleResponse);\n                Module module = new Module\n                {\n                    Name = (string)moduleInfo[\"name\"],\n                    BaseAddress = (uint)moduleInfo[\"base\"],\n                    Size = (int)(uint)moduleInfo[\"size\"],\n                    Checksum = (uint)moduleInfo[\"check\"],\n                    TimeStamp = DateTimeOffset.FromUnixTimeSeconds((uint)moduleInfo[\"timestamp\"]).DateTime,\n                    Sections = new List<ModuleSection>(),\n                    HasTls = moduleInfo.ContainsKey(\"tls\"),\n                    IsXbe = moduleInfo.ContainsKey(\"xbe\")\n                };\n\n                Session.SendCommandStrict(\"modsections name=\\\"{0}\\\"\", module.Name);\n                foreach (var sectionResponse in Session.ReceiveMultilineResponse())\n                {\n                    var sectionInfo = Connection.ParseKvpResponse(sectionResponse);\n                    module.Sections.Add(new ModuleSection\n                    {\n                        Name = (string)sectionInfo[\"name\"],\n                        Base = (uint)sectionInfo[\"base\"],\n                        Size = (int)(uint)sectionInfo[\"size\"],\n                        Flags = (uint)sectionInfo[\"flags\"]\n                    });\n                }\n\n                modules.Add(module);\n            }\n\n            return modules;\n        }\n\n        public Version GetVersion()\n        {\n            var version = _cache.Get<Version>(nameof(GetVersion));\n            if (version == null)\n            {\n                try\n                {\n                    // peek inside VS_VERSIONINFO struct\n                    var versionAddress = GetModules().FirstOrDefault(m => m.Name.Equals(\"xbdm.dll\")).GetSection(\".rsrc\").Base + 0x98;\n\n                    // call getmem directly to avoid dependency loops with ReadMemory checking the version\n                    Span<byte> buffer = stackalloc byte[sizeof(ushort) * 4];\n                    Session.SendCommandStrict(\"getmem addr={0} length={1}\", versionAddress.ToHexString(), buffer.Length);\n                    buffer.FromHexString(Session.ReceiveMultilineResponse().First());\n\n                    version = new Version(\n                        BitConverter.ToUInt16(buffer.Slice(2, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(0, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(6, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(4, sizeof(ushort)))\n                    );\n\n                    // cache the result\n                    _cache.Set(nameof(GetVersion), version);\n                }\n                catch\n                {\n                    version = new Version(\"0.0.0.0\");\n                }\n            }\n\n            return version;\n        }\n\n        public void Stop()\n        {\n            Log.Information(\"Suspending xbox execution.\");\n            Session.SendCommand(\"stop\");\n        }\n\n        public void Go()\n        {\n            Log.Information(\"Resuming xbox execution.\");\n            Session.SendCommand(\"go\");\n        }\n\n        /// <summary>\n        /// Calls an Xbox function.\n        /// </summary>\n        /// <param name=\"address\">The function address.</param>\n        /// <param name=\"args\">The function arguments.</param>\n        /// <returns>Returns an object that unboxes eax by default, but allows for reading st0 for floating-point return values.</returns>\n        public uint Call(long address, params object[] args)\n        {\n            // TODO: call context (~4039+ which requires qwordparam)\n\n            // injected script pushes arguments in reverse order for simplicity, this corrects that\n            var reversedArgs = args.Reverse().ToArray();\n\n            StringBuilder command = new StringBuilder();\n            command.AppendFormat(\"funccall type=0 addr={0} \", address);\n            for (int i = 0; i < reversedArgs.Length; i++)\n            {\n                command.AppendFormat(\"arg{0}={1} \", i, Convert.ToUInt32(reversedArgs[i]));\n            }\n\n            var returnValues = Connection.ParseKvpResponse(Session.SendCommandStrict(command.ToString()).Message);\n            return (uint)returnValues[\"eax\"];\n        }\n\n        /// <summary>\n        /// Original Xbox Debug Monitor runtime patches.\n        /// Prevents crashdumps from being written to the HDD and enables remote code execution.\n        /// </summary>\n        /// <param name=\"target\"></param>\n        private void PatchXbdm(Xbox target)\n        {\n            // the spin routine to be patched in after the signature patterns\n            // spin:\n            // jmp spin\n            // int 3\n            var spinBytes = new byte[] { 0xEB, 0xFE, 0xCC };\n\n            // prevent crashdumps from being written to the hard drive by making it spin instead (only for xbdm versions ~4831+)\n            if (target.Signatures.ContainsKey(\"ReadWriteOneSector\"))\n            {\n                Log.Information(\"Disabling crashdump functionality.\");\n                target.WriteMemory(target.Signatures[\"ReadWriteOneSector\"] + 9, spinBytes);\n            }\n            else if (target.Signatures.ContainsKey(\"WriteSMBusByte\"))\n            {\n                // this will prevent the LED state from changing upon crash\n                Log.Information(\"Disabling crashdump functionality.\");\n                target.WriteMemory(target.Signatures[\"WriteSMBusByte\"] + 9, spinBytes);\n            }\n\n            Log.Information(\"Patching xbdm memory to enable remote code execution.\");\n\n            uint argThreadStringAddress = StaticScratch.Alloc(\"thread\\0\");\n            uint argTypeStringAddress = StaticScratch.Alloc(\"type\\0\");\n            uint argAddrStringAddress = StaticScratch.Alloc(\"addr\\0\");\n            uint argLengthStringAddress = StaticScratch.Alloc(\"length\\0\");\n            uint argFormatStringAddress = StaticScratch.Alloc(\"arg%01d\\0\");\n            uint returnFormatAddress = StaticScratch.Alloc(\"eax=0x%X\\0\");\n\n            var asm = new Assembler(32);\n\n            #region HrSendGetMemory2Data\n\n            uint getmem2CallbackAddress = 0;\n            if (!HasFastGetmem)\n            {\n                // labels\n                var label1 = asm.CreateLabel();\n                var label2 = asm.CreateLabel();\n                var label3 = asm.CreateLabel();\n\n                asm.push(ebx);\n                asm.mov(ebx, __dword_ptr[esp + 8]);     // pdmcc\n                asm.mov(eax, __dword_ptr[ebx + 0x14]);  // size\n                asm.test(eax, eax);\n                asm.mov(edx, __dword_ptr[ebx + 0x10]);\n                asm.ja(label1);\n                //asm.push(__dword_ptr[ebx + 8]);\n                //asm.call((uint)target.Signatures[\"DmFreePool\"]);\n                //asm.and(__dword_ptr[ebx + 8], 0);\n                asm.mov(eax, 0x82DB0104);\n                asm.jmp(label3);\n\n                asm.Label(ref label1);\n                asm.mov(ecx, __dword_ptr[ebx + 0xC]);   // buffer size\n                asm.cmp(eax, ecx);\n                asm.jb(label2);\n                asm.mov(eax, ecx);\n\n                asm.Label(ref label2);\n                asm.push(ebp);\n                asm.push(esi);\n                asm.mov(esi, __dword_ptr[edx + 0x14]);  // address\n                asm.push(edi);\n                asm.mov(edi, __dword_ptr[ebx + 8]);\n                asm.mov(ecx, eax);\n                asm.mov(ebp, ecx);\n                asm.shr(ecx, 2);\n                asm.rep.movsd();\n                asm.mov(ecx, ebp);\n                asm.and(ecx, 3);\n                asm.rep.movsb();\n                asm.sub(__dword_ptr[ebx + 0x14], eax);\n                asm.pop(edi);\n                asm.mov(__dword_ptr[ebx + 4], eax);\n                asm.add(__dword_ptr[edx + 0x14], eax);\n                asm.pop(esi);\n                asm.mov(eax, 0x2DB0000);\n                asm.pop(ebp);\n\n                asm.Label(ref label3);\n                asm.pop(ebx);\n                asm.ret(0xC);\n\n                getmem2CallbackAddress = StaticScratch.Alloc(asm.AssembleBytes(StaticScratch.Region.Address));\n            }\n\n            #endregion\n\n            #region HrFunctionCall\n\n            // 3424+ as it depends on sprintf within xbdm, earlier versions can possibly call against the kernel but their exports are different\n            asm = new Assembler(32);\n\n            // labels\n            var binaryResponseLabel = asm.CreateLabel();\n            var getmem2Label = asm.CreateLabel();\n            var errorLabel = asm.CreateLabel();\n            var successLabel = asm.CreateLabel();\n\n            // prolog\n            asm.push(ebp);\n            asm.mov(ebp, esp);\n            asm.sub(esp, 0x10); // carve out arbitrary space for local temp variables\n            asm.pushad();\n\n            // disable write protection globally, otherwise checked kernel calls may fail when writing to the default scratch space\n            asm.mov(eax, cr0);\n            asm.and(eax, 0xFFFEFFFF);\n            asm.mov(cr0, eax);\n\n            // arguments\n            var commandPtr = ebp + 0x8;\n            var responseAddress = ebp + 0xC;\n            var pdmcc = ebp + 0x14;\n\n            // local variables\n            var temp = ebp - 0x4;\n            var callAddress = ebp - 0x8;\n            var argName = ebp - 0x10;\n\n            // check for thread id\n            asm.lea(eax, temp);\n            asm.push(eax);\n            asm.push(argThreadStringAddress);    // 'thread', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n            var customCommandLabel = asm.CreateLabel();\n            asm.je(customCommandLabel);\n\n            // call original code if thread id exists\n            asm.push(__dword_ptr[temp]);\n            asm.call((uint)target.Signatures[\"DmSetupFunctionCall\"]);\n            var doneLabel = asm.CreateLabel();\n            asm.jmp(doneLabel);\n\n            // thread argument doesn't exist, must be a custom command\n            asm.Label(ref customCommandLabel);\n\n            // determine custom function type\n            asm.lea(eax, temp);\n            asm.push(eax);\n            asm.push(argTypeStringAddress);    // 'type', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n            asm.je(errorLabel);\n\n            #region Custom Call (type 0)\n\n            asm.cmp(__dword_ptr[temp], 0);\n            asm.jne(getmem2Label);\n\n            // get the call address\n            asm.lea(eax, __dword_ptr[callAddress]);\n            asm.push(eax);\n            asm.push(argAddrStringAddress);    // 'addr', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n\n            asm.je(errorLabel);\n\n            // push arguments (leave it up to caller to reverse argument order and supply the correct amount)\n            asm.xor(edi, edi);\n            var nextArgLabel = asm.CreateLabel();\n            var noMoreArgsLabel = asm.CreateLabel();\n            asm.Label(ref nextArgLabel);\n            {\n                // get argument name\n                asm.push(edi);                                  // argument index\n                asm.push(argFormatStringAddress);                // format string address\n                asm.lea(eax, __dword_ptr[argName]);          // argument name address\n                asm.push(eax);\n                asm.call((uint)target.Signatures[\"sprintf\"]);\n                asm.add(esp, 0xC);\n\n                // check if it's included in the command\n                asm.lea(eax, __[temp]);                    // argument value address\n                asm.push(eax);\n                asm.lea(eax, __[argName]);                   // argument name address\n                asm.push(eax);\n                asm.push(__dword_ptr[commandPtr]);               // command\n                asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n                asm.test(eax, eax);\n                asm.je(noMoreArgsLabel);\n\n                // push it on the stack\n                asm.push(__dword_ptr[temp]);\n                asm.inc(edi);\n\n                // move on to the next argument\n                asm.jmp(nextArgLabel);\n            }\n            asm.Label(ref noMoreArgsLabel);\n\n            // perform the call\n            asm.call(__dword_ptr[callAddress]);\n\n            // print response message\n            asm.push(eax);                                  // integer return value\n            asm.push(returnFormatAddress);                  // format string address\n            asm.push(__dword_ptr[responseAddress]);         // response address\n            asm.call((uint)target.Signatures[\"sprintf\"]);\n            asm.add(esp, 0xC);\n            asm.jmp(successLabel);\n\n            #endregion\n\n            #region Fast Getmem (type 1)\n\n            asm.Label(ref getmem2Label);\n            asm.cmp(__dword_ptr[temp], 1);\n            asm.jne(errorLabel);\n \n            if (!HasFastGetmem)\n            {\n                // TODO: figure out why DmAllocatePool crashes, for now, allocate static scratch space (prevents multi-session!)\n                StaticScratch.Align16();\n                uint getmem2BufferSize = 512;\n                uint getmem2buffer = StaticScratch.Alloc(new byte[getmem2BufferSize]);\n\n                // get length and size args\n                asm.mov(esi, __dword_ptr[pdmcc]);\n                asm.push(__dword_ptr[responseAddress]);\n                asm.mov(edi, __dword_ptr[esi + 0x10]);\n                asm.lea(eax, __dword_ptr[pdmcc]);\n                asm.push(eax);\n                asm.push(argAddrStringAddress);\n                asm.push(__dword_ptr[commandPtr]);\n                asm.call((uint)target.Signatures[\"FGetNamedDwParam\"]);\n                asm.test(eax, eax);\n                asm.jz(errorLabel);\n                asm.push(__dword_ptr[responseAddress]);\n                asm.lea(eax, __dword_ptr[responseAddress]);\n                asm.push(eax);\n                asm.push(argLengthStringAddress);\n                asm.push(__dword_ptr[commandPtr]);\n                asm.call((uint)target.Signatures[\"FGetNamedDwParam\"]);\n                asm.test(eax, eax);\n                asm.jz(errorLabel);\n\n                asm.mov(eax, __dword_ptr[pdmcc]);   // address\n                asm.and(__dword_ptr[edi + 0x10], 0);\n                asm.mov(__dword_ptr[edi + 0x14], eax);\n                //asm.mov(eax, 0x2000);   // TODO: increase pool size?\n                //asm.push(eax);\n                //asm.call((uint)target.Signatures[\"DmAllocatePool\"]);    // TODO: crashes in here, possible IRQ issues?\n                asm.mov(__dword_ptr[esi + 0xC], getmem2BufferSize);   // buffer size\n                asm.mov(__dword_ptr[esi + 8], getmem2buffer); // buffer address\n                asm.mov(eax, __dword_ptr[responseAddress]);\n                asm.mov(__dword_ptr[esi + 0x14], eax);\n                asm.mov(__dword_ptr[esi], getmem2CallbackAddress);\n                asm.jmp(binaryResponseLabel);\n            }\n\n            #endregion\n\n            #region Return Codes\n\n            // if we're here, must be an unknown custom type\n            asm.jmp(errorLabel);\n\n            // generic success epilog\n            asm.Label(ref successLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x2DB0000);\n            asm.ret(0x10);\n\n            // successful binary response follows epilog\n            asm.Label(ref binaryResponseLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x2DB0003);\n            asm.ret(0x10);\n\n            // generic failure epilog\n            asm.Label(ref errorLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x82DB0000);\n            asm.ret(0x10);\n\n            // original epilog\n            asm.Label(ref doneLabel);\n            asm.popad();\n            asm.leave();\n            asm.ret(0x10);\n\n            #endregion\n\n            // inject RPC handler and hook\n            uint caveAddress = StaticScratch.Alloc(asm.AssembleBytes(StaticScratch.Region.Address));\n            Log.Information(\"HrFuncCall address {0}\", caveAddress.ToHexString());\n            asm.Hook(target, target.Signatures[\"HrFunctionCall\"], caveAddress);\n            \n            #endregion\n        }\n\n        public string GetDisassembly(long address, int length, bool tabPrefix = true, bool showBytes = false)\n        {\n            // read code from xbox memory\n            byte[] code = Memory.ReadBytes(address, length);\n\n            // disassemble valid instructions\n            var decoder = Iced.Intel.Decoder.Create(32, code);\n            decoder.IP = (ulong)address;\n            var instructions = new List<Instruction>();\n            while (decoder.IP < decoder.IP + (uint)code.Length)\n            {\n                var insn = decoder.Decode();\n                if (insn.IsInvalid)\n                    break;\n                instructions.Add(insn);\n            }\n\n            // formatting options\n            var formatter = new MasmFormatter();\n            formatter.Options.FirstOperandCharIndex = 8;\n            formatter.Options.SpaceAfterOperandSeparator = true;\n\n            // convert to string\n            var output = new StringOutput();\n            var disassembly = new StringBuilder();\n            bool firstInstruction = true;\n            foreach (var instr in instructions)\n            {\n                // skip newline for the first instruction\n                if (firstInstruction)\n                {\n                    firstInstruction = false;\n                } else disassembly.AppendLine();\n\n                // optionally indent\n                if (tabPrefix)\n                {\n                    disassembly.Append('\\t');\n                }\n\n                // output address\n                disassembly.Append(instr.IP.ToString(\"X8\"));\n                disassembly.Append(' ');\n\n                // optionally output instruction bytes\n                if (showBytes)\n                {\n                    for (int i = 0; i < instr.Length; i++)\n                        disassembly.Append(code[(int)(instr.IP - (ulong)address) + i].ToString(\"X2\"));\n                    int missingBytes = 10 - instr.Length;\n                    for (int i = 0; i < missingBytes; i++)\n                        disassembly.Append(\"  \");\n                    disassembly.Append(' ');\n                }\n\n                // output the decoded instruction\n                formatter.Format(instr, output);\n                disassembly.Append(output.ToStringAndReset());\n            }\n            \n            return disassembly.ToString();\n        }\n\n        public Dictionary<string, long> Signatures\n        {\n            get\n            {\n                var signatures = _cache.Get<Dictionary<string, long>>(nameof(Signatures));\n                if (signatures == null)\n                {\n                    var resolver = new SignatureResolver\n                    {\n                        // NOTE: ensure patterns don't overlap with any hooks! that way we don't have to cache any states; simplicity at the expense of slightly less perf on connect\n\n                        // universal pattern\n                        new SodmaSignature(\"ReadWriteOneSector\")\n                        { \n                            // mov     ebp, esp\n                            new OdmPattern(0x1, new byte[] { 0x8B, 0xEC }),\n\n                            // mov     dx, 1F6h\n                            new OdmPattern(0x3, new byte[] { 0x66, 0xBA, 0xF6, 0x01 }),\n\n                            // mov     al, 0A0h\n                            new OdmPattern(0x7, new byte[] { 0xB0, 0xA0 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"WriteSMBusByte\")\n                        { \n                            // mov     al, 20h\n                            new OdmPattern(0x3, new byte[] { 0xB0, 0x20 }),\n\n                            // mov     dx, 0C004h\n                            new OdmPattern(0x5, new byte[] { 0x66, 0xBA, 0x04, 0xC0 }),\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"FGetDwParam\")\n                        { \n                            // jz      short 0x2C\n                            new OdmPattern(0x15, new byte[] { 0x74, 0x2C }),\n\n                            // push     20h\n                            new OdmPattern(0x17, new byte[] { 0x6A, 0x20 }),\n\n                            // mov      [ecx], eax\n                            new OdmPattern(0x33, new byte[] { 0x89, 0x01 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"FGetNamedDwParam\")\n                        {\n                            // mov     ebp, esp\n                            new OdmPattern(0x1, new byte[] { 0x8B, 0xEC }),\n\n                            // jnz     short 0x17\n                            new OdmPattern(0x13, new byte[] { 0x75, 0x17 }),\n\n                            // retn    10h\n                            new OdmPattern(0x30, new byte[] { 0xC2, 0x10, 0x00 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"DmSetupFunctionCall\")\n                        {\n                            // test     ax, 280h\n                            new OdmPattern(0x45, new byte[] { 0x66, 0xA9, 0x80, 0x02 }),\n\n                            // push     63666D64h\n                            new OdmPattern(0x54, new byte[] { 0x68, 0x64, 0x6D, 0x66, 0x63 })\n                        },\n\n                        // early revisions\n                        new SodmaSignature(\"HrFunctionCall\")\n                        {\n                            // mov     eax, 80004005h\n                            new OdmPattern(0x1B, new byte[] { 0xB8, 0x05, 0x40, 0x00, 0x80 }),\n\n                            // mov     ebx, 10008h\n                            new OdmPattern(0x46, new byte[] { 0xBB, 0x08, 0x00, 0x01, 0x00 })\n                        },\n\n                        // later revisions\n                        new SodmaSignature(\"HrFunctionCall\")\n                        {\n                            // mov     eax, 80004005h\n                            new OdmPattern(0x1B, new byte[] { 0xB8, 0x05, 0x40, 0x00, 0x80 }),\n\n                            // mov     ebx, 10008h\n                            new OdmPattern(0x45, new byte[] { 0xBB, 0x08, 0x00, 0x01, 0x00 })\n                        },\n\n                        // xbdm 3424+ contains this (3223 does not, who knows what inbetween does) whereas some early kernel versions do not? or have different kernel export tables for alpha/dvt3/dvt4/dvt6 etc.\n                        new SodmaSignature(\"sprintf\")\n                        {\n                            // mov     esi, [ebp+arg_0]\n                            new OdmPattern(0x7, new byte[] { 0x8B, 0x75, 0x08 }),\n                    \n                            // mov      [ebp+var_1C], 7FFFFFFFh\n                            new OdmPattern(0x16, new byte[] { 0xC7, 0x45, 0xE4, 0xFF, 0xFF, 0xFF, 0x7F })\n                        },\n\n                        // early revisions\n                        new SodmaSignature(\"DmAllocatePool\")\n                        {\n                            // push    ebp\n                            new OdmPattern(0x0, new byte[] { 0x55 }),\n\n                            // mov     ebp, esp\n                            new OdmPattern(0x0, new byte[] { 0x8B, 0xEC }),\n\n                            // push    'enoN'\n                            new OdmPattern(0x3, new byte[] { 0x68, 0x4E, 0x6F, 0x6E, 0x65 })\n                        },\n\n                        // later revisions\n                        new SodmaSignature(\"DmAllocatePool\")\n                        {\n                            // push    'enoN'\n                            new OdmPattern(0x0, new byte[] { 0x68, 0x4E, 0x6F, 0x6E, 0x65 }),\n\n                            // retn    4\n                            new OdmPattern(0xE, new byte[] { 0xC2, 0x04, 0x00 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"DmFreePool\")\n                        {\n                            // cmp     eax, 0B0000000h\n                            new OdmPattern(0xF, new byte[] { 0x3D, 0x00, 0x00, 0x00, 0xB0 })\n                        }\n                    };\n\n                    // read xbdm .text section\n                    var xbdmTextSegment = GetModules().FirstOrDefault(m => m.Name.Equals(\"xbdm.dll\")).GetSection(\".text\");\n                    byte[] data = new byte[xbdmTextSegment.Size];\n                    ReadMemory(xbdmTextSegment.Base, data);\n\n                    // scan for signatures\n                    signatures = resolver.Resolve(data, xbdmTextSegment.Base);\n\n                    // cache the result indefinitely\n                    _cache.Set(nameof(Signatures), signatures);\n                }\n\n                return signatures;\n            }\n        }\n\n        #endregion\n\n        #region File\n\n        public char[] GetDrives()\n        {\n            return Session.SendCommandStrict(\"drivelist\").Message.ToCharArray();\n        }\n\n        public List<XboxFileInformation> GetDirectoryList(string path)\n        {\n            var list = new List<XboxFileInformation>();\n            Session.SendCommandStrict(\"dirlist name=\\\"{0}\\\"\", path);\n            foreach (string file in Session.ReceiveMultilineResponse())\n            {\n                var fileInfo = file.ParseXboxResponseLine();\n                var info = new XboxFileInformation();\n                info.FullName = Path.Combine(path, (string)fileInfo[\"name\"]);\n                info.Size = ((long)fileInfo[\"sizehi\"] << 32) | (long)fileInfo[\"sizelo\"];\n                info.CreationTime = DateTime.FromFileTimeUtc(((long)fileInfo[\"createhi\"] << 32) | (long)fileInfo[\"createlo\"]);\n                info.ChangeTime = DateTime.FromFileTimeUtc(((long)fileInfo[\"changehi\"] << 32) | (long)fileInfo[\"changelo\"]);\n                info.Attributes |= file.Contains(\"directory\") ? FileAttributes.Directory : FileAttributes.Normal;\n                info.Attributes |= file.Contains(\"readonly\") ? FileAttributes.ReadOnly : 0;\n                info.Attributes |= file.Contains(\"hidden\") ? FileAttributes.Hidden : 0;\n                list.Add(info);\n            }\n\n            return list; \n        }\n\n        public void GetFile(string localPath, string remotePath)\n        {\n            Session.SendCommandStrict(\"getfile name=\\\"{0}\\\"\", remotePath);\n            using var lfs = File.Create(localPath);\n            Session.CopyToCount(lfs, Session.Reader.ReadInt32());\n        }\n\n        #endregion\n\n        #region IDisposable\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    // TODO: dispose managed state (managed objects)\n                }\n\n                // TODO: free unmanaged resources (unmanaged objects) and override finalizer\n                Session?.Dispose();\n\n                // TODO: set large fields to null\n\n                _disposed = true;\n            }\n        }\n\n        ~Xbox()\n        {\n            Dispose(false);\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        #endregion\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// src/OGXbdmDumper/ConnectionInfo.cs\n//             var connections = new List<ConnectionInfo>();\n//             byte[] datagramBuffer = new byte[1024];\n//             // iterate through each network interface\n//             Parallel.ForEach(NetworkInterface.GetAllNetworkInterfaces(), nic =>\n//             {\n//                 // only worry about active IPv4 interfaces\n//                 if (nic.OperationalStatus != OperationalStatus.Up || !nic.Supports(NetworkInterfaceComponent.IPv4))\n//                     return;\n//                 // iterate through each ip address assigned to the interface\n//                 Parallel.ForEach(nic.GetIPProperties().UnicastAddresses, ip =>\n\n// the below code fragment can be found in:\n// src/OGXbdmDumper/Connection.cs\n//         /// <summary>\n//         /// Initializes the session.\n//         /// </summary>\n//         public Connection()\n//         {\n//             // initialize defaults\n//             Reader = new BinaryReader(this);\n//             Writer = new BinaryWriter(this);\n//             ResetTcp();\n//         }\n\n// the below code fragment can be found in:\n// src/OGXbdmDumper/Connection.cs\n//         /// <summary>\n//         /// The time in milliseconds to wait while sending data before throwing a TimeoutException.\n//         /// </summary>\n//         public int SendTimeout { get => _client.SendTimeout; set => _client.SendTimeout = value; }\n//         /// <summary>\n//         /// The time in milliseconds to wait while receiving data before throwing a TimeoutException.\n//         /// </summary>\n//         public int ReceiveTimeout { get => _client.ReceiveTimeout; set => _client.ReceiveTimeout = value; }\n//         #endregion\n//         #region Construction\n\n// the below code fragment can be found in:\n// src/OGXbdmDumper/Kernel.cs\n//                 throw new ArgumentNullException(nameof(xbox));\n//             Module = xbox.Modules.Find(m => m.Name == Name) ??\n//                 throw new NullReferenceException(string.Format(\"Failed to load {0} module information!\", Name));\n//             // TODO: remove 3rd-party dependency with proper PE parsing logic\n//             // grab enough of the kernel in memory to allow parsing it (possibly only need through the data section)\n//             var initSection = Module.Sections.Find(m => m.Name == \"INIT\");\n//             int size = (int)(initSection.Base - Address);\n//             var pe = new PeFile(_xbox.Memory.ReadBytes(Address, size));\n//             // resolve exports\n//             Exports = new KernelExports(Address, pe.ExportedFunctions);\n\n// the below code fragment can be found in:\n// src/OGXbdmDumper/Kernel.cs\n//         /// The kernel exports.\n//         /// </summary>\n//         public KernelExports Exports { get; private set; }\n//         /// <summary>\n//         /// Initializes communication with the Xbox kernel.\n//         /// </summary>\n//         /// <param name=\"xbox\"></param>\n//         public Kernel(Xbox xbox)\n//         {\n//             _xbox = xbox ??\n\n", "list": [{"retrieved_chunk": "            var connections = new List<ConnectionInfo>();\n            byte[] datagramBuffer = new byte[1024];\n            // iterate through each network interface\n            Parallel.ForEach(NetworkInterface.GetAllNetworkInterfaces(), nic =>\n            {\n                // only worry about active IPv4 interfaces\n                if (nic.OperationalStatus != OperationalStatus.Up || !nic.Supports(NetworkInterfaceComponent.IPv4))\n                    return;\n                // iterate through each ip address assigned to the interface\n                Parallel.ForEach(nic.GetIPProperties().UnicastAddresses, ip =>", "filename": "src/OGXbdmDumper/ConnectionInfo.cs", "score": 66.55166457984245}, {"retrieved_chunk": "        /// <summary>\n        /// Initializes the session.\n        /// </summary>\n        public Connection()\n        {\n            // initialize defaults\n            Reader = new BinaryReader(this);\n            Writer = new BinaryWriter(this);\n            ResetTcp();\n        }", "filename": "src/OGXbdmDumper/Connection.cs", "score": 65.61480573217976}, {"retrieved_chunk": "        /// <summary>\n        /// The time in milliseconds to wait while sending data before throwing a TimeoutException.\n        /// </summary>\n        public int SendTimeout { get => _client.SendTimeout; set => _client.SendTimeout = value; }\n        /// <summary>\n        /// The time in milliseconds to wait while receiving data before throwing a TimeoutException.\n        /// </summary>\n        public int ReceiveTimeout { get => _client.ReceiveTimeout; set => _client.ReceiveTimeout = value; }\n        #endregion\n        #region Construction", "filename": "src/OGXbdmDumper/Connection.cs", "score": 63.14871472847682}, {"retrieved_chunk": "                throw new ArgumentNullException(nameof(xbox));\n            Module = xbox.Modules.Find(m => m.Name == Name) ??\n                throw new NullReferenceException(string.Format(\"Failed to load {0} module information!\", Name));\n            // TODO: remove 3rd-party dependency with proper PE parsing logic\n            // grab enough of the kernel in memory to allow parsing it (possibly only need through the data section)\n            var initSection = Module.Sections.Find(m => m.Name == \"INIT\");\n            int size = (int)(initSection.Base - Address);\n            var pe = new PeFile(_xbox.Memory.ReadBytes(Address, size));\n            // resolve exports\n            Exports = new KernelExports(Address, pe.ExportedFunctions);", "filename": "src/OGXbdmDumper/Kernel.cs", "score": 62.61533660943069}, {"retrieved_chunk": "        /// The kernel exports.\n        /// </summary>\n        public KernelExports Exports { get; private set; }\n        /// <summary>\n        /// Initializes communication with the Xbox kernel.\n        /// </summary>\n        /// <param name=\"xbox\"></param>\n        public Kernel(Xbox xbox)\n        {\n            _xbox = xbox ??", "filename": "src/OGXbdmDumper/Kernel.cs", "score": 60.88570669473385}]}}, "groundtruth": "Thread> Threads => GetThreads();", "metadata": {"task_id": "project_cc_csharp/20", "repository": "Ernegien-OGXbdmDumper-07a1e82", "file": "src/OGXbdmDumper/Xbox.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 75, "right_context_start_lineno": 76}}
{"language": "csharp", "segments": {"prefix": "using JWLSLMerge.Data.Attributes;\n\nnamespace JWLSLMerge.Data.Models\n{\n    public class Note\n    {\n        [", "suffix": " get; set; }\n        public string Guid { get; set; } = null!;\n        public int? UserMarkId { get; set; }\n        public int? LocationId { get; set; }\n        public string? Title { get; set; }\n        public string? Content { get; set; }\n        public string LastModified { get; set; } = null!;\n        public string Created { get; set; } = null!;\n        public int BlockType { get; set; }\n        public int? BlockIdentifier { get; set; }\n\n        [Ignore]\n        public int NewNoteId { get; set; }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/JWDal.cs\n//         {\n//             connectionString = $\"Data Source={dbPath}\";\n//         }\n//         public IEnumerable<T> TableList<T>()\n//         {\n//             using (IDbConnection cnn = new SQLiteConnection(connectionString))\n//             {\n//                 return cnn.Query<T>($\"SELECT * FROM {typeof(T).Name}\");\n//             }\n//         }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/InputField.cs\n// \ufeffusing JWLSLMerge.Data.Attributes;\n// namespace JWLSLMerge.Data.Models\n// {\n//     public class InputField\n//     {\n//         public int LocationId { get; set; }\n//         public string TextTag { get; set; } = null!;\n//         public string Value { get; set; } = null!;\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/Tag.cs\n//         public int NewTagId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge/MergeService.cs\n//         private readonly string targetPath = null!;\n//         private readonly string targetDbFile = null!;\n//         private string lastModified = null!;\n//         public MergeService()\n//         {\n//             targetPath = Environment.GetTargetDirectory();\n//             targetDbFile = Environment.GetDbFile();\n//         }\n//         public void Run(string[] jwlibraryFiles)\n//         {\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/UserMark.cs\n//         public string UserMarkGuid { get; set; } = null!;\n//         public int Version { get; set; }\n//         [Ignore]\n//         public int NewUserMarkId { get; set; }\n//     }\n// }\n\n", "list": [{"retrieved_chunk": "        {\n            connectionString = $\"Data Source={dbPath}\";\n        }\n        public IEnumerable<T> TableList<T>()\n        {\n            using (IDbConnection cnn = new SQLiteConnection(connectionString))\n            {\n                return cnn.Query<T>($\"SELECT * FROM {typeof(T).Name}\");\n            }\n        }", "filename": "JWLSLMerge.Data/JWDal.cs", "score": 13.78401506779753}, {"retrieved_chunk": "\ufeffusing JWLSLMerge.Data.Attributes;\nnamespace JWLSLMerge.Data.Models\n{\n    public class InputField\n    {\n        public int LocationId { get; set; }\n        public string TextTag { get; set; } = null!;\n        public string Value { get; set; } = null!;\n    }\n}", "filename": "JWLSLMerge.Data/Models/InputField.cs", "score": 13.000811547599904}, {"retrieved_chunk": "        public int NewTagId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/Tag.cs", "score": 12.828308464376727}, {"retrieved_chunk": "        private readonly string targetPath = null!;\n        private readonly string targetDbFile = null!;\n        private string lastModified = null!;\n        public MergeService()\n        {\n            targetPath = Environment.GetTargetDirectory();\n            targetDbFile = Environment.GetDbFile();\n        }\n        public void Run(string[] jwlibraryFiles)\n        {", "filename": "JWLSLMerge/MergeService.cs", "score": 12.77934094725121}, {"retrieved_chunk": "        public string UserMarkGuid { get; set; } = null!;\n        public int Version { get; set; }\n        [Ignore]\n        public int NewUserMarkId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/UserMark.cs", "score": 12.358601363000677}]}}, "groundtruth": "Ignore]\n        public int NoteId {", "metadata": {"task_id": "project_cc_csharp/51", "repository": "pliniobrunelli-JWLSLMerge-7fe66dc", "file": "JWLSLMerge.Data/Models/Note.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 6, "right_context_start_lineno": 8}}
{"language": "csharp", "segments": {"prefix": "using System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Runtime.Versioning;\nusing System.Threading;\nusing static ServiceSelf.AdvApi32;\n\nnamespace ServiceSelf\n{\n    sealed class WindowsService : Service\n    {\n        private const string WorkingDirArgName = \"WD\";\n\n\n        [SupportedOSPlatform(\"windows\")]\n        public WindowsService(string name)\n           : base(name)\n        {\n        }\n\n        /// <summary>\n        /// \u5e94\u7528\u5de5\u4f5c\u76ee\u5f55\n        /// </summary>\n        /// <param name=\"args\">\u542f\u52a8\u53c2\u6570</param>\n        /// <returns></returns>\n        public static bool UseWorkingDirectory(string[] args)\n        {\n            if (Argument.TryGetValue(args, WorkingDirArgName, out var workingDir))\n            {\n                Environment.CurrentDirectory = workingDir;\n                return true;\n            }\n            return false;\n        }\n\n        [SupportedOSPlatform(\"windows\")]\n        public override void CreateStart(string filePath, ServiceOptions options)\n        {\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            filePath = Path.GetFullPath(filePath);\n            using var oldServiceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n\n            if (oldServiceHandle.IsInvalid)\n            {\n                using var newServiceHandle = this.CreateService(managerHandle, filePath, options);\n                StartService(newServiceHandle);\n            }\n            else\n            {\n                var oldFilePath = QueryServiceFilePath(oldServiceHandle);\n                if (oldFilePath.Length > 0 && oldFilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) == false)\n                {\n                    throw new InvalidOperationException(\"\u7cfb\u7edf\u5df2\u5b58\u5728\u540c\u540d\u4f46\u4e0d\u540c\u8def\u5f84\u7684\u670d\u52a1\");\n                }\n                StartService(oldServiceHandle);\n            }\n        }\n\n        private unsafe ", "suffix": "\n            var arguments = options.Arguments ?? Enumerable.Empty<Argument>();\n            arguments = string.IsNullOrEmpty(options.WorkingDirectory)\n                ? arguments.Append(new Argument(WorkingDirArgName, Path.GetDirectoryName(filePath)))\n                : arguments.Append(new Argument(WorkingDirArgName, Path.GetFullPath(options.WorkingDirectory)));\n\n            var serviceHandle = AdvApi32.CreateService(\n                managerHandle,\n                this.Name,\n                options.Windows.DisplayName,\n                ServiceAccess.SERVICE_ALL_ACCESS,\n                ServiceType.SERVICE_WIN32_OWN_PROCESS,\n                ServiceStartType.SERVICE_AUTO_START,\n                ServiceErrorControl.SERVICE_ERROR_NORMAL,\n                $@\"\"\"{filePath}\"\" {string.Join(' ', arguments)}\",\n                lpLoadOrderGroup: null,\n                lpdwTagId: 0,\n                lpDependencies: options.Windows.Dependencies,\n                lpServiceStartName: options.Windows.ServiceStartName,\n                lpPassword: options.Windows.Password);\n\n            if (serviceHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            if (string.IsNullOrEmpty(options.Description) == false)\n            {\n                var desc = new ServiceDescription { lpDescription = options.Description };\n                var pDesc = Marshal.AllocHGlobal(Marshal.SizeOf(desc));\n                Marshal.StructureToPtr(desc, pDesc, false);\n                ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_DESCRIPTION, pDesc.ToPointer());\n                Marshal.FreeHGlobal(pDesc);\n            }\n\n\n            var action = new SC_ACTION\n            {\n                Type = (SC_ACTION_TYPE)options.Windows.FailureActionType,\n            };\n            var failureAction = new SERVICE_FAILURE_ACTIONS\n            {\n                cActions = 1,\n                lpsaActions = &action,\n                dwResetPeriod = (int)TimeSpan.FromDays(1d).TotalSeconds\n            };\n\n            if (ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS, &failureAction) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            return serviceHandle;\n        }\n\n        private static ReadOnlySpan<char> QueryServiceFilePath(SafeServiceHandle serviceHandle)\n        {\n            const int ERROR_INSUFFICIENT_BUFFER = 122;\n            if (QueryServiceConfig(serviceHandle, IntPtr.Zero, 0, out var bytesNeeded) == false)\n            {\n                if (Marshal.GetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER)\n                {\n                    throw new Win32Exception();\n                }\n            }\n\n            var buffer = Marshal.AllocHGlobal(bytesNeeded);\n            try\n            {\n                if (QueryServiceConfig(serviceHandle, buffer, bytesNeeded, out _) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                var serviceConfig = Marshal.PtrToStructure<QUERY_SERVICE_CONFIG>(buffer);\n                var binaryPathName = serviceConfig.lpBinaryPathName.AsSpan();\n                if (binaryPathName.IsEmpty)\n                {\n                    return ReadOnlySpan<char>.Empty;\n                }\n\n                if (binaryPathName[0] == '\"')\n                {\n                    binaryPathName = binaryPathName[1..];\n                    var index = binaryPathName.IndexOf('\"');\n                    return index < 0 ? binaryPathName : binaryPathName[..index];\n                }\n                else\n                {\n                    var index = binaryPathName.IndexOf(' ');\n                    return index < 0 ? binaryPathName : binaryPathName[..index];\n                }\n            }\n            finally\n            {\n                Marshal.FreeHGlobal(buffer);\n            }\n        }\n\n        private static void StartService(SafeServiceHandle serviceHandle)\n        {\n            var status = new SERVICE_STATUS();\n            if (QueryServiceStatus(serviceHandle, ref status) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            if (status.dwCurrentState == ServiceState.SERVICE_RUNNING ||\n                status.dwCurrentState == ServiceState.SERVICE_START_PENDING)\n            {\n                return;\n            }\n\n            if (AdvApi32.StartService(serviceHandle, 0, null) == false)\n            {\n                throw new Win32Exception();\n            }\n        }\n\n        /// <summary>\n        /// \u505c\u6b62\u5e76\u5220\u9664\u670d\u52a1\n        /// </summary>  \n        [SupportedOSPlatform(\"windows\")]\n        public override void StopDelete()\n        {\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            using var serviceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n            if (serviceHandle.IsInvalid == true)\n            {\n                return;\n            }\n\n            StopService(serviceHandle, TimeSpan.FromSeconds(30d));\n            if (DeleteService(serviceHandle) == false)\n            {\n                throw new Win32Exception();\n            }\n        }\n\n        private static unsafe void StopService(SafeServiceHandle serviceHandle, TimeSpan maxWaitTime)\n        {\n            var status = new SERVICE_STATUS();\n            if (QueryServiceStatus(serviceHandle, ref status) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            if (status.dwCurrentState == ServiceState.SERVICE_STOPPED)\n            {\n                return;\n            }\n\n            if (status.dwCurrentState != ServiceState.SERVICE_STOP_PENDING)\n            {\n                var failureAction = new SERVICE_FAILURE_ACTIONS();\n                if (ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS, &failureAction) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                if (ControlService(serviceHandle, ServiceControl.SERVICE_CONTROL_STOP, ref status) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                // \u8fd9\u91cc\u4e0d\u9700\u8981\u6062\u590dSERVICE_CONFIG_FAILURE_ACTIONS\uff0c\u56e0\u4e3a\u4e0b\u9762\u6211\u4eec\u8981\u5220\u9664\u670d\u52a1\n            }\n\n            var stopwatch = Stopwatch.StartNew();\n            var statusQueryDelay = TimeSpan.FromMilliseconds(100d);\n            while (stopwatch.Elapsed < maxWaitTime)\n            {\n                if (status.dwCurrentState == ServiceState.SERVICE_STOPPED)\n                {\n                    return;\n                }\n\n                Thread.Sleep(statusQueryDelay);\n                if (QueryServiceStatus(serviceHandle, ref status) == false)\n                {\n                    throw new Win32Exception();\n                }\n            }\n\n            throw new TimeoutException($\"\u7b49\u5f85\u670d\u52a1\u505c\u6b62\u8d85\u8fc7\u4e86{maxWaitTime.TotalSeconds}\u79d2\");\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u83b7\u53d6\u670d\u52a1\u7684\u8fdb\u7a0bid\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <returns></returns>\n        protected unsafe override bool TryGetProcessId(out int processId)\n        {\n            processId = 0;\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            using var serviceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n            if (serviceHandle.IsInvalid == true)\n            {\n                return false;\n            }\n\n            var status = new SERVICE_STATUS_PROCESS();\n            if (QueryServiceStatusEx(serviceHandle, SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO, &status, sizeof(SERVICE_STATUS_PROCESS), out _) == false)\n            {\n                return false;\n            }\n\n            processId = (int)status.dwProcessId;\n            return processId > 0;\n        }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// ServiceSelf/LinuxService.cs\n//             }\n//             var linuxOptions = CreateLinuxOptions(filePath, options);\n//             using (var fileStream = File.OpenWrite(unitFilePath))\n//             {\n//                 using var wirter = new StreamWriter(fileStream);\n//                 linuxOptions.WriteTo(wirter);\n//             }\n//             // SELinux\n//             Shell(\"chcon\", $\"--type=bin_t {filePath}\", showError: false);\n//             SystemControl(\"daemon-reload\", showError: true);\n\n// the below code fragment can be found in:\n// ServiceSelf/LinuxService.cs\n//                     break;\n//                 }\n//             }\n//             if (filePath.IsEmpty || wantedBy.IsEmpty)\n//             {\n//                 return ReadOnlySpan<char>.Empty;\n//             }\n//             var wants = $\"{wantedBy.ToString()}.wants\";\n//             var unitFileName = Path.GetFileName(unitFilePath);\n//             var unitFileDir = Path.GetDirectoryName(unitFilePath);\n\n// the below code fragment can be found in:\n// ServiceSelf/LinuxService.cs\n//             if (geteuid() != 0)\n//             {\n//                 throw new UnauthorizedAccessException(\"\u65e0\u6cd5\u64cd\u4f5c\u670d\u52a1\uff1a\u6ca1\u6709root\u6743\u9650\");\n//             }\n//         }\n//     }\n// }\n\n// the below code fragment can be found in:\n// ServiceSelf/LinuxService.cs\n//                     line = line[execStartPrefix.Length..];\n//                     var index = line.IndexOf(' ');\n//                     filePath = index < 0 ? line : line[..index];\n//                 }\n//                 else if (line.StartsWith(wantedByPrefix, StringComparison.OrdinalIgnoreCase))\n//                 {\n//                     wantedBy = line[wantedByPrefix.Length..].Trim();\n//                 }\n//                 if (filePath.Length > 0 && wantedBy.Length > 0)\n//                 {\n\n// the below code fragment can be found in:\n// ServiceSelf/LinuxService.cs\n//                 {\n//                     execStart = $\"{filePath} {string.Join<Argument>(' ', args)}\";\n//                 }\n//             }\n//             var workingDirectory = string.IsNullOrEmpty(options.WorkingDirectory)\n//                 ? Path.GetDirectoryName(filePath)\n//                 : Path.GetFullPath(options.WorkingDirectory);\n//             var linuxOptions = options.Linux.Clone();\n//             linuxOptions.Unit[\"Description\"] = options.Description;\n//             linuxOptions.Service[\"ExecStart\"] = execStart;\n\n", "list": [{"retrieved_chunk": "            }\n            var linuxOptions = CreateLinuxOptions(filePath, options);\n            using (var fileStream = File.OpenWrite(unitFilePath))\n            {\n                using var wirter = new StreamWriter(fileStream);\n                linuxOptions.WriteTo(wirter);\n            }\n            // SELinux\n            Shell(\"chcon\", $\"--type=bin_t {filePath}\", showError: false);\n            SystemControl(\"daemon-reload\", showError: true);", "filename": "ServiceSelf/LinuxService.cs", "score": 53.22018771652771}, {"retrieved_chunk": "                    break;\n                }\n            }\n            if (filePath.IsEmpty || wantedBy.IsEmpty)\n            {\n                return ReadOnlySpan<char>.Empty;\n            }\n            var wants = $\"{wantedBy.ToString()}.wants\";\n            var unitFileName = Path.GetFileName(unitFilePath);\n            var unitFileDir = Path.GetDirectoryName(unitFilePath);", "filename": "ServiceSelf/LinuxService.cs", "score": 21.470485420837036}, {"retrieved_chunk": "            if (geteuid() != 0)\n            {\n                throw new UnauthorizedAccessException(\"\u65e0\u6cd5\u64cd\u4f5c\u670d\u52a1\uff1a\u6ca1\u6709root\u6743\u9650\");\n            }\n        }\n    }\n}", "filename": "ServiceSelf/LinuxService.cs", "score": 12.934142972279112}, {"retrieved_chunk": "                    line = line[execStartPrefix.Length..];\n                    var index = line.IndexOf(' ');\n                    filePath = index < 0 ? line : line[..index];\n                }\n                else if (line.StartsWith(wantedByPrefix, StringComparison.OrdinalIgnoreCase))\n                {\n                    wantedBy = line[wantedByPrefix.Length..].Trim();\n                }\n                if (filePath.Length > 0 && wantedBy.Length > 0)\n                {", "filename": "ServiceSelf/LinuxService.cs", "score": 12.544725417438247}, {"retrieved_chunk": "                {\n                    execStart = $\"{filePath} {string.Join<Argument>(' ', args)}\";\n                }\n            }\n            var workingDirectory = string.IsNullOrEmpty(options.WorkingDirectory)\n                ? Path.GetDirectoryName(filePath)\n                : Path.GetFullPath(options.WorkingDirectory);\n            var linuxOptions = options.Linux.Clone();\n            linuxOptions.Unit[\"Description\"] = options.Description;\n            linuxOptions.Service[\"ExecStart\"] = execStart;", "filename": "ServiceSelf/LinuxService.cs", "score": 12.519455560002188}]}}, "groundtruth": "SafeServiceHandle CreateService(SafeServiceHandle managerHandle, string filePath, ServiceOptions options)\n        {", "metadata": {"task_id": "project_cc_csharp/14", "repository": "xljiulang-ServiceSelf-7f8604b", "file": "ServiceSelf/WindowsService.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 66, "right_context_start_lineno": 68}}
{"language": "csharp", "segments": {"prefix": "using JWLSLMerge.Data.Attributes;\n\nnamespace JWLSLMerge.Data.Models\n{\n    public class PlayListItem\n    {\n        [Ignore]\n        public int PlaylistItemId { get; set; }\n        public string Label { get; set; } = null!;\n        public int StartTrimOffsetTicks { get; set; }\n        public int EndTrimOffsetTicks { get; set; }\n        public int Accuracy { get; set; }\n        public int EndAction { get; set; }\n        public string ThumbnailFilePath { get; set; } = null!;\n\n        [", "suffix": " get; set; }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/PlaylistItemMarker.cs\n//         public long DurationTicks { get; set; }\n//         public long EndTransitionDurationTicks { get; set; }\n//         [Ignore]\n//         public int NewPlaylistItemMarkerId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/Note.cs\n//         public string? Title { get; set; }\n//         public string? Content { get; set; }\n//         public string LastModified { get; set; } = null!;\n//         public string Created { get; set; } = null!;\n//         public int BlockType { get; set; }\n//         public int? BlockIdentifier { get; set; }\n//         [Ignore]\n//         public int NewNoteId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/UserMark.cs\n//         public string UserMarkGuid { get; set; } = null!;\n//         public int Version { get; set; }\n//         [Ignore]\n//         public int NewUserMarkId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/Location.cs\n//         public int? Track { get; set; }\n//         public int IssueTagNumber { get; set; }\n//         public string? KeySymbol { get; set; }\n//         public int? MepsLanguage { get; set; }\n//         public int Type { get; set; }\n//         public string? Title { get; set; }\n//         [Ignore]\n//         public int NewLocationId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/Bookmark.cs\n//         public string Title { get; set; } = null!;\n//         public string? Snippet { get; set; }\n//         public int BlockType { get; set; }\n//         public int? BlockIdentifier { get; set; }\n//     }\n// }\n\n", "list": [{"retrieved_chunk": "        public long DurationTicks { get; set; }\n        public long EndTransitionDurationTicks { get; set; }\n        [Ignore]\n        public int NewPlaylistItemMarkerId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/PlaylistItemMarker.cs", "score": 35.26889876052275}, {"retrieved_chunk": "        public string? Title { get; set; }\n        public string? Content { get; set; }\n        public string LastModified { get; set; } = null!;\n        public string Created { get; set; } = null!;\n        public int BlockType { get; set; }\n        public int? BlockIdentifier { get; set; }\n        [Ignore]\n        public int NewNoteId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/Note.cs", "score": 33.518184487704545}, {"retrieved_chunk": "        public string UserMarkGuid { get; set; } = null!;\n        public int Version { get; set; }\n        [Ignore]\n        public int NewUserMarkId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/UserMark.cs", "score": 32.64848873570582}, {"retrieved_chunk": "        public int? Track { get; set; }\n        public int IssueTagNumber { get; set; }\n        public string? KeySymbol { get; set; }\n        public int? MepsLanguage { get; set; }\n        public int Type { get; set; }\n        public string? Title { get; set; }\n        [Ignore]\n        public int NewLocationId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/Location.cs", "score": 31.624913532715233}, {"retrieved_chunk": "        public string Title { get; set; } = null!;\n        public string? Snippet { get; set; }\n        public int BlockType { get; set; }\n        public int? BlockIdentifier { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/Bookmark.cs", "score": 31.183025189281004}]}}, "groundtruth": "Ignore]\n        public int NewPlaylistItemId {", "metadata": {"task_id": "project_cc_csharp/37", "repository": "pliniobrunelli-JWLSLMerge-7fe66dc", "file": "JWLSLMerge.Data/Models/PlayListItem.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 15, "right_context_start_lineno": 17}}
{"language": "csharp", "segments": {"prefix": "using JWLSLMerge.Data.Attributes;\n\nnamespace JWLSLMerge.Data.Models\n{\n    public class PlaylistItemMarker\n    {\n        [Ignore]\n        public int PlaylistItemMarkerId { get; set; }\n        public int PlaylistItemId { get; set; }\n        public string Label { get; set; } = null!;\n        public long StartTimeTicks { get; set; }\n        public long DurationTicks { get; set; }\n        public long EndTransitionDurationTicks { get; set; }\n\n        [", "suffix": " get; set; }\n    }\n}\n", "crossfile_context": {"text": "// Here are some relevant code fragments from other files of the repo:\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/PlaylistItemIndependentMediaMap.cs\n// \ufeffnamespace JWLSLMerge.Data.Models\n// {\n//     public class PlaylistItemIndependentMediaMap\n//     {\n//         public int PlaylistItemId { get; set; }\n//         public int IndependentMediaId { get; set; }\n//         public long DurationTicks { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/PlaylistItemLocationMap.cs\n// \ufeffnamespace JWLSLMerge.Data.Models\n// {\n//     public class PlaylistItemLocationMap\n//     {\n//         public int PlaylistItemId { get; set; }\n//         public int LocationId { get; set; }\n//         public int MajorMultimediaType { get; set; }\n//         public long? BaseDurationTicks { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/PlayListItem.cs\n//         public int Accuracy { get; set; }\n//         public int EndAction { get; set; }\n//         public string ThumbnailFilePath { get; set; } = null!;\n//         [Ignore]\n//         public int NewPlaylistItemId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/Note.cs\n//         public string? Title { get; set; }\n//         public string? Content { get; set; }\n//         public string LastModified { get; set; } = null!;\n//         public string Created { get; set; } = null!;\n//         public int BlockType { get; set; }\n//         public int? BlockIdentifier { get; set; }\n//         [Ignore]\n//         public int NewNoteId { get; set; }\n//     }\n// }\n\n// the below code fragment can be found in:\n// JWLSLMerge.Data/Models/PlaylistItemMarkerParagraphMap.cs\n// \ufeffnamespace JWLSLMerge.Data.Models\n// {\n//     public class PlaylistItemMarkerParagraphMap\n//     {\n//         public int PlaylistItemMarkerId { get; set; }\n//         public int MepsDocumentId { get; set; }\n//         public int ParagraphIndex { get; set; }\n//         public int MarkerIndexWithinParagraph { get; set; }\n//     }\n// }\n\n", "list": [{"retrieved_chunk": "\ufeffnamespace JWLSLMerge.Data.Models\n{\n    public class PlaylistItemIndependentMediaMap\n    {\n        public int PlaylistItemId { get; set; }\n        public int IndependentMediaId { get; set; }\n        public long DurationTicks { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/PlaylistItemIndependentMediaMap.cs", "score": 40.139620221589794}, {"retrieved_chunk": "\ufeffnamespace JWLSLMerge.Data.Models\n{\n    public class PlaylistItemLocationMap\n    {\n        public int PlaylistItemId { get; set; }\n        public int LocationId { get; set; }\n        public int MajorMultimediaType { get; set; }\n        public long? BaseDurationTicks { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/PlaylistItemLocationMap.cs", "score": 35.276235533017854}, {"retrieved_chunk": "        public int Accuracy { get; set; }\n        public int EndAction { get; set; }\n        public string ThumbnailFilePath { get; set; } = null!;\n        [Ignore]\n        public int NewPlaylistItemId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/PlayListItem.cs", "score": 29.760486252006046}, {"retrieved_chunk": "        public string? Title { get; set; }\n        public string? Content { get; set; }\n        public string LastModified { get; set; } = null!;\n        public string Created { get; set; } = null!;\n        public int BlockType { get; set; }\n        public int? BlockIdentifier { get; set; }\n        [Ignore]\n        public int NewNoteId { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/Note.cs", "score": 25.37908122532722}, {"retrieved_chunk": "\ufeffnamespace JWLSLMerge.Data.Models\n{\n    public class PlaylistItemMarkerParagraphMap\n    {\n        public int PlaylistItemMarkerId { get; set; }\n        public int MepsDocumentId { get; set; }\n        public int ParagraphIndex { get; set; }\n        public int MarkerIndexWithinParagraph { get; set; }\n    }\n}", "filename": "JWLSLMerge.Data/Models/PlaylistItemMarkerParagraphMap.cs", "score": 25.258196191223316}]}}, "groundtruth": "Ignore]\n        public int NewPlaylistItemMarkerId {", "metadata": {"task_id": "project_cc_csharp/29", "repository": "pliniobrunelli-JWLSLMerge-7fe66dc", "file": "JWLSLMerge.Data/Models/PlaylistItemMarker.cs", "context_start_lineno": 0, "groundtruth_start_lineno": 14, "right_context_start_lineno": 16}}
